function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e3 = m2[i2];
    if (typeof e3 !== "string" && !Array.isArray(e3)) {
      for (const k2 in e3) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e3, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e3[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (Object.prototype.hasOwnProperty.call(n2, "__esModule")) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a22() {
      var isInstance = false;
      try {
        isInstance = this instanceof a22;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  /**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var l2 = Symbol.for("react.element"), n2 = Symbol.for("react.portal"), p2 = Symbol.for("react.fragment"), q2 = Symbol.for("react.strict_mode"), r2 = Symbol.for("react.profiler"), t2 = Symbol.for("react.provider"), u2 = Symbol.for("react.context"), v2 = Symbol.for("react.forward_ref"), w2 = Symbol.for("react.suspense"), x2 = Symbol.for("react.memo"), y2 = Symbol.for("react.lazy"), z2 = Symbol.iterator;
  function A2(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = z2 && a2[z2] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var B2 = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C2 = Object.assign, D2 = {};
  function E2(a2, b2, e3) {
    this.props = a2;
    this.context = b2;
    this.refs = D2;
    this.updater = e3 || B2;
  }
  E2.prototype.isReactComponent = {};
  E2.prototype.setState = function(a2, b2) {
    if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a2, b2, "setState");
  };
  E2.prototype.forceUpdate = function(a2) {
    this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
  };
  function F2() {
  }
  F2.prototype = E2.prototype;
  function G2(a2, b2, e3) {
    this.props = a2;
    this.context = b2;
    this.refs = D2;
    this.updater = e3 || B2;
  }
  var H2 = G2.prototype = new F2();
  H2.constructor = G2;
  C2(H2, E2.prototype);
  H2.isPureReactComponent = true;
  var I2 = Array.isArray, J2 = Object.prototype.hasOwnProperty, K2 = { current: null }, L2 = { key: true, ref: true, __self: true, __source: true };
  function M2(a2, b2, e3) {
    var d2, c2 = {}, k2 = null, h2 = null;
    if (null != b2) for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J2.call(b2, d2) && !L2.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
    var g2 = arguments.length - 2;
    if (1 === g2) c2.children = e3;
    else if (1 < g2) {
      for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
      c2.children = f2;
    }
    if (a2 && a2.defaultProps) for (d2 in g2 = a2.defaultProps, g2) void 0 === c2[d2] && (c2[d2] = g2[d2]);
    return { $$typeof: l2, type: a2, key: k2, ref: h2, props: c2, _owner: K2.current };
  }
  function N2(a2, b2) {
    return { $$typeof: l2, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
  }
  function O2(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === l2;
  }
  function escape2(a2) {
    var b2 = { "=": "=0", ":": "=2" };
    return "$" + a2.replace(/[=:]/g, function(a22) {
      return b2[a22];
    });
  }
  var P2 = /\/+/g;
  function Q2(a2, b2) {
    return "object" === typeof a2 && null !== a2 && null != a2.key ? escape2("" + a2.key) : b2.toString(36);
  }
  function R2(a2, b2, e3, d2, c2) {
    var k2 = typeof a2;
    if ("undefined" === k2 || "boolean" === k2) a2 = null;
    var h2 = false;
    if (null === a2) h2 = true;
    else switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l2:
          case n2:
            h2 = true;
        }
    }
    if (h2) return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q2(h2, 0) : d2, I2(c2) ? (e3 = "", null != a2 && (e3 = a2.replace(P2, "$&/") + "/"), R2(c2, b2, e3, "", function(a22) {
      return a22;
    })) : null != c2 && (O2(c2) && (c2 = N2(c2, e3 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P2, "$&/") + "/") + a2)), b2.push(c2)), 1;
    h2 = 0;
    d2 = "" === d2 ? "." : d2 + ":";
    if (I2(a2)) for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q2(k2, g2);
      h2 += R2(k2, b2, e3, f2, c2);
    }
    else if (f2 = A2(a2), "function" === typeof f2) for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; ) k2 = k2.value, f2 = d2 + Q2(k2, g2++), h2 += R2(k2, b2, e3, f2, c2);
    else if ("object" === k2) throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
    return h2;
  }
  function S2(a2, b2, e3) {
    if (null == a2) return a2;
    var d2 = [], c2 = 0;
    R2(a2, d2, "", "", function(a22) {
      return b2.call(e3, a22, c2++);
    });
    return d2;
  }
  function T2(a2) {
    if (-1 === a2._status) {
      var b2 = a2._result;
      b2 = b2();
      b2.then(function(b22) {
        if (0 === a2._status || -1 === a2._status) a2._status = 1, a2._result = b22;
      }, function(b22) {
        if (0 === a2._status || -1 === a2._status) a2._status = 2, a2._result = b22;
      });
      -1 === a2._status && (a2._status = 0, a2._result = b2);
    }
    if (1 === a2._status) return a2._result.default;
    throw a2._result;
  }
  var U2 = { current: null }, V2 = { transition: null }, W2 = { ReactCurrentDispatcher: U2, ReactCurrentBatchConfig: V2, ReactCurrentOwner: K2 };
  function X2() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S2, forEach: function(a2, b2, e3) {
    S2(a2, function() {
      b2.apply(this, arguments);
    }, e3);
  }, count: function(a2) {
    var b2 = 0;
    S2(a2, function() {
      b2++;
    });
    return b2;
  }, toArray: function(a2) {
    return S2(a2, function(a22) {
      return a22;
    }) || [];
  }, only: function(a2) {
    if (!O2(a2)) throw Error("React.Children.only expected to receive a single React element child.");
    return a2;
  } };
  react_production_min.Component = E2;
  react_production_min.Fragment = p2;
  react_production_min.Profiler = r2;
  react_production_min.PureComponent = G2;
  react_production_min.StrictMode = q2;
  react_production_min.Suspense = w2;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W2;
  react_production_min.act = X2;
  react_production_min.cloneElement = function(a2, b2, e3) {
    if (null === a2 || void 0 === a2) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
    var d2 = C2({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
    if (null != b2) {
      void 0 !== b2.ref && (k2 = b2.ref, h2 = K2.current);
      void 0 !== b2.key && (c2 = "" + b2.key);
      if (a2.type && a2.type.defaultProps) var g2 = a2.type.defaultProps;
      for (f2 in b2) J2.call(b2, f2) && !L2.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
    }
    var f2 = arguments.length - 2;
    if (1 === f2) d2.children = e3;
    else if (1 < f2) {
      g2 = Array(f2);
      for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
      d2.children = g2;
    }
    return { $$typeof: l2, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
  };
  react_production_min.createContext = function(a2) {
    a2 = { $$typeof: u2, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a2.Provider = { $$typeof: t2, _context: a2 };
    return a2.Consumer = a2;
  };
  react_production_min.createElement = M2;
  react_production_min.createFactory = function(a2) {
    var b2 = M2.bind(null, a2);
    b2.type = a2;
    return b2;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a2) {
    return { $$typeof: v2, render: a2 };
  };
  react_production_min.isValidElement = O2;
  react_production_min.lazy = function(a2) {
    return { $$typeof: y2, _payload: { _status: -1, _result: a2 }, _init: T2 };
  };
  react_production_min.memo = function(a2, b2) {
    return { $$typeof: x2, type: a2, compare: void 0 === b2 ? null : b2 };
  };
  react_production_min.startTransition = function(a2) {
    var b2 = V2.transition;
    V2.transition = {};
    try {
      a2();
    } finally {
      V2.transition = b2;
    }
  };
  react_production_min.unstable_act = X2;
  react_production_min.useCallback = function(a2, b2) {
    return U2.current.useCallback(a2, b2);
  };
  react_production_min.useContext = function(a2) {
    return U2.current.useContext(a2);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a2) {
    return U2.current.useDeferredValue(a2);
  };
  react_production_min.useEffect = function(a2, b2) {
    return U2.current.useEffect(a2, b2);
  };
  react_production_min.useId = function() {
    return U2.current.useId();
  };
  react_production_min.useImperativeHandle = function(a2, b2, e3) {
    return U2.current.useImperativeHandle(a2, b2, e3);
  };
  react_production_min.useInsertionEffect = function(a2, b2) {
    return U2.current.useInsertionEffect(a2, b2);
  };
  react_production_min.useLayoutEffect = function(a2, b2) {
    return U2.current.useLayoutEffect(a2, b2);
  };
  react_production_min.useMemo = function(a2, b2) {
    return U2.current.useMemo(a2, b2);
  };
  react_production_min.useReducer = function(a2, b2, e3) {
    return U2.current.useReducer(a2, b2, e3);
  };
  react_production_min.useRef = function(a2) {
    return U2.current.useRef(a2);
  };
  react_production_min.useState = function(a2) {
    return U2.current.useState(a2);
  };
  react_production_min.useSyncExternalStore = function(a2, b2, e3) {
    return U2.current.useSyncExternalStore(a2, b2, e3);
  };
  react_production_min.useTransition = function() {
    return U2.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  return react_production_min;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  {
    react.exports = requireReact_production_min();
  }
  return react.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f2 = requireReact(), k2 = Symbol.for("react.element"), l2 = Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n2 = f2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p2 = { key: true, ref: true, __self: true, __source: true };
  function q2(c2, a2, g2) {
    var b2, d2 = {}, e3 = null, h2 = null;
    void 0 !== g2 && (e3 = "" + g2);
    void 0 !== a2.key && (e3 = "" + a2.key);
    void 0 !== a2.ref && (h2 = a2.ref);
    for (b2 in a2) m2.call(a2, b2) && !p2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
    if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
    return { $$typeof: k2, type: c2, key: e3, ref: h2, props: d2, _owner: n2.current };
  }
  reactJsxRuntime_production_min.Fragment = l2;
  reactJsxRuntime_production_min.jsx = q2;
  reactJsxRuntime_production_min.jsxs = q2;
  return reactJsxRuntime_production_min;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var reactExports = requireReact();
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  if (hasRequiredScheduler_production_min) return scheduler_production_min;
  hasRequiredScheduler_production_min = 1;
  (function(exports) {
    function f2(a2, b2) {
      var c2 = a2.length;
      a2.push(b2);
      a: for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e3 = a2[d2];
        if (0 < g2(e3, b2)) a2[d2] = b2, a2[c2] = e3, c2 = d2;
        else break a;
      }
    }
    function h2(a2) {
      return 0 === a2.length ? null : a2[0];
    }
    function k2(a2) {
      if (0 === a2.length) return null;
      var b2 = a2[0], c2 = a2.pop();
      if (c2 !== b2) {
        a2[0] = c2;
        a: for (var d2 = 0, e3 = a2.length, w2 = e3 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2)) n2 < e3 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e3 && 0 > g2(x2, c2)) a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else break a;
        }
      }
      return b2;
    }
    function g2(a2, b2) {
      var c2 = a2.sortIndex - b2.sortIndex;
      return 0 !== c2 ? c2 : a2.id - b2.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l2 = performance;
      exports.unstable_now = function() {
        return l2.now();
      };
    } else {
      var p2 = Date, q2 = p2.now();
      exports.unstable_now = function() {
        return p2.now() - q2;
      };
    }
    var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G2(a2) {
      for (var b2 = h2(t2); null !== b2; ) {
        if (null === b2.callback) k2(t2);
        else if (b2.startTime <= a2) k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
        else break;
        b2 = h2(t2);
      }
    }
    function H2(a2) {
      B2 = false;
      G2(a2);
      if (!A2) if (null !== h2(r2)) A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
    }
    function J2(a2, b2) {
      A2 = false;
      B2 && (B2 = false, E2(L2), L2 = -1);
      z2 = true;
      var c2 = y2;
      try {
        G2(b2);
        for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
          var d2 = v2.callback;
          if ("function" === typeof d2) {
            v2.callback = null;
            y2 = v2.priorityLevel;
            var e3 = d2(v2.expirationTime <= b2);
            b2 = exports.unstable_now();
            "function" === typeof e3 ? v2.callback = e3 : v2 === h2(r2) && k2(r2);
            G2(b2);
          } else k2(r2);
          v2 = h2(r2);
        }
        if (null !== v2) var w2 = true;
        else {
          var m2 = h2(t2);
          null !== m2 && K2(H2, m2.startTime - b2);
          w2 = false;
        }
        return w2;
      } finally {
        v2 = null, y2 = c2, z2 = false;
      }
    }
    var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
    function M2() {
      return exports.unstable_now() - Q2 < P2 ? false : true;
    }
    function R2() {
      if (null !== O2) {
        var a2 = exports.unstable_now();
        Q2 = a2;
        var b2 = true;
        try {
          b2 = O2(true, a2);
        } finally {
          b2 ? S2() : (N2 = false, O2 = null);
        }
      } else N2 = false;
    }
    var S2;
    if ("function" === typeof F2) S2 = function() {
      F2(R2);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T2 = new MessageChannel(), U2 = T2.port2;
      T2.port1.onmessage = R2;
      S2 = function() {
        U2.postMessage(null);
      };
    } else S2 = function() {
      D2(R2, 0);
    };
    function I2(a2) {
      O2 = a2;
      N2 || (N2 = true, S2());
    }
    function K2(a2, b2) {
      L2 = D2(function() {
        a2(exports.unstable_now());
      }, b2);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a2) {
      a2.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A2 || z2 || (A2 = true, I2(J2));
    };
    exports.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y2;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h2(r2);
    };
    exports.unstable_next = function(a2) {
      switch (y2) {
        case 1:
        case 2:
        case 3:
          var b2 = 3;
          break;
        default:
          b2 = y2;
      }
      var c2 = y2;
      y2 = b2;
      try {
        return a2();
      } finally {
        y2 = c2;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a2, b2) {
      switch (a2) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a2 = 3;
      }
      var c2 = y2;
      y2 = a2;
      try {
        return b2();
      } finally {
        y2 = c2;
      }
    };
    exports.unstable_scheduleCallback = function(a2, b2, c2) {
      var d2 = exports.unstable_now();
      "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
      switch (a2) {
        case 1:
          var e3 = -1;
          break;
        case 2:
          e3 = 250;
          break;
        case 5:
          e3 = 1073741823;
          break;
        case 4:
          e3 = 1e4;
          break;
        default:
          e3 = 5e3;
      }
      e3 = c2 + e3;
      a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e3, sortIndex: -1 };
      c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e3, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
      return a2;
    };
    exports.unstable_shouldYield = M2;
    exports.unstable_wrapCallback = function(a2) {
      var b2 = y2;
      return function() {
        var c2 = y2;
        y2 = b2;
        try {
          return a2.apply(this, arguments);
        } finally {
          y2 = c2;
        }
      };
    };
  })(scheduler_production_min);
  return scheduler_production_min;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production_min();
  }
  return scheduler.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa = requireReact(), ca = requireScheduler();
  function p2(a2) {
    for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
    return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a2, b2) {
    ha(a2, b2);
    ha(a2 + "Capture", b2);
  }
  function ha(a2, b2) {
    ea[a2] = b2;
    for (a2 = 0; a2 < b2.length; a2++) da.add(b2[a2]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka2 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a2) {
    if (ja.call(ma, a2)) return true;
    if (ja.call(la, a2)) return false;
    if (ka2.test(a2)) return ma[a2] = true;
    la[a2] = true;
    return false;
  }
  function pa(a2, b2, c2, d2) {
    if (null !== c2 && 0 === c2.type) return false;
    switch (typeof b2) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d2) return false;
        if (null !== c2) return !c2.acceptsBooleans;
        a2 = a2.toLowerCase().slice(0, 5);
        return "data-" !== a2 && "aria-" !== a2;
      default:
        return false;
    }
  }
  function qa(a2, b2, c2, d2) {
    if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2)) return true;
    if (d2) return false;
    if (null !== c2) switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
    return false;
  }
  function v2(a2, b2, c2, d2, e3, f2, g2) {
    this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
    this.attributeName = d2;
    this.attributeNamespace = e3;
    this.mustUseProperty = c2;
    this.propertyName = a2;
    this.type = b2;
    this.sanitizeURL = f2;
    this.removeEmptyString = g2;
  }
  var z2 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
    z2[a2] = new v2(a2, 0, false, a2, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
    var b2 = a2[0];
    z2[b2] = new v2(b2, 1, false, a2[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
    z2[a2] = new v2(a2, 2, false, a2.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
    z2[a2] = new v2(a2, 2, false, a2, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
    z2[a2] = new v2(a2, 3, false, a2.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
    z2[a2] = new v2(a2, 3, true, a2, null, false, false);
  });
  ["capture", "download"].forEach(function(a2) {
    z2[a2] = new v2(a2, 4, false, a2, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a2) {
    z2[a2] = new v2(a2, 6, false, a2, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a2) {
    z2[a2] = new v2(a2, 5, false, a2.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a2) {
    return a2[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
    var b2 = a2.replace(
      ra,
      sa
    );
    z2[b2] = new v2(b2, 1, false, a2, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
    var b2 = a2.replace(ra, sa);
    z2[b2] = new v2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
    var b2 = a2.replace(ra, sa);
    z2[b2] = new v2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a2) {
    z2[a2] = new v2(a2, 1, false, a2.toLowerCase(), null, false, false);
  });
  z2.xlinkHref = new v2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a2) {
    z2[a2] = new v2(a2, 1, false, a2.toLowerCase(), null, true, true);
  });
  function ta(a2, b2, c2, d2) {
    var e3 = z2.hasOwnProperty(b2) ? z2[b2] : null;
    if (null !== e3 ? 0 !== e3.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c2, e3, d2) && (c2 = null), d2 || null === e3 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e3.mustUseProperty ? a2[e3.propertyName] = null === c2 ? 3 === e3.type ? false : "" : c2 : (b2 = e3.attributeName, d2 = e3.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e3 = e3.type, c2 = 3 === e3 || 4 === e3 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = Ja && a2[Ja] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var A2 = Object.assign, La;
  function Ma(a2) {
    if (void 0 === La) try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
    return "\n" + La + a2;
  }
  var Na = false;
  function Oa(a2, b2) {
    if (!a2 || Na) return "";
    Na = true;
    var c2 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b2) if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l2) {
          d2 = l2;
        }
        a2();
      }
    } catch (l2) {
      if (l2 && d2 && "string" === typeof l2.stack) {
        for (var e3 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e3.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e3[g2] !== f2[h2]; ) h2--;
        for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e3[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e3[g2] !== f2[h2]) {
                var k2 = "\n" + e3[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c2;
    }
    return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
  }
  function Pa(a2) {
    switch (a2.tag) {
      case 5:
        return Ma(a2.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a2 = Oa(a2.type, false), a2;
      case 11:
        return a2 = Oa(a2.type.render, false), a2;
      case 1:
        return a2 = Oa(a2.type, true), a2;
      default:
        return "";
    }
  }
  function Qa(a2) {
    if (null == a2) return null;
    if ("function" === typeof a2) return a2.displayName || a2.name || null;
    if ("string" === typeof a2) return a2;
    switch (a2) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a2) switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
    return null;
  }
  function Ra(a2) {
    var b2 = a2.type;
    switch (a2.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b2.displayName || "Context") + ".Consumer";
      case 10:
        return (b2._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b2;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b2);
      case 8:
        return b2 === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b2) return b2.displayName || b2.name || null;
        if ("string" === typeof b2) return b2;
    }
    return null;
  }
  function Sa(a2) {
    switch (typeof a2) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a2;
      case "object":
        return a2;
      default:
        return "";
    }
  }
  function Ta(a2) {
    var b2 = a2.type;
    return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
  }
  function Ua(a2) {
    var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
    if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
      var e3 = c2.get, f2 = c2.set;
      Object.defineProperty(a2, b2, { configurable: true, get: function() {
        return e3.call(this);
      }, set: function(a3) {
        d2 = "" + a3;
        f2.call(this, a3);
      } });
      Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
      return { getValue: function() {
        return d2;
      }, setValue: function(a3) {
        d2 = "" + a3;
      }, stopTracking: function() {
        a2._valueTracker = null;
        delete a2[b2];
      } };
    }
  }
  function Va(a2) {
    a2._valueTracker || (a2._valueTracker = Ua(a2));
  }
  function Wa(a2) {
    if (!a2) return false;
    var b2 = a2._valueTracker;
    if (!b2) return true;
    var c2 = b2.getValue();
    var d2 = "";
    a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
    a2 = d2;
    return a2 !== c2 ? (b2.setValue(a2), true) : false;
  }
  function Xa(a2) {
    a2 = a2 || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a2) return null;
    try {
      return a2.activeElement || a2.body;
    } catch (b2) {
      return a2.body;
    }
  }
  function Ya(a2, b2) {
    var c2 = b2.checked;
    return A2({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
  }
  function Za(a2, b2) {
    var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
    c2 = Sa(null != b2.value ? b2.value : c2);
    a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
  }
  function ab(a2, b2) {
    b2 = b2.checked;
    null != b2 && ta(a2, "checked", b2, false);
  }
  function bb(a2, b2) {
    ab(a2, b2);
    var c2 = Sa(b2.value), d2 = b2.type;
    if (null != c2) if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2) a2.value = "" + c2;
    } else a2.value !== "" + c2 && (a2.value = "" + c2);
    else if ("submit" === d2 || "reset" === d2) {
      a2.removeAttribute("value");
      return;
    }
    b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
    null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
  }
  function db(a2, b2, c2) {
    if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
      var d2 = b2.type;
      if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value)) return;
      b2 = "" + a2._wrapperState.initialValue;
      c2 || b2 === a2.value || (a2.value = b2);
      a2.defaultValue = b2;
    }
    c2 = a2.name;
    "" !== c2 && (a2.name = "");
    a2.defaultChecked = !!a2._wrapperState.initialChecked;
    "" !== c2 && (a2.name = c2);
  }
  function cb(a2, b2, c2) {
    if ("number" !== b2 || Xa(a2.ownerDocument) !== a2) null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
  }
  var eb = Array.isArray;
  function fb(a2, b2, c2, d2) {
    a2 = a2.options;
    if (b2) {
      b2 = {};
      for (var e3 = 0; e3 < c2.length; e3++) b2["$" + c2[e3]] = true;
      for (c2 = 0; c2 < a2.length; c2++) e3 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e3 && (a2[c2].selected = e3), e3 && d2 && (a2[c2].defaultSelected = true);
    } else {
      c2 = "" + Sa(c2);
      b2 = null;
      for (e3 = 0; e3 < a2.length; e3++) {
        if (a2[e3].value === c2) {
          a2[e3].selected = true;
          d2 && (a2[e3].defaultSelected = true);
          return;
        }
        null !== b2 || a2[e3].disabled || (b2 = a2[e3]);
      }
      null !== b2 && (b2.selected = true);
    }
  }
  function gb(a2, b2) {
    if (null != b2.dangerouslySetInnerHTML) throw Error(p2(91));
    return A2({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
  }
  function hb(a2, b2) {
    var c2 = b2.value;
    if (null == c2) {
      c2 = b2.children;
      b2 = b2.defaultValue;
      if (null != c2) {
        if (null != b2) throw Error(p2(92));
        if (eb(c2)) {
          if (1 < c2.length) throw Error(p2(93));
          c2 = c2[0];
        }
        b2 = c2;
      }
      null == b2 && (b2 = "");
      c2 = b2;
    }
    a2._wrapperState = { initialValue: Sa(c2) };
  }
  function ib(a2, b2) {
    var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
    null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
    null != d2 && (a2.defaultValue = "" + d2);
  }
  function jb(a2) {
    var b2 = a2.textContent;
    b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
  }
  function kb(a2) {
    switch (a2) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a2, b2) {
    return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
  }
  var mb, nb = (function(a2) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e3) {
      MSApp.execUnsafeLocalFunction(function() {
        return a2(b2, c2, d2, e3);
      });
    } : a2;
  })(function(a2, b2) {
    if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2) a2.innerHTML = b2;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
      for (b2 = mb.firstChild; a2.firstChild; ) a2.removeChild(a2.firstChild);
      for (; b2.firstChild; ) a2.appendChild(b2.firstChild);
    }
  });
  function ob(a2, b2) {
    if (b2) {
      var c2 = a2.firstChild;
      if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
        c2.nodeValue = b2;
        return;
      }
    }
    a2.textContent = b2;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a2) {
    qb.forEach(function(b2) {
      b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
      pb[b2] = pb[a2];
    });
  });
  function rb(a2, b2, c2) {
    return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
  }
  function sb(a2, b2) {
    a2 = a2.style;
    for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e3 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e3) : a2[c2] = e3;
    }
  }
  var tb = A2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a2, b2) {
    if (b2) {
      if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p2(137, a2));
      if (null != b2.dangerouslySetInnerHTML) {
        if (null != b2.children) throw Error(p2(60));
        if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p2(61));
      }
      if (null != b2.style && "object" !== typeof b2.style) throw Error(p2(62));
    }
  }
  function vb(a2, b2) {
    if (-1 === a2.indexOf("-")) return "string" === typeof b2.is;
    switch (a2) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a2) {
    a2 = a2.target || a2.srcElement || window;
    a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
    return 3 === a2.nodeType ? a2.parentNode : a2;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a2) {
    if (a2 = Cb(a2)) {
      if ("function" !== typeof yb) throw Error(p2(280));
      var b2 = a2.stateNode;
      b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
    }
  }
  function Eb(a2) {
    zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
  }
  function Fb() {
    if (zb) {
      var a2 = zb, b2 = Ab;
      Ab = zb = null;
      Bb(a2);
      if (b2) for (a2 = 0; a2 < b2.length; a2++) Bb(b2[a2]);
    }
  }
  function Gb(a2, b2) {
    return a2(b2);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a2, b2, c2) {
    if (Ib) return a2(b2, c2);
    Ib = true;
    try {
      return Gb(a2, b2, c2);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a2, b2) {
    var c2 = a2.stateNode;
    if (null === c2) return null;
    var d2 = Db(c2);
    if (null === d2) return null;
    c2 = d2[b2];
    a: switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
    if (a2) return null;
    if (c2 && "function" !== typeof c2) throw Error(p2(231, b2, typeof c2));
    return c2;
  }
  var Lb = false;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
  function Nb(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
    var l2 = Array.prototype.slice.call(arguments, 3);
    try {
      b2.apply(c2, l2);
    } catch (m2) {
      this.onError(m2);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
    Ob = true;
    Pb = a2;
  } };
  function Tb(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l2 = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p2(198));
      Qb || (Qb = true, Rb = l2);
    }
  }
  function Vb(a2) {
    var b2 = a2, c2 = a2;
    if (a2.alternate) for (; b2.return; ) b2 = b2.return;
    else {
      a2 = b2;
      do
        b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
      while (a2);
    }
    return 3 === b2.tag ? c2 : null;
  }
  function Wb(a2) {
    if (13 === a2.tag) {
      var b2 = a2.memoizedState;
      null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
      if (null !== b2) return b2.dehydrated;
    }
    return null;
  }
  function Xb(a2) {
    if (Vb(a2) !== a2) throw Error(p2(188));
  }
  function Yb(a2) {
    var b2 = a2.alternate;
    if (!b2) {
      b2 = Vb(a2);
      if (null === b2) throw Error(p2(188));
      return b2 !== a2 ? null : a2;
    }
    for (var c2 = a2, d2 = b2; ; ) {
      var e3 = c2.return;
      if (null === e3) break;
      var f2 = e3.alternate;
      if (null === f2) {
        d2 = e3.return;
        if (null !== d2) {
          c2 = d2;
          continue;
        }
        break;
      }
      if (e3.child === f2.child) {
        for (f2 = e3.child; f2; ) {
          if (f2 === c2) return Xb(e3), a2;
          if (f2 === d2) return Xb(e3), b2;
          f2 = f2.sibling;
        }
        throw Error(p2(188));
      }
      if (c2.return !== d2.return) c2 = e3, d2 = f2;
      else {
        for (var g2 = false, h2 = e3.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = e3;
            d2 = f2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = e3;
            c2 = f2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) {
          for (h2 = f2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = f2;
              d2 = e3;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = f2;
              c2 = e3;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) throw Error(p2(189));
        }
      }
      if (c2.alternate !== d2) throw Error(p2(190));
    }
    if (3 !== c2.tag) throw Error(p2(188));
    return c2.stateNode.current === c2 ? a2 : b2;
  }
  function Zb(a2) {
    a2 = Yb(a2);
    return null !== a2 ? $b(a2) : null;
  }
  function $b(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2;
    for (a2 = a2.child; null !== a2; ) {
      var b2 = $b(a2);
      if (null !== b2) return b2;
      a2 = a2.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B2 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a2) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a2) {
    a2 >>>= 0;
    return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a2) {
    switch (a2 & -a2) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a2 & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a2 & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a2;
    }
  }
  function uc(a2, b2) {
    var c2 = a2.pendingLanes;
    if (0 === c2) return 0;
    var d2 = 0, e3 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
    if (0 !== g2) {
      var h2 = g2 & ~e3;
      0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
    } else g2 = c2 & ~e3, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
    if (0 === d2) return 0;
    if (0 !== b2 && b2 !== d2 && 0 === (b2 & e3) && (e3 = d2 & -d2, f2 = b2 & -b2, e3 >= f2 || 16 === e3 && 0 !== (f2 & 4194240))) return b2;
    0 !== (d2 & 4) && (d2 |= c2 & 16);
    b2 = a2.entangledLanes;
    if (0 !== b2) for (a2 = a2.entanglements, b2 &= d2; 0 < b2; ) c2 = 31 - oc(b2), e3 = 1 << c2, d2 |= a2[c2], b2 &= ~e3;
    return d2;
  }
  function vc(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 4:
        return b2 + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b2 + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a2, b2) {
    for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e3 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
      var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e3[g2];
      if (-1 === k2) {
        if (0 === (h2 & c2) || 0 !== (h2 & d2)) e3[g2] = vc(h2, b2);
      } else k2 <= b2 && (a2.expiredLanes |= h2);
      f2 &= ~h2;
    }
  }
  function xc(a2) {
    a2 = a2.pendingLanes & -1073741825;
    return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a2 = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a2;
  }
  function zc(a2) {
    for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a2);
    return b2;
  }
  function Ac(a2, b2, c2) {
    a2.pendingLanes |= b2;
    536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
    a2 = a2.eventTimes;
    b2 = 31 - oc(b2);
    a2[b2] = c2;
  }
  function Bc(a2, b2) {
    var c2 = a2.pendingLanes & ~b2;
    a2.pendingLanes = b2;
    a2.suspendedLanes = 0;
    a2.pingedLanes = 0;
    a2.expiredLanes &= b2;
    a2.mutableReadLanes &= b2;
    a2.entangledLanes &= b2;
    b2 = a2.entanglements;
    var d2 = a2.eventTimes;
    for (a2 = a2.expirationTimes; 0 < c2; ) {
      var e3 = 31 - oc(c2), f2 = 1 << e3;
      b2[e3] = 0;
      d2[e3] = -1;
      a2[e3] = -1;
      c2 &= ~f2;
    }
  }
  function Cc(a2, b2) {
    var c2 = a2.entangledLanes |= b2;
    for (a2 = a2.entanglements; c2; ) {
      var d2 = 31 - oc(c2), e3 = 1 << d2;
      e3 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
      c2 &= ~e3;
    }
  }
  var C2 = 0;
  function Dc(a2) {
    a2 &= -a2;
    return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a2, b2) {
    switch (a2) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b2.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b2.pointerId);
    }
  }
  function Tc(a2, b2, c2, d2, e3, f2) {
    if (null === a2 || a2.nativeEvent !== f2) return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e3] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
    a2.eventSystemFlags |= d2;
    b2 = a2.targetContainers;
    null !== e3 && -1 === b2.indexOf(e3) && b2.push(e3);
    return a2;
  }
  function Uc(a2, b2, c2, d2, e3) {
    switch (b2) {
      case "focusin":
        return Lc = Tc(Lc, a2, b2, c2, d2, e3), true;
      case "dragenter":
        return Mc = Tc(Mc, a2, b2, c2, d2, e3), true;
      case "mouseover":
        return Nc = Tc(Nc, a2, b2, c2, d2, e3), true;
      case "pointerover":
        var f2 = e3.pointerId;
        Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e3));
        return true;
      case "gotpointercapture":
        return f2 = e3.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e3)), true;
    }
    return false;
  }
  function Vc(a2) {
    var b2 = Wc(a2.target);
    if (null !== b2) {
      var c2 = Vb(b2);
      if (null !== c2) {
        if (b2 = c2.tag, 13 === b2) {
          if (b2 = Wb(c2), null !== b2) {
            a2.blockedOn = b2;
            Ic(a2.priority, function() {
              Gc(c2);
            });
            return;
          }
        } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
          a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a2.blockedOn = null;
  }
  function Xc(a2) {
    if (null !== a2.blockedOn) return false;
    for (var b2 = a2.targetContainers; 0 < b2.length; ) {
      var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
      if (null === c2) {
        c2 = a2.nativeEvent;
        var d2 = new c2.constructor(c2.type, c2);
        wb = d2;
        c2.target.dispatchEvent(d2);
        wb = null;
      } else return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
      b2.shift();
    }
    return true;
  }
  function Zc(a2, b2, c2) {
    Xc(a2) && c2.delete(b2);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a2, b2) {
    a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a2) {
    function b2(b3) {
      return ad(b3, a2);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a2);
      for (var c2 = 1; c2 < Kc.length; c2++) {
        var d2 = Kc[c2];
        d2.blockedOn === a2 && (d2.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a2);
    null !== Mc && ad(Mc, a2);
    null !== Nc && ad(Nc, a2);
    Oc.forEach(b2);
    Pc.forEach(b2);
    for (c2 = 0; c2 < Qc.length; c2++) d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
    for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a2, b2, c2, d2) {
    var e3 = C2, f2 = cd.transition;
    cd.transition = null;
    try {
      C2 = 1, fd(a2, b2, c2, d2);
    } finally {
      C2 = e3, cd.transition = f2;
    }
  }
  function gd(a2, b2, c2, d2) {
    var e3 = C2, f2 = cd.transition;
    cd.transition = null;
    try {
      C2 = 4, fd(a2, b2, c2, d2);
    } finally {
      C2 = e3, cd.transition = f2;
    }
  }
  function fd(a2, b2, c2, d2) {
    if (dd) {
      var e3 = Yc(a2, b2, c2, d2);
      if (null === e3) hd(a2, b2, d2, id, c2), Sc(a2, d2);
      else if (Uc(e3, a2, b2, c2, d2)) d2.stopPropagation();
      else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
        for (; null !== e3; ) {
          var f2 = Cb(e3);
          null !== f2 && Ec(f2);
          f2 = Yc(a2, b2, c2, d2);
          null === f2 && hd(a2, b2, d2, id, c2);
          if (f2 === e3) break;
          e3 = f2;
        }
        null !== e3 && d2.stopPropagation();
      } else hd(a2, b2, d2, null, c2);
    }
  }
  var id = null;
  function Yc(a2, b2, c2, d2) {
    id = null;
    a2 = xb(d2);
    a2 = Wc(a2);
    if (null !== a2) if (b2 = Vb(a2), null === b2) a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2) return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else b2 !== a2 && (a2 = null);
    id = a2;
    return null;
  }
  function jd(a2) {
    switch (a2) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a2, b2 = ld, c2 = b2.length, d2, e3 = "value" in kd ? kd.value : kd.textContent, f2 = e3.length;
    for (a2 = 0; a2 < c2 && b2[a2] === e3[a2]; a2++) ;
    var g2 = c2 - a2;
    for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e3[f2 - d2]; d2++) ;
    return md = e3.slice(a2, 1 < d2 ? 1 - d2 : void 0);
  }
  function od(a2) {
    var b2 = a2.keyCode;
    "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
    10 === a2 && (a2 = 13);
    return 32 <= a2 || 13 === a2 ? a2 : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a2) {
    function b2(b3, d2, e3, f2, g2) {
      this._reactName = b3;
      this._targetInst = e3;
      this.type = d2;
      this.nativeEvent = f2;
      this.target = g2;
      this.currentTarget = null;
      for (var c2 in a2) a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
      this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A2(b2.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a3 = this.nativeEvent;
      a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a3 = this.nativeEvent;
      a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b2;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
    return a2.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A2({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
    return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
  }, movementX: function(a2) {
    if ("movementX" in a2) return a2.movementX;
    a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
    return wd;
  }, movementY: function(a2) {
    return "movementY" in a2 ? a2.movementY : xd;
  } }), Bd = rd(Ad), Cd = A2({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A2({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A2({}, sd, { clipboardData: function(a2) {
    return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A2({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a2) {
    var b2 = this.nativeEvent;
    return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A2({}, ud, { key: function(a2) {
    if (a2.key) {
      var b2 = Md[a2.key] || a2.key;
      if ("Unidentified" !== b2) return b2;
    }
    return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
    return "keypress" === a2.type ? od(a2) : 0;
  }, keyCode: function(a2) {
    return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  }, which: function(a2) {
    return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A2({}, Ad, {
    deltaX: function(a2) {
      return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
    },
    deltaY: function(a2) {
      return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a2, b2) {
    switch (a2) {
      case "keyup":
        return -1 !== $d.indexOf(b2.keyCode);
      case "keydown":
        return 229 !== b2.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a2) {
    a2 = a2.detail;
    return "object" === typeof a2 && "data" in a2 ? a2.data : null;
  }
  var ie = false;
  function je(a2, b2) {
    switch (a2) {
      case "compositionend":
        return he(b2);
      case "keypress":
        if (32 !== b2.which) return null;
        fe = true;
        return ee;
      case "textInput":
        return a2 = b2.data, a2 === ee && fe ? null : a2;
      default:
        return null;
    }
  }
  function ke(a2, b2) {
    if (ie) return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
    switch (a2) {
      case "paste":
        return null;
      case "keypress":
        if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
          if (b2.char && 1 < b2.char.length) return b2.char;
          if (b2.which) return String.fromCharCode(b2.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b2.locale ? null : b2.data;
      default:
        return null;
    }
  }
  var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a2) {
    var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
  }
  function ne(a2, b2, c2, d2) {
    Eb(d2);
    b2 = oe(b2, "onChange");
    0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
  }
  var pe = null, qe = null;
  function re2(a2) {
    se(a2, 0);
  }
  function te(a2) {
    var b2 = ue(a2);
    if (Wa(b2)) return a2;
  }
  function ve(a2, b2) {
    if ("change" === a2) return b2;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }
      xe = ye;
    } else xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a2) {
    if ("value" === a2.propertyName && te(qe)) {
      var b2 = [];
      ne(b2, qe, a2, xb(a2));
      Jb(re2, b2);
    }
  }
  function Ce(a2, b2, c2) {
    "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
  }
  function De(a2) {
    if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2) return te(qe);
  }
  function Ee(a2, b2) {
    if ("click" === a2) return te(b2);
  }
  function Fe(a2, b2) {
    if ("input" === a2 || "change" === a2) return te(b2);
  }
  function Ge(a2, b2) {
    return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a2, b2) {
    if (He(a2, b2)) return true;
    if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2) return false;
    var c2 = Object.keys(a2), d2 = Object.keys(b2);
    if (c2.length !== d2.length) return false;
    for (d2 = 0; d2 < c2.length; d2++) {
      var e3 = c2[d2];
      if (!ja.call(b2, e3) || !He(a2[e3], b2[e3])) return false;
    }
    return true;
  }
  function Je(a2) {
    for (; a2 && a2.firstChild; ) a2 = a2.firstChild;
    return a2;
  }
  function Ke(a2, b2) {
    var c2 = Je(a2);
    a2 = 0;
    for (var d2; c2; ) {
      if (3 === c2.nodeType) {
        d2 = a2 + c2.textContent.length;
        if (a2 <= b2 && d2 >= b2) return { node: c2, offset: b2 - a2 };
        a2 = d2;
      }
      a: {
        for (; c2; ) {
          if (c2.nextSibling) {
            c2 = c2.nextSibling;
            break a;
          }
          c2 = c2.parentNode;
        }
        c2 = void 0;
      }
      c2 = Je(c2);
    }
  }
  function Le(a2, b2) {
    return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
  }
  function Me() {
    for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
      try {
        var c2 = "string" === typeof b2.contentWindow.location.href;
      } catch (d2) {
        c2 = false;
      }
      if (c2) a2 = b2.contentWindow;
      else break;
      b2 = Xa(a2.document);
    }
    return b2;
  }
  function Ne(a2) {
    var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
  }
  function Oe(a2) {
    var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
    if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
      if (null !== d2 && Ne(c2)) {
        if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
        else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
          a2 = a2.getSelection();
          var e3 = c2.textContent.length, f2 = Math.min(d2.start, e3);
          d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e3);
          !a2.extend && f2 > d2 && (e3 = d2, d2 = f2, f2 = e3);
          e3 = Ke(c2, f2);
          var g2 = Ke(
            c2,
            d2
          );
          e3 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e3.node || a2.anchorOffset !== e3.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e3.node, e3.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
        }
      }
      b2 = [];
      for (a2 = c2; a2 = a2.parentNode; ) 1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
      "function" === typeof c2.focus && c2.focus();
      for (c2 = 0; c2 < b2.length; c2++) a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a2, b2, c2) {
    var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
    Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
  }
  function Ve(a2, b2) {
    var c2 = {};
    c2[a2.toLowerCase()] = b2.toLowerCase();
    c2["Webkit" + a2] = "webkit" + b2;
    c2["Moz" + a2] = "moz" + b2;
    return c2;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a2) {
    if (Xe[a2]) return Xe[a2];
    if (!We[a2]) return a2;
    var b2 = We[a2], c2;
    for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye) return Xe[a2] = b2[c2];
    return a2;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a2, b2) {
    df.set(a2, b2);
    fa(b2, [a2]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a2, b2, c2) {
    var d2 = a2.type || "unknown-event";
    a2.currentTarget = c2;
    Ub(d2, b2, void 0, a2);
    a2.currentTarget = null;
  }
  function se(a2, b2) {
    b2 = 0 !== (b2 & 4);
    for (var c2 = 0; c2 < a2.length; c2++) {
      var d2 = a2[c2], e3 = d2.event;
      d2 = d2.listeners;
      a: {
        var f2 = void 0;
        if (b2) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e3.isPropagationStopped()) break a;
          nf(e3, h2, l2);
          f2 = k2;
        }
        else for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e3.isPropagationStopped()) break a;
          nf(e3, h2, l2);
          f2 = k2;
        }
      }
    }
    if (Qb) throw a2 = Rb, Qb = false, Rb = null, a2;
  }
  function D2(a2, b2) {
    var c2 = b2[of];
    void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
    var d2 = a2 + "__bubble";
    c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
  }
  function qf(a2, b2, c2) {
    var d2 = 0;
    b2 && (d2 |= 4);
    pf(c2, a2, d2, b2);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a2) {
    if (!a2[rf]) {
      a2[rf] = true;
      da.forEach(function(b3) {
        "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
      });
      var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
      null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
    }
  }
  function pf(a2, b2, c2, d2) {
    switch (jd(b2)) {
      case 1:
        var e3 = ed;
        break;
      case 4:
        e3 = gd;
        break;
      default:
        e3 = fd;
    }
    c2 = e3.bind(null, b2, c2, a2);
    e3 = void 0;
    !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e3 = true);
    d2 ? void 0 !== e3 ? a2.addEventListener(b2, c2, { capture: true, passive: e3 }) : a2.addEventListener(b2, c2, true) : void 0 !== e3 ? a2.addEventListener(b2, c2, { passive: e3 }) : a2.addEventListener(b2, c2, false);
  }
  function hd(a2, b2, c2, d2, e3) {
    var f2 = d2;
    if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2) a: for (; ; ) {
      if (null === d2) return;
      var g2 = d2.tag;
      if (3 === g2 || 4 === g2) {
        var h2 = d2.stateNode.containerInfo;
        if (h2 === e3 || 8 === h2.nodeType && h2.parentNode === e3) break;
        if (4 === g2) for (g2 = d2.return; null !== g2; ) {
          var k2 = g2.tag;
          if (3 === k2 || 4 === k2) {
            if (k2 = g2.stateNode.containerInfo, k2 === e3 || 8 === k2.nodeType && k2.parentNode === e3) return;
          }
          g2 = g2.return;
        }
        for (; null !== h2; ) {
          g2 = Wc(h2);
          if (null === g2) return;
          k2 = g2.tag;
          if (5 === k2 || 6 === k2) {
            d2 = f2 = g2;
            continue a;
          }
          h2 = h2.parentNode;
        }
      }
      d2 = d2.return;
    }
    Jb(function() {
      var d3 = f2, e4 = xb(c2), g3 = [];
      a: {
        var h3 = df.get(a2);
        if (void 0 !== h3) {
          var k3 = td, n2 = a2;
          switch (a2) {
            case "keypress":
              if (0 === od(c2)) break a;
            case "keydown":
            case "keyup":
              k3 = Rd;
              break;
            case "focusin":
              n2 = "focus";
              k3 = Fd;
              break;
            case "focusout":
              n2 = "blur";
              k3 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k3 = Fd;
              break;
            case "click":
              if (2 === c2.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k3 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k3 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k3 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k3 = Hd;
              break;
            case cf:
              k3 = Xd;
              break;
            case "scroll":
              k3 = vd;
              break;
            case "wheel":
              k3 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k3 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k3 = Td;
          }
          var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
          t2 = [];
          for (var w2 = d3, u2; null !== w2; ) {
            u2 = w2;
            var F2 = u2.stateNode;
            5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
            if (J2) break;
            w2 = w2.return;
          }
          0 < t2.length && (h3 = new k3(h3, n2, null, c2, e4), g3.push({ event: h3, listeners: t2 }));
        }
      }
      if (0 === (b2 & 7)) {
        a: {
          h3 = "mouseover" === a2 || "pointerover" === a2;
          k3 = "mouseout" === a2 || "pointerout" === a2;
          if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
          if (k3 || h3) {
            h3 = e4.window === e4 ? e4 : (h3 = e4.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
            if (k3) {
              if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
            } else k3 = null, n2 = d3;
            if (k3 !== n2) {
              t2 = Bd;
              F2 = "onMouseLeave";
              x2 = "onMouseEnter";
              w2 = "mouse";
              if ("pointerout" === a2 || "pointerover" === a2) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
              J2 = null == k3 ? h3 : ue(k3);
              u2 = null == n2 ? h3 : ue(n2);
              h3 = new t2(F2, w2 + "leave", k3, c2, e4);
              h3.target = J2;
              h3.relatedTarget = u2;
              F2 = null;
              Wc(e4) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e4), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
              J2 = F2;
              if (k3 && n2) b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2)) w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2)) u2++;
                for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
              else t2 = null;
              null !== k3 && wf(g3, h3, k3, t2, false);
              null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
            }
          }
        }
        a: {
          h3 = d3 ? ue(d3) : window;
          k3 = h3.nodeName && h3.nodeName.toLowerCase();
          if ("select" === k3 || "input" === k3 && "file" === h3.type) var na = ve;
          else if (me(h3)) if (we) na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
          else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
          if (na && (na = na(a2, d3))) {
            ne(g3, na, c2, e4);
            break a;
          }
          xa && xa(a2, h3, d3);
          "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
        }
        xa = d3 ? ue(d3) : window;
        switch (a2) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g3, c2, e4);
            break;
          case "selectionchange":
            if (Pe) break;
          case "keydown":
          case "keyup":
            Ue(g3, c2, e4);
        }
        var $a;
        if (ae) b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e4, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e4), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a2, c2) : ke(a2, c2)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e4 = new Ld("onBeforeInput", "beforeinput", null, c2, e4), g3.push({ event: e4, listeners: d3 }), e4.data = $a);
      }
      se(g3, b2);
    });
  }
  function tf(a2, b2, c2) {
    return { instance: a2, listener: b2, currentTarget: c2 };
  }
  function oe(a2, b2) {
    for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
      var e3 = a2, f2 = e3.stateNode;
      5 === e3.tag && null !== f2 && (e3 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e3)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e3)));
      a2 = a2.return;
    }
    return d2;
  }
  function vf(a2) {
    if (null === a2) return null;
    do
      a2 = a2.return;
    while (a2 && 5 !== a2.tag);
    return a2 ? a2 : null;
  }
  function wf(a2, b2, c2, d2, e3) {
    for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
      var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
      if (null !== k2 && k2 === d2) break;
      5 === h2.tag && null !== l2 && (h2 = l2, e3 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e3 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
      c2 = c2.return;
    }
    0 !== g2.length && a2.push({ event: b2, listeners: g2 });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a2) {
    return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
  }
  function Af(a2, b2, c2) {
    b2 = zf(b2);
    if (zf(a2) !== b2 && c2) throw Error(p2(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a2, b2) {
    return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
    return Hf.resolve(null).then(a2).catch(If);
  } : Ff;
  function If(a2) {
    setTimeout(function() {
      throw a2;
    });
  }
  function Kf(a2, b2) {
    var c2 = b2, d2 = 0;
    do {
      var e3 = c2.nextSibling;
      a2.removeChild(c2);
      if (e3 && 8 === e3.nodeType) if (c2 = e3.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e3);
          bd(b2);
          return;
        }
        d2--;
      } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
      c2 = e3;
    } while (c2);
    bd(b2);
  }
  function Lf(a2) {
    for (; null != a2; a2 = a2.nextSibling) {
      var b2 = a2.nodeType;
      if (1 === b2 || 3 === b2) break;
      if (8 === b2) {
        b2 = a2.data;
        if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
        if ("/$" === b2) return null;
      }
    }
    return a2;
  }
  function Mf(a2) {
    a2 = a2.previousSibling;
    for (var b2 = 0; a2; ) {
      if (8 === a2.nodeType) {
        var c2 = a2.data;
        if ("$" === c2 || "$!" === c2 || "$?" === c2) {
          if (0 === b2) return a2;
          b2--;
        } else "/$" === c2 && b2++;
      }
      a2 = a2.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a2) {
    var b2 = a2[Of];
    if (b2) return b2;
    for (var c2 = a2.parentNode; c2; ) {
      if (b2 = c2[uf] || c2[Of]) {
        c2 = b2.alternate;
        if (null !== b2.child || null !== c2 && null !== c2.child) for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of]) return c2;
          a2 = Mf(a2);
        }
        return b2;
      }
      a2 = c2;
      c2 = a2.parentNode;
    }
    return null;
  }
  function Cb(a2) {
    a2 = a2[Of] || a2[uf];
    return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
  }
  function ue(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2.stateNode;
    throw Error(p2(33));
  }
  function Db(a2) {
    return a2[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a2) {
    return { current: a2 };
  }
  function E2(a2) {
    0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G2(a2, b2) {
    Tf++;
    Sf[Tf] = a2.current;
    a2.current = b2;
  }
  var Vf = {}, H2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a2, b2) {
    var c2 = a2.type.contextTypes;
    if (!c2) return Vf;
    var d2 = a2.stateNode;
    if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2) return d2.__reactInternalMemoizedMaskedChildContext;
    var e3 = {}, f2;
    for (f2 in c2) e3[f2] = b2[f2];
    d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e3);
    return e3;
  }
  function Zf(a2) {
    a2 = a2.childContextTypes;
    return null !== a2 && void 0 !== a2;
  }
  function $f() {
    E2(Wf);
    E2(H2);
  }
  function ag(a2, b2, c2) {
    if (H2.current !== Vf) throw Error(p2(168));
    G2(H2, b2);
    G2(Wf, c2);
  }
  function bg(a2, b2, c2) {
    var d2 = a2.stateNode;
    b2 = b2.childContextTypes;
    if ("function" !== typeof d2.getChildContext) return c2;
    d2 = d2.getChildContext();
    for (var e3 in d2) if (!(e3 in b2)) throw Error(p2(108, Ra(a2) || "Unknown", e3));
    return A2({}, c2, d2);
  }
  function cg(a2) {
    a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H2.current;
    G2(H2, a2);
    G2(Wf, Wf.current);
    return true;
  }
  function dg(a2, b2, c2) {
    var d2 = a2.stateNode;
    if (!d2) throw Error(p2(169));
    c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E2(Wf), E2(H2), G2(H2, a2)) : E2(Wf);
    G2(Wf, c2);
  }
  var eg = null, fg = false, gg = false;
  function hg(a2) {
    null === eg ? eg = [a2] : eg.push(a2);
  }
  function ig(a2) {
    fg = true;
    hg(a2);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a2 = 0, b2 = C2;
      try {
        var c2 = eg;
        for (C2 = 1; a2 < c2.length; a2++) {
          var d2 = c2[a2];
          do
            d2 = d2(true);
          while (null !== d2);
        }
        eg = null;
        fg = false;
      } catch (e3) {
        throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e3;
      } finally {
        C2 = b2, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a2, b2) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a2;
    ng = b2;
  }
  function ug(a2, b2, c2) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a2;
    var d2 = rg;
    a2 = sg;
    var e3 = 32 - oc(d2) - 1;
    d2 &= ~(1 << e3);
    c2 += 1;
    var f2 = 32 - oc(b2) + e3;
    if (30 < f2) {
      var g2 = e3 - e3 % 5;
      f2 = (d2 & (1 << g2) - 1).toString(32);
      d2 >>= g2;
      e3 -= g2;
      rg = 1 << 32 - oc(b2) + e3 | c2 << e3 | d2;
      sg = f2 + a2;
    } else rg = 1 << f2 | c2 << e3 | d2, sg = a2;
  }
  function vg(a2) {
    null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
  }
  function wg(a2) {
    for (; a2 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a2 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I2 = false, zg = null;
  function Ag(a2, b2) {
    var c2 = Bg(5, null, null, 0);
    c2.elementType = "DELETED";
    c2.stateNode = b2;
    c2.return = a2;
    b2 = a2.deletions;
    null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
  }
  function Cg(a2, b2) {
    switch (a2.tag) {
      case 5:
        var c2 = a2.type;
        b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
        return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
      case 6:
        return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
      case 13:
        return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a2) {
    return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
  }
  function Eg(a2) {
    if (I2) {
      var b2 = yg;
      if (b2) {
        var c2 = b2;
        if (!Cg(a2, b2)) {
          if (Dg(a2)) throw Error(p2(418));
          b2 = Lf(c2.nextSibling);
          var d2 = xg;
          b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I2 = false, xg = a2);
        }
      } else {
        if (Dg(a2)) throw Error(p2(418));
        a2.flags = a2.flags & -4097 | 2;
        I2 = false;
        xg = a2;
      }
    }
  }
  function Fg(a2) {
    for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
    xg = a2;
  }
  function Gg(a2) {
    if (a2 !== xg) return false;
    if (!I2) return Fg(a2), I2 = true, false;
    var b2;
    (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
    if (b2 && (b2 = yg)) {
      if (Dg(a2)) throw Hg(), Error(p2(418));
      for (; b2; ) Ag(a2, b2), b2 = Lf(b2.nextSibling);
    }
    Fg(a2);
    if (13 === a2.tag) {
      a2 = a2.memoizedState;
      a2 = null !== a2 ? a2.dehydrated : null;
      if (!a2) throw Error(p2(317));
      a: {
        a2 = a2.nextSibling;
        for (b2 = 0; a2; ) {
          if (8 === a2.nodeType) {
            var c2 = a2.data;
            if ("/$" === c2) {
              if (0 === b2) {
                yg = Lf(a2.nextSibling);
                break a;
              }
              b2--;
            } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
          }
          a2 = a2.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a2.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a2 = yg; a2; ) a2 = Lf(a2.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I2 = false;
  }
  function Jg(a2) {
    null === zg ? zg = [a2] : zg.push(a2);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a2, b2, c2) {
    a2 = c2.ref;
    if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
      if (c2._owner) {
        c2 = c2._owner;
        if (c2) {
          if (1 !== c2.tag) throw Error(p2(309));
          var d2 = c2.stateNode;
        }
        if (!d2) throw Error(p2(147, a2));
        var e3 = d2, f2 = "" + a2;
        if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
        b2 = function(a3) {
          var b3 = e3.refs;
          null === a3 ? delete b3[f2] : b3[f2] = a3;
        };
        b2._stringRef = f2;
        return b2;
      }
      if ("string" !== typeof a2) throw Error(p2(284));
      if (!c2._owner) throw Error(p2(290, a2));
    }
    return a2;
  }
  function Mg(a2, b2) {
    a2 = Object.prototype.toString.call(b2);
    throw Error(p2(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
  }
  function Ng(a2) {
    var b2 = a2._init;
    return b2(a2._payload);
  }
  function Og(a2) {
    function b2(b3, c3) {
      if (a2) {
        var d3 = b3.deletions;
        null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
      }
    }
    function c2(c3, d3) {
      if (!a2) return null;
      for (; null !== d3; ) b2(c3, d3), d3 = d3.sibling;
      return null;
    }
    function d2(a3, b3) {
      for (a3 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
      return a3;
    }
    function e3(a3, b3) {
      a3 = Pg(a3, b3);
      a3.index = 0;
      a3.sibling = null;
      return a3;
    }
    function f2(b3, c3, d3) {
      b3.index = d3;
      if (!a2) return b3.flags |= 1048576, c3;
      d3 = b3.alternate;
      if (null !== d3) return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
      b3.flags |= 2;
      return c3;
    }
    function g2(b3) {
      a2 && null === b3.alternate && (b3.flags |= 2);
      return b3;
    }
    function h2(a3, b3, c3, d3) {
      if (null === b3 || 6 !== b3.tag) return b3 = Qg(c3, a3.mode, d3), b3.return = a3, b3;
      b3 = e3(b3, c3);
      b3.return = a3;
      return b3;
    }
    function k2(a3, b3, c3, d3) {
      var f3 = c3.type;
      if (f3 === ya) return m2(a3, b3, c3.props.children, d3, c3.key);
      if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type)) return d3 = e3(b3, c3.props), d3.ref = Lg(a3, b3, c3), d3.return = a3, d3;
      d3 = Rg(c3.type, c3.key, c3.props, null, a3.mode, d3);
      d3.ref = Lg(a3, b3, c3);
      d3.return = a3;
      return d3;
    }
    function l2(a3, b3, c3, d3) {
      if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation) return b3 = Sg(c3, a3.mode, d3), b3.return = a3, b3;
      b3 = e3(b3, c3.children || []);
      b3.return = a3;
      return b3;
    }
    function m2(a3, b3, c3, d3, f3) {
      if (null === b3 || 7 !== b3.tag) return b3 = Tg(c3, a3.mode, d3, f3), b3.return = a3, b3;
      b3 = e3(b3, c3);
      b3.return = a3;
      return b3;
    }
    function q2(a3, b3, c3) {
      if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = Qg("" + b3, a3.mode, c3), b3.return = a3, b3;
      if ("object" === typeof b3 && null !== b3) {
        switch (b3.$$typeof) {
          case va:
            return c3 = Rg(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = Lg(a3, null, b3), c3.return = a3, c3;
          case wa:
            return b3 = Sg(b3, a3.mode, c3), b3.return = a3, b3;
          case Ha:
            var d3 = b3._init;
            return q2(a3, d3(b3._payload), c3);
        }
        if (eb(b3) || Ka(b3)) return b3 = Tg(b3, a3.mode, c3, null), b3.return = a3, b3;
        Mg(a3, b3);
      }
      return null;
    }
    function r2(a3, b3, c3, d3) {
      var e4 = null !== b3 ? b3.key : null;
      if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e4 ? null : h2(a3, b3, "" + c3, d3);
      if ("object" === typeof c3 && null !== c3) {
        switch (c3.$$typeof) {
          case va:
            return c3.key === e4 ? k2(a3, b3, c3, d3) : null;
          case wa:
            return c3.key === e4 ? l2(a3, b3, c3, d3) : null;
          case Ha:
            return e4 = c3._init, r2(
              a3,
              b3,
              e4(c3._payload),
              d3
            );
        }
        if (eb(c3) || Ka(c3)) return null !== e4 ? null : m2(a3, b3, c3, d3, null);
        Mg(a3, c3);
      }
      return null;
    }
    function y2(a3, b3, c3, d3, e4) {
      if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e4);
      if ("object" === typeof d3 && null !== d3) {
        switch (d3.$$typeof) {
          case va:
            return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e4);
          case wa:
            return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e4);
          case Ha:
            var f3 = d3._init;
            return y2(a3, b3, c3, f3(d3._payload), e4);
        }
        if (eb(d3) || Ka(d3)) return a3 = a3.get(c3) || null, m2(b3, a3, d3, e4, null);
        Mg(b3, d3);
      }
      return null;
    }
    function n2(e4, g3, h3, k3) {
      for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
        u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
        var n3 = r2(e4, u2, h3[w2], k3);
        if (null === n3) {
          null === u2 && (u2 = x2);
          break;
        }
        a2 && u2 && null === n3.alternate && b2(e4, u2);
        g3 = f2(n3, g3, w2);
        null === m3 ? l3 = n3 : m3.sibling = n3;
        m3 = n3;
        u2 = x2;
      }
      if (w2 === h3.length) return c2(e4, u2), I2 && tg(e4, w2), l3;
      if (null === u2) {
        for (; w2 < h3.length; w2++) u2 = q2(e4, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
        I2 && tg(e4, w2);
        return l3;
      }
      for (u2 = d2(e4, u2); w2 < h3.length; w2++) x2 = y2(u2, e4, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
      a2 && u2.forEach(function(a3) {
        return b2(e4, a3);
      });
      I2 && tg(e4, w2);
      return l3;
    }
    function t2(e4, g3, h3, k3) {
      var l3 = Ka(h3);
      if ("function" !== typeof l3) throw Error(p2(150));
      h3 = l3.call(h3);
      if (null == h3) throw Error(p2(151));
      for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
        m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
        var t3 = r2(e4, m3, n3.value, k3);
        if (null === t3) {
          null === m3 && (m3 = x2);
          break;
        }
        a2 && m3 && null === t3.alternate && b2(e4, m3);
        g3 = f2(t3, g3, w2);
        null === u2 ? l3 = t3 : u2.sibling = t3;
        u2 = t3;
        m3 = x2;
      }
      if (n3.done) return c2(
        e4,
        m3
      ), I2 && tg(e4, w2), l3;
      if (null === m3) {
        for (; !n3.done; w2++, n3 = h3.next()) n3 = q2(e4, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        I2 && tg(e4, w2);
        return l3;
      }
      for (m3 = d2(e4, m3); !n3.done; w2++, n3 = h3.next()) n3 = y2(m3, e4, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      a2 && m3.forEach(function(a3) {
        return b2(e4, a3);
      });
      I2 && tg(e4, w2);
      return l3;
    }
    function J2(a3, d3, f3, h3) {
      "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
      if ("object" === typeof f3 && null !== f3) {
        switch (f3.$$typeof) {
          case va:
            a: {
              for (var k3 = f3.key, l3 = d3; null !== l3; ) {
                if (l3.key === k3) {
                  k3 = f3.type;
                  if (k3 === ya) {
                    if (7 === l3.tag) {
                      c2(a3, l3.sibling);
                      d3 = e3(l3, f3.props.children);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    }
                  } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                    c2(a3, l3.sibling);
                    d3 = e3(l3, f3.props);
                    d3.ref = Lg(a3, l3, f3);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                  c2(a3, l3);
                  break;
                } else b2(a3, l3);
                l3 = l3.sibling;
              }
              f3.type === ya ? (d3 = Tg(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Lg(a3, d3, f3), h3.return = a3, a3 = h3);
            }
            return g2(a3);
          case wa:
            a: {
              for (l3 = f3.key; null !== d3; ) {
                if (d3.key === l3) if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e3(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
                else b2(a3, d3);
                d3 = d3.sibling;
              }
              d3 = Sg(f3, a3.mode, h3);
              d3.return = a3;
              a3 = d3;
            }
            return g2(a3);
          case Ha:
            return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
        }
        if (eb(f3)) return n2(a3, d3, f3, h3);
        if (Ka(f3)) return t2(a3, d3, f3, h3);
        Mg(a3, f3);
      }
      return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e3(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = Qg(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
    }
    return J2;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a2) {
    var b2 = Wg.current;
    E2(Wg);
    a2._currentValue = b2;
  }
  function bh(a2, b2, c2) {
    for (; null !== a2; ) {
      var d2 = a2.alternate;
      (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
      if (a2 === c2) break;
      a2 = a2.return;
    }
  }
  function ch(a2, b2) {
    Xg = a2;
    Zg = Yg = null;
    a2 = a2.dependencies;
    null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (dh = true), a2.firstContext = null);
  }
  function eh(a2) {
    var b2 = a2._currentValue;
    if (Zg !== a2) if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Yg) {
      if (null === Xg) throw Error(p2(308));
      Yg = a2;
      Xg.dependencies = { lanes: 0, firstContext: a2 };
    } else Yg = Yg.next = a2;
    return b2;
  }
  var fh = null;
  function gh(a2) {
    null === fh ? fh = [a2] : fh.push(a2);
  }
  function hh(a2, b2, c2, d2) {
    var e3 = b2.interleaved;
    null === e3 ? (c2.next = c2, gh(b2)) : (c2.next = e3.next, e3.next = c2);
    b2.interleaved = c2;
    return ih(a2, d2);
  }
  function ih(a2, b2) {
    a2.lanes |= b2;
    var c2 = a2.alternate;
    null !== c2 && (c2.lanes |= b2);
    c2 = a2;
    for (a2 = a2.return; null !== a2; ) a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
    return 3 === c2.tag ? c2.stateNode : null;
  }
  var jh = false;
  function kh(a2) {
    a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a2, b2) {
    a2 = a2.updateQueue;
    b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
  }
  function mh(a2, b2) {
    return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a2, b2, c2) {
    var d2 = a2.updateQueue;
    if (null === d2) return null;
    d2 = d2.shared;
    if (0 !== (K2 & 2)) {
      var e3 = d2.pending;
      null === e3 ? b2.next = b2 : (b2.next = e3.next, e3.next = b2);
      d2.pending = b2;
      return ih(a2, c2);
    }
    e3 = d2.interleaved;
    null === e3 ? (b2.next = b2, gh(d2)) : (b2.next = e3.next, e3.next = b2);
    d2.interleaved = b2;
    return ih(a2, c2);
  }
  function oh(a2, b2, c2) {
    b2 = b2.updateQueue;
    if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
      var d2 = b2.lanes;
      d2 &= a2.pendingLanes;
      c2 |= d2;
      b2.lanes = c2;
      Cc(a2, c2);
    }
  }
  function ph(a2, b2) {
    var c2 = a2.updateQueue, d2 = a2.alternate;
    if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
      var e3 = null, f2 = null;
      c2 = c2.firstBaseUpdate;
      if (null !== c2) {
        do {
          var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
          null === f2 ? e3 = f2 = g2 : f2 = f2.next = g2;
          c2 = c2.next;
        } while (null !== c2);
        null === f2 ? e3 = f2 = b2 : f2 = f2.next = b2;
      } else e3 = f2 = b2;
      c2 = { baseState: d2.baseState, firstBaseUpdate: e3, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
      a2.updateQueue = c2;
      return;
    }
    a2 = c2.lastBaseUpdate;
    null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
    c2.lastBaseUpdate = b2;
  }
  function qh(a2, b2, c2, d2) {
    var e3 = a2.updateQueue;
    jh = false;
    var f2 = e3.firstBaseUpdate, g2 = e3.lastBaseUpdate, h2 = e3.shared.pending;
    if (null !== h2) {
      e3.shared.pending = null;
      var k2 = h2, l2 = k2.next;
      k2.next = null;
      null === g2 ? f2 = l2 : g2.next = l2;
      g2 = k2;
      var m2 = a2.alternate;
      null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
    }
    if (null !== f2) {
      var q2 = e3.baseState;
      g2 = 0;
      m2 = l2 = k2 = null;
      h2 = f2;
      do {
        var r2 = h2.lane, y2 = h2.eventTime;
        if ((d2 & r2) === r2) {
          null !== m2 && (m2 = m2.next = {
            eventTime: y2,
            lane: 0,
            tag: h2.tag,
            payload: h2.payload,
            callback: h2.callback,
            next: null
          });
          a: {
            var n2 = a2, t2 = h2;
            r2 = b2;
            y2 = c2;
            switch (t2.tag) {
              case 1:
                n2 = t2.payload;
                if ("function" === typeof n2) {
                  q2 = n2.call(y2, q2, r2);
                  break a;
                }
                q2 = n2;
                break a;
              case 3:
                n2.flags = n2.flags & -65537 | 128;
              case 0:
                n2 = t2.payload;
                r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                if (null === r2 || void 0 === r2) break a;
                q2 = A2({}, q2, r2);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e3.effects, null === r2 ? e3.effects = [h2] : r2.push(h2));
        } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
        h2 = h2.next;
        if (null === h2) if (h2 = e3.shared.pending, null === h2) break;
        else r2 = h2, h2 = r2.next, r2.next = null, e3.lastBaseUpdate = r2, e3.shared.pending = null;
      } while (1);
      null === m2 && (k2 = q2);
      e3.baseState = k2;
      e3.firstBaseUpdate = l2;
      e3.lastBaseUpdate = m2;
      b2 = e3.shared.interleaved;
      if (null !== b2) {
        e3 = b2;
        do
          g2 |= e3.lane, e3 = e3.next;
        while (e3 !== b2);
      } else null === f2 && (e3.shared.lanes = 0);
      rh |= g2;
      a2.lanes = g2;
      a2.memoizedState = q2;
    }
  }
  function sh(a2, b2, c2) {
    a2 = b2.effects;
    b2.effects = null;
    if (null !== a2) for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e3 = d2.callback;
      if (null !== e3) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e3) throw Error(p2(191, e3));
        e3.call(d2);
      }
    }
  }
  var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
  function xh(a2) {
    if (a2 === th) throw Error(p2(174));
    return a2;
  }
  function yh(a2, b2) {
    G2(wh, b2);
    G2(vh, a2);
    G2(uh, th);
    a2 = b2.nodeType;
    switch (a2) {
      case 9:
      case 11:
        b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
        break;
      default:
        a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
    }
    E2(uh);
    G2(uh, b2);
  }
  function zh() {
    E2(uh);
    E2(vh);
    E2(wh);
  }
  function Ah(a2) {
    xh(wh.current);
    var b2 = xh(uh.current);
    var c2 = lb(b2, a2.type);
    b2 !== c2 && (G2(vh, a2), G2(uh, c2));
  }
  function Bh(a2) {
    vh.current === a2 && (E2(uh), E2(vh));
  }
  var L2 = Uf(0);
  function Ch(a2) {
    for (var b2 = a2; null !== b2; ) {
      if (13 === b2.tag) {
        var c2 = b2.memoizedState;
        if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
      } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
        if (0 !== (b2.flags & 128)) return b2;
      } else if (null !== b2.child) {
        b2.child.return = b2;
        b2 = b2.child;
        continue;
      }
      if (b2 === a2) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2) return null;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a2 = 0; a2 < Dh.length; a2++) Dh[a2]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M2 = null, N2 = null, O2 = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P2() {
    throw Error(p2(321));
  }
  function Mh(a2, b2) {
    if (null === b2) return false;
    for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++) if (!He(a2[c2], b2[c2])) return false;
    return true;
  }
  function Nh(a2, b2, c2, d2, e3, f2) {
    Hh = f2;
    M2 = b2;
    b2.memoizedState = null;
    b2.updateQueue = null;
    b2.lanes = 0;
    Fh.current = null === a2 || null === a2.memoizedState ? Oh : Ph;
    a2 = c2(d2, e3);
    if (Jh) {
      f2 = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f2) throw Error(p2(301));
        f2 += 1;
        O2 = N2 = null;
        b2.updateQueue = null;
        Fh.current = Qh;
        a2 = c2(d2, e3);
      } while (Jh);
    }
    Fh.current = Rh;
    b2 = null !== N2 && null !== N2.next;
    Hh = 0;
    O2 = N2 = M2 = null;
    Ih = false;
    if (b2) throw Error(p2(300));
    return a2;
  }
  function Sh() {
    var a2 = 0 !== Kh;
    Kh = 0;
    return a2;
  }
  function Th() {
    var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O2 ? M2.memoizedState = O2 = a2 : O2 = O2.next = a2;
    return O2;
  }
  function Uh() {
    if (null === N2) {
      var a2 = M2.alternate;
      a2 = null !== a2 ? a2.memoizedState : null;
    } else a2 = N2.next;
    var b2 = null === O2 ? M2.memoizedState : O2.next;
    if (null !== b2) O2 = b2, N2 = a2;
    else {
      if (null === a2) throw Error(p2(310));
      N2 = a2;
      a2 = { memoizedState: N2.memoizedState, baseState: N2.baseState, baseQueue: N2.baseQueue, queue: N2.queue, next: null };
      null === O2 ? M2.memoizedState = O2 = a2 : O2 = O2.next = a2;
    }
    return O2;
  }
  function Vh(a2, b2) {
    return "function" === typeof b2 ? b2(a2) : b2;
  }
  function Wh(a2) {
    var b2 = Uh(), c2 = b2.queue;
    if (null === c2) throw Error(p2(311));
    c2.lastRenderedReducer = a2;
    var d2 = N2, e3 = d2.baseQueue, f2 = c2.pending;
    if (null !== f2) {
      if (null !== e3) {
        var g2 = e3.next;
        e3.next = f2.next;
        f2.next = g2;
      }
      d2.baseQueue = e3 = f2;
      c2.pending = null;
    }
    if (null !== e3) {
      f2 = e3.next;
      d2 = d2.baseState;
      var h2 = g2 = null, k2 = null, l2 = f2;
      do {
        var m2 = l2.lane;
        if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
        else {
          var q2 = {
            lane: m2,
            action: l2.action,
            hasEagerState: l2.hasEagerState,
            eagerState: l2.eagerState,
            next: null
          };
          null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
          M2.lanes |= m2;
          rh |= m2;
        }
        l2 = l2.next;
      } while (null !== l2 && l2 !== f2);
      null === k2 ? g2 = d2 : k2.next = h2;
      He(d2, b2.memoizedState) || (dh = true);
      b2.memoizedState = d2;
      b2.baseState = g2;
      b2.baseQueue = k2;
      c2.lastRenderedState = d2;
    }
    a2 = c2.interleaved;
    if (null !== a2) {
      e3 = a2;
      do
        f2 = e3.lane, M2.lanes |= f2, rh |= f2, e3 = e3.next;
      while (e3 !== a2);
    } else null === e3 && (c2.lanes = 0);
    return [b2.memoizedState, c2.dispatch];
  }
  function Xh(a2) {
    var b2 = Uh(), c2 = b2.queue;
    if (null === c2) throw Error(p2(311));
    c2.lastRenderedReducer = a2;
    var d2 = c2.dispatch, e3 = c2.pending, f2 = b2.memoizedState;
    if (null !== e3) {
      c2.pending = null;
      var g2 = e3 = e3.next;
      do
        f2 = a2(f2, g2.action), g2 = g2.next;
      while (g2 !== e3);
      He(f2, b2.memoizedState) || (dh = true);
      b2.memoizedState = f2;
      null === b2.baseQueue && (b2.baseState = f2);
      c2.lastRenderedState = f2;
    }
    return [f2, d2];
  }
  function Yh() {
  }
  function Zh(a2, b2) {
    var c2 = M2, d2 = Uh(), e3 = b2(), f2 = !He(d2.memoizedState, e3);
    f2 && (d2.memoizedState = e3, dh = true);
    d2 = d2.queue;
    $h(ai.bind(null, c2, d2, a2), [a2]);
    if (d2.getSnapshot !== b2 || f2 || null !== O2 && O2.memoizedState.tag & 1) {
      c2.flags |= 2048;
      bi(9, ci.bind(null, c2, d2, e3, b2), void 0, null);
      if (null === Q2) throw Error(p2(349));
      0 !== (Hh & 30) || di(c2, b2, e3);
    }
    return e3;
  }
  function di(a2, b2, c2) {
    a2.flags |= 16384;
    a2 = { getSnapshot: b2, value: c2 };
    b2 = M2.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, M2.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
  }
  function ci(a2, b2, c2, d2) {
    b2.value = c2;
    b2.getSnapshot = d2;
    ei(b2) && fi(a2);
  }
  function ai(a2, b2, c2) {
    return c2(function() {
      ei(b2) && fi(a2);
    });
  }
  function ei(a2) {
    var b2 = a2.getSnapshot;
    a2 = a2.value;
    try {
      var c2 = b2();
      return !He(a2, c2);
    } catch (d2) {
      return true;
    }
  }
  function fi(a2) {
    var b2 = ih(a2, 1);
    null !== b2 && gi(b2, a2, 1, -1);
  }
  function hi(a2) {
    var b2 = Th();
    "function" === typeof a2 && (a2 = a2());
    b2.memoizedState = b2.baseState = a2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
    b2.queue = a2;
    a2 = a2.dispatch = ii.bind(null, M2, a2);
    return [b2.memoizedState, a2];
  }
  function bi(a2, b2, c2, d2) {
    a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
    b2 = M2.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, M2.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
    return a2;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a2, b2, c2, d2) {
    var e3 = Th();
    M2.flags |= a2;
    e3.memoizedState = bi(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
  }
  function li(a2, b2, c2, d2) {
    var e3 = Uh();
    d2 = void 0 === d2 ? null : d2;
    var f2 = void 0;
    if (null !== N2) {
      var g2 = N2.memoizedState;
      f2 = g2.destroy;
      if (null !== d2 && Mh(d2, g2.deps)) {
        e3.memoizedState = bi(b2, c2, f2, d2);
        return;
      }
    }
    M2.flags |= a2;
    e3.memoizedState = bi(1 | b2, c2, f2, d2);
  }
  function mi(a2, b2) {
    return ki(8390656, 8, a2, b2);
  }
  function $h(a2, b2) {
    return li(2048, 8, a2, b2);
  }
  function ni(a2, b2) {
    return li(4, 2, a2, b2);
  }
  function oi(a2, b2) {
    return li(4, 4, a2, b2);
  }
  function pi2(a2, b2) {
    if ("function" === typeof b2) return a2 = a2(), b2(a2), function() {
      b2(null);
    };
    if (null !== b2 && void 0 !== b2) return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
  }
  function qi(a2, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return li(4, 4, pi2.bind(null, b2, a2), c2);
  }
  function ri() {
  }
  function si(a2, b2) {
    var c2 = Uh();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c2.memoizedState;
    if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
    c2.memoizedState = [a2, b2];
    return a2;
  }
  function ti(a2, b2) {
    var c2 = Uh();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c2.memoizedState;
    if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
    a2 = a2();
    c2.memoizedState = [a2, b2];
    return a2;
  }
  function ui(a2, b2, c2) {
    if (0 === (Hh & 21)) return a2.baseState && (a2.baseState = false, dh = true), a2.memoizedState = c2;
    He(c2, b2) || (c2 = yc(), M2.lanes |= c2, rh |= c2, a2.baseState = true);
    return b2;
  }
  function vi(a2, b2) {
    var c2 = C2;
    C2 = 0 !== c2 && 4 > c2 ? c2 : 4;
    a2(true);
    var d2 = Gh.transition;
    Gh.transition = {};
    try {
      a2(false), b2();
    } finally {
      C2 = c2, Gh.transition = d2;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a2, b2, c2) {
    var d2 = yi(a2);
    c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi(a2)) Ai(b2, c2);
    else if (c2 = hh(a2, b2, c2, d2), null !== c2) {
      var e3 = R2();
      gi(c2, a2, d2, e3);
      Bi(c2, b2, d2);
    }
  }
  function ii(a2, b2, c2) {
    var d2 = yi(a2), e3 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi(a2)) Ai(b2, e3);
    else {
      var f2 = a2.alternate;
      if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e3.hasEagerState = true;
        e3.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e3.next = e3, gh(b2)) : (e3.next = k2.next, k2.next = e3);
          b2.interleaved = e3;
          return;
        }
      } catch (l2) {
      } finally {
      }
      c2 = hh(a2, b2, e3, d2);
      null !== c2 && (e3 = R2(), gi(c2, a2, d2, e3), Bi(c2, b2, d2));
    }
  }
  function zi(a2) {
    var b2 = a2.alternate;
    return a2 === M2 || null !== b2 && b2 === M2;
  }
  function Ai(a2, b2) {
    Jh = Ih = true;
    var c2 = a2.pending;
    null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
    a2.pending = b2;
  }
  function Bi(a2, b2, c2) {
    if (0 !== (c2 & 4194240)) {
      var d2 = b2.lanes;
      d2 &= a2.pendingLanes;
      c2 |= d2;
      b2.lanes = c2;
      Cc(a2, c2);
    }
  }
  var Rh = { readContext: eh, useCallback: P2, useContext: P2, useEffect: P2, useImperativeHandle: P2, useInsertionEffect: P2, useLayoutEffect: P2, useMemo: P2, useReducer: P2, useRef: P2, useState: P2, useDebugValue: P2, useDeferredValue: P2, useTransition: P2, useMutableSource: P2, useSyncExternalStore: P2, useId: P2, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a2, b2) {
    Th().memoizedState = [a2, void 0 === b2 ? null : b2];
    return a2;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a2, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return ki(
      4194308,
      4,
      pi2.bind(null, b2, a2),
      c2
    );
  }, useLayoutEffect: function(a2, b2) {
    return ki(4194308, 4, a2, b2);
  }, useInsertionEffect: function(a2, b2) {
    return ki(4, 2, a2, b2);
  }, useMemo: function(a2, b2) {
    var c2 = Th();
    b2 = void 0 === b2 ? null : b2;
    a2 = a2();
    c2.memoizedState = [a2, b2];
    return a2;
  }, useReducer: function(a2, b2, c2) {
    var d2 = Th();
    b2 = void 0 !== c2 ? c2(b2) : b2;
    d2.memoizedState = d2.baseState = b2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
    d2.queue = a2;
    a2 = a2.dispatch = xi.bind(null, M2, a2);
    return [d2.memoizedState, a2];
  }, useRef: function(a2) {
    var b2 = Th();
    a2 = { current: a2 };
    return b2.memoizedState = a2;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a2) {
    return Th().memoizedState = a2;
  }, useTransition: function() {
    var a2 = hi(false), b2 = a2[0];
    a2 = vi.bind(null, a2[1]);
    Th().memoizedState = a2;
    return [b2, a2];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a2, b2, c2) {
    var d2 = M2, e3 = Th();
    if (I2) {
      if (void 0 === c2) throw Error(p2(407));
      c2 = c2();
    } else {
      c2 = b2();
      if (null === Q2) throw Error(p2(349));
      0 !== (Hh & 30) || di(d2, b2, c2);
    }
    e3.memoizedState = c2;
    var f2 = { value: c2, getSnapshot: b2 };
    e3.queue = f2;
    mi(ai.bind(
      null,
      d2,
      f2,
      a2
    ), [a2]);
    d2.flags |= 2048;
    bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
    return c2;
  }, useId: function() {
    var a2 = Th(), b2 = Q2.identifierPrefix;
    if (I2) {
      var c2 = sg;
      var d2 = rg;
      c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
      b2 = ":" + b2 + "R" + c2;
      c2 = Kh++;
      0 < c2 && (b2 += "H" + c2.toString(32));
      b2 += ":";
    } else c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
    return a2.memoizedState = b2;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a2) {
      var b2 = Uh();
      return ui(b2, N2.memoizedState, a2);
    },
    useTransition: function() {
      var a2 = Wh(Vh)[0], b2 = Uh().memoizedState;
      return [a2, b2];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a2) {
    var b2 = Uh();
    return null === N2 ? b2.memoizedState = a2 : ui(b2, N2.memoizedState, a2);
  }, useTransition: function() {
    var a2 = Xh(Vh)[0], b2 = Uh().memoizedState;
    return [a2, b2];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci(a2, b2) {
    if (a2 && a2.defaultProps) {
      b2 = A2({}, b2);
      a2 = a2.defaultProps;
      for (var c2 in a2) void 0 === b2[c2] && (b2[c2] = a2[c2]);
      return b2;
    }
    return b2;
  }
  function Di(a2, b2, c2, d2) {
    b2 = a2.memoizedState;
    c2 = c2(d2, b2);
    c2 = null === c2 || void 0 === c2 ? b2 : A2({}, b2, c2);
    a2.memoizedState = c2;
    0 === a2.lanes && (a2.updateQueue.baseState = c2);
  }
  var Ei = { isMounted: function(a2) {
    return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
  }, enqueueSetState: function(a2, b2, c2) {
    a2 = a2._reactInternals;
    var d2 = R2(), e3 = yi(a2), f2 = mh(d2, e3);
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    b2 = nh(a2, f2, e3);
    null !== b2 && (gi(b2, a2, e3, d2), oh(b2, a2, e3));
  }, enqueueReplaceState: function(a2, b2, c2) {
    a2 = a2._reactInternals;
    var d2 = R2(), e3 = yi(a2), f2 = mh(d2, e3);
    f2.tag = 1;
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    b2 = nh(a2, f2, e3);
    null !== b2 && (gi(b2, a2, e3, d2), oh(b2, a2, e3));
  }, enqueueForceUpdate: function(a2, b2) {
    a2 = a2._reactInternals;
    var c2 = R2(), d2 = yi(a2), e3 = mh(c2, d2);
    e3.tag = 2;
    void 0 !== b2 && null !== b2 && (e3.callback = b2);
    b2 = nh(a2, e3, d2);
    null !== b2 && (gi(b2, a2, d2, c2), oh(b2, a2, d2));
  } };
  function Fi(a2, b2, c2, d2, e3, f2, g2) {
    a2 = a2.stateNode;
    return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e3, f2) : true;
  }
  function Gi(a2, b2, c2) {
    var d2 = false, e3 = Vf;
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e3 = Zf(b2) ? Xf : H2.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e3) : Vf);
    b2 = new b2(c2, f2);
    a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
    b2.updater = Ei;
    a2.stateNode = b2;
    b2._reactInternals = a2;
    d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e3, a2.__reactInternalMemoizedMaskedChildContext = f2);
    return b2;
  }
  function Hi(a2, b2, c2, d2) {
    a2 = b2.state;
    "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
    "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
    b2.state !== a2 && Ei.enqueueReplaceState(b2, b2.state, null);
  }
  function Ii(a2, b2, c2, d2) {
    var e3 = a2.stateNode;
    e3.props = c2;
    e3.state = a2.memoizedState;
    e3.refs = {};
    kh(a2);
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? e3.context = eh(f2) : (f2 = Zf(b2) ? Xf : H2.current, e3.context = Yf(a2, f2));
    e3.state = a2.memoizedState;
    f2 = b2.getDerivedStateFromProps;
    "function" === typeof f2 && (Di(a2, b2, f2, c2), e3.state = a2.memoizedState);
    "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e3.getSnapshotBeforeUpdate || "function" !== typeof e3.UNSAFE_componentWillMount && "function" !== typeof e3.componentWillMount || (b2 = e3.state, "function" === typeof e3.componentWillMount && e3.componentWillMount(), "function" === typeof e3.UNSAFE_componentWillMount && e3.UNSAFE_componentWillMount(), b2 !== e3.state && Ei.enqueueReplaceState(e3, e3.state, null), qh(a2, c2, e3, d2), e3.state = a2.memoizedState);
    "function" === typeof e3.componentDidMount && (a2.flags |= 4194308);
  }
  function Ji(a2, b2) {
    try {
      var c2 = "", d2 = b2;
      do
        c2 += Pa(d2), d2 = d2.return;
      while (d2);
      var e3 = c2;
    } catch (f2) {
      e3 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
    }
    return { value: a2, source: b2, stack: e3, digest: null };
  }
  function Ki(a2, b2, c2) {
    return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
  }
  function Li(a2, b2) {
    try {
      console.error(b2.value);
    } catch (c2) {
      setTimeout(function() {
        throw c2;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a2, b2, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    c2.payload = { element: null };
    var d2 = b2.value;
    c2.callback = function() {
      Oi || (Oi = true, Pi = d2);
      Li(a2, b2);
    };
    return c2;
  }
  function Qi(a2, b2, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    var d2 = a2.type.getDerivedStateFromError;
    if ("function" === typeof d2) {
      var e3 = b2.value;
      c2.payload = function() {
        return d2(e3);
      };
      c2.callback = function() {
        Li(a2, b2);
      };
    }
    var f2 = a2.stateNode;
    null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
      Li(a2, b2);
      "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c3 = b2.stack;
      this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
    });
    return c2;
  }
  function Si(a2, b2, c2) {
    var d2 = a2.pingCache;
    if (null === d2) {
      d2 = a2.pingCache = new Mi();
      var e3 = /* @__PURE__ */ new Set();
      d2.set(b2, e3);
    } else e3 = d2.get(b2), void 0 === e3 && (e3 = /* @__PURE__ */ new Set(), d2.set(b2, e3));
    e3.has(c2) || (e3.add(c2), a2 = Ti.bind(null, a2, b2, c2), b2.then(a2, a2));
  }
  function Ui(a2) {
    do {
      var b2;
      if (b2 = 13 === a2.tag) b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
      if (b2) return a2;
      a2 = a2.return;
    } while (null !== a2);
    return null;
  }
  function Vi(a2, b2, c2, d2, e3) {
    if (0 === (a2.mode & 1)) return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a2;
    a2.flags |= 65536;
    a2.lanes = e3;
    return a2;
  }
  var Wi = ua.ReactCurrentOwner, dh = false;
  function Xi(a2, b2, c2, d2) {
    b2.child = null === a2 ? Vg(b2, null, c2, d2) : Ug(b2, a2.child, c2, d2);
  }
  function Yi(a2, b2, c2, d2, e3) {
    c2 = c2.render;
    var f2 = b2.ref;
    ch(b2, e3);
    d2 = Nh(a2, b2, c2, d2, f2, e3);
    c2 = Sh();
    if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e3, Zi(a2, b2, e3);
    I2 && c2 && vg(b2);
    b2.flags |= 1;
    Xi(a2, b2, d2, e3);
    return b2.child;
  }
  function $i(a2, b2, c2, d2, e3) {
    if (null === a2) {
      var f2 = c2.type;
      if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f2, bj(a2, b2, f2, d2, e3);
      a2 = Rg(c2.type, null, d2, b2, b2.mode, e3);
      a2.ref = b2.ref;
      a2.return = b2;
      return b2.child = a2;
    }
    f2 = a2.child;
    if (0 === (a2.lanes & e3)) {
      var g2 = f2.memoizedProps;
      c2 = c2.compare;
      c2 = null !== c2 ? c2 : Ie;
      if (c2(g2, d2) && a2.ref === b2.ref) return Zi(a2, b2, e3);
    }
    b2.flags |= 1;
    a2 = Pg(f2, d2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  function bj(a2, b2, c2, d2, e3) {
    if (null !== a2) {
      var f2 = a2.memoizedProps;
      if (Ie(f2, d2) && a2.ref === b2.ref) if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e3)) 0 !== (a2.flags & 131072) && (dh = true);
      else return b2.lanes = a2.lanes, Zi(a2, b2, e3);
    }
    return cj(a2, b2, c2, d2, e3);
  }
  function dj(a2, b2, c2) {
    var d2 = b2.pendingProps, e3 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
    if ("hidden" === d2.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G2(ej, fj), fj |= c2;
    else {
      if (0 === (c2 & 1073741824)) return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G2(ej, fj), fj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G2(ej, fj);
      fj |= d2;
    }
    else null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G2(ej, fj), fj |= d2;
    Xi(a2, b2, e3, c2);
    return b2.child;
  }
  function gj(a2, b2) {
    var c2 = b2.ref;
    if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
  }
  function cj(a2, b2, c2, d2, e3) {
    var f2 = Zf(c2) ? Xf : H2.current;
    f2 = Yf(b2, f2);
    ch(b2, e3);
    c2 = Nh(a2, b2, c2, d2, f2, e3);
    d2 = Sh();
    if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e3, Zi(a2, b2, e3);
    I2 && d2 && vg(b2);
    b2.flags |= 1;
    Xi(a2, b2, c2, e3);
    return b2.child;
  }
  function hj(a2, b2, c2, d2, e3) {
    if (Zf(c2)) {
      var f2 = true;
      cg(b2);
    } else f2 = false;
    ch(b2, e3);
    if (null === b2.stateNode) ij(a2, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e3), d2 = true;
    else if (null === a2) {
      var g2 = b2.stateNode, h2 = b2.memoizedProps;
      g2.props = h2;
      var k2 = g2.context, l2 = c2.contextType;
      "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H2.current, l2 = Yf(b2, l2));
      var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
      q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
      jh = false;
      var r2 = b2.memoizedState;
      g2.state = r2;
      qh(b2, d2, g2, e3);
      k2 = b2.memoizedState;
      h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
    } else {
      g2 = b2.stateNode;
      lh(a2, b2);
      h2 = b2.memoizedProps;
      l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
      g2.props = l2;
      q2 = b2.pendingProps;
      r2 = g2.context;
      k2 = c2.contextType;
      "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H2.current, k2 = Yf(b2, k2));
      var y2 = c2.getDerivedStateFromProps;
      (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g2, d2, k2);
      jh = false;
      r2 = b2.memoizedState;
      g2.state = r2;
      qh(b2, d2, g2, e3);
      var n2 = b2.memoizedState;
      h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
    }
    return jj(a2, b2, c2, d2, f2, e3);
  }
  function jj(a2, b2, c2, d2, e3, f2) {
    gj(a2, b2);
    var g2 = 0 !== (b2.flags & 128);
    if (!d2 && !g2) return e3 && dg(b2, c2, false), Zi(a2, b2, f2);
    d2 = b2.stateNode;
    Wi.current = b2;
    var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
    b2.flags |= 1;
    null !== a2 && g2 ? (b2.child = Ug(b2, a2.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a2, b2, h2, f2);
    b2.memoizedState = d2.state;
    e3 && dg(b2, c2, true);
    return b2.child;
  }
  function kj(a2) {
    var b2 = a2.stateNode;
    b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
    yh(a2, b2.containerInfo);
  }
  function lj(a2, b2, c2, d2, e3) {
    Ig();
    Jg(e3);
    b2.flags |= 256;
    Xi(a2, b2, c2, d2);
    return b2.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a2) {
    return { baseLanes: a2, cachePool: null, transitions: null };
  }
  function oj(a2, b2, c2) {
    var d2 = b2.pendingProps, e3 = L2.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
    (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e3 & 2));
    if (h2) f2 = true, b2.flags &= -129;
    else if (null === a2 || null !== a2.memoizedState) e3 |= 1;
    G2(L2, e3 & 1);
    if (null === a2) {
      Eg(b2);
      a2 = b2.memoizedState;
      if (null !== a2 && (a2 = a2.dehydrated, null !== a2)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
      g2 = d2.children;
      a2 = d2.fallback;
      return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a2 = Tg(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a2) : qj(b2, g2);
    }
    e3 = a2.memoizedState;
    if (null !== e3 && (h2 = e3.dehydrated, null !== h2)) return rj(a2, b2, g2, d2, h2, e3, c2);
    if (f2) {
      f2 = d2.fallback;
      g2 = b2.mode;
      e3 = a2.child;
      h2 = e3.sibling;
      var k2 = { mode: "hidden", children: d2.children };
      0 === (g2 & 1) && b2.child !== e3 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e3, k2), d2.subtreeFlags = e3.subtreeFlags & 14680064);
      null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
      f2.return = b2;
      d2.return = b2;
      d2.sibling = f2;
      b2.child = d2;
      d2 = f2;
      f2 = b2.child;
      g2 = a2.child.memoizedState;
      g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
      f2.memoizedState = g2;
      f2.childLanes = a2.childLanes & ~c2;
      b2.memoizedState = mj;
      return d2;
    }
    f2 = a2.child;
    a2 = f2.sibling;
    d2 = Pg(f2, { mode: "visible", children: d2.children });
    0 === (b2.mode & 1) && (d2.lanes = c2);
    d2.return = b2;
    d2.sibling = null;
    null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
    b2.child = d2;
    b2.memoizedState = null;
    return d2;
  }
  function qj(a2, b2) {
    b2 = pj({ mode: "visible", children: b2 }, a2.mode, 0, null);
    b2.return = a2;
    return a2.child = b2;
  }
  function sj(a2, b2, c2, d2) {
    null !== d2 && Jg(d2);
    Ug(b2, a2.child, null, c2);
    a2 = qj(b2, b2.pendingProps.children);
    a2.flags |= 2;
    b2.memoizedState = null;
    return a2;
  }
  function rj(a2, b2, c2, d2, e3, f2, g2) {
    if (c2) {
      if (b2.flags & 256) return b2.flags &= -257, d2 = Ki(Error(p2(422))), sj(a2, b2, g2, d2);
      if (null !== b2.memoizedState) return b2.child = a2.child, b2.flags |= 128, null;
      f2 = d2.fallback;
      e3 = b2.mode;
      d2 = pj({ mode: "visible", children: d2.children }, e3, 0, null);
      f2 = Tg(f2, e3, g2, null);
      f2.flags |= 2;
      d2.return = b2;
      f2.return = b2;
      d2.sibling = f2;
      b2.child = d2;
      0 !== (b2.mode & 1) && Ug(b2, a2.child, null, g2);
      b2.child.memoizedState = nj(g2);
      b2.memoizedState = mj;
      return f2;
    }
    if (0 === (b2.mode & 1)) return sj(a2, b2, g2, null);
    if ("$!" === e3.data) {
      d2 = e3.nextSibling && e3.nextSibling.dataset;
      if (d2) var h2 = d2.dgst;
      d2 = h2;
      f2 = Error(p2(419));
      d2 = Ki(f2, d2, void 0);
      return sj(a2, b2, g2, d2);
    }
    h2 = 0 !== (g2 & a2.childLanes);
    if (dh || h2) {
      d2 = Q2;
      if (null !== d2) {
        switch (g2 & -g2) {
          case 4:
            e3 = 2;
            break;
          case 16:
            e3 = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e3 = 32;
            break;
          case 536870912:
            e3 = 268435456;
            break;
          default:
            e3 = 0;
        }
        e3 = 0 !== (e3 & (d2.suspendedLanes | g2)) ? 0 : e3;
        0 !== e3 && e3 !== f2.retryLane && (f2.retryLane = e3, ih(a2, e3), gi(d2, a2, e3, -1));
      }
      tj();
      d2 = Ki(Error(p2(421)));
      return sj(a2, b2, g2, d2);
    }
    if ("$?" === e3.data) return b2.flags |= 128, b2.child = a2.child, b2 = uj.bind(null, a2), e3._reactRetry = b2, null;
    a2 = f2.treeContext;
    yg = Lf(e3.nextSibling);
    xg = b2;
    I2 = true;
    zg = null;
    null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
    b2 = qj(b2, d2.children);
    b2.flags |= 4096;
    return b2;
  }
  function vj(a2, b2, c2) {
    a2.lanes |= b2;
    var d2 = a2.alternate;
    null !== d2 && (d2.lanes |= b2);
    bh(a2.return, b2, c2);
  }
  function wj(a2, b2, c2, d2, e3) {
    var f2 = a2.memoizedState;
    null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e3 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e3);
  }
  function xj(a2, b2, c2) {
    var d2 = b2.pendingProps, e3 = d2.revealOrder, f2 = d2.tail;
    Xi(a2, b2, d2.children, c2);
    d2 = L2.current;
    if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b2.flags |= 128;
    else {
      if (null !== a2 && 0 !== (a2.flags & 128)) a: for (a2 = b2.child; null !== a2; ) {
        if (13 === a2.tag) null !== a2.memoizedState && vj(a2, c2, b2);
        else if (19 === a2.tag) vj(a2, c2, b2);
        else if (null !== a2.child) {
          a2.child.return = a2;
          a2 = a2.child;
          continue;
        }
        if (a2 === b2) break a;
        for (; null === a2.sibling; ) {
          if (null === a2.return || a2.return === b2) break a;
          a2 = a2.return;
        }
        a2.sibling.return = a2.return;
        a2 = a2.sibling;
      }
      d2 &= 1;
    }
    G2(L2, d2);
    if (0 === (b2.mode & 1)) b2.memoizedState = null;
    else switch (e3) {
      case "forwards":
        c2 = b2.child;
        for (e3 = null; null !== c2; ) a2 = c2.alternate, null !== a2 && null === Ch(a2) && (e3 = c2), c2 = c2.sibling;
        c2 = e3;
        null === c2 ? (e3 = b2.child, b2.child = null) : (e3 = c2.sibling, c2.sibling = null);
        wj(b2, false, e3, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e3 = b2.child;
        for (b2.child = null; null !== e3; ) {
          a2 = e3.alternate;
          if (null !== a2 && null === Ch(a2)) {
            b2.child = e3;
            break;
          }
          a2 = e3.sibling;
          e3.sibling = c2;
          c2 = e3;
          e3 = a2;
        }
        wj(b2, true, c2, null, f2);
        break;
      case "together":
        wj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
    return b2.child;
  }
  function ij(a2, b2) {
    0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
  }
  function Zi(a2, b2, c2) {
    null !== a2 && (b2.dependencies = a2.dependencies);
    rh |= b2.lanes;
    if (0 === (c2 & b2.childLanes)) return null;
    if (null !== a2 && b2.child !== a2.child) throw Error(p2(153));
    if (null !== b2.child) {
      a2 = b2.child;
      c2 = Pg(a2, a2.pendingProps);
      b2.child = c2;
      for (c2.return = b2; null !== a2.sibling; ) a2 = a2.sibling, c2 = c2.sibling = Pg(a2, a2.pendingProps), c2.return = b2;
      c2.sibling = null;
    }
    return b2.child;
  }
  function yj(a2, b2, c2) {
    switch (b2.tag) {
      case 3:
        kj(b2);
        Ig();
        break;
      case 5:
        Ah(b2);
        break;
      case 1:
        Zf(b2.type) && cg(b2);
        break;
      case 4:
        yh(b2, b2.stateNode.containerInfo);
        break;
      case 10:
        var d2 = b2.type._context, e3 = b2.memoizedProps.value;
        G2(Wg, d2._currentValue);
        d2._currentValue = e3;
        break;
      case 13:
        d2 = b2.memoizedState;
        if (null !== d2) {
          if (null !== d2.dehydrated) return G2(L2, L2.current & 1), b2.flags |= 128, null;
          if (0 !== (c2 & b2.child.childLanes)) return oj(a2, b2, c2);
          G2(L2, L2.current & 1);
          a2 = Zi(a2, b2, c2);
          return null !== a2 ? a2.sibling : null;
        }
        G2(L2, L2.current & 1);
        break;
      case 19:
        d2 = 0 !== (c2 & b2.childLanes);
        if (0 !== (a2.flags & 128)) {
          if (d2) return xj(a2, b2, c2);
          b2.flags |= 128;
        }
        e3 = b2.memoizedState;
        null !== e3 && (e3.rendering = null, e3.tail = null, e3.lastEffect = null);
        G2(L2, L2.current);
        if (d2) break;
        else return null;
      case 22:
      case 23:
        return b2.lanes = 0, dj(a2, b2, c2);
    }
    return Zi(a2, b2, c2);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a2, b2) {
    for (var c2 = b2.child; null !== c2; ) {
      if (5 === c2.tag || 6 === c2.tag) a2.appendChild(c2.stateNode);
      else if (4 !== c2.tag && null !== c2.child) {
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
      if (c2 === b2) break;
      for (; null === c2.sibling; ) {
        if (null === c2.return || c2.return === b2) return;
        c2 = c2.return;
      }
      c2.sibling.return = c2.return;
      c2 = c2.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a2, b2, c2, d2) {
    var e3 = a2.memoizedProps;
    if (e3 !== d2) {
      a2 = b2.stateNode;
      xh(uh.current);
      var f2 = null;
      switch (c2) {
        case "input":
          e3 = Ya(a2, e3);
          d2 = Ya(a2, d2);
          f2 = [];
          break;
        case "select":
          e3 = A2({}, e3, { value: void 0 });
          d2 = A2({}, d2, { value: void 0 });
          f2 = [];
          break;
        case "textarea":
          e3 = gb(a2, e3);
          d2 = gb(a2, d2);
          f2 = [];
          break;
        default:
          "function" !== typeof e3.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
      }
      ub(c2, d2);
      var g2;
      c2 = null;
      for (l2 in e3) if (!d2.hasOwnProperty(l2) && e3.hasOwnProperty(l2) && null != e3[l2]) if ("style" === l2) {
        var h2 = e3[l2];
        for (g2 in h2) h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
      } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
      for (l2 in d2) {
        var k2 = d2[l2];
        h2 = null != e3 ? e3[l2] : void 0;
        if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
          for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
          for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
        } else c2 || (f2 || (f2 = []), f2.push(
          l2,
          c2
        )), c2 = k2;
        else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D2("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
      }
      c2 && (f2 = f2 || []).push("style", c2);
      var l2 = f2;
      if (b2.updateQueue = l2) b2.flags |= 4;
    }
  };
  Cj = function(a2, b2, c2, d2) {
    c2 !== d2 && (b2.flags |= 4);
  };
  function Dj(a2, b2) {
    if (!I2) switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; ) null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
  }
  function S2(a2) {
    var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
    if (b2) for (var e3 = a2.child; null !== e3; ) c2 |= e3.lanes | e3.childLanes, d2 |= e3.subtreeFlags & 14680064, d2 |= e3.flags & 14680064, e3.return = a2, e3 = e3.sibling;
    else for (e3 = a2.child; null !== e3; ) c2 |= e3.lanes | e3.childLanes, d2 |= e3.subtreeFlags, d2 |= e3.flags, e3.return = a2, e3 = e3.sibling;
    a2.subtreeFlags |= d2;
    a2.childLanes = c2;
    return b2;
  }
  function Ej(a2, b2, c2) {
    var d2 = b2.pendingProps;
    wg(b2);
    switch (b2.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S2(b2), null;
      case 1:
        return Zf(b2.type) && $f(), S2(b2), null;
      case 3:
        d2 = b2.stateNode;
        zh();
        E2(Wf);
        E2(H2);
        Eh();
        d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
        if (null === a2 || null === a2.child) Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a2, b2);
        S2(b2);
        return null;
      case 5:
        Bh(b2);
        var e3 = xh(wh.current);
        c2 = b2.type;
        if (null !== a2 && null != b2.stateNode) Bj(a2, b2, c2, d2, e3), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        else {
          if (!d2) {
            if (null === b2.stateNode) throw Error(p2(166));
            S2(b2);
            return null;
          }
          a2 = xh(uh.current);
          if (Gg(b2)) {
            d2 = b2.stateNode;
            c2 = b2.type;
            var f2 = b2.memoizedProps;
            d2[Of] = b2;
            d2[Pf] = f2;
            a2 = 0 !== (b2.mode & 1);
            switch (c2) {
              case "dialog":
                D2("cancel", d2);
                D2("close", d2);
                break;
              case "iframe":
              case "object":
              case "embed":
                D2("load", d2);
                break;
              case "video":
              case "audio":
                for (e3 = 0; e3 < lf.length; e3++) D2(lf[e3], d2);
                break;
              case "source":
                D2("error", d2);
                break;
              case "img":
              case "image":
              case "link":
                D2(
                  "error",
                  d2
                );
                D2("load", d2);
                break;
              case "details":
                D2("toggle", d2);
                break;
              case "input":
                Za(d2, f2);
                D2("invalid", d2);
                break;
              case "select":
                d2._wrapperState = { wasMultiple: !!f2.multiple };
                D2("invalid", d2);
                break;
              case "textarea":
                hb(d2, f2), D2("invalid", d2);
            }
            ub(c2, f2);
            e3 = null;
            for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e3 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e3 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D2("scroll", d2);
            }
            switch (c2) {
              case "input":
                Va(d2);
                db(d2, f2, true);
                break;
              case "textarea":
                Va(d2);
                jb(d2);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f2.onClick && (d2.onclick = Bf);
            }
            d2 = e3;
            b2.updateQueue = d2;
            null !== d2 && (b2.flags |= 4);
          } else {
            g2 = 9 === e3.nodeType ? e3 : e3.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
            "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
            a2[Of] = b2;
            a2[Pf] = d2;
            zj(a2, b2, false, false);
            b2.stateNode = a2;
            a: {
              g2 = vb(c2, d2);
              switch (c2) {
                case "dialog":
                  D2("cancel", a2);
                  D2("close", a2);
                  e3 = d2;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D2("load", a2);
                  e3 = d2;
                  break;
                case "video":
                case "audio":
                  for (e3 = 0; e3 < lf.length; e3++) D2(lf[e3], a2);
                  e3 = d2;
                  break;
                case "source":
                  D2("error", a2);
                  e3 = d2;
                  break;
                case "img":
                case "image":
                case "link":
                  D2(
                    "error",
                    a2
                  );
                  D2("load", a2);
                  e3 = d2;
                  break;
                case "details":
                  D2("toggle", a2);
                  e3 = d2;
                  break;
                case "input":
                  Za(a2, d2);
                  e3 = Ya(a2, d2);
                  D2("invalid", a2);
                  break;
                case "option":
                  e3 = d2;
                  break;
                case "select":
                  a2._wrapperState = { wasMultiple: !!d2.multiple };
                  e3 = A2({}, d2, { value: void 0 });
                  D2("invalid", a2);
                  break;
                case "textarea":
                  hb(a2, d2);
                  e3 = gb(a2, d2);
                  D2("invalid", a2);
                  break;
                default:
                  e3 = d2;
              }
              ub(c2, e3);
              h2 = e3;
              for (f2 in h2) if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D2("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
              switch (c2) {
                case "input":
                  Va(a2);
                  db(a2, d2, false);
                  break;
                case "textarea":
                  Va(a2);
                  jb(a2);
                  break;
                case "option":
                  null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                  break;
                case "select":
                  a2.multiple = !!d2.multiple;
                  f2 = d2.value;
                  null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                    a2,
                    !!d2.multiple,
                    d2.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e3.onClick && (a2.onclick = Bf);
              }
              switch (c2) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d2 = !!d2.autoFocus;
                  break a;
                case "img":
                  d2 = true;
                  break a;
                default:
                  d2 = false;
              }
            }
            d2 && (b2.flags |= 4);
          }
          null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        }
        S2(b2);
        return null;
      case 6:
        if (a2 && null != b2.stateNode) Cj(a2, b2, a2.memoizedProps, d2);
        else {
          if ("string" !== typeof d2 && null === b2.stateNode) throw Error(p2(166));
          c2 = xh(wh.current);
          xh(uh.current);
          if (Gg(b2)) {
            d2 = b2.stateNode;
            c2 = b2.memoizedProps;
            d2[Of] = b2;
            if (f2 = d2.nodeValue !== c2) {
              if (a2 = xg, null !== a2) switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
            }
            f2 && (b2.flags |= 4);
          } else d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
        }
        S2(b2);
        return null;
      case 13:
        E2(L2);
        d2 = b2.memoizedState;
        if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
          if (I2 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
          else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
            if (null === a2) {
              if (!f2) throw Error(p2(318));
              f2 = b2.memoizedState;
              f2 = null !== f2 ? f2.dehydrated : null;
              if (!f2) throw Error(p2(317));
              f2[Of] = b2;
            } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
            S2(b2);
            f2 = false;
          } else null !== zg && (Fj(zg), zg = null), f2 = true;
          if (!f2) return b2.flags & 65536 ? b2 : null;
        }
        if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
        d2 = null !== d2;
        d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (L2.current & 1) ? 0 === T2 && (T2 = 3) : tj()));
        null !== b2.updateQueue && (b2.flags |= 4);
        S2(b2);
        return null;
      case 4:
        return zh(), Aj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S2(b2), null;
      case 10:
        return ah(b2.type._context), S2(b2), null;
      case 17:
        return Zf(b2.type) && $f(), S2(b2), null;
      case 19:
        E2(L2);
        f2 = b2.memoizedState;
        if (null === f2) return S2(b2), null;
        d2 = 0 !== (b2.flags & 128);
        g2 = f2.rendering;
        if (null === g2) if (d2) Dj(f2, false);
        else {
          if (0 !== T2 || null !== a2 && 0 !== (a2.flags & 128)) for (a2 = b2.child; null !== a2; ) {
            g2 = Ch(a2);
            if (null !== g2) {
              b2.flags |= 128;
              Dj(f2, false);
              d2 = g2.updateQueue;
              null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
              b2.subtreeFlags = 0;
              d2 = c2;
              for (c2 = b2.child; null !== c2; ) f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
              G2(L2, L2.current & 1 | 2);
              return b2.child;
            }
            a2 = a2.sibling;
          }
          null !== f2.tail && B2() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        }
        else {
          if (!d2) if (a2 = Ch(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I2) return S2(b2), null;
          } else 2 * B2() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
          f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
        }
        if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B2(), b2.sibling = null, c2 = L2.current, G2(L2, d2 ? c2 & 1 | 2 : c2 & 1), b2;
        S2(b2);
        return null;
      case 22:
      case 23:
        return Hj(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S2(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S2(b2), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p2(156, b2.tag));
  }
  function Ij(a2, b2) {
    wg(b2);
    switch (b2.tag) {
      case 1:
        return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 3:
        return zh(), E2(Wf), E2(H2), Eh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 5:
        return Bh(b2), null;
      case 13:
        E2(L2);
        a2 = b2.memoizedState;
        if (null !== a2 && null !== a2.dehydrated) {
          if (null === b2.alternate) throw Error(p2(340));
          Ig();
        }
        a2 = b2.flags;
        return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 19:
        return E2(L2), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b2.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U2 = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V2 = null;
  function Lj(a2, b2) {
    var c2 = a2.ref;
    if (null !== c2) if ("function" === typeof c2) try {
      c2(null);
    } catch (d2) {
      W2(a2, b2, d2);
    }
    else c2.current = null;
  }
  function Mj(a2, b2, c2) {
    try {
      c2();
    } catch (d2) {
      W2(a2, b2, d2);
    }
  }
  var Nj = false;
  function Oj(a2, b2) {
    Cf = dd;
    a2 = Me();
    if (Ne(a2)) {
      if ("selectionStart" in a2) var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
      else a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e3 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b: for (; ; ) {
            for (var y2; ; ) {
              q2 !== c2 || 0 !== e3 && 3 !== q2.nodeType || (h2 = g2 + e3);
              q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
              3 === q2.nodeType && (g2 += q2.nodeValue.length);
              if (null === (y2 = q2.firstChild)) break;
              r2 = q2;
              q2 = y2;
            }
            for (; ; ) {
              if (q2 === a2) break b;
              r2 === c2 && ++l2 === e3 && (h2 = g2);
              r2 === f2 && ++m2 === d2 && (k2 = g2);
              if (null !== (y2 = q2.nextSibling)) break;
              q2 = r2;
              r2 = q2.parentNode;
            }
            q2 = y2;
          }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else c2 = null;
      }
      c2 = c2 || { start: 0, end: 0 };
    } else c2 = null;
    Df = { focusedElem: a2, selectionRange: c2 };
    dd = false;
    for (V2 = b2; null !== V2; ) if (b2 = V2, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2) a2.return = b2, V2 = a2;
    else for (; null !== V2; ) {
      b2 = V2;
      try {
        var n2 = b2.alternate;
        if (0 !== (b2.flags & 1024)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n2) {
              var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
              x2.__reactInternalSnapshotBeforeUpdate = w2;
            }
            break;
          case 3:
            var u2 = b2.stateNode.containerInfo;
            1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p2(163));
        }
      } catch (F2) {
        W2(b2, b2.return, F2);
      }
      a2 = b2.sibling;
      if (null !== a2) {
        a2.return = b2.return;
        V2 = a2;
        break;
      }
      V2 = b2.return;
    }
    n2 = Nj;
    Nj = false;
    return n2;
  }
  function Pj(a2, b2, c2) {
    var d2 = b2.updateQueue;
    d2 = null !== d2 ? d2.lastEffect : null;
    if (null !== d2) {
      var e3 = d2 = d2.next;
      do {
        if ((e3.tag & a2) === a2) {
          var f2 = e3.destroy;
          e3.destroy = void 0;
          void 0 !== f2 && Mj(b2, c2, f2);
        }
        e3 = e3.next;
      } while (e3 !== d2);
    }
  }
  function Qj(a2, b2) {
    b2 = b2.updateQueue;
    b2 = null !== b2 ? b2.lastEffect : null;
    if (null !== b2) {
      var c2 = b2 = b2.next;
      do {
        if ((c2.tag & a2) === a2) {
          var d2 = c2.create;
          c2.destroy = d2();
        }
        c2 = c2.next;
      } while (c2 !== b2);
    }
  }
  function Rj(a2) {
    var b2 = a2.ref;
    if (null !== b2) {
      var c2 = a2.stateNode;
      switch (a2.tag) {
        case 5:
          a2 = c2;
          break;
        default:
          a2 = c2;
      }
      "function" === typeof b2 ? b2(a2) : b2.current = a2;
    }
  }
  function Sj(a2) {
    var b2 = a2.alternate;
    null !== b2 && (a2.alternate = null, Sj(b2));
    a2.child = null;
    a2.deletions = null;
    a2.sibling = null;
    5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
    a2.stateNode = null;
    a2.return = null;
    a2.dependencies = null;
    a2.memoizedProps = null;
    a2.memoizedState = null;
    a2.pendingProps = null;
    a2.stateNode = null;
    a2.updateQueue = null;
  }
  function Tj(a2) {
    return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
  }
  function Uj(a2) {
    a: for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Tj(a2.return)) return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2) continue a;
        if (null === a2.child || 4 === a2.tag) continue a;
        else a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2)) return a2.stateNode;
    }
  }
  function Vj(a2, b2, c2) {
    var d2 = a2.tag;
    if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
    else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Vj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Vj(a2, b2, c2), a2 = a2.sibling;
  }
  function Wj(a2, b2, c2) {
    var d2 = a2.tag;
    if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
    else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Wj(a2, b2, c2), a2 = a2.sibling;
  }
  var X2 = null, Xj = false;
  function Yj(a2, b2, c2) {
    for (c2 = c2.child; null !== c2; ) Zj(a2, b2, c2), c2 = c2.sibling;
  }
  function Zj(a2, b2, c2) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
    switch (c2.tag) {
      case 5:
        U2 || Lj(c2, b2);
      case 6:
        var d2 = X2, e3 = Xj;
        X2 = null;
        Yj(a2, b2, c2);
        X2 = d2;
        Xj = e3;
        null !== X2 && (Xj ? (a2 = X2, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X2.removeChild(c2.stateNode));
        break;
      case 18:
        null !== X2 && (Xj ? (a2 = X2, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X2, c2.stateNode));
        break;
      case 4:
        d2 = X2;
        e3 = Xj;
        X2 = c2.stateNode.containerInfo;
        Xj = true;
        Yj(a2, b2, c2);
        X2 = d2;
        Xj = e3;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U2 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
          e3 = d2 = d2.next;
          do {
            var f2 = e3, g2 = f2.destroy;
            f2 = f2.tag;
            void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
            e3 = e3.next;
          } while (e3 !== d2);
        }
        Yj(a2, b2, c2);
        break;
      case 1:
        if (!U2 && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount)) try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W2(c2, b2, h2);
        }
        Yj(a2, b2, c2);
        break;
      case 21:
        Yj(a2, b2, c2);
        break;
      case 22:
        c2.mode & 1 ? (U2 = (d2 = U2) || null !== c2.memoizedState, Yj(a2, b2, c2), U2 = d2) : Yj(a2, b2, c2);
        break;
      default:
        Yj(a2, b2, c2);
    }
  }
  function ak(a2) {
    var b2 = a2.updateQueue;
    if (null !== b2) {
      a2.updateQueue = null;
      var c2 = a2.stateNode;
      null === c2 && (c2 = a2.stateNode = new Kj());
      b2.forEach(function(b3) {
        var d2 = bk.bind(null, a2, b3);
        c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
      });
    }
  }
  function ck(a2, b2) {
    var c2 = b2.deletions;
    if (null !== c2) for (var d2 = 0; d2 < c2.length; d2++) {
      var e3 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a: for (; null !== h2; ) {
          switch (h2.tag) {
            case 5:
              X2 = h2.stateNode;
              Xj = false;
              break a;
            case 3:
              X2 = h2.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X2 = h2.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h2 = h2.return;
        }
        if (null === X2) throw Error(p2(160));
        Zj(f2, g2, e3);
        X2 = null;
        Xj = false;
        var k2 = e3.alternate;
        null !== k2 && (k2.return = null);
        e3.return = null;
      } catch (l2) {
        W2(e3, b2, l2);
      }
    }
    if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) dk(b2, a2), b2 = b2.sibling;
  }
  function dk(a2, b2) {
    var c2 = a2.alternate, d2 = a2.flags;
    switch (a2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b2, a2);
        ek(a2);
        if (d2 & 4) {
          try {
            Pj(3, a2, a2.return), Qj(3, a2);
          } catch (t2) {
            W2(a2, a2.return, t2);
          }
          try {
            Pj(5, a2, a2.return);
          } catch (t2) {
            W2(a2, a2.return, t2);
          }
        }
        break;
      case 1:
        ck(b2, a2);
        ek(a2);
        d2 & 512 && null !== c2 && Lj(c2, c2.return);
        break;
      case 5:
        ck(b2, a2);
        ek(a2);
        d2 & 512 && null !== c2 && Lj(c2, c2.return);
        if (a2.flags & 32) {
          var e3 = a2.stateNode;
          try {
            ob(e3, "");
          } catch (t2) {
            W2(a2, a2.return, t2);
          }
        }
        if (d2 & 4 && (e3 = a2.stateNode, null != e3)) {
          var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
          a2.updateQueue = null;
          if (null !== k2) try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e3, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e3, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e3, q2) : "children" === m2 ? ob(e3, q2) : ta(e3, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e3, f2);
                break;
              case "textarea":
                ib(e3, f2);
                break;
              case "select":
                var r2 = e3._wrapperState.wasMultiple;
                e3._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e3, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e3,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e3, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e3[Pf] = f2;
          } catch (t2) {
            W2(a2, a2.return, t2);
          }
        }
        break;
      case 6:
        ck(b2, a2);
        ek(a2);
        if (d2 & 4) {
          if (null === a2.stateNode) throw Error(p2(162));
          e3 = a2.stateNode;
          f2 = a2.memoizedProps;
          try {
            e3.nodeValue = f2;
          } catch (t2) {
            W2(a2, a2.return, t2);
          }
        }
        break;
      case 3:
        ck(b2, a2);
        ek(a2);
        if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
          bd(b2.containerInfo);
        } catch (t2) {
          W2(a2, a2.return, t2);
        }
        break;
      case 4:
        ck(b2, a2);
        ek(a2);
        break;
      case 13:
        ck(b2, a2);
        ek(a2);
        e3 = a2.child;
        e3.flags & 8192 && (f2 = null !== e3.memoizedState, e3.stateNode.isHidden = f2, !f2 || null !== e3.alternate && null !== e3.alternate.memoizedState || (fk = B2()));
        d2 & 4 && ak(a2);
        break;
      case 22:
        m2 = null !== c2 && null !== c2.memoizedState;
        a2.mode & 1 ? (U2 = (l2 = U2) || m2, ck(b2, a2), U2 = l2) : ck(b2, a2);
        ek(a2);
        if (d2 & 8192) {
          l2 = null !== a2.memoizedState;
          if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1)) for (V2 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V2 = m2; null !== V2; ) {
              r2 = V2;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W2(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V2 = y2) : gk(q2);
            }
            m2 = m2.sibling;
          }
          a: for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e3 = q2.stateNode, l2 ? (f2 = e3.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W2(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2) try {
                q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
              } catch (t2) {
                W2(a2, a2.return, t2);
              }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2) break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2) break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
        }
        break;
      case 19:
        ck(b2, a2);
        ek(a2);
        d2 & 4 && ak(a2);
        break;
      case 21:
        break;
      default:
        ck(
          b2,
          a2
        ), ek(a2);
    }
  }
  function ek(a2) {
    var b2 = a2.flags;
    if (b2 & 2) {
      try {
        a: {
          for (var c2 = a2.return; null !== c2; ) {
            if (Tj(c2)) {
              var d2 = c2;
              break a;
            }
            c2 = c2.return;
          }
          throw Error(p2(160));
        }
        switch (d2.tag) {
          case 5:
            var e3 = d2.stateNode;
            d2.flags & 32 && (ob(e3, ""), d2.flags &= -33);
            var f2 = Uj(a2);
            Wj(a2, f2, e3);
            break;
          case 3:
          case 4:
            var g2 = d2.stateNode.containerInfo, h2 = Uj(a2);
            Vj(a2, h2, g2);
            break;
          default:
            throw Error(p2(161));
        }
      } catch (k2) {
        W2(a2, a2.return, k2);
      }
      a2.flags &= -3;
    }
    b2 & 4096 && (a2.flags &= -4097);
  }
  function hk(a2, b2, c2) {
    V2 = a2;
    ik(a2);
  }
  function ik(a2, b2, c2) {
    for (var d2 = 0 !== (a2.mode & 1); null !== V2; ) {
      var e3 = V2, f2 = e3.child;
      if (22 === e3.tag && d2) {
        var g2 = null !== e3.memoizedState || Jj;
        if (!g2) {
          var h2 = e3.alternate, k2 = null !== h2 && null !== h2.memoizedState || U2;
          h2 = Jj;
          var l2 = U2;
          Jj = g2;
          if ((U2 = k2) && !l2) for (V2 = e3; null !== V2; ) g2 = V2, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e3) : null !== k2 ? (k2.return = g2, V2 = k2) : jk(e3);
          for (; null !== f2; ) V2 = f2, ik(f2), f2 = f2.sibling;
          V2 = e3;
          Jj = h2;
          U2 = l2;
        }
        kk(a2);
      } else 0 !== (e3.subtreeFlags & 8772) && null !== f2 ? (f2.return = e3, V2 = f2) : kk(a2);
    }
  }
  function kk(a2) {
    for (; null !== V2; ) {
      var b2 = V2;
      if (0 !== (b2.flags & 8772)) {
        var c2 = b2.alternate;
        try {
          if (0 !== (b2.flags & 8772)) switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U2 || Qj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U2) if (null === c2) d2.componentDidMount();
              else {
                var e3 = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
                d2.componentDidUpdate(e3, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
              }
              var f2 = b2.updateQueue;
              null !== f2 && sh(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child) switch (b2.child.tag) {
                  case 5:
                    c2 = b2.child.stateNode;
                    break;
                  case 1:
                    c2 = b2.child.stateNode;
                }
                sh(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p2(163));
          }
          U2 || b2.flags & 512 && Rj(b2);
        } catch (r2) {
          W2(b2, b2.return, r2);
        }
      }
      if (b2 === a2) {
        V2 = null;
        break;
      }
      c2 = b2.sibling;
      if (null !== c2) {
        c2.return = b2.return;
        V2 = c2;
        break;
      }
      V2 = b2.return;
    }
  }
  function gk(a2) {
    for (; null !== V2; ) {
      var b2 = V2;
      if (b2 === a2) {
        V2 = null;
        break;
      }
      var c2 = b2.sibling;
      if (null !== c2) {
        c2.return = b2.return;
        V2 = c2;
        break;
      }
      V2 = b2.return;
    }
  }
  function jk(a2) {
    for (; null !== V2; ) {
      var b2 = V2;
      try {
        switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            var c2 = b2.return;
            try {
              Qj(4, b2);
            } catch (k2) {
              W2(b2, c2, k2);
            }
            break;
          case 1:
            var d2 = b2.stateNode;
            if ("function" === typeof d2.componentDidMount) {
              var e3 = b2.return;
              try {
                d2.componentDidMount();
              } catch (k2) {
                W2(b2, e3, k2);
              }
            }
            var f2 = b2.return;
            try {
              Rj(b2);
            } catch (k2) {
              W2(b2, f2, k2);
            }
            break;
          case 5:
            var g2 = b2.return;
            try {
              Rj(b2);
            } catch (k2) {
              W2(b2, g2, k2);
            }
        }
      } catch (k2) {
        W2(b2, b2.return, k2);
      }
      if (b2 === a2) {
        V2 = null;
        break;
      }
      var h2 = b2.sibling;
      if (null !== h2) {
        h2.return = b2.return;
        V2 = h2;
        break;
      }
      V2 = b2.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K2 = 0, Q2 = null, Y2 = null, Z2 = 0, fj = 0, ej = Uf(0), T2 = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R2() {
    return 0 !== (K2 & 6) ? B2() : -1 !== Ak ? Ak : Ak = B2();
  }
  function yi(a2) {
    if (0 === (a2.mode & 1)) return 1;
    if (0 !== (K2 & 2) && 0 !== Z2) return Z2 & -Z2;
    if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
    a2 = C2;
    if (0 !== a2) return a2;
    a2 = window.event;
    a2 = void 0 === a2 ? 16 : jd(a2.type);
    return a2;
  }
  function gi(a2, b2, c2, d2) {
    if (50 < yk) throw yk = 0, zk = null, Error(p2(185));
    Ac(a2, c2, d2);
    if (0 === (K2 & 2) || a2 !== Q2) a2 === Q2 && (0 === (K2 & 2) && (qk |= c2), 4 === T2 && Ck(a2, Z2)), Dk(a2, d2), 1 === c2 && 0 === K2 && 0 === (b2.mode & 1) && (Gj = B2() + 500, fg && jg());
  }
  function Dk(a2, b2) {
    var c2 = a2.callbackNode;
    wc(a2, b2);
    var d2 = uc(a2, a2 === Q2 ? Z2 : 0);
    if (0 === d2) null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
    else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
      null != c2 && bc(c2);
      if (1 === b2) 0 === a2.tag ? ig(Ek.bind(null, a2)) : hg(Ek.bind(null, a2)), Jf(function() {
        0 === (K2 & 6) && jg();
      }), c2 = null;
      else {
        switch (Dc(d2)) {
          case 1:
            c2 = fc;
            break;
          case 4:
            c2 = gc;
            break;
          case 16:
            c2 = hc;
            break;
          case 536870912:
            c2 = jc;
            break;
          default:
            c2 = hc;
        }
        c2 = Fk(c2, Gk.bind(null, a2));
      }
      a2.callbackPriority = b2;
      a2.callbackNode = c2;
    }
  }
  function Gk(a2, b2) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K2 & 6)) throw Error(p2(327));
    var c2 = a2.callbackNode;
    if (Hk() && a2.callbackNode !== c2) return null;
    var d2 = uc(a2, a2 === Q2 ? Z2 : 0);
    if (0 === d2) return null;
    if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2) b2 = Ik(a2, d2);
    else {
      b2 = d2;
      var e3 = K2;
      K2 |= 2;
      var f2 = Jk();
      if (Q2 !== a2 || Z2 !== b2) uk = null, Gj = B2() + 500, Kk(a2, b2);
      do
        try {
          Lk();
          break;
        } catch (h2) {
          Mk(a2, h2);
        }
      while (1);
      $g();
      mk.current = f2;
      K2 = e3;
      null !== Y2 ? b2 = 0 : (Q2 = null, Z2 = 0, b2 = T2);
    }
    if (0 !== b2) {
      2 === b2 && (e3 = xc(a2), 0 !== e3 && (d2 = e3, b2 = Nk(a2, e3)));
      if (1 === b2) throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B2()), c2;
      if (6 === b2) Ck(a2, d2);
      else {
        e3 = a2.current.alternate;
        if (0 === (d2 & 30) && !Ok(e3) && (b2 = Ik(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Nk(a2, f2))), 1 === b2)) throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B2()), c2;
        a2.finishedWork = e3;
        a2.finishedLanes = d2;
        switch (b2) {
          case 0:
          case 1:
            throw Error(p2(345));
          case 2:
            Pk(a2, tk, uk);
            break;
          case 3:
            Ck(a2, d2);
            if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B2(), 10 < b2)) {
              if (0 !== uc(a2, 0)) break;
              e3 = a2.suspendedLanes;
              if ((e3 & d2) !== d2) {
                R2();
                a2.pingedLanes |= a2.suspendedLanes & e3;
                break;
              }
              a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), b2);
              break;
            }
            Pk(a2, tk, uk);
            break;
          case 4:
            Ck(a2, d2);
            if ((d2 & 4194240) === d2) break;
            b2 = a2.eventTimes;
            for (e3 = -1; 0 < d2; ) {
              var g2 = 31 - oc(d2);
              f2 = 1 << g2;
              g2 = b2[g2];
              g2 > e3 && (e3 = g2);
              d2 &= ~f2;
            }
            d2 = e3;
            d2 = B2() - d2;
            d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
            if (10 < d2) {
              a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), d2);
              break;
            }
            Pk(a2, tk, uk);
            break;
          case 5:
            Pk(a2, tk, uk);
            break;
          default:
            throw Error(p2(329));
        }
      }
    }
    Dk(a2, B2());
    return a2.callbackNode === c2 ? Gk.bind(null, a2) : null;
  }
  function Nk(a2, b2) {
    var c2 = sk;
    a2.current.memoizedState.isDehydrated && (Kk(a2, b2).flags |= 256);
    a2 = Ik(a2, b2);
    2 !== a2 && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
    return a2;
  }
  function Fj(a2) {
    null === tk ? tk = a2 : tk.push.apply(tk, a2);
  }
  function Ok(a2) {
    for (var b2 = a2; ; ) {
      if (b2.flags & 16384) {
        var c2 = b2.updateQueue;
        if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d2 = 0; d2 < c2.length; d2++) {
          var e3 = c2[d2], f2 = e3.getSnapshot;
          e3 = e3.value;
          try {
            if (!He(f2(), e3)) return false;
          } catch (g2) {
            return false;
          }
        }
      }
      c2 = b2.child;
      if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
      else {
        if (b2 === a2) break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a2) return true;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
    }
    return true;
  }
  function Ck(a2, b2) {
    b2 &= ~rk;
    b2 &= ~qk;
    a2.suspendedLanes |= b2;
    a2.pingedLanes &= ~b2;
    for (a2 = a2.expirationTimes; 0 < b2; ) {
      var c2 = 31 - oc(b2), d2 = 1 << c2;
      a2[c2] = -1;
      b2 &= ~d2;
    }
  }
  function Ek(a2) {
    if (0 !== (K2 & 6)) throw Error(p2(327));
    Hk();
    var b2 = uc(a2, 0);
    if (0 === (b2 & 1)) return Dk(a2, B2()), null;
    var c2 = Ik(a2, b2);
    if (0 !== a2.tag && 2 === c2) {
      var d2 = xc(a2);
      0 !== d2 && (b2 = d2, c2 = Nk(a2, d2));
    }
    if (1 === c2) throw c2 = pk, Kk(a2, 0), Ck(a2, b2), Dk(a2, B2()), c2;
    if (6 === c2) throw Error(p2(345));
    a2.finishedWork = a2.current.alternate;
    a2.finishedLanes = b2;
    Pk(a2, tk, uk);
    Dk(a2, B2());
    return null;
  }
  function Qk(a2, b2) {
    var c2 = K2;
    K2 |= 1;
    try {
      return a2(b2);
    } finally {
      K2 = c2, 0 === K2 && (Gj = B2() + 500, fg && jg());
    }
  }
  function Rk(a2) {
    null !== wk && 0 === wk.tag && 0 === (K2 & 6) && Hk();
    var b2 = K2;
    K2 |= 1;
    var c2 = ok.transition, d2 = C2;
    try {
      if (ok.transition = null, C2 = 1, a2) return a2();
    } finally {
      C2 = d2, ok.transition = c2, K2 = b2, 0 === (K2 & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E2(ej);
  }
  function Kk(a2, b2) {
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    var c2 = a2.timeoutHandle;
    -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
    if (null !== Y2) for (c2 = Y2.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          zh();
          E2(Wf);
          E2(H2);
          Eh();
          break;
        case 5:
          Bh(d2);
          break;
        case 4:
          zh();
          break;
        case 13:
          E2(L2);
          break;
        case 19:
          E2(L2);
          break;
        case 10:
          ah(d2.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c2 = c2.return;
    }
    Q2 = a2;
    Y2 = a2 = Pg(a2.current, null);
    Z2 = fj = b2;
    T2 = 0;
    pk = null;
    rk = qk = rh = 0;
    tk = sk = null;
    if (null !== fh) {
      for (b2 = 0; b2 < fh.length; b2++) if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e3 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e3;
          d2.next = g2;
        }
        c2.pending = d2;
      }
      fh = null;
    }
    return a2;
  }
  function Mk(a2, b2) {
    do {
      var c2 = Y2;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d2 = M2.memoizedState; null !== d2; ) {
            var e3 = d2.queue;
            null !== e3 && (e3.pending = null);
            d2 = d2.next;
          }
          Ih = false;
        }
        Hh = 0;
        O2 = N2 = M2 = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c2 || null === c2.return) {
          T2 = 1;
          pk = b2;
          Y2 = null;
          break;
        }
        a: {
          var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
          b2 = Z2;
          h2.flags |= 32768;
          if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
            var l2 = k2, m2 = h2, q2 = m2.tag;
            if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
              var r2 = m2.alternate;
              r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
            }
            var y2 = Ui(g2);
            if (null !== y2) {
              y2.flags &= -257;
              Vi(y2, g2, h2, f2, b2);
              y2.mode & 1 && Si(f2, l2, b2);
              b2 = y2;
              k2 = l2;
              var n2 = b2.updateQueue;
              if (null === n2) {
                var t2 = /* @__PURE__ */ new Set();
                t2.add(k2);
                b2.updateQueue = t2;
              } else n2.add(k2);
              break a;
            } else {
              if (0 === (b2 & 1)) {
                Si(f2, l2, b2);
                tj();
                break a;
              }
              k2 = Error(p2(426));
            }
          } else if (I2 && h2.mode & 1) {
            var J2 = Ui(g2);
            if (null !== J2) {
              0 === (J2.flags & 65536) && (J2.flags |= 256);
              Vi(J2, g2, h2, f2, b2);
              Jg(Ji(k2, h2));
              break a;
            }
          }
          f2 = k2 = Ji(k2, h2);
          4 !== T2 && (T2 = 2);
          null === sk ? sk = [f2] : sk.push(f2);
          f2 = g2;
          do {
            switch (f2.tag) {
              case 3:
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var x2 = Ni(f2, k2, b2);
                ph(f2, x2);
                break a;
              case 1:
                h2 = k2;
                var w2 = f2.type, u2 = f2.stateNode;
                if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var F2 = Qi(f2, h2, b2);
                  ph(f2, F2);
                  break a;
                }
            }
            f2 = f2.return;
          } while (null !== f2);
        }
        Sk(c2);
      } catch (na) {
        b2 = na;
        Y2 === c2 && null !== c2 && (Y2 = c2 = c2.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a2 = mk.current;
    mk.current = Rh;
    return null === a2 ? Rh : a2;
  }
  function tj() {
    if (0 === T2 || 3 === T2 || 2 === T2) T2 = 4;
    null === Q2 || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q2, Z2);
  }
  function Ik(a2, b2) {
    var c2 = K2;
    K2 |= 2;
    var d2 = Jk();
    if (Q2 !== a2 || Z2 !== b2) uk = null, Kk(a2, b2);
    do
      try {
        Tk();
        break;
      } catch (e3) {
        Mk(a2, e3);
      }
    while (1);
    $g();
    K2 = c2;
    mk.current = d2;
    if (null !== Y2) throw Error(p2(261));
    Q2 = null;
    Z2 = 0;
    return T2;
  }
  function Tk() {
    for (; null !== Y2; ) Uk(Y2);
  }
  function Lk() {
    for (; null !== Y2 && !cc(); ) Uk(Y2);
  }
  function Uk(a2) {
    var b2 = Vk(a2.alternate, a2, fj);
    a2.memoizedProps = a2.pendingProps;
    null === b2 ? Sk(a2) : Y2 = b2;
    nk.current = null;
  }
  function Sk(a2) {
    var b2 = a2;
    do {
      var c2 = b2.alternate;
      a2 = b2.return;
      if (0 === (b2.flags & 32768)) {
        if (c2 = Ej(c2, b2, fj), null !== c2) {
          Y2 = c2;
          return;
        }
      } else {
        c2 = Ij(c2, b2);
        if (null !== c2) {
          c2.flags &= 32767;
          Y2 = c2;
          return;
        }
        if (null !== a2) a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
        else {
          T2 = 6;
          Y2 = null;
          return;
        }
      }
      b2 = b2.sibling;
      if (null !== b2) {
        Y2 = b2;
        return;
      }
      Y2 = b2 = a2;
    } while (null !== b2);
    0 === T2 && (T2 = 5);
  }
  function Pk(a2, b2, c2) {
    var d2 = C2, e3 = ok.transition;
    try {
      ok.transition = null, C2 = 1, Wk(a2, b2, c2, d2);
    } finally {
      ok.transition = e3, C2 = d2;
    }
    return null;
  }
  function Wk(a2, b2, c2, d2) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K2 & 6)) throw Error(p2(327));
    c2 = a2.finishedWork;
    var e3 = a2.finishedLanes;
    if (null === c2) return null;
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    if (c2 === a2.current) throw Error(p2(177));
    a2.callbackNode = null;
    a2.callbackPriority = 0;
    var f2 = c2.lanes | c2.childLanes;
    Bc(a2, f2);
    a2 === Q2 && (Y2 = Q2 = null, Z2 = 0);
    0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f2 = 0 !== (c2.flags & 15990);
    if (0 !== (c2.subtreeFlags & 15990) || f2) {
      f2 = ok.transition;
      ok.transition = null;
      var g2 = C2;
      C2 = 1;
      var h2 = K2;
      K2 |= 4;
      nk.current = null;
      Oj(a2, c2);
      dk(c2, a2);
      Oe(Df);
      dd = !!Cf;
      Df = Cf = null;
      a2.current = c2;
      hk(c2);
      dc();
      K2 = h2;
      C2 = g2;
      ok.transition = f2;
    } else a2.current = c2;
    vk && (vk = false, wk = a2, xk = e3);
    f2 = a2.pendingLanes;
    0 === f2 && (Ri = null);
    mc(c2.stateNode);
    Dk(a2, B2());
    if (null !== b2) for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e3 = b2[c2], d2(e3.value, { componentStack: e3.stack, digest: e3.digest });
    if (Oi) throw Oi = false, a2 = Pi, Pi = null, a2;
    0 !== (xk & 1) && 0 !== a2.tag && Hk();
    f2 = a2.pendingLanes;
    0 !== (f2 & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a2 = Dc(xk), b2 = ok.transition, c2 = C2;
      try {
        ok.transition = null;
        C2 = 16 > a2 ? 16 : a2;
        if (null === wk) var d2 = false;
        else {
          a2 = wk;
          wk = null;
          xk = 0;
          if (0 !== (K2 & 6)) throw Error(p2(331));
          var e3 = K2;
          K2 |= 4;
          for (V2 = a2.current; null !== V2; ) {
            var f2 = V2, g2 = f2.child;
            if (0 !== (V2.flags & 16)) {
              var h2 = f2.deletions;
              if (null !== h2) {
                for (var k2 = 0; k2 < h2.length; k2++) {
                  var l2 = h2[k2];
                  for (V2 = l2; null !== V2; ) {
                    var m2 = V2;
                    switch (m2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m2, f2);
                    }
                    var q2 = m2.child;
                    if (null !== q2) q2.return = m2, V2 = q2;
                    else for (; null !== V2; ) {
                      m2 = V2;
                      var r2 = m2.sibling, y2 = m2.return;
                      Sj(m2);
                      if (m2 === l2) {
                        V2 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V2 = r2;
                        break;
                      }
                      V2 = y2;
                    }
                  }
                }
                var n2 = f2.alternate;
                if (null !== n2) {
                  var t2 = n2.child;
                  if (null !== t2) {
                    n2.child = null;
                    do {
                      var J2 = t2.sibling;
                      t2.sibling = null;
                      t2 = J2;
                    } while (null !== t2);
                  }
                }
                V2 = f2;
              }
            }
            if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V2 = g2;
            else b: for (; null !== V2; ) {
              f2 = V2;
              if (0 !== (f2.flags & 2048)) switch (f2.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f2, f2.return);
              }
              var x2 = f2.sibling;
              if (null !== x2) {
                x2.return = f2.return;
                V2 = x2;
                break b;
              }
              V2 = f2.return;
            }
          }
          var w2 = a2.current;
          for (V2 = w2; null !== V2; ) {
            g2 = V2;
            var u2 = g2.child;
            if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V2 = u2;
            else b: for (g2 = w2; null !== V2; ) {
              h2 = V2;
              if (0 !== (h2.flags & 2048)) try {
                switch (h2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h2);
                }
              } catch (na) {
                W2(h2, h2.return, na);
              }
              if (h2 === g2) {
                V2 = null;
                break b;
              }
              var F2 = h2.sibling;
              if (null !== F2) {
                F2.return = h2.return;
                V2 = F2;
                break b;
              }
              V2 = h2.return;
            }
          }
          K2 = e3;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
          d2 = true;
        }
        return d2;
      } finally {
        C2 = c2, ok.transition = b2;
      }
    }
    return false;
  }
  function Xk(a2, b2, c2) {
    b2 = Ji(c2, b2);
    b2 = Ni(a2, b2, 1);
    a2 = nh(a2, b2, 1);
    b2 = R2();
    null !== a2 && (Ac(a2, 1, b2), Dk(a2, b2));
  }
  function W2(a2, b2, c2) {
    if (3 === a2.tag) Xk(a2, a2, c2);
    else for (; null !== b2; ) {
      if (3 === b2.tag) {
        Xk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
          a2 = Ji(c2, a2);
          a2 = Qi(b2, a2, 1);
          b2 = nh(b2, a2, 1);
          a2 = R2();
          null !== b2 && (Ac(b2, 1, a2), Dk(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
  }
  function Ti(a2, b2, c2) {
    var d2 = a2.pingCache;
    null !== d2 && d2.delete(b2);
    b2 = R2();
    a2.pingedLanes |= a2.suspendedLanes & c2;
    Q2 === a2 && (Z2 & c2) === c2 && (4 === T2 || 3 === T2 && (Z2 & 130023424) === Z2 && 500 > B2() - fk ? Kk(a2, 0) : rk |= c2);
    Dk(a2, b2);
  }
  function Yk(a2, b2) {
    0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c2 = R2();
    a2 = ih(a2, b2);
    null !== a2 && (Ac(a2, b2, c2), Dk(a2, c2));
  }
  function uj(a2) {
    var b2 = a2.memoizedState, c2 = 0;
    null !== b2 && (c2 = b2.retryLane);
    Yk(a2, c2);
  }
  function bk(a2, b2) {
    var c2 = 0;
    switch (a2.tag) {
      case 13:
        var d2 = a2.stateNode;
        var e3 = a2.memoizedState;
        null !== e3 && (c2 = e3.retryLane);
        break;
      case 19:
        d2 = a2.stateNode;
        break;
      default:
        throw Error(p2(314));
    }
    null !== d2 && d2.delete(b2);
    Yk(a2, c2);
  }
  var Vk;
  Vk = function(a2, b2, c2) {
    if (null !== a2) if (a2.memoizedProps !== b2.pendingProps || Wf.current) dh = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128)) return dh = false, yj(a2, b2, c2);
      dh = 0 !== (a2.flags & 131072) ? true : false;
    }
    else dh = false, I2 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
    b2.lanes = 0;
    switch (b2.tag) {
      case 2:
        var d2 = b2.type;
        ij(a2, b2);
        a2 = b2.pendingProps;
        var e3 = Yf(b2, H2.current);
        ch(b2, c2);
        e3 = Nh(null, b2, d2, a2, e3, c2);
        var f2 = Sh();
        b2.flags |= 1;
        "object" === typeof e3 && null !== e3 && "function" === typeof e3.render && void 0 === e3.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e3.state && void 0 !== e3.state ? e3.state : null, kh(b2), e3.updater = Ei, b2.stateNode = e3, e3._reactInternals = b2, Ii(b2, d2, a2, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I2 && f2 && vg(b2), Xi(null, b2, e3, c2), b2 = b2.child);
        return b2;
      case 16:
        d2 = b2.elementType;
        a: {
          ij(a2, b2);
          a2 = b2.pendingProps;
          e3 = d2._init;
          d2 = e3(d2._payload);
          b2.type = d2;
          e3 = b2.tag = Zk(d2);
          a2 = Ci(d2, a2);
          switch (e3) {
            case 0:
              b2 = cj(null, b2, d2, a2, c2);
              break a;
            case 1:
              b2 = hj(null, b2, d2, a2, c2);
              break a;
            case 11:
              b2 = Yi(null, b2, d2, a2, c2);
              break a;
            case 14:
              b2 = $i(null, b2, d2, Ci(d2.type, a2), c2);
              break a;
          }
          throw Error(p2(
            306,
            d2,
            ""
          ));
        }
        return b2;
      case 0:
        return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Ci(d2, e3), cj(a2, b2, d2, e3, c2);
      case 1:
        return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Ci(d2, e3), hj(a2, b2, d2, e3, c2);
      case 3:
        a: {
          kj(b2);
          if (null === a2) throw Error(p2(387));
          d2 = b2.pendingProps;
          f2 = b2.memoizedState;
          e3 = f2.element;
          lh(a2, b2);
          qh(b2, d2, null, c2);
          var g2 = b2.memoizedState;
          d2 = g2.element;
          if (f2.isDehydrated) if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e3 = Ji(Error(p2(423)), b2);
            b2 = lj(a2, b2, d2, c2, e3);
            break a;
          } else if (d2 !== e3) {
            e3 = Ji(Error(p2(424)), b2);
            b2 = lj(a2, b2, d2, c2, e3);
            break a;
          } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I2 = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
          else {
            Ig();
            if (d2 === e3) {
              b2 = Zi(a2, b2, c2);
              break a;
            }
            Xi(a2, b2, d2, c2);
          }
          b2 = b2.child;
        }
        return b2;
      case 5:
        return Ah(b2), null === a2 && Eg(b2), d2 = b2.type, e3 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e3.children, Ef(d2, e3) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a2, b2), Xi(a2, b2, g2, c2), b2.child;
      case 6:
        return null === a2 && Eg(b2), null;
      case 13:
        return oj(a2, b2, c2);
      case 4:
        return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Ug(b2, null, d2, c2) : Xi(a2, b2, d2, c2), b2.child;
      case 11:
        return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Ci(d2, e3), Yi(a2, b2, d2, e3, c2);
      case 7:
        return Xi(a2, b2, b2.pendingProps, c2), b2.child;
      case 8:
        return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
      case 12:
        return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
      case 10:
        a: {
          d2 = b2.type._context;
          e3 = b2.pendingProps;
          f2 = b2.memoizedProps;
          g2 = e3.value;
          G2(Wg, d2._currentValue);
          d2._currentValue = g2;
          if (null !== f2) if (He(f2.value, g2)) {
            if (f2.children === e3.children && !Wf.current) {
              b2 = Zi(a2, b2, c2);
              break a;
            }
          } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
            var h2 = f2.dependencies;
            if (null !== h2) {
              g2 = f2.child;
              for (var k2 = h2.firstContext; null !== k2; ) {
                if (k2.context === d2) {
                  if (1 === f2.tag) {
                    k2 = mh(-1, c2 & -c2);
                    k2.tag = 2;
                    var l2 = f2.updateQueue;
                    if (null !== l2) {
                      l2 = l2.shared;
                      var m2 = l2.pending;
                      null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                      l2.pending = k2;
                    }
                  }
                  f2.lanes |= c2;
                  k2 = f2.alternate;
                  null !== k2 && (k2.lanes |= c2);
                  bh(
                    f2.return,
                    c2,
                    b2
                  );
                  h2.lanes |= c2;
                  break;
                }
                k2 = k2.next;
              }
            } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
            else if (18 === f2.tag) {
              g2 = f2.return;
              if (null === g2) throw Error(p2(341));
              g2.lanes |= c2;
              h2 = g2.alternate;
              null !== h2 && (h2.lanes |= c2);
              bh(g2, c2, b2);
              g2 = f2.sibling;
            } else g2 = f2.child;
            if (null !== g2) g2.return = f2;
            else for (g2 = f2; null !== g2; ) {
              if (g2 === b2) {
                g2 = null;
                break;
              }
              f2 = g2.sibling;
              if (null !== f2) {
                f2.return = g2.return;
                g2 = f2;
                break;
              }
              g2 = g2.return;
            }
            f2 = g2;
          }
          Xi(a2, b2, e3.children, c2);
          b2 = b2.child;
        }
        return b2;
      case 9:
        return e3 = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e3 = eh(e3), d2 = d2(e3), b2.flags |= 1, Xi(a2, b2, d2, c2), b2.child;
      case 14:
        return d2 = b2.type, e3 = Ci(d2, b2.pendingProps), e3 = Ci(d2.type, e3), $i(a2, b2, d2, e3, c2);
      case 15:
        return bj(a2, b2, b2.type, b2.pendingProps, c2);
      case 17:
        return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Ci(d2, e3), ij(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, ch(b2, c2), Gi(b2, d2, e3), Ii(b2, d2, e3, c2), jj(null, b2, d2, true, a2, c2);
      case 19:
        return xj(a2, b2, c2);
      case 22:
        return dj(a2, b2, c2);
    }
    throw Error(p2(156, b2.tag));
  };
  function Fk(a2, b2) {
    return ac(a2, b2);
  }
  function $k(a2, b2, c2, d2) {
    this.tag = a2;
    this.key = c2;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b2;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d2;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a2, b2, c2, d2) {
    return new $k(a2, b2, c2, d2);
  }
  function aj(a2) {
    a2 = a2.prototype;
    return !(!a2 || !a2.isReactComponent);
  }
  function Zk(a2) {
    if ("function" === typeof a2) return aj(a2) ? 1 : 0;
    if (void 0 !== a2 && null !== a2) {
      a2 = a2.$$typeof;
      if (a2 === Da) return 11;
      if (a2 === Ga) return 14;
    }
    return 2;
  }
  function Pg(a2, b2) {
    var c2 = a2.alternate;
    null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
    c2.flags = a2.flags & 14680064;
    c2.childLanes = a2.childLanes;
    c2.lanes = a2.lanes;
    c2.child = a2.child;
    c2.memoizedProps = a2.memoizedProps;
    c2.memoizedState = a2.memoizedState;
    c2.updateQueue = a2.updateQueue;
    b2 = a2.dependencies;
    c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
    c2.sibling = a2.sibling;
    c2.index = a2.index;
    c2.ref = a2.ref;
    return c2;
  }
  function Rg(a2, b2, c2, d2, e3, f2) {
    var g2 = 2;
    d2 = a2;
    if ("function" === typeof a2) aj(a2) && (g2 = 1);
    else if ("string" === typeof a2) g2 = 5;
    else a: switch (a2) {
      case ya:
        return Tg(c2.children, e3, f2, b2);
      case za:
        g2 = 8;
        e3 |= 8;
        break;
      case Aa:
        return a2 = Bg(12, c2, b2, e3 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
      case Ea:
        return a2 = Bg(13, c2, b2, e3), a2.elementType = Ea, a2.lanes = f2, a2;
      case Fa:
        return a2 = Bg(19, c2, b2, e3), a2.elementType = Fa, a2.lanes = f2, a2;
      case Ia:
        return pj(c2, e3, f2, b2);
      default:
        if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
          case Ba:
            g2 = 10;
            break a;
          case Ca:
            g2 = 9;
            break a;
          case Da:
            g2 = 11;
            break a;
          case Ga:
            g2 = 14;
            break a;
          case Ha:
            g2 = 16;
            d2 = null;
            break a;
        }
        throw Error(p2(130, null == a2 ? a2 : typeof a2, ""));
    }
    b2 = Bg(g2, c2, b2, e3);
    b2.elementType = a2;
    b2.type = d2;
    b2.lanes = f2;
    return b2;
  }
  function Tg(a2, b2, c2, d2) {
    a2 = Bg(7, a2, d2, b2);
    a2.lanes = c2;
    return a2;
  }
  function pj(a2, b2, c2, d2) {
    a2 = Bg(22, a2, d2, b2);
    a2.elementType = Ia;
    a2.lanes = c2;
    a2.stateNode = { isHidden: false };
    return a2;
  }
  function Qg(a2, b2, c2) {
    a2 = Bg(6, a2, null, b2);
    a2.lanes = c2;
    return a2;
  }
  function Sg(a2, b2, c2) {
    b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
    b2.lanes = c2;
    b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
    return b2;
  }
  function al(a2, b2, c2, d2, e3) {
    this.tag = b2;
    this.containerInfo = a2;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d2;
    this.onRecoverableError = e3;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
    a2 = new al(a2, b2, c2, h2, k2);
    1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
    f2 = Bg(3, null, null, b2);
    a2.current = f2;
    f2.stateNode = a2;
    f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f2);
    return a2;
  }
  function cl(a2, b2, c2) {
    var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
  }
  function dl(a2) {
    if (!a2) return Vf;
    a2 = a2._reactInternals;
    a: {
      if (Vb(a2) !== a2 || 1 !== a2.tag) throw Error(p2(170));
      var b2 = a2;
      do {
        switch (b2.tag) {
          case 3:
            b2 = b2.stateNode.context;
            break a;
          case 1:
            if (Zf(b2.type)) {
              b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b2 = b2.return;
      } while (null !== b2);
      throw Error(p2(171));
    }
    if (1 === a2.tag) {
      var c2 = a2.type;
      if (Zf(c2)) return bg(a2, c2, b2);
    }
    return b2;
  }
  function el(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
    a2 = bl(c2, d2, true, a2, e3, f2, g2, h2, k2);
    a2.context = dl(null);
    c2 = a2.current;
    d2 = R2();
    e3 = yi(c2);
    f2 = mh(d2, e3);
    f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
    nh(c2, f2, e3);
    a2.current.lanes = e3;
    Ac(a2, e3, d2);
    Dk(a2, d2);
    return a2;
  }
  function fl(a2, b2, c2, d2) {
    var e3 = b2.current, f2 = R2(), g2 = yi(e3);
    c2 = dl(c2);
    null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
    b2 = mh(f2, g2);
    b2.payload = { element: a2 };
    d2 = void 0 === d2 ? null : d2;
    null !== d2 && (b2.callback = d2);
    a2 = nh(e3, b2, g2);
    null !== a2 && (gi(a2, e3, g2, f2), oh(a2, e3, g2));
    return g2;
  }
  function gl(a2) {
    a2 = a2.current;
    if (!a2.child) return null;
    switch (a2.child.tag) {
      case 5:
        return a2.child.stateNode;
      default:
        return a2.child.stateNode;
    }
  }
  function hl(a2, b2) {
    a2 = a2.memoizedState;
    if (null !== a2 && null !== a2.dehydrated) {
      var c2 = a2.retryLane;
      a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
    }
  }
  function il(a2, b2) {
    hl(a2, b2);
    (a2 = a2.alternate) && hl(a2, b2);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a2) {
    console.error(a2);
  };
  function ll(a2) {
    this._internalRoot = a2;
  }
  ml.prototype.render = ll.prototype.render = function(a2) {
    var b2 = this._internalRoot;
    if (null === b2) throw Error(p2(409));
    fl(a2, b2, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a2 = this._internalRoot;
    if (null !== a2) {
      this._internalRoot = null;
      var b2 = a2.containerInfo;
      Rk(function() {
        fl(null, a2, null, null);
      });
      b2[uf] = null;
    }
  };
  function ml(a2) {
    this._internalRoot = a2;
  }
  ml.prototype.unstable_scheduleHydration = function(a2) {
    if (a2) {
      var b2 = Hc();
      a2 = { blockedOn: null, target: a2, priority: b2 };
      for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
      Qc.splice(c2, 0, a2);
      0 === c2 && Vc(a2);
    }
  };
  function nl(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
  }
  function ol(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
  }
  function pl() {
  }
  function ql(a2, b2, c2, d2, e3) {
    if (e3) {
      if ("function" === typeof d2) {
        var f2 = d2;
        d2 = function() {
          var a3 = gl(g2);
          f2.call(a3);
        };
      }
      var g2 = el(b2, d2, a2, 0, null, false, false, "", pl);
      a2._reactRootContainer = g2;
      a2[uf] = g2.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      Rk();
      return g2;
    }
    for (; e3 = a2.lastChild; ) a2.removeChild(e3);
    if ("function" === typeof d2) {
      var h2 = d2;
      d2 = function() {
        var a3 = gl(k2);
        h2.call(a3);
      };
    }
    var k2 = bl(a2, 0, false, null, null, false, false, "", pl);
    a2._reactRootContainer = k2;
    a2[uf] = k2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Rk(function() {
      fl(b2, k2, c2, d2);
    });
    return k2;
  }
  function rl(a2, b2, c2, d2, e3) {
    var f2 = c2._reactRootContainer;
    if (f2) {
      var g2 = f2;
      if ("function" === typeof e3) {
        var h2 = e3;
        e3 = function() {
          var a3 = gl(g2);
          h2.call(a3);
        };
      }
      fl(b2, g2, a2, e3);
    } else g2 = ql(c2, b2, a2, e3, d2);
    return gl(g2);
  }
  Ec = function(a2) {
    switch (a2.tag) {
      case 3:
        var b2 = a2.stateNode;
        if (b2.current.memoizedState.isDehydrated) {
          var c2 = tc(b2.pendingLanes);
          0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B2()), 0 === (K2 & 6) && (Gj = B2() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b3 = ih(a2, 1);
          if (null !== b3) {
            var c3 = R2();
            gi(b3, a2, 1, c3);
          }
        }), il(a2, 1);
    }
  };
  Fc = function(a2) {
    if (13 === a2.tag) {
      var b2 = ih(a2, 134217728);
      if (null !== b2) {
        var c2 = R2();
        gi(b2, a2, 134217728, c2);
      }
      il(a2, 134217728);
    }
  };
  Gc = function(a2) {
    if (13 === a2.tag) {
      var b2 = yi(a2), c2 = ih(a2, b2);
      if (null !== c2) {
        var d2 = R2();
        gi(c2, a2, b2, d2);
      }
      il(a2, b2);
    }
  };
  Hc = function() {
    return C2;
  };
  Ic = function(a2, b2) {
    var c2 = C2;
    try {
      return C2 = a2, b2();
    } finally {
      C2 = c2;
    }
  };
  yb = function(a2, b2, c2) {
    switch (b2) {
      case "input":
        bb(a2, c2);
        b2 = c2.name;
        if ("radio" === c2.type && null != b2) {
          for (c2 = a2; c2.parentNode; ) c2 = c2.parentNode;
          c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
          for (b2 = 0; b2 < c2.length; b2++) {
            var d2 = c2[b2];
            if (d2 !== a2 && d2.form === a2.form) {
              var e3 = Db(d2);
              if (!e3) throw Error(p2(90));
              Wa(d2);
              bb(d2, e3);
            }
          }
        }
        break;
      case "textarea":
        ib(a2, c2);
        break;
      case "select":
        b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
    a2 = Zb(a2);
    return null === a2 ? null : a2.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch (a2) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a2, b2) {
    var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b2)) throw Error(p2(200));
    return cl(a2, b2, null, c2);
  };
  reactDom_production_min.createRoot = function(a2, b2) {
    if (!nl(a2)) throw Error(p2(299));
    var c2 = false, d2 = "", e3 = kl;
    null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e3 = b2.onRecoverableError));
    b2 = bl(a2, 1, false, null, null, c2, false, d2, e3);
    a2[uf] = b2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    return new ll(b2);
  };
  reactDom_production_min.findDOMNode = function(a2) {
    if (null == a2) return null;
    if (1 === a2.nodeType) return a2;
    var b2 = a2._reactInternals;
    if (void 0 === b2) {
      if ("function" === typeof a2.render) throw Error(p2(188));
      a2 = Object.keys(a2).join(",");
      throw Error(p2(268, a2));
    }
    a2 = Zb(b2);
    a2 = null === a2 ? null : a2.stateNode;
    return a2;
  };
  reactDom_production_min.flushSync = function(a2) {
    return Rk(a2);
  };
  reactDom_production_min.hydrate = function(a2, b2, c2) {
    if (!ol(b2)) throw Error(p2(200));
    return rl(null, a2, b2, true, c2);
  };
  reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
    if (!nl(a2)) throw Error(p2(405));
    var d2 = null != c2 && c2.hydratedSources || null, e3 = false, f2 = "", g2 = kl;
    null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e3 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
    b2 = el(b2, null, a2, 1, null != c2 ? c2 : null, e3, false, f2, g2);
    a2[uf] = b2.current;
    sf(a2);
    if (d2) for (a2 = 0; a2 < d2.length; a2++) c2 = d2[a2], e3 = c2._getVersion, e3 = e3(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e3] : b2.mutableSourceEagerHydrationData.push(
      c2,
      e3
    );
    return new ml(b2);
  };
  reactDom_production_min.render = function(a2, b2, c2) {
    if (!ol(b2)) throw Error(p2(200));
    return rl(null, a2, b2, false, c2);
  };
  reactDom_production_min.unmountComponentAtNode = function(a2) {
    if (!ol(a2)) throw Error(p2(40));
    return a2._reactRootContainer ? (Rk(function() {
      rl(null, null, a2, false, function() {
        a2._reactRootContainer = null;
        a2[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
    if (!ol(c2)) throw Error(p2(200));
    if (null == a2 || void 0 === a2._reactInternals) throw Error(p2(38));
    return rl(a2, b2, c2, false, d2);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  return reactDom_production_min;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production_min();
  }
  return reactDom.exports;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  var m2 = requireReactDom();
  {
    client.createRoot = m2.createRoot;
    client.hydrateRoot = m2.hydrateRoot;
  }
  return client;
}
var clientExports = requireClient();
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
var reactDomExports = requireReactDom();
/**
 * @remix-run/router v1.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$v() {
  _extends$v = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$v.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to2) {
    return typeof to2 === "string" ? to2 : createPath(to2);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant$1(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e3) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
function createLocation(current2, to2, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$v({
    pathname: typeof current2 === "string" ? current2 : current2.pathname,
    search: "",
    hash: ""
  }, typeof to2 === "string" ? parsePath(to2) : to2, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to2 && to2.key || key || createKey()
  });
  return location;
}
function createPath(_ref2) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref2;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#") pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path2) {
  let parsedPath = {};
  if (path2) {
    let hashIndex = path2.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path2.substr(hashIndex);
      path2 = path2.substr(0, hashIndex);
    }
    let searchIndex = path2.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path2.substr(searchIndex);
      path2 = path2.substr(0, searchIndex);
    }
    if (path2) {
      parsedPath.pathname = path2;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation2, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener2 = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends$v({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener2) {
      listener2({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to2, state) {
    action = Action.Push;
    let location = createLocation(history.location, to2, state);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener2) {
      listener2({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace2(to2, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to2, state);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener2) {
      listener2({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to2) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to2 === "string" ? to2 : createPath(to2);
    href = href.replace(/ $/, "%20");
    invariant$1(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation2(window2, globalHistory);
    },
    listen(fn) {
      if (listener2) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener2 = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener2 = null;
      };
    },
    createHref(to2) {
      return createHref(window2, to2);
    },
    createURL,
    encodeLocation(to2) {
      let url = createURL(to2);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  return matchRoutesImpl(routes, locationArg, basename);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches2 = null;
  for (let i2 = 0; matches2 == null && i2 < branches.length; ++i2) {
    let decoded = decodePath(pathname);
    matches2 = matchRouteBranch(branches[i2], decoded);
  }
  return matches2;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant$1(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path2 = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant$1(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path2 + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path2);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path: path2,
      score: computeScore(path2, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path2) {
  let segments2 = path2.split("/");
  if (segments2.length === 0) return [];
  let [first, ...rest] = segments2;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path2.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s2) => s2 === "*";
function computeScore(path2, index) {
  let segments2 = path2.split("/");
  let initialScore = segments2.length;
  if (segments2.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments2.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches2 = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    let route = meta.route;
    if (!match) {
      return null;
    }
    Object.assign(matchedParams, match.params);
    matches2.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches2;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce((memo, _ref2, index) => {
    let {
      paramName,
      isOptional
    } = _ref2;
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index];
    if (isOptional && !value) {
      memo[paramName] = void 0;
    } else {
      memo[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path2, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path2 === "*" || !path2.endsWith("*") || path2.endsWith("/*"), 'Route path "' + path2 + '" will be treated as if it were ' + ('"' + path2.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path2.replace(/\*$/, "/*") + '".'));
  let params = [];
  let regexpSource = "^" + path2.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_2, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path2.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path2 === "*" || path2 === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path2 !== "" && path2 !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
const ABSOLUTE_URL_REGEX$1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX$1.test(url);
function resolvePath(to2, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to2 === "string" ? parsePath(to2) : to2;
  let pathname;
  if (toPathname) {
    if (isAbsoluteUrl(toPathname)) {
      pathname = toPathname;
    } else {
      if (toPathname.includes("//")) {
        let oldPathname = toPathname;
        toPathname = toPathname.replace(/\/\/+/g, "/");
        warning(false, "Pathnames cannot have embedded double slashes - normalizing " + (oldPathname + " -> " + toPathname));
      }
      if (toPathname.startsWith("/")) {
        pathname = resolvePathname(toPathname.substring(1), "/");
      } else {
        pathname = resolvePathname(toPathname, fromPathname);
      }
    }
  } else {
    pathname = fromPathname;
  }
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments2 = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments2.length > 1) segments2.pop();
    } else if (segment !== ".") {
      segments2.push(segment);
    }
  });
  return segments2.length > 1 ? segments2.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path2) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path2) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches2) {
  return matches2.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
function getResolveToMatches(matches2, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches2);
  if (v7_relativeSplatPath) {
    return pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);
  }
  return pathMatches.map((match) => match.pathnameBase);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to2;
  if (typeof toArg === "string") {
    to2 = parsePath(toArg);
  } else {
    to2 = _extends$v({}, toArg);
    invariant$1(!to2.pathname || !to2.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to2));
    invariant$1(!to2.pathname || !to2.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to2));
    invariant$1(!to2.search || !to2.search.includes("#"), getInvalidPathError("#", "search", "hash", to2));
  }
  let isEmptyPath = toArg === "" || to2.pathname === "";
  let toPathname = isEmptyPath ? "/" : to2.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to2.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path2 = resolvePath(to2, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path2.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path2.pathname += "/";
  }
  return path2;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.30.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$u() {
  _extends$u = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$u.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to2, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant$1(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to2, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant$1(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useIsomorphicLayoutEffect$1(cb) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? invariant$1(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    future,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: matches2
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches2, future.v7_relativeSplatPath));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$1(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to2 === "number") {
      navigator2.go(to2);
      return;
    }
    let path2 = resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path2.pathname = path2.pathname === "/" ? basename : joinPaths([basename, path2.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path2, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
function useResolvedPath(to2, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    future
  } = reactExports.useContext(NavigationContext);
  let {
    matches: matches2
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches2, future.v7_relativeSplatPath));
  return reactExports.useMemo(() => resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to2, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  !useInRouterContext() ? invariant$1(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant$1(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments2 = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments2.slice(parentSegments.length).join("/");
  }
  let matches2 = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches2 && matches2.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
    ]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
    ])
  })), parentMatches, dataRouterState, future);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$u({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref2) {
  let {
    routeContext,
    match,
    children
  } = _ref2;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches2, parentMatches, dataRouterState, future) {
  var _dataRouterState;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches2 == null) {
    var _future;
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches2 = dataRouterState.matches;
    } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches2 = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches2;
  let errors2 = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
  if (errors2 != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors2 == null ? void 0 : errors2[m2.route.id]) !== void 0);
    !(errorIndex >= 0) ? invariant$1(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i2 = 0; i2 < renderedMatches.length; i2++) {
      let match = renderedMatches[i2];
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i2;
      }
      if (match.route.id) {
        let {
          loaderData,
          errors: errors22
        } = dataRouterState;
        let needsToRunLoader = match.route.loader && loaderData[match.route.id] === void 0 && (!errors22 || errors22[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match, index) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors2 && match.route.id ? errors2[match.route.id] : void 0;
      errorElement = match.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index === 0) {
          warningOnce("route-fallback");
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches22 = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match,
        routeContext: {
          outlet,
          matches: matches22,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches22,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook$1 = /* @__PURE__ */ (function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
})(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ (function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
})(DataRouterStateHook$1 || {});
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant$1(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant$1(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant$1(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant$1(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState();
  let routeId = useCurrentRouteId();
  if (error !== void 0) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
  let id = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$1(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to2 === "number") {
      router.navigate(to2);
    } else {
      router.navigate(to2, _extends$u({
        fromRouteId: id
      }, options));
    }
  }, [router, id]);
  return navigate;
}
const alreadyWarned$1 = {};
function warningOnce(key, cond, message) {
  if (!alreadyWarned$1[key]) {
    alreadyWarned$1[key] = true;
  }
}
function logV6DeprecationWarnings(renderFuture, routerFuture) {
  if ((renderFuture == null ? void 0 : renderFuture.v7_startTransition) === void 0) ;
  if ((renderFuture == null ? void 0 : renderFuture.v7_relativeSplatPath) === void 0 && true) ;
}
function Route(_props) {
  invariant$1(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? invariant$1(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends$u({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash: hash2,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash2, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children, (element, index) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant$1(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant$1(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.30.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$t() {
  _extends$t = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$t.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$n(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
const _excluded$n = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"];
const REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e3) {
}
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$1[START_TRANSITION];
function BrowserRouter(_ref4) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref4;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  reactExports.useEffect(() => logV6DeprecationWarnings(future), [future]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future
  });
}
const isBrowser$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref7, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to: to2,
    preventScrollReset,
    viewTransition
  } = _ref7, rest = _objectWithoutPropertiesLoose$n(_ref7, _excluded$n);
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to2 === "string" && ABSOLUTE_URL_REGEX.test(to2)) {
    absoluteHref = to2;
    if (isBrowser$1) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to2.startsWith("//") ? new URL(currentUrl.protocol + to2) : new URL(to2);
        let path2 = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path2 != null) {
          to2 = path2 + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e3) {
      }
    }
  }
  let href = useHref(to2, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to2, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative,
    viewTransition
  });
  function handleClick(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends$t({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref,
      target
    }))
  );
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
  DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetcher"] = "useFetcher";
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to2, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    viewTransition
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path2 = useResolvedPath(to2, {
    relative
  });
  return reactExports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path2);
      navigate(to2, {
        replace: replace2,
        state,
        preventScrollReset,
        relative,
        viewTransition
      });
    }
  }, [location, navigate, path2, replaceProp, state, target, to2, preventScrollReset, relative, viewTransition]);
}
const isString$1 = (obj) => typeof obj === "string";
const defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
const makeString = (object2) => {
  if (object2 == null) return "";
  return "" + object2;
};
const copy$2 = (a2, s2, t2) => {
  a2.forEach((m2) => {
    if (s2[m2]) t2[m2] = s2[m2];
  });
};
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
const canNotTraverseDeeper = (object2) => !object2 || isString$1(object2);
const getLastOfPath = (object2, path2, Empty) => {
  const stack = !isString$1(path2) ? path2 : path2.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object2)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object2[key] && Empty) object2[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object2, key)) {
      object2 = object2[key];
    } else {
      object2 = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object2)) return {};
  return {
    obj: object2,
    k: cleanKey(stack[stackIndex])
  };
};
const setPath = (object2, path2, newValue) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object2, path2, Object);
  if (obj !== void 0 || path2.length === 1) {
    obj[k2] = newValue;
    return;
  }
  let e3 = path2[path2.length - 1];
  let p2 = path2.slice(0, path2.length - 1);
  let last2 = getLastOfPath(object2, p2, Object);
  while (last2.obj === void 0 && p2.length) {
    e3 = `${p2[p2.length - 1]}.${e3}`;
    p2 = p2.slice(0, p2.length - 1);
    last2 = getLastOfPath(object2, p2, Object);
    if (last2?.obj && typeof last2.obj[`${last2.k}.${e3}`] !== "undefined") {
      last2.obj = void 0;
    }
  }
  last2.obj[`${last2.k}.${e3}`] = newValue;
};
const pushPath = (object2, path2, newValue, concat) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object2, path2, Object);
  obj[k2] = obj[k2] || [];
  obj[k2].push(newValue);
};
const getPath$2 = (object2, path2) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object2, path2);
  if (!obj) return void 0;
  if (!Object.prototype.hasOwnProperty.call(obj, k2)) return void 0;
  return obj[k2];
};
const getPathWithDefaults = (data, defaultData, key) => {
  const value = getPath$2(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath$2(defaultData, key);
};
const deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString$1(target[prop]) || target[prop] instanceof String || isString$1(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
const regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const escape = (data) => {
  if (isString$1(data)) {
    return data.replace(/[&<>"'\/]/g, (s2) => _entityMap[s2]);
  }
  return data;
};
class RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
}
const chars = [" ", ",", "?", "!", ";"];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c2) => nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0);
  if (possibleChars.length === 0) return true;
  const r2 = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c2) => c2 === "?" ? "\\?" : c2).join("|")})`);
  let matched = !r2.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r2.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
const deepFind = (obj, path2, keySeparator = ".") => {
  if (!obj) return void 0;
  if (obj[path2]) {
    if (!Object.prototype.hasOwnProperty.call(obj, path2)) return void 0;
    return obj[path2];
  }
  const tokens = path2.split(keySeparator);
  let current2 = obj;
  for (let i2 = 0; i2 < tokens.length; ) {
    if (!current2 || typeof current2 !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j2 = i2; j2 < tokens.length; ++j2) {
      if (j2 !== i2) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j2];
      next = current2[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j2 < tokens.length - 1) {
          continue;
        }
        i2 += j2 - i2 + 1;
        break;
      }
    }
    current2 = next;
  }
  return current2;
};
const getCleanedCode = (code) => code?.replace("_", "-");
const consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    console?.[type]?.apply?.(console, args);
  }
};
class Logger {
  constructor(concreteLogger, options = {}) {
    this.init(concreteLogger, options);
  }
  init(concreteLogger, options = {}) {
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log(...args) {
    return this.forward(args, "log", "", true);
  }
  warn(...args) {
    return this.forward(args, "warn", "", true);
  }
  error(...args) {
    return this.forward(args, "error", "");
  }
  deprecate(...args) {
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix2, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString$1(args[0])) args[0] = `${prefix2}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  }
}
var baseLogger = new Logger();
let EventEmitter$1 = class EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener2) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener2) || 0;
      this.observers[event].set(listener2, numListeners + 1);
    });
    return this;
  }
  off(event, listener2) {
    if (!this.observers[event]) return;
    if (!listener2) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener2);
  }
  emit(event, ...args) {
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach(([observer, numTimesAdded]) => {
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach(([observer, numTimesAdded]) => {
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
};
class ResourceStore extends EventEmitter$1 {
  constructor(data, options = {
    ns: ["translation"],
    defaultNS: "translation"
  }) {
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns, key, options = {}) {
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path2;
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
    } else {
      path2 = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path2.push(...key);
        } else if (isString$1(key) && keySeparator) {
          path2.push(...key.split(keySeparator));
        } else {
          path2.push(key);
        }
      }
    }
    const result = getPath$2(this.data, path2);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path2[0];
      ns = path2[1];
      key = path2.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || !isString$1(key)) return result;
    return deepFind(this.data?.[lng]?.[ns], key, keySeparator);
  }
  addResource(lng, ns, key, value, options = {
    silent: false
  }) {
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path2 = [lng, ns];
    if (key) path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      value = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path2, value);
    if (!options.silent) this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources2, options = {
    silent: false
  }) {
    for (const m2 in resources2) {
      if (isString$1(resources2[m2]) || Array.isArray(resources2[m2])) this.addResource(lng, ns, m2, resources2[m2], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng, ns, resources2);
  }
  addResourceBundle(lng, ns, resources2, deep, overwrite, options = {
    silent: false,
    skipCopy: false
  }) {
    let path2 = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      deep = resources2;
      resources2 = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    let pack = getPath$2(this.data, path2) || {};
    if (!options.skipCopy) resources2 = JSON.parse(JSON.stringify(resources2));
    if (deep) {
      deepExtend(pack, resources2, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources2
      };
    }
    setPath(this.data, path2, pack);
    if (!options.silent) this.emit("added", lng, ns, resources2);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n2 = data && Object.keys(data) || [];
    return !!n2.find((v2) => data[v2] && Object.keys(data[v2]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      value = this.processors[processor]?.process(value, key, options, translator) ?? value;
    });
    return value;
  }
};
const PATH_KEY = Symbol("i18next/PATH_KEY");
function createProxy$1() {
  const state = [];
  const handler = /* @__PURE__ */ Object.create(null);
  let proxy;
  handler.get = (target, key) => {
    proxy?.revoke?.();
    if (key === PATH_KEY) return state;
    state.push(key);
    proxy = Proxy.revocable(target, handler);
    return proxy.proxy;
  };
  return Proxy.revocable(/* @__PURE__ */ Object.create(null), handler).proxy;
}
function keysFromSelector(selector, opts) {
  const {
    [PATH_KEY]: path2
  } = selector(createProxy$1());
  return path2.join(opts?.keySeparator ?? ".");
}
const checkedLoadedFor = {};
const shouldHandleAsObject = (res) => !isString$1(res) && typeof res !== "boolean" && typeof res !== "number";
class Translator extends EventEmitter$1 {
  constructor(services, options = {}) {
    super();
    copy$2(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key, o2 = {
    interpolation: {}
  }) {
    const opt = {
      ...o2
    };
    if (key == null) return false;
    const resolved = this.resolve(key, opt);
    if (resolved?.res === void 0) return false;
    const isObject2 = shouldHandleAsObject(resolved.res);
    if (opt.returnObjects === false && isObject2) {
      return false;
    }
    return true;
  }
  extractFromKey(key, opt) {
    let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
    let namespaces = opt.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m2 = key.match(this.interpolator.nestingRegexp);
      if (m2 && m2.length > 0) {
        return {
          key,
          namespaces: isString$1(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    return {
      key,
      namespaces: isString$1(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, o2, lastKey) {
    let opt = typeof o2 === "object" ? {
      ...o2
    } : o2;
    if (typeof opt !== "object" && this.options.overloadTranslationOptionHandler) {
      opt = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof opt === "object") opt = {
      ...opt
    };
    if (!opt) opt = {};
    if (keys == null) return "";
    if (typeof keys === "function") keys = keysFromSelector(keys, {
      ...this.options,
      ...opt
    });
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = opt.returnDetails !== void 0 ? opt.returnDetails : this.options.returnDetails;
    const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], opt);
    const namespace = namespaces[namespaces.length - 1];
    let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const lng = opt.lng || this.language;
    const appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng?.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(opt)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(opt)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, opt);
    let res = resolved?.res;
    const resUsedKey = resolved?.usedKey || key;
    const resExactUsedKey = resolved?.exactUsedKey || key;
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = opt.joinArrays !== void 0 ? opt.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const needsPluralHandling = opt.count !== void 0 && !isString$1(opt.count);
    const hasDefaultValue = Translator.hasDefaultValue(opt);
    const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : "";
    const defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {
      ordinal: false
    }) : "";
    const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
    const defaultValue = needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] || opt[`defaultValue${defaultValueSuffix}`] || opt[`defaultValue${defaultValueSuffixOrdinalFallback}`] || opt.defaultValue;
    let resForObjHndl = res;
    if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {
      resForObjHndl = defaultValue;
    }
    const handleAsObject = shouldHandleAsObject(resForObjHndl);
    const resType = Object.prototype.toString.apply(resForObjHndl);
    if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString$1(joinArrays) && Array.isArray(resForObjHndl))) {
      if (!opt.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {
          ...opt,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r2;
          resolved.usedParams = this.getUsedParamsDetails(opt);
          return resolved;
        }
        return r2;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(resForObjHndl);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m2 in resForObjHndl) {
          if (Object.prototype.hasOwnProperty.call(resForObjHndl, m2)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m2}`;
            if (hasDefaultValue && !res) {
              copy2[m2] = this.translate(deepKey, {
                ...opt,
                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m2] : void 0,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            } else {
              copy2[m2] = this.translate(deepKey, {
                ...opt,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            }
            if (copy2[m2] === deepKey) copy2[m2] = resForObjHndl[m2];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString$1(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, opt, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...opt,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i2 = 0; i2 < fallbackLngs.length; i2++) {
            lngs.push(fallbackLngs[i2]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);
        } else {
          lngs.push(opt.lng || this.language);
        }
        const send = (l2, k2, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, opt);
          } else if (this.backendConnector?.saveMissing) {
            this.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, opt);
          }
          this.emit("missingKey", l2, namespace, k2, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, opt);
              if (needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, opt[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, opt, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) {
        res = `${namespace}${nsSeparator}${key}`;
      }
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}${nsSeparator}${key}` : key, usedDefault ? res : void 0, opt);
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(opt);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, opt, resolved, lastKey) {
    if (this.i18nFormat?.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...opt
      }, opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!opt.skipInterpolation) {
      if (opt.interpolation) this.interpolator.init({
        ...opt,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...opt.interpolation
          }
        }
      });
      const skipOnVariables = isString$1(res) && (opt?.interpolation?.skipOnVariables !== void 0 ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = opt.replace && !isString$1(opt.replace) ? opt.replace : opt;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) opt.nest = false;
      }
      if (!opt.lng && resolved && resolved.res) opt.lng = this.language || resolved.usedLng;
      if (opt.nest !== false) res = this.interpolator.nest(res, (...args) => {
        if (lastKey?.[0] === args[0] && !opt.context) {
          this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return this.translate(...args, key);
      }, opt);
      if (opt.interpolation) this.interpolator.reset();
    }
    const postProcess = opt.postProcess || this.options.postProcess;
    const postProcessorNames = isString$1(postProcess) ? [postProcess] : postProcess;
    if (res != null && postProcessorNames?.length && opt.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(opt)
        },
        ...opt
      } : opt, this);
    }
    return res;
  }
  resolve(keys, opt = {}) {
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString$1(keys)) keys = [keys];
    keys.forEach((k2) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k2, opt);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = opt.count !== void 0 && !isString$1(opt.count);
      const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
      const needsContextHandling = opt.context !== void 0 && (isString$1(opt.context) || typeof opt.context === "number") && opt.context !== "";
      const codes = opt.lngs ? opt.lngs : this.languageUtils.toResolveHierarchy(opt.lng || this.language, opt.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat?.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, opt);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, opt.count, opt);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              finalKeys.push(key + pluralSuffix);
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator || "_"}${opt.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                finalKeys.push(contextKey + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, opt);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key, options = {}) {
    if (this.i18nFormat?.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails(options = {}) {
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && !isString$1(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix2 = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix2 === option.substring(0, prefix2.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
}
class LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p2 = code.split("-");
    if (p2.length === 2) return null;
    p2.pop();
    if (p2[p2.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p2.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p2 = code.split("-");
    return this.formatLanguageCode(p2[0]);
  }
  formatLanguageCode(code) {
    if (isString$1(code) && code.indexOf("-") > -1) {
      let formattedCode;
      try {
        formattedCode = Intl.getCanonicalLocales(code)[0];
      } catch (e3) {
      }
      if (formattedCode && this.options.lowerCaseLng) {
        formattedCode = formattedCode.toLowerCase();
      }
      if (formattedCode) return formattedCode;
      if (this.options.lowerCaseLng) {
        return code.toLowerCase();
      }
      return code;
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngScOnly = this.getScriptPartFromCode(code);
        if (this.isSupportedCode(lngScOnly)) return found = lngScOnly;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (isString$1(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes((fallbackCode === false ? [] : fallbackCode) || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c2) => {
      if (!c2) return;
      if (this.isSupportedCode(c2)) {
        codes.push(c2);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c2}`);
      }
    };
    if (isString$1(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (isString$1(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
}
const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
const dummyRule = {
  select: (count) => count === 1 ? "one" : "other",
  resolvedOptions: () => ({
    pluralCategories: ["one", "other"]
  })
};
class PluralResolver {
  constructor(languageUtils, options = {}) {
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code, options = {}) {
    const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
    const type = options.ordinal ? "ordinal" : "cardinal";
    const cacheKey = JSON.stringify({
      cleanedCode,
      type
    });
    if (cacheKey in this.pluralRulesCache) {
      return this.pluralRulesCache[cacheKey];
    }
    let rule;
    try {
      rule = new Intl.PluralRules(cleanedCode, {
        type
      });
    } catch (err) {
      if (!Intl) {
        this.logger.error("No Intl support, please use an Intl polyfill!");
        return dummyRule;
      }
      if (!code.match(/-|_/)) return dummyRule;
      const lngPart = this.languageUtils.getLanguagePartFromCode(code);
      rule = this.getRule(lngPart, options);
    }
    this.pluralRulesCache[cacheKey] = rule;
    return rule;
  }
  needsPlural(code, options = {}) {
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule("dev", options);
    return rule?.resolvedOptions().pluralCategories.length > 1;
  }
  getPluralFormsOfKey(code, key, options = {}) {
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code, options = {}) {
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule("dev", options);
    if (!rule) return [];
    return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
  }
  getSuffix(code, count, options = {}) {
    const rule = this.getRule(code, options);
    if (rule) {
      return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return this.getSuffix("dev", count, options);
  }
}
const deepFindWithDefaults = (data, defaultData, key, keySeparator = ".", ignoreJSONStructure = true) => {
  let path2 = getPathWithDefaults(data, defaultData, key);
  if (!path2 && ignoreJSONStructure && isString$1(key)) {
    path2 = deepFind(data, key, keySeparator);
    if (path2 === void 0) path2 = deepFind(defaultData, key, keySeparator);
  }
  return path2;
};
const regexSafe = (val) => val.replace(/\$/g, "$$$$");
class Interpolator {
  constructor(options = {}) {
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options?.interpolation?.format || ((value) => value);
    this.init(options);
  }
  init(options = {}) {
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix: prefix2,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== void 0 ? escape$1 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix2 ? regexEscape(prefix2) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp?.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path2 = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path2, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path2;
      }
      const p2 = key.split(this.formatSeparator);
      const k2 = p2.shift().trim();
      const f2 = p2.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k2, this.options.keySeparator, this.options.ignoreJSONStructure), f2, lng, {
        ...options,
        ...data,
        interpolationkey: k2
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options?.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options?.interpolation?.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value = isString$1(temp) ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (!isString$1(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc, options = {}) {
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c2 = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c2[1]}`;
      key = c2[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e3) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e3);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString$1(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      const keyEndIndex = /{.*}/.test(match[1]) ? match[1].lastIndexOf("}") + 1 : match[1].indexOf(this.formatSeparator);
      if (keyEndIndex !== -1) {
        formatters = match[1].slice(keyEndIndex).split(this.formatSeparator).map((elem) => elem.trim()).filter(Boolean);
        match[1] = match[1].slice(0, keyEndIndex);
      }
      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && !isString$1(value)) return value;
      if (!isString$1(value)) value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = "";
      }
      if (formatters.length) {
        value = formatters.reduce((v2, f2) => this.format(v2, f2, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
}
const parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    const optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
const createCachedFormatter = (fn) => {
  const cache = {};
  return (v2, l2, o2) => {
    let optForCache = o2;
    if (o2 && o2.interpolationkey && o2.formatParams && o2.formatParams[o2.interpolationkey] && o2[o2.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [o2.interpolationkey]: void 0
      };
    }
    const key = l2 + JSON.stringify(optForCache);
    let frm = cache[key];
    if (!frm) {
      frm = fn(getCleanedCode(l2), o2);
      cache[key] = frm;
    }
    return frm(v2);
  };
};
const createNonCachedFormatter = (fn) => (v2, l2, o2) => fn(getCleanedCode(l2), o2)(v2);
class Formatter {
  constructor(options = {}) {
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.init(options);
  }
  init(services, options = {
    interpolation: {}
  }) {
    this.formatSeparator = options.interpolation.formatSeparator || ",";
    const cf = options.cacheInBuiltFormats ? createCachedFormatter : createNonCachedFormatter;
    this.formats = {
      number: cf((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: cf((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: cf((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: cf((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: cf((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format2, lng, options = {}) {
    const formats = format2.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f2) => f2.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f2) => f2.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f2) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f2);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options?.formatParams?.[options.interpolationkey] || {};
          const l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l2, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
}
const removePending = (q2, name) => {
  if (q2.pending[name] !== void 0) {
    delete q2.pending[name];
    q2.pendingCount--;
  }
};
let Connector$1 = class Connector extends EventEmitter$1 {
  constructor(backend, store, services, options = {}) {
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    this.backend?.init?.(services, options.backend, options);
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0) ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0) pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0) pending[name] = true;
          if (toLoad[name] === void 0) toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s2 = name.split("|");
    const lng = s2[0];
    const ns = s2[1];
    if (err) this.emit("failedLoading", lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    if (err && data) this.state[name] = 0;
    const loaded = {};
    this.queue.forEach((q2) => {
      pushPath(q2.loaded, [lng], ns);
      removePending(q2, name);
      if (err) q2.errors.push(err);
      if (q2.pendingCount === 0 && !q2.done) {
        Object.keys(q2.loaded).forEach((l2) => {
          if (!loaded[l2]) loaded[l2] = {};
          const loadedKeys = q2.loaded[l2];
          if (loadedKeys.length) {
            loadedKeys.forEach((n2) => {
              if (loaded[l2][n2] === void 0) loaded[l2][n2] = true;
            });
          }
        });
        q2.done = true;
        if (q2.errors.length) {
          q2.callback(q2.errors);
        } else {
          q2.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q2) => !q2.done);
  }
  read(lng, ns, fcName, tried = 0, wait = this.retryTimeout, callback) {
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r2 = fc(lng, ns);
        if (r2 && typeof r2.then === "function") {
          r2.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r2);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces, options = {}, callback) {
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString$1(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString$1(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name, prefix2 = "") {
    const s2 = name.split("|");
    const lng = s2[0];
    const ns = s2[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn(`${prefix2}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix2}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate, options = {}, clb = () => {
  }) {
    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend?.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r2;
          if (fc.length === 5) {
            r2 = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r2 = fc(languages, namespace, key, fallbackValue);
          }
          if (r2 && typeof r2.then === "function") {
            r2.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r2);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
};
const get$3 = () => ({
  debug: false,
  initAsync: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString$1(args[1])) ret.defaultValue = args[1];
    if (isString$1(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value) => value,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  },
  cacheInBuiltFormats: true
});
const transformOptions = (options) => {
  if (isString$1(options.ns)) options.ns = [options.ns];
  if (isString$1(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString$1(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs?.indexOf?.("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  if (typeof options.initImmediate === "boolean") options.initAsync = options.initImmediate;
  return options;
};
const noop$6 = () => {
};
const bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
class I18n extends EventEmitter$1 {
  constructor(options = {}, callback) {
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initAsync) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init(options = {}, callback) {
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (options.defaultNS == null && options.ns) {
      if (isString$1(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get$3();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    this.options.interpolation = {
      ...defOpts.interpolation,
      ...this.options.interpolation
    };
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s2 = this.services;
      s2.logger = baseLogger;
      s2.resourceStore = this.store;
      s2.languageUtils = lu;
      s2.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      const usingLegacyFormatFunction = this.options.interpolation.format && this.options.interpolation.format !== defOpts.interpolation.format;
      if (usingLegacyFormatFunction) {
        this.logger.deprecate(`init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting`);
      }
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s2.formatter = createClassOnDemand(formatter);
        if (s2.formatter.init) s2.formatter.init(s2, this.options);
        this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
      }
      s2.interpolator = new Interpolator(this.options);
      s2.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s2.backendConnector = new Connector$1(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
      s2.backendConnector.on("*", (event, ...args) => {
        this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s2.languageDetector.init) s2.languageDetector.init(s2, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s2.i18nFormat.init) s2.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", (event, ...args) => {
        this.emit(event, ...args);
      });
      this.modules.external.forEach((m2) => {
        if (m2.init) m2.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop$6;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = (...args) => this.store[fcName](...args);
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = (...args) => {
        this.store[fcName](...args);
        return this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initAsync) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language, callback = noop$6) {
    let usedCallback = callback;
    const usedLng = isString$1(language) ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng?.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append2 = (lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l2) => {
          if (l2 === "cimode") return;
          if (toLoad.indexOf(l2) < 0) toLoad.push(l2);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l2) => append2(l2));
      } else {
        append2(usedLng);
      }
      this.options.preload?.forEach?.((l2) => append2(l2));
      this.services.backendConnector.load(toLoad, this.options.ns, (e3) => {
        if (!e3 && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e3);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop$6;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l2) {
    if (!l2 || !this.languages) return;
    if (["cimode", "dev"].indexOf(l2) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
    if (!this.resolvedLanguage && this.languages.indexOf(l2) < 0 && this.store.hasLanguageSomeTranslations(l2)) {
      this.resolvedLanguage = l2;
      this.languages.unshift(l2);
    }
  }
  changeLanguage(lng, callback) {
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l2) => {
      this.language = l2;
      this.languages = this.services.languageUtils.toResolveHierarchy(l2);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l2);
    };
    const done = (err, l2) => {
      if (l2) {
        if (this.isLanguageChangingTo === lng) {
          setLngProps(l2);
          this.translator.changeLanguage(l2);
          this.isLanguageChangingTo = void 0;
          this.emit("languageChanged", l2);
          this.logger.log("languageChanged", l2);
        }
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve((...args) => this.t(...args));
      if (callback) callback(err, (...args) => this.t(...args));
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const fl = isString$1(lngs) ? lngs : lngs && lngs[0];
      const l2 = this.store.hasLanguageSomeTranslations(fl) ? fl : this.services.languageUtils.getBestMatchFromCodes(isString$1(lngs) ? [lngs] : lngs);
      if (l2) {
        if (!this.language) {
          setLngProps(l2);
        }
        if (!this.translator.language) this.translator.changeLanguage(l2);
        this.services.languageDetector?.cacheUserLanguage?.(l2);
      }
      this.loadResources(l2, (err) => {
        done(err, l2);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    const fixedT = (key, opts, ...rest) => {
      let o2;
      if (typeof opts !== "object") {
        o2 = this.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        o2 = {
          ...opts
        };
      }
      o2.lng = o2.lng || fixedT.lng;
      o2.lngs = o2.lngs || fixedT.lngs;
      o2.ns = o2.ns || fixedT.ns;
      if (o2.keyPrefix !== "") o2.keyPrefix = o2.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = this.options.keySeparator || ".";
      let resultKey;
      if (o2.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k2) => {
          if (typeof k2 === "function") k2 = keysFromSelector(k2, {
            ...this.options,
            ...opts
          });
          return `${o2.keyPrefix}${keySeparator}${k2}`;
        });
      } else {
        if (typeof key === "function") key = keysFromSelector(key, {
          ...this.options,
          ...opts
        });
        resultKey = o2.keyPrefix ? `${o2.keyPrefix}${keySeparator}${key}` : key;
      }
      return this.t(resultKey, o2);
    };
    if (isString$1(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t(...args) {
    return this.translator?.translate(...args);
  }
  exists(...args) {
    return this.translator?.exists(...args);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns, options = {}) {
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = (l2, n2) => {
      const loadState = this.services.backendConnector.state[`${l2}|${n2}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString$1(ns)) ns = [ns];
    ns.forEach((n2) => {
      if (this.options.ns.indexOf(n2) < 0) this.options.ns.push(n2);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString$1(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    try {
      const l2 = new Intl.Locale(lng);
      if (l2 && l2.getTextInfo) {
        const ti = l2.getTextInfo();
        if (ti && ti.direction) return ti.direction;
      }
    } catch (e3) {
    }
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services?.languageUtils || new LanguageUtil(get$3());
    if (lng.toLowerCase().indexOf("-latn") > 1) return "ltr";
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance(options = {}, callback) {
    return new I18n(options, callback);
  }
  cloneInstance(options = {}, callback = noop$6) {
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone2 = new I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone2.logger = clone2.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m2) => {
      clone2[m2] = this[m2];
    });
    clone2.services = {
      ...this.services
    };
    clone2.services.utils = {
      hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
    };
    if (forkResourceStore) {
      const clonedData = Object.keys(this.store.data).reduce((prev, l2) => {
        prev[l2] = {
          ...this.store.data[l2]
        };
        prev[l2] = Object.keys(prev[l2]).reduce((acc, n2) => {
          acc[n2] = {
            ...prev[l2][n2]
          };
          return acc;
        }, prev[l2]);
        return prev;
      }, {});
      clone2.store = new ResourceStore(clonedData, mergedOptions);
      clone2.services.resourceStore = clone2.store;
    }
    clone2.translator = new Translator(clone2.services, mergedOptions);
    clone2.translator.on("*", (event, ...args) => {
      clone2.emit(event, ...args);
    });
    clone2.init(mergedOptions, callback);
    clone2.translator.options = mergedOptions;
    clone2.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
    };
    return clone2;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const warn$1 = (i18n, code, msg, rest) => {
  const args = [msg, {
    code,
    ...rest || {}
  }];
  if (i18n?.services?.logger?.forward) {
    return i18n.services.logger.forward(args, "warn", "react-i18next::", true);
  }
  if (isString(args[0])) args[0] = `react-i18next:: ${args[0]}`;
  if (i18n?.services?.logger?.warn) {
    i18n.services.logger.warn(...args);
  } else if (console?.warn) {
    console.warn(...args);
  }
};
const alreadyWarned = {};
const warnOnce = (i18n, code, msg, rest) => {
  if (isString(msg) && alreadyWarned[msg]) return;
  if (isString(msg)) alreadyWarned[msg] = /* @__PURE__ */ new Date();
  warn$1(i18n, code, msg, rest);
};
const loadedClb = (i18n, cb) => () => {
  if (i18n.isInitialized) {
    cb();
  } else {
    const initialized = () => {
      setTimeout(() => {
        i18n.off("initialized", initialized);
      }, 0);
      cb();
    };
    i18n.on("initialized", initialized);
  }
};
const loadNamespaces = (i18n, ns, cb) => {
  i18n.loadNamespaces(ns, loadedClb(i18n, cb));
};
const loadLanguages = (i18n, lng, ns, cb) => {
  if (isString(ns)) ns = [ns];
  if (i18n.options.preload && i18n.options.preload.indexOf(lng) > -1) return loadNamespaces(i18n, ns, cb);
  ns.forEach((n2) => {
    if (i18n.options.ns.indexOf(n2) < 0) i18n.options.ns.push(n2);
  });
  i18n.loadLanguages(lng, loadedClb(i18n, cb));
};
const hasLoadedNamespace = (ns, i18n, options = {}) => {
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce(i18n, "NO_LANGUAGES", "i18n.languages were undefined or empty", {
      languages: i18n.languages
    });
    return true;
  }
  return i18n.hasLoadedNamespace(ns, {
    lng: options.lng,
    precheck: (i18nInstance2, loadNotPending) => {
      if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns)) return false;
    }
  });
};
const isString = (obj) => typeof obj === "string";
const isObject$1 = (obj) => typeof obj === "object" && obj !== null;
const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
const htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "",
  "&#169;": "",
  "&reg;": "",
  "&#174;": "",
  "&hellip;": "",
  "&#8230;": "",
  "&#x2F;": "/",
  "&#47;": "/"
};
const unescapeHtmlEntity = (m2) => htmlEntities[m2];
const unescape$1 = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);
let defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape: unescape$1
};
const setDefaults = (options = {}) => {
  defaultOptions = {
    ...defaultOptions,
    ...options
  };
};
const getDefaults$1 = () => defaultOptions;
let i18nInstance;
const setI18n = (instance2) => {
  i18nInstance = instance2;
};
const getI18n = () => i18nInstance;
const initReactI18next = {
  type: "3rdParty",
  init(instance2) {
    setDefaults(instance2.options.react);
    setI18n(instance2);
  }
};
const I18nContext = reactExports.createContext();
class ReportNamespaces {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(namespaces) {
    namespaces.forEach((ns) => {
      if (!this.usedNamespaces[ns]) this.usedNamespaces[ns] = true;
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
}
var shim = { exports: {} };
var useSyncExternalStoreShim_production = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_production;
function requireUseSyncExternalStoreShim_production() {
  if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
  hasRequiredUseSyncExternalStoreShim_production = 1;
  var React2 = requireReact();
  function is2(x2, y2) {
    return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is2, useState = React2.useState, useEffect = React2.useEffect, useLayoutEffect = React2.useLayoutEffect, useDebugValue = React2.useDebugValue;
  function useSyncExternalStore$2(subscribe, getSnapshot) {
    var value = getSnapshot(), _useState = useState({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
    useLayoutEffect(
      function() {
        inst.value = value;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      },
      [subscribe, value, getSnapshot]
    );
    useEffect(
      function() {
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        });
      },
      [subscribe]
    );
    useDebugValue(value);
    return value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch (error) {
      return true;
    }
  }
  function useSyncExternalStore$1(subscribe, getSnapshot) {
    return getSnapshot();
  }
  var shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
  useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React2.useSyncExternalStore ? React2.useSyncExternalStore : shim2;
  return useSyncExternalStoreShim_production;
}
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim.exports;
  hasRequiredShim = 1;
  {
    shim.exports = requireUseSyncExternalStoreShim_production();
  }
  return shim.exports;
}
var shimExports = requireShim();
const notReadyT = (k2, optsOrDefaultValue) => {
  if (isString(optsOrDefaultValue)) return optsOrDefaultValue;
  if (isObject$1(optsOrDefaultValue) && isString(optsOrDefaultValue.defaultValue)) return optsOrDefaultValue.defaultValue;
  return Array.isArray(k2) ? k2[k2.length - 1] : k2;
};
const notReadySnapshot = {
  t: notReadyT,
  ready: false
};
const dummySubscribe = () => () => {
};
const useTranslation = (ns, props = {}) => {
  const {
    i18n: i18nFromProps
  } = props;
  const {
    i18n: i18nFromContext,
    defaultNS: defaultNSFromContext
  } = reactExports.useContext(I18nContext) || {};
  const i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce(i18n, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next");
  }
  const i18nOptions = reactExports.useMemo(() => ({
    ...getDefaults$1(),
    ...i18n?.options?.react,
    ...props
  }), [i18n, props]);
  const {
    useSuspense,
    keyPrefix
  } = i18nOptions;
  const namespaces = reactExports.useMemo(() => {
    const nsOrContext = defaultNSFromContext || i18n?.options?.defaultNS;
    return isString(nsOrContext) ? [nsOrContext] : nsOrContext || ["translation"];
  }, [ns, defaultNSFromContext, i18n]);
  i18n?.reportNamespaces?.addUsedNamespaces?.(namespaces);
  const revisionRef = reactExports.useRef(0);
  const subscribe = reactExports.useCallback((callback) => {
    if (!i18n) return dummySubscribe;
    const {
      bindI18n,
      bindI18nStore
    } = i18nOptions;
    const wrappedCallback = () => {
      revisionRef.current += 1;
      callback();
    };
    if (bindI18n) i18n.on(bindI18n, wrappedCallback);
    if (bindI18nStore) i18n.store.on(bindI18nStore, wrappedCallback);
    return () => {
      if (bindI18n) bindI18n.split(" ").forEach((e3) => i18n.off(e3, wrappedCallback));
      if (bindI18nStore) bindI18nStore.split(" ").forEach((e3) => i18n.store.off(e3, wrappedCallback));
    };
  }, [i18n, i18nOptions]);
  const snapshotRef = reactExports.useRef();
  const getSnapshot = reactExports.useCallback(() => {
    if (!i18n) {
      return notReadySnapshot;
    }
    const calculatedReady = !!(i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n2) => hasLoadedNamespace(n2, i18n, i18nOptions));
    const currentLng = props.lng || i18n.language;
    const currentRevision = revisionRef.current;
    const lastSnapshot = snapshotRef.current;
    if (lastSnapshot && lastSnapshot.ready === calculatedReady && lastSnapshot.lng === currentLng && lastSnapshot.keyPrefix === keyPrefix && lastSnapshot.revision === currentRevision) {
      return lastSnapshot;
    }
    const calculatedT = i18n.getFixedT(currentLng, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
    const newSnapshot = {
      t: calculatedT,
      ready: calculatedReady,
      lng: currentLng,
      keyPrefix,
      revision: currentRevision
    };
    snapshotRef.current = newSnapshot;
    return newSnapshot;
  }, [i18n, namespaces, keyPrefix, i18nOptions, props.lng]);
  const [loadCount, setLoadCount] = reactExports.useState(0);
  const {
    t: t2,
    ready
  } = shimExports.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
  reactExports.useEffect(() => {
    if (i18n && !ready && !useSuspense) {
      const onLoaded = () => setLoadCount((c2) => c2 + 1);
      if (props.lng) {
        loadLanguages(i18n, props.lng, namespaces, onLoaded);
      } else {
        loadNamespaces(i18n, namespaces, onLoaded);
      }
    }
  }, [i18n, props.lng, namespaces, ready, useSuspense, loadCount]);
  const finalI18n = i18n || {};
  const ret = reactExports.useMemo(() => {
    const arr = [t2, finalI18n, ready];
    arr.t = t2;
    arr.i18n = finalI18n;
    arr.ready = ready;
    return arr;
  }, [t2, finalI18n, ready]);
  if (i18n && useSuspense && !ready) {
    throw new Promise((resolve) => {
      const onLoaded = () => resolve();
      if (props.lng) {
        loadLanguages(i18n, props.lng, namespaces, onLoaded);
      } else {
        loadNamespaces(i18n, namespaces, onLoaded);
      }
    });
  }
  return ret;
};
const IndianFlag = ({ size = "medium", interactive = false }) => {
  const [isWaving, setIsWaving] = reactExports.useState(false);
  const [isHovered, setIsHovered] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const timer = setTimeout(() => {
      setIsWaving(true);
    }, 500);
    return () => clearTimeout(timer);
  }, []);
  const getSizeClasses = () => {
    switch (size) {
      case "small":
        return "w-12 h-8";
      case "large":
        return "w-20 h-12";
      default:
        return "w-16 h-10";
    }
  };
  const handleFlagClick = () => {
    if (interactive) {
      setIsWaving(!isWaving);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `relative overflow-hidden rounded ${getSizeClasses()} ${isWaving ? "animate-flag-wave" : ""} ${isHovered ? "scale-110" : ""} transition-transform duration-300 cursor-pointer`,
        onClick: handleFlagClick,
        onMouseEnter: () => interactive && setIsHovered(true),
        onMouseLeave: () => interactive && setIsHovered(false),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-0 left-0 w-full h-1/3 bg-[#FF9933]" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-1/3 left-0 w-full h-1/3 bg-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-4 h-4 rounded-full border-2 border-[#000080]", children: [...Array(24)].map((_2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "absolute top-1/2 left-1/2 w-2 h-0.5 bg-[#000080]",
              style: {
                transform: `translate(-50%, -50%) rotate(${i2 * 15}deg)`,
                transformOrigin: "center"
              }
            },
            i2
          )) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-0 left-0 w-full h-1/3 bg-[#138808]" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("style", { jsx: true, children: `
        @keyframes flag-wave {
          0% { transform: rotate(0deg); }
          25% { transform: rotate(2deg); }
          50% { transform: rotate(0deg); }
          75% { transform: rotate(-2deg); }
          100% { transform: rotate(0deg); }
        }
        
        .animate-flag-wave {
          animation: flag-wave 2s ease-in-out infinite;
        }
      ` })
  ] });
};
const ReadingAssistance = ({ isOpen, onClose }) => {
  const { t: t2 } = useTranslation();
  const [readingMode, setReadingMode] = reactExports.useState(false);
  const [textToSpeech, setTextToSpeech] = reactExports.useState(false);
  const [speechRate, setSpeechRate] = reactExports.useState(1);
  const [isSpeaking, setIsSpeaking] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const savedReadingMode = localStorage.getItem("readingMode") === "true";
    const savedTextToSpeech = localStorage.getItem("textToSpeech") === "true";
    const savedSpeechRate = localStorage.getItem("speechRate") || "1";
    setReadingMode(savedReadingMode);
    setTextToSpeech(savedTextToSpeech);
    setSpeechRate(parseFloat(savedSpeechRate));
    if (savedReadingMode) {
      document.documentElement.classList.add("reading-mode");
    }
  }, []);
  const toggleReadingMode = () => {
    const newReadingMode = !readingMode;
    setReadingMode(newReadingMode);
    localStorage.setItem("readingMode", newReadingMode.toString());
    if (newReadingMode) {
      document.documentElement.classList.add("reading-mode");
    } else {
      document.documentElement.classList.remove("reading-mode");
    }
  };
  const toggleTextToSpeech = () => {
    const newTTS = !textToSpeech;
    setTextToSpeech(newTTS);
    localStorage.setItem("textToSpeech", newTTS.toString());
  };
  const changeSpeechRate = (rate) => {
    setSpeechRate(rate);
    localStorage.setItem("speechRate", rate.toString());
  };
  const speakText = (text) => {
    if ("speechSynthesis" in window) {
      window.speechSynthesis.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = speechRate;
      utterance.onstart = () => setIsSpeaking(true);
      utterance.onend = () => setIsSpeaking(false);
      utterance.onerror = () => setIsSpeaking(false);
      window.speechSynthesis.speak(utterance);
    }
  };
  const stopSpeaking = () => {
    if ("speechSynthesis" in window) {
      window.speechSynthesis.cancel();
      setIsSpeaking(false);
    }
  };
  reactExports.useEffect(() => {
    if (!textToSpeech) return;
    const handleSelection = () => {
      const selection = window.getSelection();
      if (selection && selection.toString().trim()) {
        const selectedText = selection.toString().trim();
        speakText(selectedText);
      }
    };
    document.addEventListener("mouseup", handleSelection);
    return () => document.removeEventListener("mouseup", handleSelection);
  }, [textToSpeech, speechRate]);
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white dark:bg-gray-800 rounded-2xl shadow-xl max-w-md w-full max-h-[90vh] overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white", children: t2("accessibility.reading_assistance") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: onClose,
          className: "text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200",
          "aria-label": t2("navigation.close"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M6 18L18 6M6 6l12 12" }) })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-gray-800 dark:text-white", children: t2("accessibility.reading_mode") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 dark:text-gray-300", children: t2("accessibility.reading_mode_desc") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: toggleReadingMode,
            className: `relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${readingMode ? "bg-blue-600" : "bg-gray-300 dark:bg-gray-600"}`,
            "aria-pressed": readingMode,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: `inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${readingMode ? "translate-x-6" : "translate-x-1"}`
              }
            )
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-gray-800 dark:text-white", children: t2("accessibility.text_to_speech") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 dark:text-gray-300", children: t2("accessibility.text_to_speech_desc") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: toggleTextToSpeech,
            className: `relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${textToSpeech ? "bg-blue-600" : "bg-gray-300 dark:bg-gray-600"}`,
            "aria-pressed": textToSpeech,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: `inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${textToSpeech ? "translate-x-6" : "translate-x-1"}`
              }
            )
          }
        )
      ] }),
      textToSpeech && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-gray-800 dark:text-white mb-3", children: t2("accessibility.speech_rate") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => changeSpeechRate(0.75),
              className: `px-3 py-1 rounded-lg ${speechRate === 0.75 ? "bg-blue-600 text-white" : "bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200"}`,
              children: "0.75x"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => changeSpeechRate(1),
              className: `px-3 py-1 rounded-lg ${speechRate === 1 ? "bg-blue-600 text-white" : "bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200"}`,
              children: "1x"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => changeSpeechRate(1.25),
              className: `px-3 py-1 rounded-lg ${speechRate === 1.25 ? "bg-blue-600 text-white" : "bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200"}`,
              children: "1.25x"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => changeSpeechRate(1.5),
              className: `px-3 py-1 rounded-lg ${speechRate === 1.5 ? "bg-blue-600 text-white" : "bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200"}`,
              children: "1.5x"
            }
          )
        ] })
      ] }),
      textToSpeech && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex space-x-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: stopSpeaking,
          disabled: !isSpeaking,
          className: `flex-1 py-2 px-4 rounded-lg font-medium ${isSpeaking ? "bg-red-600 hover:bg-red-700 text-white" : "bg-gray-200 dark:bg-gray-700 text-gray-500 dark:text-gray-400 cursor-not-allowed"}`,
          children: t2("accessibility.stop_speaking")
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 dark:bg-blue-900 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold text-blue-800 dark:text-blue-200 mb-2", children: t2("accessibility.how_to_use") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-blue-700 dark:text-blue-300", children: t2("accessibility.tts_instructions") })
      ] })
    ] })
  ] }) }) });
};
const ThemeSwitcher = () => {
  const [theme, setTheme] = reactExports.useState("light");
  reactExports.useEffect(() => {
    const savedTheme = localStorage.getItem("theme") || "light";
    setTheme(savedTheme);
    document.documentElement.classList.toggle("dark", savedTheme === "dark");
  }, []);
  const toggleTheme = () => {
    const newTheme = theme === "light" ? "dark" : "light";
    setTheme(newTheme);
    localStorage.setItem("theme", newTheme);
    document.documentElement.classList.toggle("dark", newTheme === "dark");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      onClick: toggleTheme,
      className: "p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors",
      "aria-label": "Toggle theme",
      children: theme === "light" ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" }) })
    }
  );
};
const Navigation = ({
  darkMode,
  toggleDarkMode,
  increaseFontSize,
  decreaseFontSize,
  highContrast,
  toggleHighContrast,
  changeLanguage
}) => {
  const { t: t2, i18n } = useTranslation();
  const location = useLocation();
  const [isMenuOpen, setIsMenuOpen] = reactExports.useState(false);
  const [isAccessibilityOpen, setIsAccessibilityOpen] = reactExports.useState(false);
  const [isLanguageOpen, setIsLanguageOpen] = reactExports.useState(false);
  const [isReadingAssistanceOpen, setIsReadingAssistanceOpen] = reactExports.useState(false);
  const [isSearchOpen, setIsSearchOpen] = reactExports.useState(false);
  const [searchQuery, setSearchQuery] = reactExports.useState("");
  const [skipLinkFocused, setSkipLinkFocused] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const handleKeyDown = (e3) => {
      if (e3.key === "Escape") {
        setIsMenuOpen(false);
        setIsAccessibilityOpen(false);
        setIsLanguageOpen(false);
        setIsReadingAssistanceOpen(false);
        setIsSearchOpen(false);
      }
      if (e3.key === "Tab" && e3.target === document.body) {
        setSkipLinkFocused(true);
      }
    };
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, []);
  const handleSearch = (e3) => {
    e3.preventDefault();
    if (searchQuery.trim()) {
      console.log("Searching for:", searchQuery);
      setIsSearchOpen(false);
      setSearchQuery("");
    }
  };
  const skipToMainContent = () => {
    const mainContent = document.querySelector("main") || document.getElementById("main-content");
    if (mainContent) {
      const originalTabindex = mainContent.getAttribute("tabindex");
      mainContent.setAttribute("tabindex", "-1");
      mainContent.focus();
      mainContent.scrollIntoView({ behavior: "smooth", block: "start" });
      setTimeout(() => {
        if (originalTabindex !== null) {
          mainContent.setAttribute("tabindex", originalTabindex);
        } else {
          mainContent.removeAttribute("tabindex");
        }
        setSkipLinkFocused(false);
      }, 100);
    }
  };
  const navItems = [
    { path: "/", label: t2("common.home") },
    { path: "/campaigns", label: t2("common.campaigns") },
    { path: "/donate", label: t2("common.donate") },
    { path: "/ngo", label: t2("common.ngoDashboard") },
    { path: "/admin", label: t2("common.adminDashboard") },
    { path: "/ivr", label: t2("common.ivrSystem") },
    { path: "/stats", label: t2("common.statistics") },
    { path: "/prediction", label: t2("common.prediction") }
    // Added Prediction link
  ];
  const languages = [
    { code: "en", name: t2("common.english") },
    { code: "hi", name: t2("common.hindi") },
    { code: "ta", name: t2("common.tamil") },
    { code: "te", name: t2("common.telugu") },
    { code: "mr", name: t2("common.marathi") },
    { code: "bn", name: t2("common.bengali") },
    { code: "gu", name: t2("common.gujarati") }
  ];
  const currentLanguage = i18n.language;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "bg-gradient-to-r from-blue-700 to-indigo-800 text-white shadow-lg sticky top-0 z-50", role: "navigation", "aria-label": "Main navigation", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "a",
      {
        href: "#main-content",
        className: `sr-only focus:not-sr-only focus:absolute focus:p-4 focus:bg-white focus:text-blue-700 focus:z-50 focus:rounded-lg focus:shadow-lg ${skipLinkFocused ? "block" : ""}`,
        onClick: (e3) => {
          e3.preventDefault();
          skipToMainContent();
        },
        children: t2("accessibility.skip_to_main_content")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center h-16", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: "/", className: "text-2xl font-bold flex items-center", "aria-label": "ImpactX Home", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-white text-blue-700 rounded-full w-8 h-8 flex items-center justify-center mr-2", children: "" }),
          t2("common.app_name"),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IndianFlag, {}) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hidden md:flex items-center space-x-1", children: [
          navItems.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Link,
            {
              to: item.path,
              className: `px-4 py-2 rounded-lg text-sm font-medium transition-all duration-300 ${location.pathname === item.path ? "bg-white text-blue-700 shadow-md" : "text-blue-100 hover:bg-blue-600 hover:text-white"}`,
              "aria-current": location.pathname === item.path ? "page" : void 0,
              children: item.label
            },
            item.path
          )),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative mx-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSearch, className: "flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: searchQuery,
                onChange: (e3) => setSearchQuery(e3.target.value),
                placeholder: t2("common.search"),
                className: "px-3 py-1 rounded-l-lg text-gray-700 text-sm focus:outline-none w-32 focus:w-48 transition-all duration-300",
                "aria-label": t2("common.search")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "submit",
                className: "bg-blue-500 hover:bg-blue-600 px-3 py-1 rounded-r-lg text-white",
                "aria-label": t2("common.search"),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" }) })
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: () => {
                  setIsLanguageOpen(!isLanguageOpen);
                  setIsAccessibilityOpen(false);
                },
                className: "p-2 rounded-full ml-2 flex items-center text-sm",
                "aria-label": t2("common.language"),
                "aria-expanded": isLanguageOpen,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 mr-1", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129" }) }),
                  languages.find((lang) => lang.code === currentLanguage)?.name || "EN"
                ]
              }
            ),
            isLanguageOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-xl py-2 z-50", role: "menu", children: languages.map((lang) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => {
                  changeLanguage(lang.code);
                  setIsLanguageOpen(false);
                },
                className: `block w-full text-left px-4 py-2 text-sm ${currentLanguage === lang.code ? "bg-blue-100 text-blue-700" : "text-gray-700 hover:bg-gray-100"}`,
                role: "menuitem",
                children: lang.name
              },
              lang.code
            )) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => {
                  setIsAccessibilityOpen(!isAccessibilityOpen);
                  setIsLanguageOpen(false);
                },
                className: "p-2 rounded-full ml-2",
                "aria-label": t2("accessibility.accessibility_options"),
                "aria-expanded": isAccessibilityOpen,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4" }) })
              }
            ),
            isAccessibilityOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute right-0 mt-2 w-64 bg-white rounded-lg shadow-xl py-2 z-50", role: "menu", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 py-2 border-b border-gray-200", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-gray-800", children: t2("accessibility.accessibility_options") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: increaseFontSize,
                  className: "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100",
                  role: "menuitem",
                  children: t2("accessibility.increase_font_size")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: decreaseFontSize,
                  className: "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100",
                  role: "menuitem",
                  children: t2("accessibility.decrease_font_size")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: toggleHighContrast,
                  className: "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100",
                  role: "menuitem",
                  children: t2("accessibility.high_contrast")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => {
                    setIsReadingAssistanceOpen(true);
                    setIsAccessibilityOpen(false);
                  },
                  className: "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100",
                  role: "menuitem",
                  children: t2("accessibility.reading_assistance")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeSwitcher, {}) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "md:hidden flex items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => {
                setIsSearchOpen(!isSearchOpen);
                setIsMenuOpen(false);
                setIsLanguageOpen(false);
                setIsAccessibilityOpen(false);
              },
              className: "p-2 rounded-full mr-2",
              "aria-label": t2("common.search"),
              "aria-expanded": isSearchOpen,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" }) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => {
                  setIsLanguageOpen(!isLanguageOpen);
                  setIsMenuOpen(false);
                  setIsAccessibilityOpen(false);
                },
                className: "p-2 rounded-full mr-2 flex items-center text-sm",
                "aria-label": t2("common.language"),
                "aria-expanded": isLanguageOpen,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129" }) })
              }
            ),
            isLanguageOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-xl py-2 z-50", role: "menu", children: languages.map((lang) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => {
                  changeLanguage(lang.code);
                  setIsLanguageOpen(false);
                },
                className: `block w-full text-left px-4 py-2 text-sm ${currentLanguage === lang.code ? "bg-blue-100 text-blue-700" : "text-gray-700 hover:bg-gray-100"}`,
                role: "menuitem",
                children: lang.name
              },
              lang.code
            )) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => {
                setIsAccessibilityOpen(!isAccessibilityOpen);
                setIsMenuOpen(false);
                setIsLanguageOpen(false);
              },
              className: "p-2 rounded-full mr-2",
              "aria-label": t2("accessibility.accessibility_options"),
              "aria-expanded": isAccessibilityOpen,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4" }) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeSwitcher, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => {
                setIsMenuOpen(!isMenuOpen);
                setIsLanguageOpen(false);
                setIsAccessibilityOpen(false);
              },
              className: "text-white focus:outline-none p-2 rounded-lg hover:bg-blue-600 transition-colors",
              "aria-label": isMenuOpen ? t2("navigation.close") : t2("navigation.menu"),
              "aria-expanded": isMenuOpen,
              "aria-controls": "mobile-menu",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: isMenuOpen ? /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 6h16M4 12h16M4 18h16" }) })
            }
          )
        ] })
      ] }),
      isSearchOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "md:hidden mt-2 pb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSearch, className: "flex", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: searchQuery,
            onChange: (e3) => setSearchQuery(e3.target.value),
            placeholder: t2("common.search"),
            className: "flex-grow px-3 py-2 rounded-l-lg text-gray-700 text-sm focus:outline-none",
            autoFocus: true,
            "aria-label": t2("common.search")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "submit",
            className: "bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded-r-lg text-white",
            "aria-label": t2("common.search"),
            children: t2("common.search")
          }
        )
      ] }) }),
      isMenuOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "mobile-menu", className: "md:hidden bg-blue-600 rounded-lg mt-2 py-2 absolute left-4 right-4 shadow-xl", role: "menu", children: navItems.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        Link,
        {
          to: item.path,
          onClick: () => setIsMenuOpen(false),
          className: `block px-4 py-3 text-sm font-medium transition-colors ${location.pathname === item.path ? "bg-blue-700 text-white" : "text-blue-100 hover:bg-blue-500 hover:text-white"}`,
          role: "menuitem",
          "aria-current": location.pathname === item.path ? "page" : void 0,
          children: item.label
        },
        item.path
      )) }),
      isAccessibilityOpen && !isMenuOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "md:hidden bg-white rounded-lg mt-2 py-2 absolute left-4 right-4 shadow-xl z-50", role: "menu", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 py-2 border-b border-gray-200", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-gray-800", children: t2("accessibility.accessibility_options") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: increaseFontSize,
            className: "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100",
            role: "menuitem",
            children: t2("accessibility.increase_font_size")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: decreaseFontSize,
            className: "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100",
            role: "menuitem",
            children: t2("accessibility.decrease_font_size")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: toggleHighContrast,
            className: "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100",
            role: "menuitem",
            children: t2("accessibility.high_contrast")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => {
              setIsReadingAssistanceOpen(true);
              setIsAccessibilityOpen(false);
            },
            className: "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100",
            role: "menuitem",
            children: t2("accessibility.reading_assistance")
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReadingAssistance,
      {
        isOpen: isReadingAssistanceOpen,
        onClose: () => setIsReadingAssistanceOpen(false)
      }
    )
  ] });
};
function useAttribution(map2, attribution) {
  const attributionRef = reactExports.useRef(attribution);
  reactExports.useEffect(function updateAttribution() {
    if (attribution !== attributionRef.current && map2.attributionControl != null) {
      if (attributionRef.current != null) {
        map2.attributionControl.removeAttribution(attributionRef.current);
      }
      if (attribution != null) {
        map2.attributionControl.addAttribution(attribution);
      }
    }
    attributionRef.current = attribution;
  }, [
    map2,
    attribution
  ]);
}
function updateCircle(layer, props, prevProps) {
  if (props.center !== prevProps.center) {
    layer.setLatLng(props.center);
  }
  if (props.radius != null && props.radius !== prevProps.radius) {
    layer.setRadius(props.radius);
  }
}
const CONTEXT_VERSION = 1;
function createLeafletContext(map2) {
  return Object.freeze({
    __version: CONTEXT_VERSION,
    map: map2
  });
}
function extendContext(source, extra) {
  return Object.freeze({
    ...source,
    ...extra
  });
}
const LeafletContext = reactExports.createContext(null);
function useLeafletContext() {
  const context = reactExports.use(LeafletContext);
  if (context == null) {
    throw new Error("No context provided: useLeafletContext() can only be used in a descendant of <MapContainer>");
  }
  return context;
}
function createContainerComponent(useElement) {
  function ContainerComponent(props, forwardedRef) {
    const { instance: instance2, context } = useElement(props).current;
    reactExports.useImperativeHandle(forwardedRef, () => instance2);
    const { children } = props;
    return children == null ? null : /* @__PURE__ */ React.createElement(LeafletContext, {
      value: context
    }, children);
  }
  return /* @__PURE__ */ reactExports.forwardRef(ContainerComponent);
}
function createDivOverlayComponent(useElement) {
  function OverlayComponent(props, forwardedRef) {
    const [isOpen, setOpen] = reactExports.useState(false);
    const { instance: instance2 } = useElement(props, setOpen).current;
    reactExports.useImperativeHandle(forwardedRef, () => instance2);
    reactExports.useEffect(function updateOverlay() {
      if (isOpen) {
        instance2.update();
      }
    }, [
      instance2,
      isOpen,
      props.children
    ]);
    const contentNode = instance2._contentNode;
    return contentNode ? /* @__PURE__ */ reactDomExports.createPortal(props.children, contentNode) : null;
  }
  return /* @__PURE__ */ reactExports.forwardRef(OverlayComponent);
}
function createLeafComponent(useElement) {
  function LeafComponent(props, forwardedRef) {
    const { instance: instance2 } = useElement(props).current;
    reactExports.useImperativeHandle(forwardedRef, () => instance2);
    return null;
  }
  return /* @__PURE__ */ reactExports.forwardRef(LeafComponent);
}
function useEventHandlers(element, eventHandlers) {
  const eventHandlersRef = reactExports.useRef(void 0);
  reactExports.useEffect(function addEventHandlers() {
    if (eventHandlers != null) {
      element.instance.on(eventHandlers);
    }
    eventHandlersRef.current = eventHandlers;
    return function removeEventHandlers() {
      if (eventHandlersRef.current != null) {
        element.instance.off(eventHandlersRef.current);
      }
      eventHandlersRef.current = null;
    };
  }, [
    element,
    eventHandlers
  ]);
}
function withPane(props, context) {
  const pane = props.pane ?? context.pane;
  return pane ? {
    ...props,
    pane
  } : props;
}
function createDivOverlayHook(useElement, useLifecycle) {
  return function useDivOverlay(props, setOpen) {
    const context = useLeafletContext();
    const elementRef = useElement(withPane(props, context), context);
    useAttribution(context.map, props.attribution);
    useEventHandlers(elementRef.current, props.eventHandlers);
    useLifecycle(elementRef.current, context, props, setOpen);
    return elementRef;
  };
}
var leafletSrc$1 = { exports: {} };
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
var leafletSrc = leafletSrc$1.exports;
var hasRequiredLeafletSrc;
function requireLeafletSrc() {
  if (hasRequiredLeafletSrc) return leafletSrc$1.exports;
  hasRequiredLeafletSrc = 1;
  (function(module, exports) {
    (function(global, factory) {
      factory(exports);
    })(leafletSrc, (function(exports2) {
      var version2 = "1.9.4";
      function extend2(dest) {
        var i2, j2, len, src;
        for (j2 = 1, len = arguments.length; j2 < len; j2++) {
          src = arguments[j2];
          for (i2 in src) {
            dest[i2] = src[i2];
          }
        }
        return dest;
      }
      var create$2 = Object.create || /* @__PURE__ */ (function() {
        function F2() {
        }
        return function(proto) {
          F2.prototype = proto;
          return new F2();
        };
      })();
      function bind(fn, obj) {
        var slice2 = Array.prototype.slice;
        if (fn.bind) {
          return fn.bind.apply(fn, slice2.call(arguments, 1));
        }
        var args = slice2.call(arguments, 2);
        return function() {
          return fn.apply(obj, args.length ? args.concat(slice2.call(arguments)) : arguments);
        };
      }
      var lastId = 0;
      function stamp(obj) {
        if (!("_leaflet_id" in obj)) {
          obj["_leaflet_id"] = ++lastId;
        }
        return obj._leaflet_id;
      }
      function throttle2(fn, time2, context) {
        var lock, args, wrapperFn, later;
        later = function() {
          lock = false;
          if (args) {
            wrapperFn.apply(context, args);
            args = false;
          }
        };
        wrapperFn = function() {
          if (lock) {
            args = arguments;
          } else {
            fn.apply(context, arguments);
            setTimeout(later, time2);
            lock = true;
          }
        };
        return wrapperFn;
      }
      function wrapNum(x2, range2, includeMax) {
        var max2 = range2[1], min2 = range2[0], d2 = max2 - min2;
        return x2 === max2 && includeMax ? x2 : ((x2 - min2) % d2 + d2) % d2 + min2;
      }
      function falseFn() {
        return false;
      }
      function formatNum(num, precision) {
        if (precision === false) {
          return num;
        }
        var pow2 = Math.pow(10, precision === void 0 ? 6 : precision);
        return Math.round(num * pow2) / pow2;
      }
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function splitWords(str) {
        return trim(str).split(/\s+/);
      }
      function setOptions(obj, options) {
        if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
          obj.options = obj.options ? create$2(obj.options) : {};
        }
        for (var i2 in options) {
          obj.options[i2] = options[i2];
        }
        return obj.options;
      }
      function getParamString(obj, existingUrl, uppercase) {
        var params = [];
        for (var i2 in obj) {
          params.push(encodeURIComponent(uppercase ? i2.toUpperCase() : i2) + "=" + encodeURIComponent(obj[i2]));
        }
        return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
      }
      var templateRe = /\{ *([\w_ -]+) *\}/g;
      function template(str, data) {
        return str.replace(templateRe, function(str2, key) {
          var value = data[key];
          if (value === void 0) {
            throw new Error("No value provided for variable " + str2);
          } else if (typeof value === "function") {
            value = value(data);
          }
          return value;
        });
      }
      var isArray = Array.isArray || function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      function indexOf(array2, el) {
        for (var i2 = 0; i2 < array2.length; i2++) {
          if (array2[i2] === el) {
            return i2;
          }
        }
        return -1;
      }
      var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
      function getPrefixed(name) {
        return window["webkit" + name] || window["moz" + name] || window["ms" + name];
      }
      var lastTime = 0;
      function timeoutDefer(fn) {
        var time2 = +/* @__PURE__ */ new Date(), timeToCall = Math.max(0, 16 - (time2 - lastTime));
        lastTime = time2 + timeToCall;
        return window.setTimeout(fn, timeToCall);
      }
      var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
      var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
        window.clearTimeout(id);
      };
      function requestAnimFrame(fn, context, immediate) {
        if (immediate && requestFn === timeoutDefer) {
          fn.call(context);
        } else {
          return requestFn.call(window, bind(fn, context));
        }
      }
      function cancelAnimFrame(id) {
        if (id) {
          cancelFn.call(window, id);
        }
      }
      var Util = {
        __proto__: null,
        extend: extend2,
        create: create$2,
        bind,
        get lastId() {
          return lastId;
        },
        stamp,
        throttle: throttle2,
        wrapNum,
        falseFn,
        formatNum,
        trim,
        splitWords,
        setOptions,
        getParamString,
        template,
        isArray,
        indexOf,
        emptyImageUrl,
        requestFn,
        cancelFn,
        requestAnimFrame,
        cancelAnimFrame
      };
      function Class() {
      }
      Class.extend = function(props) {
        var NewClass = function() {
          setOptions(this);
          if (this.initialize) {
            this.initialize.apply(this, arguments);
          }
          this.callInitHooks();
        };
        var parentProto = NewClass.__super__ = this.prototype;
        var proto = create$2(parentProto);
        proto.constructor = NewClass;
        NewClass.prototype = proto;
        for (var i2 in this) {
          if (Object.prototype.hasOwnProperty.call(this, i2) && i2 !== "prototype" && i2 !== "__super__") {
            NewClass[i2] = this[i2];
          }
        }
        if (props.statics) {
          extend2(NewClass, props.statics);
        }
        if (props.includes) {
          checkDeprecatedMixinEvents(props.includes);
          extend2.apply(null, [proto].concat(props.includes));
        }
        extend2(proto, props);
        delete proto.statics;
        delete proto.includes;
        if (proto.options) {
          proto.options = parentProto.options ? create$2(parentProto.options) : {};
          extend2(proto.options, props.options);
        }
        proto._initHooks = [];
        proto.callInitHooks = function() {
          if (this._initHooksCalled) {
            return;
          }
          if (parentProto.callInitHooks) {
            parentProto.callInitHooks.call(this);
          }
          this._initHooksCalled = true;
          for (var i22 = 0, len = proto._initHooks.length; i22 < len; i22++) {
            proto._initHooks[i22].call(this);
          }
        };
        return NewClass;
      };
      Class.include = function(props) {
        var parentOptions = this.prototype.options;
        extend2(this.prototype, props);
        if (props.options) {
          this.prototype.options = parentOptions;
          this.mergeOptions(props.options);
        }
        return this;
      };
      Class.mergeOptions = function(options) {
        extend2(this.prototype.options, options);
        return this;
      };
      Class.addInitHook = function(fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        var init = typeof fn === "function" ? fn : function() {
          this[fn].apply(this, args);
        };
        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
        return this;
      };
      function checkDeprecatedMixinEvents(includes) {
        if (typeof L === "undefined" || !L || !L.Mixin) {
          return;
        }
        includes = isArray(includes) ? includes : [includes];
        for (var i2 = 0; i2 < includes.length; i2++) {
          if (includes[i2] === L.Mixin.Events) {
            console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
          }
        }
      }
      var Events = {
        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function(types, fn, context) {
          if (typeof types === "object") {
            for (var type in types) {
              this._on(type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            for (var i2 = 0, len = types.length; i2 < len; i2++) {
              this._on(types[i2], fn, context);
            }
          }
          return this;
        },
        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object. This includes implicitly attached events.
         */
        off: function(types, fn, context) {
          if (!arguments.length) {
            delete this._events;
          } else if (typeof types === "object") {
            for (var type in types) {
              this._off(type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            var removeAll = arguments.length === 1;
            for (var i2 = 0, len = types.length; i2 < len; i2++) {
              if (removeAll) {
                this._off(types[i2]);
              } else {
                this._off(types[i2], fn, context);
              }
            }
          }
          return this;
        },
        // attach listener (without syntactic sugar now)
        _on: function(type, fn, context, _once) {
          if (typeof fn !== "function") {
            console.warn("wrong listener type: " + typeof fn);
            return;
          }
          if (this._listens(type, fn, context) !== false) {
            return;
          }
          if (context === this) {
            context = void 0;
          }
          var newListener = { fn, ctx: context };
          if (_once) {
            newListener.once = true;
          }
          this._events = this._events || {};
          this._events[type] = this._events[type] || [];
          this._events[type].push(newListener);
        },
        _off: function(type, fn, context) {
          var listeners, i2, len;
          if (!this._events) {
            return;
          }
          listeners = this._events[type];
          if (!listeners) {
            return;
          }
          if (arguments.length === 1) {
            if (this._firingCount) {
              for (i2 = 0, len = listeners.length; i2 < len; i2++) {
                listeners[i2].fn = falseFn;
              }
            }
            delete this._events[type];
            return;
          }
          if (typeof fn !== "function") {
            console.warn("wrong listener type: " + typeof fn);
            return;
          }
          var index2 = this._listens(type, fn, context);
          if (index2 !== false) {
            var listener2 = listeners[index2];
            if (this._firingCount) {
              listener2.fn = falseFn;
              this._events[type] = listeners = listeners.slice();
            }
            listeners.splice(index2, 1);
          }
        },
        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide a data
        // object  the first argument of the listener function will contain its
        // properties. The event can optionally be propagated to event parents.
        fire: function(type, data, propagate) {
          if (!this.listens(type, propagate)) {
            return this;
          }
          var event = extend2({}, data, {
            type,
            target: this,
            sourceTarget: data && data.sourceTarget || this
          });
          if (this._events) {
            var listeners = this._events[type];
            if (listeners) {
              this._firingCount = this._firingCount + 1 || 1;
              for (var i2 = 0, len = listeners.length; i2 < len; i2++) {
                var l2 = listeners[i2];
                var fn = l2.fn;
                if (l2.once) {
                  this.off(type, fn, l2.ctx);
                }
                fn.call(l2.ctx || this, event);
              }
              this._firingCount--;
            }
          }
          if (propagate) {
            this._propagateEvent(event);
          }
          return this;
        },
        // @method listens(type: String, propagate?: Boolean): Boolean
        // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
        listens: function(type, fn, context, propagate) {
          if (typeof type !== "string") {
            console.warn('"string" type argument expected');
          }
          var _fn = fn;
          if (typeof fn !== "function") {
            propagate = !!fn;
            _fn = void 0;
            context = void 0;
          }
          var listeners = this._events && this._events[type];
          if (listeners && listeners.length) {
            if (this._listens(type, _fn, context) !== false) {
              return true;
            }
          }
          if (propagate) {
            for (var id in this._eventParents) {
              if (this._eventParents[id].listens(type, fn, context, propagate)) {
                return true;
              }
            }
          }
          return false;
        },
        // returns the index (number) or false
        _listens: function(type, fn, context) {
          if (!this._events) {
            return false;
          }
          var listeners = this._events[type] || [];
          if (!fn) {
            return !!listeners.length;
          }
          if (context === this) {
            context = void 0;
          }
          for (var i2 = 0, len = listeners.length; i2 < len; i2++) {
            if (listeners[i2].fn === fn && listeners[i2].ctx === context) {
              return i2;
            }
          }
          return false;
        },
        // @method once(): this
        // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
        once: function(types, fn, context) {
          if (typeof types === "object") {
            for (var type in types) {
              this._on(type, types[type], fn, true);
            }
          } else {
            types = splitWords(types);
            for (var i2 = 0, len = types.length; i2 < len; i2++) {
              this._on(types[i2], fn, context, true);
            }
          }
          return this;
        },
        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function(obj) {
          this._eventParents = this._eventParents || {};
          this._eventParents[stamp(obj)] = obj;
          return this;
        },
        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function(obj) {
          if (this._eventParents) {
            delete this._eventParents[stamp(obj)];
          }
          return this;
        },
        _propagateEvent: function(e3) {
          for (var id in this._eventParents) {
            this._eventParents[id].fire(e3.type, extend2({
              layer: e3.target,
              propagatedFrom: e3.target
            }, e3), true);
          }
        }
      };
      Events.addEventListener = Events.on;
      Events.removeEventListener = Events.clearAllEventListeners = Events.off;
      Events.addOneTimeEventListener = Events.once;
      Events.fireEvent = Events.fire;
      Events.hasEventListeners = Events.listens;
      var Evented = Class.extend(Events);
      function Point(x2, y2, round2) {
        this.x = round2 ? Math.round(x2) : x2;
        this.y = round2 ? Math.round(y2) : y2;
      }
      var trunc = Math.trunc || function(v2) {
        return v2 > 0 ? Math.floor(v2) : Math.ceil(v2);
      };
      Point.prototype = {
        // @method clone(): Point
        // Returns a copy of the current point.
        clone: function() {
          return new Point(this.x, this.y);
        },
        // @method add(otherPoint: Point): Point
        // Returns the result of addition of the current and the given points.
        add: function(point2) {
          return this.clone()._add(toPoint(point2));
        },
        _add: function(point2) {
          this.x += point2.x;
          this.y += point2.y;
          return this;
        },
        // @method subtract(otherPoint: Point): Point
        // Returns the result of subtraction of the given point from the current.
        subtract: function(point2) {
          return this.clone()._subtract(toPoint(point2));
        },
        _subtract: function(point2) {
          this.x -= point2.x;
          this.y -= point2.y;
          return this;
        },
        // @method divideBy(num: Number): Point
        // Returns the result of division of the current point by the given number.
        divideBy: function(num) {
          return this.clone()._divideBy(num);
        },
        _divideBy: function(num) {
          this.x /= num;
          this.y /= num;
          return this;
        },
        // @method multiplyBy(num: Number): Point
        // Returns the result of multiplication of the current point by the given number.
        multiplyBy: function(num) {
          return this.clone()._multiplyBy(num);
        },
        _multiplyBy: function(num) {
          this.x *= num;
          this.y *= num;
          return this;
        },
        // @method scaleBy(scale: Point): Point
        // Multiply each coordinate of the current point by each coordinate of
        // `scale`. In linear algebra terms, multiply the point by the
        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
        // defined by `scale`.
        scaleBy: function(point2) {
          return new Point(this.x * point2.x, this.y * point2.y);
        },
        // @method unscaleBy(scale: Point): Point
        // Inverse of `scaleBy`. Divide each coordinate of the current point by
        // each coordinate of `scale`.
        unscaleBy: function(point2) {
          return new Point(this.x / point2.x, this.y / point2.y);
        },
        // @method round(): Point
        // Returns a copy of the current point with rounded coordinates.
        round: function() {
          return this.clone()._round();
        },
        _round: function() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        },
        // @method floor(): Point
        // Returns a copy of the current point with floored coordinates (rounded down).
        floor: function() {
          return this.clone()._floor();
        },
        _floor: function() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        },
        // @method ceil(): Point
        // Returns a copy of the current point with ceiled coordinates (rounded up).
        ceil: function() {
          return this.clone()._ceil();
        },
        _ceil: function() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        },
        // @method trunc(): Point
        // Returns a copy of the current point with truncated coordinates (rounded towards zero).
        trunc: function() {
          return this.clone()._trunc();
        },
        _trunc: function() {
          this.x = trunc(this.x);
          this.y = trunc(this.y);
          return this;
        },
        // @method distanceTo(otherPoint: Point): Number
        // Returns the cartesian distance between the current and the given points.
        distanceTo: function(point2) {
          point2 = toPoint(point2);
          var x2 = point2.x - this.x, y2 = point2.y - this.y;
          return Math.sqrt(x2 * x2 + y2 * y2);
        },
        // @method equals(otherPoint: Point): Boolean
        // Returns `true` if the given point has the same coordinates.
        equals: function(point2) {
          point2 = toPoint(point2);
          return point2.x === this.x && point2.y === this.y;
        },
        // @method contains(otherPoint: Point): Boolean
        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
        contains: function(point2) {
          point2 = toPoint(point2);
          return Math.abs(point2.x) <= Math.abs(this.x) && Math.abs(point2.y) <= Math.abs(this.y);
        },
        // @method toString(): String
        // Returns a string representation of the point for debugging purposes.
        toString: function() {
          return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
        }
      };
      function toPoint(x2, y2, round2) {
        if (x2 instanceof Point) {
          return x2;
        }
        if (isArray(x2)) {
          return new Point(x2[0], x2[1]);
        }
        if (x2 === void 0 || x2 === null) {
          return x2;
        }
        if (typeof x2 === "object" && "x" in x2 && "y" in x2) {
          return new Point(x2.x, x2.y);
        }
        return new Point(x2, y2, round2);
      }
      function Bounds(a2, b2) {
        if (!a2) {
          return;
        }
        var points = b2 ? [a2, b2] : a2;
        for (var i2 = 0, len = points.length; i2 < len; i2++) {
          this.extend(points[i2]);
        }
      }
      Bounds.prototype = {
        // @method extend(point: Point): this
        // Extends the bounds to contain the given point.
        // @alternative
        // @method extend(otherBounds: Bounds): this
        // Extend the bounds to contain the given bounds
        extend: function(obj) {
          var min2, max2;
          if (!obj) {
            return this;
          }
          if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
            min2 = max2 = toPoint(obj);
          } else {
            obj = toBounds(obj);
            min2 = obj.min;
            max2 = obj.max;
            if (!min2 || !max2) {
              return this;
            }
          }
          if (!this.min && !this.max) {
            this.min = min2.clone();
            this.max = max2.clone();
          } else {
            this.min.x = Math.min(min2.x, this.min.x);
            this.max.x = Math.max(max2.x, this.max.x);
            this.min.y = Math.min(min2.y, this.min.y);
            this.max.y = Math.max(max2.y, this.max.y);
          }
          return this;
        },
        // @method getCenter(round?: Boolean): Point
        // Returns the center point of the bounds.
        getCenter: function(round2) {
          return toPoint(
            (this.min.x + this.max.x) / 2,
            (this.min.y + this.max.y) / 2,
            round2
          );
        },
        // @method getBottomLeft(): Point
        // Returns the bottom-left point of the bounds.
        getBottomLeft: function() {
          return toPoint(this.min.x, this.max.y);
        },
        // @method getTopRight(): Point
        // Returns the top-right point of the bounds.
        getTopRight: function() {
          return toPoint(this.max.x, this.min.y);
        },
        // @method getTopLeft(): Point
        // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
        getTopLeft: function() {
          return this.min;
        },
        // @method getBottomRight(): Point
        // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
        getBottomRight: function() {
          return this.max;
        },
        // @method getSize(): Point
        // Returns the size of the given bounds
        getSize: function() {
          return this.max.subtract(this.min);
        },
        // @method contains(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains(point: Point): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(obj) {
          var min2, max2;
          if (typeof obj[0] === "number" || obj instanceof Point) {
            obj = toPoint(obj);
          } else {
            obj = toBounds(obj);
          }
          if (obj instanceof Bounds) {
            min2 = obj.min;
            max2 = obj.max;
          } else {
            min2 = max2 = obj;
          }
          return min2.x >= this.min.x && max2.x <= this.max.x && min2.y >= this.min.y && max2.y <= this.max.y;
        },
        // @method intersects(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds
        // intersect if they have at least one point in common.
        intersects: function(bounds) {
          bounds = toBounds(bounds);
          var min2 = this.min, max2 = this.max, min22 = bounds.min, max22 = bounds.max, xIntersects = max22.x >= min2.x && min22.x <= max2.x, yIntersects = max22.y >= min2.y && min22.y <= max2.y;
          return xIntersects && yIntersects;
        },
        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds
        // overlap if their intersection is an area.
        overlaps: function(bounds) {
          bounds = toBounds(bounds);
          var min2 = this.min, max2 = this.max, min22 = bounds.min, max22 = bounds.max, xOverlaps = max22.x > min2.x && min22.x < max2.x, yOverlaps = max22.y > min2.y && min22.y < max2.y;
          return xOverlaps && yOverlaps;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this.min && this.max);
        },
        // @method pad(bufferRatio: Number): Bounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(bufferRatio) {
          var min2 = this.min, max2 = this.max, heightBuffer = Math.abs(min2.x - max2.x) * bufferRatio, widthBuffer = Math.abs(min2.y - max2.y) * bufferRatio;
          return toBounds(
            toPoint(min2.x - heightBuffer, min2.y - widthBuffer),
            toPoint(max2.x + heightBuffer, max2.y + widthBuffer)
          );
        },
        // @method equals(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle is equivalent to the given bounds.
        equals: function(bounds) {
          if (!bounds) {
            return false;
          }
          bounds = toBounds(bounds);
          return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
        }
      };
      function toBounds(a2, b2) {
        if (!a2 || a2 instanceof Bounds) {
          return a2;
        }
        return new Bounds(a2, b2);
      }
      function LatLngBounds(corner1, corner2) {
        if (!corner1) {
          return;
        }
        var latlngs = corner2 ? [corner1, corner2] : corner1;
        for (var i2 = 0, len = latlngs.length; i2 < len; i2++) {
          this.extend(latlngs[i2]);
        }
      }
      LatLngBounds.prototype = {
        // @method extend(latlng: LatLng): this
        // Extend the bounds to contain the given point
        // @alternative
        // @method extend(otherBounds: LatLngBounds): this
        // Extend the bounds to contain the given bounds
        extend: function(obj) {
          var sw = this._southWest, ne = this._northEast, sw2, ne2;
          if (obj instanceof LatLng) {
            sw2 = obj;
            ne2 = obj;
          } else if (obj instanceof LatLngBounds) {
            sw2 = obj._southWest;
            ne2 = obj._northEast;
            if (!sw2 || !ne2) {
              return this;
            }
          } else {
            return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
          }
          if (!sw && !ne) {
            this._southWest = new LatLng(sw2.lat, sw2.lng);
            this._northEast = new LatLng(ne2.lat, ne2.lng);
          } else {
            sw.lat = Math.min(sw2.lat, sw.lat);
            sw.lng = Math.min(sw2.lng, sw.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
          }
          return this;
        },
        // @method pad(bufferRatio: Number): LatLngBounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(bufferRatio) {
          var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
          return new LatLngBounds(
            new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
            new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer)
          );
        },
        // @method getCenter(): LatLng
        // Returns the center point of the bounds.
        getCenter: function() {
          return new LatLng(
            (this._southWest.lat + this._northEast.lat) / 2,
            (this._southWest.lng + this._northEast.lng) / 2
          );
        },
        // @method getSouthWest(): LatLng
        // Returns the south-west point of the bounds.
        getSouthWest: function() {
          return this._southWest;
        },
        // @method getNorthEast(): LatLng
        // Returns the north-east point of the bounds.
        getNorthEast: function() {
          return this._northEast;
        },
        // @method getNorthWest(): LatLng
        // Returns the north-west point of the bounds.
        getNorthWest: function() {
          return new LatLng(this.getNorth(), this.getWest());
        },
        // @method getSouthEast(): LatLng
        // Returns the south-east point of the bounds.
        getSouthEast: function() {
          return new LatLng(this.getSouth(), this.getEast());
        },
        // @method getWest(): Number
        // Returns the west longitude of the bounds
        getWest: function() {
          return this._southWest.lng;
        },
        // @method getSouth(): Number
        // Returns the south latitude of the bounds
        getSouth: function() {
          return this._southWest.lat;
        },
        // @method getEast(): Number
        // Returns the east longitude of the bounds
        getEast: function() {
          return this._northEast.lng;
        },
        // @method getNorth(): Number
        // Returns the north latitude of the bounds
        getNorth: function() {
          return this._northEast.lat;
        },
        // @method contains(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains (latlng: LatLng): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(obj) {
          if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
            obj = toLatLng(obj);
          } else {
            obj = toLatLngBounds(obj);
          }
          var sw = this._southWest, ne = this._northEast, sw2, ne2;
          if (obj instanceof LatLngBounds) {
            sw2 = obj.getSouthWest();
            ne2 = obj.getNorthEast();
          } else {
            sw2 = ne2 = obj;
          }
          return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
        },
        // @method intersects(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
        intersects: function(bounds) {
          bounds = toLatLngBounds(bounds);
          var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
          return latIntersects && lngIntersects;
        },
        // @method overlaps(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
        overlaps: function(bounds) {
          bounds = toLatLngBounds(bounds);
          var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
          return latOverlaps && lngOverlaps;
        },
        // @method toBBoxString(): String
        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
        toBBoxString: function() {
          return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
        },
        // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(bounds, maxMargin) {
          if (!bounds) {
            return false;
          }
          bounds = toLatLngBounds(bounds);
          return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this._southWest && this._northEast);
        }
      };
      function toLatLngBounds(a2, b2) {
        if (a2 instanceof LatLngBounds) {
          return a2;
        }
        return new LatLngBounds(a2, b2);
      }
      function LatLng(lat, lng, alt) {
        if (isNaN(lat) || isNaN(lng)) {
          throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
        }
        this.lat = +lat;
        this.lng = +lng;
        if (alt !== void 0) {
          this.alt = +alt;
        }
      }
      LatLng.prototype = {
        // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
        // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(obj, maxMargin) {
          if (!obj) {
            return false;
          }
          obj = toLatLng(obj);
          var margin = Math.max(
            Math.abs(this.lat - obj.lat),
            Math.abs(this.lng - obj.lng)
          );
          return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
        },
        // @method toString(): String
        // Returns a string representation of the point (for debugging purposes).
        toString: function(precision) {
          return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
        },
        // @method distanceTo(otherLatLng: LatLng): Number
        // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
        distanceTo: function(other) {
          return Earth.distance(this, toLatLng(other));
        },
        // @method wrap(): LatLng
        // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
        wrap: function() {
          return Earth.wrapLatLng(this);
        },
        // @method toBounds(sizeInMeters: Number): LatLngBounds
        // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
        toBounds: function(sizeInMeters) {
          var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
          return toLatLngBounds(
            [this.lat - latAccuracy, this.lng - lngAccuracy],
            [this.lat + latAccuracy, this.lng + lngAccuracy]
          );
        },
        clone: function() {
          return new LatLng(this.lat, this.lng, this.alt);
        }
      };
      function toLatLng(a2, b2, c2) {
        if (a2 instanceof LatLng) {
          return a2;
        }
        if (isArray(a2) && typeof a2[0] !== "object") {
          if (a2.length === 3) {
            return new LatLng(a2[0], a2[1], a2[2]);
          }
          if (a2.length === 2) {
            return new LatLng(a2[0], a2[1]);
          }
          return null;
        }
        if (a2 === void 0 || a2 === null) {
          return a2;
        }
        if (typeof a2 === "object" && "lat" in a2) {
          return new LatLng(a2.lat, "lng" in a2 ? a2.lng : a2.lon, a2.alt);
        }
        if (b2 === void 0) {
          return null;
        }
        return new LatLng(a2, b2, c2);
      }
      var CRS = {
        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
        // Projects geographical coordinates into pixel coordinates for a given zoom.
        latLngToPoint: function(latlng, zoom2) {
          var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
          return this.transformation._transform(projectedPoint, scale2);
        },
        // @method pointToLatLng(point: Point, zoom: Number): LatLng
        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
        // zoom into geographical coordinates.
        pointToLatLng: function(point2, zoom2) {
          var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point2, scale2);
          return this.projection.unproject(untransformedPoint);
        },
        // @method project(latlng: LatLng): Point
        // Projects geographical coordinates into coordinates in units accepted for
        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
        project: function(latlng) {
          return this.projection.project(latlng);
        },
        // @method unproject(point: Point): LatLng
        // Given a projected coordinate returns the corresponding LatLng.
        // The inverse of `project`.
        unproject: function(point2) {
          return this.projection.unproject(point2);
        },
        // @method scale(zoom: Number): Number
        // Returns the scale used when transforming projected coordinates into
        // pixel coordinates for a particular zoom. For example, it returns
        // `256 * 2^zoom` for Mercator-based CRS.
        scale: function(zoom2) {
          return 256 * Math.pow(2, zoom2);
        },
        // @method zoom(scale: Number): Number
        // Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
        zoom: function(scale2) {
          return Math.log(scale2 / 256) / Math.LN2;
        },
        // @method getProjectedBounds(zoom: Number): Bounds
        // Returns the projection's bounds scaled and transformed for the provided `zoom`.
        getProjectedBounds: function(zoom2) {
          if (this.infinite) {
            return null;
          }
          var b2 = this.projection.bounds, s2 = this.scale(zoom2), min2 = this.transformation.transform(b2.min, s2), max2 = this.transformation.transform(b2.max, s2);
          return new Bounds(min2, max2);
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates.
        // @property code: String
        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
        //
        // @property wrapLng: Number[]
        // An array of two numbers defining whether the longitude (horizontal) coordinate
        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
        //
        // @property wrapLat: Number[]
        // Like `wrapLng`, but for the latitude (vertical) axis.
        // wrapLng: [min, max],
        // wrapLat: [min, max],
        // @property infinite: Boolean
        // If true, the coordinate space will be unbounded (infinite in both axes)
        infinite: false,
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where lat and lng has been wrapped according to the
        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
        wrapLatLng: function(latlng) {
          var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
          return new LatLng(lat, lng, alt);
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring
        // that its center is within the CRS's bounds.
        // Only accepts actual `L.LatLngBounds` instances, not arrays.
        wrapLatLngBounds: function(bounds) {
          var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
          if (latShift === 0 && lngShift === 0) {
            return bounds;
          }
          var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
          return new LatLngBounds(newSw, newNe);
        }
      };
      var Earth = extend2({}, CRS, {
        wrapLng: [-180, 180],
        // Mean Earth Radius, as recommended for use by
        // the International Union of Geodesy and Geophysics,
        // see https://rosettacode.org/wiki/Haversine_formula
        R: 6371e3,
        // distance between two geographical points using spherical law of cosines approximation
        distance: function(latlng1, latlng2) {
          var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a2 = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c2 = 2 * Math.atan2(Math.sqrt(a2), Math.sqrt(1 - a2));
          return this.R * c2;
        }
      });
      var earthRadius = 6378137;
      var SphericalMercator = {
        R: earthRadius,
        MAX_LATITUDE: 85.0511287798,
        project: function(latlng) {
          var d2 = Math.PI / 180, max2 = this.MAX_LATITUDE, lat = Math.max(Math.min(max2, latlng.lat), -max2), sin2 = Math.sin(lat * d2);
          return new Point(
            this.R * latlng.lng * d2,
            this.R * Math.log((1 + sin2) / (1 - sin2)) / 2
          );
        },
        unproject: function(point2) {
          var d2 = 180 / Math.PI;
          return new LatLng(
            (2 * Math.atan(Math.exp(point2.y / this.R)) - Math.PI / 2) * d2,
            point2.x * d2 / this.R
          );
        },
        bounds: (function() {
          var d2 = earthRadius * Math.PI;
          return new Bounds([-d2, -d2], [d2, d2]);
        })()
      };
      function Transformation(a2, b2, c2, d2) {
        if (isArray(a2)) {
          this._a = a2[0];
          this._b = a2[1];
          this._c = a2[2];
          this._d = a2[3];
          return;
        }
        this._a = a2;
        this._b = b2;
        this._c = c2;
        this._d = d2;
      }
      Transformation.prototype = {
        // @method transform(point: Point, scale?: Number): Point
        // Returns a transformed point, optionally multiplied by the given scale.
        // Only accepts actual `L.Point` instances, not arrays.
        transform: function(point2, scale2) {
          return this._transform(point2.clone(), scale2);
        },
        // destructive transform (faster)
        _transform: function(point2, scale2) {
          scale2 = scale2 || 1;
          point2.x = scale2 * (this._a * point2.x + this._b);
          point2.y = scale2 * (this._c * point2.y + this._d);
          return point2;
        },
        // @method untransform(point: Point, scale?: Number): Point
        // Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts actual `L.Point` instances, not arrays.
        untransform: function(point2, scale2) {
          scale2 = scale2 || 1;
          return new Point(
            (point2.x / scale2 - this._b) / this._a,
            (point2.y / scale2 - this._d) / this._c
          );
        }
      };
      function toTransformation(a2, b2, c2, d2) {
        return new Transformation(a2, b2, c2, d2);
      }
      var EPSG3857 = extend2({}, Earth, {
        code: "EPSG:3857",
        projection: SphericalMercator,
        transformation: (function() {
          var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
          return toTransformation(scale2, 0.5, -scale2, 0.5);
        })()
      });
      var EPSG900913 = extend2({}, EPSG3857, {
        code: "EPSG:900913"
      });
      function svgCreate(name) {
        return document.createElementNS("http://www.w3.org/2000/svg", name);
      }
      function pointsToPath(rings, closed) {
        var str = "", i2, j2, len, len2, points, p2;
        for (i2 = 0, len = rings.length; i2 < len; i2++) {
          points = rings[i2];
          for (j2 = 0, len2 = points.length; j2 < len2; j2++) {
            p2 = points[j2];
            str += (j2 ? "L" : "M") + p2.x + " " + p2.y;
          }
          str += closed ? Browser2.svg ? "z" : "x" : "";
        }
        return str || "M0 0";
      }
      var style = document.documentElement.style;
      var ie = "ActiveXObject" in window;
      var ielt9 = ie && !document.addEventListener;
      var edge = "msLaunchUri" in navigator && !("documentMode" in document);
      var webkit = userAgentContains("webkit");
      var android = userAgentContains("android");
      var android23 = userAgentContains("android 2") || userAgentContains("android 3");
      var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
      var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
      var opera = !!window.opera;
      var chrome = !edge && userAgentContains("chrome");
      var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
      var safari = !chrome && userAgentContains("safari");
      var phantom = userAgentContains("phantom");
      var opera12 = "OTransition" in style;
      var win = navigator.platform.indexOf("Win") === 0;
      var ie3d = ie && "transition" in style;
      var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
      var gecko3d = "MozPerspective" in style;
      var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
      var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
      var mobileWebkit = mobile && webkit;
      var mobileWebkit3d = mobile && webkit3d;
      var msPointer = !window.PointerEvent && window.MSPointerEvent;
      var pointer = !!(window.PointerEvent || msPointer);
      var touchNative = "ontouchstart" in window || !!window.TouchEvent;
      var touch = !window.L_NO_TOUCH && (touchNative || pointer);
      var mobileOpera = mobile && opera;
      var mobileGecko = mobile && gecko;
      var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
      var passiveEvents = (function() {
        var supportsPassiveOption = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassiveOption = true;
            }
          });
          window.addEventListener("testPassiveEventSupport", falseFn, opts);
          window.removeEventListener("testPassiveEventSupport", falseFn, opts);
        } catch (e3) {
        }
        return supportsPassiveOption;
      })();
      var canvas$1 = (function() {
        return !!document.createElement("canvas").getContext;
      })();
      var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
      var inlineSvg = !!svg$1 && (function() {
        var div = document.createElement("div");
        div.innerHTML = "<svg/>";
        return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
      })();
      var vml = !svg$1 && (function() {
        try {
          var div = document.createElement("div");
          div.innerHTML = '<v:shape adj="1"/>';
          var shape = div.firstChild;
          shape.style.behavior = "url(#default#VML)";
          return shape && typeof shape.adj === "object";
        } catch (e3) {
          return false;
        }
      })();
      var mac = navigator.platform.indexOf("Mac") === 0;
      var linux = navigator.platform.indexOf("Linux") === 0;
      function userAgentContains(str) {
        return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
      }
      var Browser2 = {
        ie,
        ielt9,
        edge,
        webkit,
        android,
        android23,
        androidStock,
        opera,
        chrome,
        gecko,
        safari,
        phantom,
        opera12,
        win,
        ie3d,
        webkit3d,
        gecko3d,
        any3d,
        mobile,
        mobileWebkit,
        mobileWebkit3d,
        msPointer,
        pointer,
        touch,
        touchNative,
        mobileOpera,
        mobileGecko,
        retina,
        passiveEvents,
        canvas: canvas$1,
        svg: svg$1,
        vml,
        inlineSvg,
        mac,
        linux
      };
      var POINTER_DOWN = Browser2.msPointer ? "MSPointerDown" : "pointerdown";
      var POINTER_MOVE = Browser2.msPointer ? "MSPointerMove" : "pointermove";
      var POINTER_UP = Browser2.msPointer ? "MSPointerUp" : "pointerup";
      var POINTER_CANCEL = Browser2.msPointer ? "MSPointerCancel" : "pointercancel";
      var pEvent = {
        touchstart: POINTER_DOWN,
        touchmove: POINTER_MOVE,
        touchend: POINTER_UP,
        touchcancel: POINTER_CANCEL
      };
      var handle = {
        touchstart: _onPointerStart,
        touchmove: _handlePointer,
        touchend: _handlePointer,
        touchcancel: _handlePointer
      };
      var _pointers = {};
      var _pointerDocListener = false;
      function addPointerListener(obj, type, handler) {
        if (type === "touchstart") {
          _addPointerDocListener();
        }
        if (!handle[type]) {
          console.warn("wrong event specified:", type);
          return falseFn;
        }
        handler = handle[type].bind(this, handler);
        obj.addEventListener(pEvent[type], handler, false);
        return handler;
      }
      function removePointerListener(obj, type, handler) {
        if (!pEvent[type]) {
          console.warn("wrong event specified:", type);
          return;
        }
        obj.removeEventListener(pEvent[type], handler, false);
      }
      function _globalPointerDown(e3) {
        _pointers[e3.pointerId] = e3;
      }
      function _globalPointerMove(e3) {
        if (_pointers[e3.pointerId]) {
          _pointers[e3.pointerId] = e3;
        }
      }
      function _globalPointerUp(e3) {
        delete _pointers[e3.pointerId];
      }
      function _addPointerDocListener() {
        if (!_pointerDocListener) {
          document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
          document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
          document.addEventListener(POINTER_UP, _globalPointerUp, true);
          document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
          _pointerDocListener = true;
        }
      }
      function _handlePointer(handler, e3) {
        if (e3.pointerType === (e3.MSPOINTER_TYPE_MOUSE || "mouse")) {
          return;
        }
        e3.touches = [];
        for (var i2 in _pointers) {
          e3.touches.push(_pointers[i2]);
        }
        e3.changedTouches = [e3];
        handler(e3);
      }
      function _onPointerStart(handler, e3) {
        if (e3.MSPOINTER_TYPE_TOUCH && e3.pointerType === e3.MSPOINTER_TYPE_TOUCH) {
          preventDefault(e3);
        }
        _handlePointer(handler, e3);
      }
      function makeDblclick(event) {
        var newEvent = {}, prop, i2;
        for (i2 in event) {
          prop = event[i2];
          newEvent[i2] = prop && prop.bind ? prop.bind(event) : prop;
        }
        event = newEvent;
        newEvent.type = "dblclick";
        newEvent.detail = 2;
        newEvent.isTrusted = false;
        newEvent._simulated = true;
        return newEvent;
      }
      var delay = 200;
      function addDoubleTapListener(obj, handler) {
        obj.addEventListener("dblclick", handler);
        var last2 = 0, detail;
        function simDblclick(e3) {
          if (e3.detail !== 1) {
            detail = e3.detail;
            return;
          }
          if (e3.pointerType === "mouse" || e3.sourceCapabilities && !e3.sourceCapabilities.firesTouchEvents) {
            return;
          }
          var path2 = getPropagationPath(e3);
          if (path2.some(function(el) {
            return el instanceof HTMLLabelElement && el.attributes.for;
          }) && !path2.some(function(el) {
            return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
          })) {
            return;
          }
          var now = Date.now();
          if (now - last2 <= delay) {
            detail++;
            if (detail === 2) {
              handler(makeDblclick(e3));
            }
          } else {
            detail = 1;
          }
          last2 = now;
        }
        obj.addEventListener("click", simDblclick);
        return {
          dblclick: handler,
          simDblclick
        };
      }
      function removeDoubleTapListener(obj, handlers) {
        obj.removeEventListener("dblclick", handlers.dblclick);
        obj.removeEventListener("click", handlers.simDblclick);
      }
      var TRANSFORM = testProp(
        ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
      );
      var TRANSITION = testProp(
        ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
      );
      var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
      function get2(id) {
        return typeof id === "string" ? document.getElementById(id) : id;
      }
      function getStyle(el, style2) {
        var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
        if ((!value || value === "auto") && document.defaultView) {
          var css = document.defaultView.getComputedStyle(el, null);
          value = css ? css[style2] : null;
        }
        return value === "auto" ? null : value;
      }
      function create$1(tagName, className, container) {
        var el = document.createElement(tagName);
        el.className = className || "";
        if (container) {
          container.appendChild(el);
        }
        return el;
      }
      function remove(el) {
        var parent = el.parentNode;
        if (parent) {
          parent.removeChild(el);
        }
      }
      function empty(el) {
        while (el.firstChild) {
          el.removeChild(el.firstChild);
        }
      }
      function toFront(el) {
        var parent = el.parentNode;
        if (parent && parent.lastChild !== el) {
          parent.appendChild(el);
        }
      }
      function toBack(el) {
        var parent = el.parentNode;
        if (parent && parent.firstChild !== el) {
          parent.insertBefore(el, parent.firstChild);
        }
      }
      function hasClass(el, name) {
        if (el.classList !== void 0) {
          return el.classList.contains(name);
        }
        var className = getClass(el);
        return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
      }
      function addClass(el, name) {
        if (el.classList !== void 0) {
          var classes = splitWords(name);
          for (var i2 = 0, len = classes.length; i2 < len; i2++) {
            el.classList.add(classes[i2]);
          }
        } else if (!hasClass(el, name)) {
          var className = getClass(el);
          setClass(el, (className ? className + " " : "") + name);
        }
      }
      function removeClass(el, name) {
        if (el.classList !== void 0) {
          el.classList.remove(name);
        } else {
          setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
        }
      }
      function setClass(el, name) {
        if (el.className.baseVal === void 0) {
          el.className = name;
        } else {
          el.className.baseVal = name;
        }
      }
      function getClass(el) {
        if (el.correspondingElement) {
          el = el.correspondingElement;
        }
        return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
      }
      function setOpacity(el, value) {
        if ("opacity" in el.style) {
          el.style.opacity = value;
        } else if ("filter" in el.style) {
          _setOpacityIE(el, value);
        }
      }
      function _setOpacityIE(el, value) {
        var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
        try {
          filter = el.filters.item(filterName);
        } catch (e3) {
          if (value === 1) {
            return;
          }
        }
        value = Math.round(value * 100);
        if (filter) {
          filter.Enabled = value !== 100;
          filter.Opacity = value;
        } else {
          el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
        }
      }
      function testProp(props) {
        var style2 = document.documentElement.style;
        for (var i2 = 0; i2 < props.length; i2++) {
          if (props[i2] in style2) {
            return props[i2];
          }
        }
        return false;
      }
      function setTransform(el, offset, scale2) {
        var pos = offset || new Point(0, 0);
        el.style[TRANSFORM] = (Browser2.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
      }
      function setPosition(el, point2) {
        el._leaflet_pos = point2;
        if (Browser2.any3d) {
          setTransform(el, point2);
        } else {
          el.style.left = point2.x + "px";
          el.style.top = point2.y + "px";
        }
      }
      function getPosition(el) {
        return el._leaflet_pos || new Point(0, 0);
      }
      var disableTextSelection;
      var enableTextSelection;
      var _userSelect;
      if ("onselectstart" in document) {
        disableTextSelection = function() {
          on(window, "selectstart", preventDefault);
        };
        enableTextSelection = function() {
          off(window, "selectstart", preventDefault);
        };
      } else {
        var userSelectProperty = testProp(
          ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
        );
        disableTextSelection = function() {
          if (userSelectProperty) {
            var style2 = document.documentElement.style;
            _userSelect = style2[userSelectProperty];
            style2[userSelectProperty] = "none";
          }
        };
        enableTextSelection = function() {
          if (userSelectProperty) {
            document.documentElement.style[userSelectProperty] = _userSelect;
            _userSelect = void 0;
          }
        };
      }
      function disableImageDrag() {
        on(window, "dragstart", preventDefault);
      }
      function enableImageDrag() {
        off(window, "dragstart", preventDefault);
      }
      var _outlineElement, _outlineStyle;
      function preventOutline(element) {
        while (element.tabIndex === -1) {
          element = element.parentNode;
        }
        if (!element.style) {
          return;
        }
        restoreOutline();
        _outlineElement = element;
        _outlineStyle = element.style.outlineStyle;
        element.style.outlineStyle = "none";
        on(window, "keydown", restoreOutline);
      }
      function restoreOutline() {
        if (!_outlineElement) {
          return;
        }
        _outlineElement.style.outlineStyle = _outlineStyle;
        _outlineElement = void 0;
        _outlineStyle = void 0;
        off(window, "keydown", restoreOutline);
      }
      function getSizedParentNode(element) {
        do {
          element = element.parentNode;
        } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
        return element;
      }
      function getScale(element) {
        var rect = element.getBoundingClientRect();
        return {
          x: rect.width / element.offsetWidth || 1,
          y: rect.height / element.offsetHeight || 1,
          boundingClientRect: rect
        };
      }
      var DomUtil = {
        __proto__: null,
        TRANSFORM,
        TRANSITION,
        TRANSITION_END,
        get: get2,
        getStyle,
        create: create$1,
        remove,
        empty,
        toFront,
        toBack,
        hasClass,
        addClass,
        removeClass,
        setClass,
        getClass,
        setOpacity,
        testProp,
        setTransform,
        setPosition,
        getPosition,
        get disableTextSelection() {
          return disableTextSelection;
        },
        get enableTextSelection() {
          return enableTextSelection;
        },
        disableImageDrag,
        enableImageDrag,
        preventOutline,
        restoreOutline,
        getSizedParentNode,
        getScale
      };
      function on(obj, types, fn, context) {
        if (types && typeof types === "object") {
          for (var type in types) {
            addOne(obj, type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          for (var i2 = 0, len = types.length; i2 < len; i2++) {
            addOne(obj, types[i2], fn, context);
          }
        }
        return this;
      }
      var eventsKey = "_leaflet_events";
      function off(obj, types, fn, context) {
        if (arguments.length === 1) {
          batchRemove(obj);
          delete obj[eventsKey];
        } else if (types && typeof types === "object") {
          for (var type in types) {
            removeOne(obj, type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          if (arguments.length === 2) {
            batchRemove(obj, function(type2) {
              return indexOf(types, type2) !== -1;
            });
          } else {
            for (var i2 = 0, len = types.length; i2 < len; i2++) {
              removeOne(obj, types[i2], fn, context);
            }
          }
        }
        return this;
      }
      function batchRemove(obj, filterFn) {
        for (var id in obj[eventsKey]) {
          var type = id.split(/\d/)[0];
          if (!filterFn || filterFn(type)) {
            removeOne(obj, type, null, null, id);
          }
        }
      }
      var mouseSubst = {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        wheel: !("onwheel" in window) && "mousewheel"
      };
      function addOne(obj, type, fn, context) {
        var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
        if (obj[eventsKey] && obj[eventsKey][id]) {
          return this;
        }
        var handler = function(e3) {
          return fn.call(context || obj, e3 || window.event);
        };
        var originalHandler = handler;
        if (!Browser2.touchNative && Browser2.pointer && type.indexOf("touch") === 0) {
          handler = addPointerListener(obj, type, handler);
        } else if (Browser2.touch && type === "dblclick") {
          handler = addDoubleTapListener(obj, handler);
        } else if ("addEventListener" in obj) {
          if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
            obj.addEventListener(mouseSubst[type] || type, handler, Browser2.passiveEvents ? { passive: false } : false);
          } else if (type === "mouseenter" || type === "mouseleave") {
            handler = function(e3) {
              e3 = e3 || window.event;
              if (isExternalTarget(obj, e3)) {
                originalHandler(e3);
              }
            };
            obj.addEventListener(mouseSubst[type], handler, false);
          } else {
            obj.addEventListener(type, originalHandler, false);
          }
        } else {
          obj.attachEvent("on" + type, handler);
        }
        obj[eventsKey] = obj[eventsKey] || {};
        obj[eventsKey][id] = handler;
      }
      function removeOne(obj, type, fn, context, id) {
        id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
        var handler = obj[eventsKey] && obj[eventsKey][id];
        if (!handler) {
          return this;
        }
        if (!Browser2.touchNative && Browser2.pointer && type.indexOf("touch") === 0) {
          removePointerListener(obj, type, handler);
        } else if (Browser2.touch && type === "dblclick") {
          removeDoubleTapListener(obj, handler);
        } else if ("removeEventListener" in obj) {
          obj.removeEventListener(mouseSubst[type] || type, handler, false);
        } else {
          obj.detachEvent("on" + type, handler);
        }
        obj[eventsKey][id] = null;
      }
      function stopPropagation(e3) {
        if (e3.stopPropagation) {
          e3.stopPropagation();
        } else if (e3.originalEvent) {
          e3.originalEvent._stopped = true;
        } else {
          e3.cancelBubble = true;
        }
        return this;
      }
      function disableScrollPropagation(el) {
        addOne(el, "wheel", stopPropagation);
        return this;
      }
      function disableClickPropagation(el) {
        on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
        el["_leaflet_disable_click"] = true;
        return this;
      }
      function preventDefault(e3) {
        if (e3.preventDefault) {
          e3.preventDefault();
        } else {
          e3.returnValue = false;
        }
        return this;
      }
      function stop(e3) {
        preventDefault(e3);
        stopPropagation(e3);
        return this;
      }
      function getPropagationPath(ev) {
        if (ev.composedPath) {
          return ev.composedPath();
        }
        var path2 = [];
        var el = ev.target;
        while (el) {
          path2.push(el);
          el = el.parentNode;
        }
        return path2;
      }
      function getMousePosition(e3, container) {
        if (!container) {
          return new Point(e3.clientX, e3.clientY);
        }
        var scale2 = getScale(container), offset = scale2.boundingClientRect;
        return new Point(
          // offset.left/top values are in page scale (like clientX/Y),
          // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
          (e3.clientX - offset.left) / scale2.x - container.clientLeft,
          (e3.clientY - offset.top) / scale2.y - container.clientTop
        );
      }
      var wheelPxFactor = Browser2.linux && Browser2.chrome ? window.devicePixelRatio : Browser2.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
      function getWheelDelta(e3) {
        return Browser2.edge ? e3.wheelDeltaY / 2 : (
          // Don't trust window-geometry-based delta
          e3.deltaY && e3.deltaMode === 0 ? -e3.deltaY / wheelPxFactor : (
            // Pixels
            e3.deltaY && e3.deltaMode === 1 ? -e3.deltaY * 20 : (
              // Lines
              e3.deltaY && e3.deltaMode === 2 ? -e3.deltaY * 60 : (
                // Pages
                e3.deltaX || e3.deltaZ ? 0 : (
                  // Skip horizontal/depth wheel events
                  e3.wheelDelta ? (e3.wheelDeltaY || e3.wheelDelta) / 2 : (
                    // Legacy IE pixels
                    e3.detail && Math.abs(e3.detail) < 32765 ? -e3.detail * 20 : (
                      // Legacy Moz lines
                      e3.detail ? e3.detail / -32765 * 60 : (
                        // Legacy Moz pages
                        0
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
      function isExternalTarget(el, e3) {
        var related = e3.relatedTarget;
        if (!related) {
          return true;
        }
        try {
          while (related && related !== el) {
            related = related.parentNode;
          }
        } catch (err) {
          return false;
        }
        return related !== el;
      }
      var DomEvent = {
        __proto__: null,
        on,
        off,
        stopPropagation,
        disableScrollPropagation,
        disableClickPropagation,
        preventDefault,
        stop,
        getPropagationPath,
        getMousePosition,
        getWheelDelta,
        isExternalTarget,
        addListener: on,
        removeListener: off
      };
      var PosAnimation = Evented.extend({
        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
        // Run an animation of a given element to a new position, optionally setting
        // duration in seconds (`0.25` by default) and easing linearity factor (3rd
        // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
        // `0.5` by default).
        run: function(el, newPos, duration, easeLinearity) {
          this.stop();
          this._el = el;
          this._inProgress = true;
          this._duration = duration || 0.25;
          this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
          this._startPos = getPosition(el);
          this._offset = newPos.subtract(this._startPos);
          this._startTime = +/* @__PURE__ */ new Date();
          this.fire("start");
          this._animate();
        },
        // @method stop()
        // Stops the animation (if currently running).
        stop: function() {
          if (!this._inProgress) {
            return;
          }
          this._step(true);
          this._complete();
        },
        _animate: function() {
          this._animId = requestAnimFrame(this._animate, this);
          this._step();
        },
        _step: function(round2) {
          var elapsed = +/* @__PURE__ */ new Date() - this._startTime, duration = this._duration * 1e3;
          if (elapsed < duration) {
            this._runFrame(this._easeOut(elapsed / duration), round2);
          } else {
            this._runFrame(1);
            this._complete();
          }
        },
        _runFrame: function(progress, round2) {
          var pos = this._startPos.add(this._offset.multiplyBy(progress));
          if (round2) {
            pos._round();
          }
          setPosition(this._el, pos);
          this.fire("step");
        },
        _complete: function() {
          cancelAnimFrame(this._animId);
          this._inProgress = false;
          this.fire("end");
        },
        _easeOut: function(t2) {
          return 1 - Math.pow(1 - t2, this._easeOutPower);
        }
      });
      var Map2 = Evented.extend({
        options: {
          // @section Map State Options
          // @option crs: CRS = L.CRS.EPSG3857
          // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
          // sure what it means.
          crs: EPSG3857,
          // @option center: LatLng = undefined
          // Initial geographic center of the map
          center: void 0,
          // @option zoom: Number = undefined
          // Initial map zoom level
          zoom: void 0,
          // @option minZoom: Number = *
          // Minimum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the lowest of their `minZoom` options will be used instead.
          minZoom: void 0,
          // @option maxZoom: Number = *
          // Maximum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the highest of their `maxZoom` options will be used instead.
          maxZoom: void 0,
          // @option layers: Layer[] = []
          // Array of layers that will be added to the map initially
          layers: [],
          // @option maxBounds: LatLngBounds = null
          // When this option is set, the map restricts the view to the given
          // geographical bounds, bouncing the user back if the user tries to pan
          // outside the view. To set the restriction dynamically, use
          // [`setMaxBounds`](#map-setmaxbounds) method.
          maxBounds: void 0,
          // @option renderer: Renderer = *
          // The default method for drawing vector layers on the map. `L.SVG`
          // or `L.Canvas` by default depending on browser support.
          renderer: void 0,
          // @section Animation Options
          // @option zoomAnimation: Boolean = true
          // Whether the map zoom animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          zoomAnimation: true,
          // @option zoomAnimationThreshold: Number = 4
          // Won't animate zoom if the zoom difference exceeds this value.
          zoomAnimationThreshold: 4,
          // @option fadeAnimation: Boolean = true
          // Whether the tile fade animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          fadeAnimation: true,
          // @option markerZoomAnimation: Boolean = true
          // Whether markers animate their zoom with the zoom animation, if disabled
          // they will disappear for the length of the animation. By default it's
          // enabled in all browsers that support CSS3 Transitions except Android.
          markerZoomAnimation: true,
          // @option transform3DLimit: Number = 2^23
          // Defines the maximum size of a CSS translation transform. The default
          // value should not be changed unless a web browser positions layers in
          // the wrong place after doing a large `panBy`.
          transform3DLimit: 8388608,
          // Precision limit of a 32-bit float
          // @section Interaction Options
          // @option zoomSnap: Number = 1
          // Forces the map's zoom level to always be a multiple of this, particularly
          // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
          // By default, the zoom level snaps to the nearest integer; lower values
          // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
          // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
          zoomSnap: 1,
          // @option zoomDelta: Number = 1
          // Controls how much the map's zoom level will change after a
          // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
          // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
          // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
          zoomDelta: 1,
          // @option trackResize: Boolean = true
          // Whether the map automatically handles browser window resize to update itself.
          trackResize: true
        },
        initialize: function(id, options) {
          options = setOptions(this, options);
          this._handlers = [];
          this._layers = {};
          this._zoomBoundLayers = {};
          this._sizeChanged = true;
          this._initContainer(id);
          this._initLayout();
          this._onResize = bind(this._onResize, this);
          this._initEvents();
          if (options.maxBounds) {
            this.setMaxBounds(options.maxBounds);
          }
          if (options.zoom !== void 0) {
            this._zoom = this._limitZoom(options.zoom);
          }
          if (options.center && options.zoom !== void 0) {
            this.setView(toLatLng(options.center), options.zoom, { reset: true });
          }
          this.callInitHooks();
          this._zoomAnimated = TRANSITION && Browser2.any3d && !Browser2.mobileOpera && this.options.zoomAnimation;
          if (this._zoomAnimated) {
            this._createAnimProxy();
            on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
          }
          this._addLayers(this.options.layers);
        },
        // @section Methods for modifying map state
        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) with the given
        // animation options.
        setView: function(center, zoom2, options) {
          zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
          center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
          options = options || {};
          this._stop();
          if (this._loaded && !options.reset && options !== true) {
            if (options.animate !== void 0) {
              options.zoom = extend2({ animate: options.animate }, options.zoom);
              options.pan = extend2({ animate: options.animate, duration: options.duration }, options.pan);
            }
            var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options.zoom) : this._tryAnimatedPan(center, options.pan);
            if (moved) {
              clearTimeout(this._sizeTimer);
              return this;
            }
          }
          this._resetView(center, zoom2, options.pan && options.pan.noMoveStart);
          return this;
        },
        // @method setZoom(zoom: Number, options?: Zoom/pan options): this
        // Sets the zoom of the map.
        setZoom: function(zoom2, options) {
          if (!this._loaded) {
            this._zoom = zoom2;
            return this;
          }
          return this.setView(this.getCenter(), zoom2, { zoom: options });
        },
        // @method zoomIn(delta?: Number, options?: Zoom options): this
        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomIn: function(delta, options) {
          delta = delta || (Browser2.any3d ? this.options.zoomDelta : 1);
          return this.setZoom(this._zoom + delta, options);
        },
        // @method zoomOut(delta?: Number, options?: Zoom options): this
        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomOut: function(delta, options) {
          delta = delta || (Browser2.any3d ? this.options.zoomDelta : 1);
          return this.setZoom(this._zoom - delta, options);
        },
        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified geographical point on the map
        // stationary (e.g. used internally for scroll zoom and double-click zoom).
        // @alternative
        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
        setZoomAround: function(latlng, zoom2, options) {
          var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
          return this.setView(newCenter, zoom2, { zoom: options });
        },
        _getBoundsCenterZoom: function(bounds, options) {
          options = options || {};
          bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
          var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
          zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
          if (zoom2 === Infinity) {
            return {
              center: bounds.getCenter(),
              zoom: zoom2
            };
          }
          var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
          return {
            center,
            zoom: zoom2
          };
        },
        // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets a map view that contains the given geographical bounds with the
        // maximum zoom level possible.
        fitBounds: function(bounds, options) {
          bounds = toLatLngBounds(bounds);
          if (!bounds.isValid()) {
            throw new Error("Bounds are not valid.");
          }
          var target = this._getBoundsCenterZoom(bounds, options);
          return this.setView(target.center, target.zoom, options);
        },
        // @method fitWorld(options?: fitBounds options): this
        // Sets a map view that mostly contains the whole world with the maximum
        // zoom level possible.
        fitWorld: function(options) {
          return this.fitBounds([[-90, -180], [90, 180]], options);
        },
        // @method panTo(latlng: LatLng, options?: Pan options): this
        // Pans the map to a given center.
        panTo: function(center, options) {
          return this.setView(center, this._zoom, { pan: options });
        },
        // @method panBy(offset: Point, options?: Pan options): this
        // Pans the map by a given number of pixels (animated).
        panBy: function(offset, options) {
          offset = toPoint(offset).round();
          options = options || {};
          if (!offset.x && !offset.y) {
            return this.fire("moveend");
          }
          if (options.animate !== true && !this.getSize().contains(offset)) {
            this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
            return this;
          }
          if (!this._panAnim) {
            this._panAnim = new PosAnimation();
            this._panAnim.on({
              "step": this._onPanTransitionStep,
              "end": this._onPanTransitionEnd
            }, this);
          }
          if (!options.noMoveStart) {
            this.fire("movestart");
          }
          if (options.animate !== false) {
            addClass(this._mapPane, "leaflet-pan-anim");
            var newPos = this._getMapPanePos().subtract(offset).round();
            this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
          } else {
            this._rawPanBy(offset);
            this.fire("move").fire("moveend");
          }
          return this;
        },
        // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) performing a smooth
        // pan-zoom animation.
        flyTo: function(targetCenter, targetZoom, options) {
          options = options || {};
          if (options.animate === false || !Browser2.any3d) {
            return this.setView(targetCenter, targetZoom, options);
          }
          this._stop();
          var from2 = this.project(this.getCenter()), to2 = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
          targetCenter = toLatLng(targetCenter);
          targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
          var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to2.distanceTo(from2) || 1, rho = 1.42, rho2 = rho * rho;
          function r2(i2) {
            var s1 = i2 ? -1 : 1, s2 = i2 ? w1 : w0, t12 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b2 = t12 / b1, sq = Math.sqrt(b2 * b2 + 1) - b2;
            var log2 = sq < 1e-9 ? -18 : Math.log(sq);
            return log2;
          }
          function sinh(n2) {
            return (Math.exp(n2) - Math.exp(-n2)) / 2;
          }
          function cosh(n2) {
            return (Math.exp(n2) + Math.exp(-n2)) / 2;
          }
          function tanh(n2) {
            return sinh(n2) / cosh(n2);
          }
          var r0 = r2(0);
          function w2(s2) {
            return w0 * (cosh(r0) / cosh(r0 + rho * s2));
          }
          function u2(s2) {
            return w0 * (cosh(r0) * tanh(r0 + rho * s2) - sinh(r0)) / rho2;
          }
          function easeOut(t2) {
            return 1 - Math.pow(1 - t2, 1.5);
          }
          var start = Date.now(), S2 = (r2(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S2 * 0.8;
          function frame() {
            var t2 = (Date.now() - start) / duration, s2 = easeOut(t2) * S2;
            if (t2 <= 1) {
              this._flyToFrame = requestAnimFrame(frame, this);
              this._move(
                this.unproject(from2.add(to2.subtract(from2).multiplyBy(u2(s2) / u1)), startZoom),
                this.getScaleZoom(w0 / w2(s2), startZoom),
                { flyTo: true }
              );
            } else {
              this._move(targetCenter, targetZoom)._moveEnd(true);
            }
          }
          this._moveStart(true, options.noMoveStart);
          frame.call(this);
          return this;
        },
        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
        flyToBounds: function(bounds, options) {
          var target = this._getBoundsCenterZoom(bounds, options);
          return this.flyTo(target.center, target.zoom, options);
        },
        // @method setMaxBounds(bounds: LatLngBounds): this
        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
        setMaxBounds: function(bounds) {
          bounds = toLatLngBounds(bounds);
          if (this.listens("moveend", this._panInsideMaxBounds)) {
            this.off("moveend", this._panInsideMaxBounds);
          }
          if (!bounds.isValid()) {
            this.options.maxBounds = null;
            return this;
          }
          this.options.maxBounds = bounds;
          if (this._loaded) {
            this._panInsideMaxBounds();
          }
          return this.on("moveend", this._panInsideMaxBounds);
        },
        // @method setMinZoom(zoom: Number): this
        // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
        setMinZoom: function(zoom2) {
          var oldZoom = this.options.minZoom;
          this.options.minZoom = zoom2;
          if (this._loaded && oldZoom !== zoom2) {
            this.fire("zoomlevelschange");
            if (this.getZoom() < this.options.minZoom) {
              return this.setZoom(zoom2);
            }
          }
          return this;
        },
        // @method setMaxZoom(zoom: Number): this
        // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
        setMaxZoom: function(zoom2) {
          var oldZoom = this.options.maxZoom;
          this.options.maxZoom = zoom2;
          if (this._loaded && oldZoom !== zoom2) {
            this.fire("zoomlevelschange");
            if (this.getZoom() > this.options.maxZoom) {
              return this.setZoom(zoom2);
            }
          }
          return this;
        },
        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
        panInsideBounds: function(bounds, options) {
          this._enforcingBounds = true;
          var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
          if (!center.equals(newCenter)) {
            this.panTo(newCenter, options);
          }
          this._enforcingBounds = false;
          return this;
        },
        // @method panInside(latlng: LatLng, options?: padding options): this
        // Pans the map the minimum amount to make the `latlng` visible. Use
        // padding options to fit the display to more restricted bounds.
        // If `latlng` is already within the (optionally padded) display bounds,
        // the map will not be panned.
        panInside: function(latlng, options) {
          options = options || {};
          var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
          if (!paddedBounds.contains(pixelPoint)) {
            this._enforcingBounds = true;
            var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
            var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
            pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
            pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
            this.panTo(this.unproject(pixelCenter), options);
            this._enforcingBounds = false;
          }
          return this;
        },
        // @method invalidateSize(options: Zoom/pan options): this
        // Checks if the map container size changed and updates the map if so 
        // call it after you've changed the map size dynamically, also animating
        // pan by default. If `options.pan` is `false`, panning will not occur.
        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
        // that it doesn't happen often even if the method is called many
        // times in a row.
        // @alternative
        // @method invalidateSize(animate: Boolean): this
        // Checks if the map container size changed and updates the map if so 
        // call it after you've changed the map size dynamically, also animating
        // pan by default.
        invalidateSize: function(options) {
          if (!this._loaded) {
            return this;
          }
          options = extend2({
            animate: false,
            pan: true
          }, options === true ? { animate: true } : options);
          var oldSize = this.getSize();
          this._sizeChanged = true;
          this._lastCenter = null;
          var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
          if (!offset.x && !offset.y) {
            return this;
          }
          if (options.animate && options.pan) {
            this.panBy(offset);
          } else {
            if (options.pan) {
              this._rawPanBy(offset);
            }
            this.fire("move");
            if (options.debounceMoveend) {
              clearTimeout(this._sizeTimer);
              this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
            } else {
              this.fire("moveend");
            }
          }
          return this.fire("resize", {
            oldSize,
            newSize
          });
        },
        // @section Methods for modifying map state
        // @method stop(): this
        // Stops the currently running `panTo` or `flyTo` animation, if any.
        stop: function() {
          this.setZoom(this._limitZoom(this._zoom));
          if (!this.options.zoomSnap) {
            this.fire("viewreset");
          }
          return this._stop();
        },
        // @section Geolocation methods
        // @method locate(options?: Locate options): this
        // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
        // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
        // and optionally sets the map view to the user's location with respect to
        // detection accuracy (or to the world view if geolocation failed).
        // Note that, if your page doesn't use HTTPS, this method will fail in
        // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
        // See `Locate options` for more details.
        locate: function(options) {
          options = this._locateOptions = extend2({
            timeout: 1e4,
            watch: false
            // setView: false
            // maxZoom: <Number>
            // maximumAge: 0
            // enableHighAccuracy: false
          }, options);
          if (!("geolocation" in navigator)) {
            this._handleGeolocationError({
              code: 0,
              message: "Geolocation not supported."
            });
            return this;
          }
          var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
          if (options.watch) {
            this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
          } else {
            navigator.geolocation.getCurrentPosition(onResponse, onError, options);
          }
          return this;
        },
        // @method stopLocate(): this
        // Stops watching location previously initiated by `map.locate({watch: true})`
        // and aborts resetting the map view if map.locate was called with
        // `{setView: true}`.
        stopLocate: function() {
          if (navigator.geolocation && navigator.geolocation.clearWatch) {
            navigator.geolocation.clearWatch(this._locationWatchId);
          }
          if (this._locateOptions) {
            this._locateOptions.setView = false;
          }
          return this;
        },
        _handleGeolocationError: function(error) {
          if (!this._container._leaflet_id) {
            return;
          }
          var c2 = error.code, message = error.message || (c2 === 1 ? "permission denied" : c2 === 2 ? "position unavailable" : "timeout");
          if (this._locateOptions.setView && !this._loaded) {
            this.fitWorld();
          }
          this.fire("locationerror", {
            code: c2,
            message: "Geolocation error: " + message + "."
          });
        },
        _handleGeolocationResponse: function(pos) {
          if (!this._container._leaflet_id) {
            return;
          }
          var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
          if (options.setView) {
            var zoom2 = this.getBoundsZoom(bounds);
            this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
          }
          var data = {
            latlng,
            bounds,
            timestamp: pos.timestamp
          };
          for (var i2 in pos.coords) {
            if (typeof pos.coords[i2] === "number") {
              data[i2] = pos.coords[i2];
            }
          }
          this.fire("locationfound", data);
        },
        // TODO Appropriate docs section?
        // @section Other Methods
        // @method addHandler(name: String, HandlerClass: Function): this
        // Adds a new `Handler` to the map, given its name and constructor function.
        addHandler: function(name, HandlerClass) {
          if (!HandlerClass) {
            return this;
          }
          var handler = this[name] = new HandlerClass(this);
          this._handlers.push(handler);
          if (this.options[name]) {
            handler.enable();
          }
          return this;
        },
        // @method remove(): this
        // Destroys the map and clears all related event listeners.
        remove: function() {
          this._initEvents(true);
          if (this.options.maxBounds) {
            this.off("moveend", this._panInsideMaxBounds);
          }
          if (this._containerId !== this._container._leaflet_id) {
            throw new Error("Map container is being reused by another instance");
          }
          try {
            delete this._container._leaflet_id;
            delete this._containerId;
          } catch (e3) {
            this._container._leaflet_id = void 0;
            this._containerId = void 0;
          }
          if (this._locationWatchId !== void 0) {
            this.stopLocate();
          }
          this._stop();
          remove(this._mapPane);
          if (this._clearControlPos) {
            this._clearControlPos();
          }
          if (this._resizeRequest) {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = null;
          }
          this._clearHandlers();
          if (this._loaded) {
            this.fire("unload");
          }
          var i2;
          for (i2 in this._layers) {
            this._layers[i2].remove();
          }
          for (i2 in this._panes) {
            remove(this._panes[i2]);
          }
          this._layers = [];
          this._panes = [];
          delete this._mapPane;
          delete this._renderer;
          return this;
        },
        // @section Other Methods
        // @method createPane(name: String, container?: HTMLElement): HTMLElement
        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
        // then returns it. The pane is created as a child of `container`, or
        // as a child of the main map pane if not set.
        createPane: function(name, container) {
          var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
          if (name) {
            this._panes[name] = pane;
          }
          return pane;
        },
        // @section Methods for Getting Map State
        // @method getCenter(): LatLng
        // Returns the geographical center of the map view
        getCenter: function() {
          this._checkIfLoaded();
          if (this._lastCenter && !this._moved()) {
            return this._lastCenter.clone();
          }
          return this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        // @method getZoom(): Number
        // Returns the current zoom level of the map view
        getZoom: function() {
          return this._zoom;
        },
        // @method getBounds(): LatLngBounds
        // Returns the geographical bounds visible in the current map view
        getBounds: function() {
          var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
          return new LatLngBounds(sw, ne);
        },
        // @method getMinZoom(): Number
        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
        getMinZoom: function() {
          return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
        },
        // @method getMaxZoom(): Number
        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
        getMaxZoom: function() {
          return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
        },
        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
        // Returns the maximum zoom level on which the given bounds fit to the map
        // view in its entirety. If `inside` (optional) is set to `true`, the method
        // instead returns the minimum zoom level on which the map view fits into
        // the given bounds in its entirety.
        getBoundsZoom: function(bounds, inside, padding) {
          bounds = toLatLngBounds(bounds);
          padding = toPoint(padding || [0, 0]);
          var zoom2 = this.getZoom() || 0, min2 = this.getMinZoom(), max2 = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser2.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
          zoom2 = this.getScaleZoom(scale2, zoom2);
          if (snap) {
            zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
            zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
          }
          return Math.max(min2, Math.min(max2, zoom2));
        },
        // @method getSize(): Point
        // Returns the current size of the map container (in pixels).
        getSize: function() {
          if (!this._size || this._sizeChanged) {
            this._size = new Point(
              this._container.clientWidth || 0,
              this._container.clientHeight || 0
            );
            this._sizeChanged = false;
          }
          return this._size.clone();
        },
        // @method getPixelBounds(): Bounds
        // Returns the bounds of the current map view in projected pixel
        // coordinates (sometimes useful in layer and overlay implementations).
        getPixelBounds: function(center, zoom2) {
          var topLeftPoint = this._getTopLeftPoint(center, zoom2);
          return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
        },
        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
        // the map pane? "left point of the map layer" can be confusing, specially
        // since there can be negative offsets.
        // @method getPixelOrigin(): Point
        // Returns the projected pixel coordinates of the top left point of
        // the map layer (useful in custom layer and overlay implementations).
        getPixelOrigin: function() {
          this._checkIfLoaded();
          return this._pixelOrigin;
        },
        // @method getPixelWorldBounds(zoom?: Number): Bounds
        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
        // If `zoom` is omitted, the map's current zoom level is used.
        getPixelWorldBounds: function(zoom2) {
          return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
        },
        // @section Other Methods
        // @method getPane(pane: String|HTMLElement): HTMLElement
        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
        getPane: function(pane) {
          return typeof pane === "string" ? this._panes[pane] : pane;
        },
        // @method getPanes(): Object
        // Returns a plain object containing the names of all [panes](#map-pane) as keys and
        // the panes as values.
        getPanes: function() {
          return this._panes;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the map.
        getContainer: function() {
          return this._container;
        },
        // @section Conversion Methods
        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
        // Returns the scale factor to be applied to a map transition from zoom level
        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
        getZoomScale: function(toZoom, fromZoom) {
          var crs = this.options.crs;
          fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
          return crs.scale(toZoom) / crs.scale(fromZoom);
        },
        // @method getScaleZoom(scale: Number, fromZoom: Number): Number
        // Returns the zoom level that the map would end up at, if it is at `fromZoom`
        // level and everything is scaled by a factor of `scale`. Inverse of
        // [`getZoomScale`](#map-getZoomScale).
        getScaleZoom: function(scale2, fromZoom) {
          var crs = this.options.crs;
          fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
          var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
          return isNaN(zoom2) ? Infinity : zoom2;
        },
        // @method project(latlng: LatLng, zoom: Number): Point
        // Projects a geographical coordinate `LatLng` according to the projection
        // of the map's CRS, then scales it according to `zoom` and the CRS's
        // `Transformation`. The result is pixel coordinate relative to
        // the CRS origin.
        project: function(latlng, zoom2) {
          zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
          return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
        },
        // @method unproject(point: Point, zoom: Number): LatLng
        // Inverse of [`project`](#map-project).
        unproject: function(point2, zoom2) {
          zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
          return this.options.crs.pointToLatLng(toPoint(point2), zoom2);
        },
        // @method layerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding geographical coordinate (for the current zoom level).
        layerPointToLatLng: function(point2) {
          var projectedPoint = toPoint(point2).add(this.getPixelOrigin());
          return this.unproject(projectedPoint);
        },
        // @method latLngToLayerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the [origin pixel](#map-getpixelorigin).
        latLngToLayerPoint: function(latlng) {
          var projectedPoint = this.project(toLatLng(latlng))._round();
          return projectedPoint._subtract(this.getPixelOrigin());
        },
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
        // CRS's bounds.
        // By default this means longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees.
        wrapLatLng: function(latlng) {
          return this.options.crs.wrapLatLng(toLatLng(latlng));
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring that
        // its center is within the CRS's bounds.
        // By default this means the center longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees, and the majority of the bounds
        // overlaps the CRS's bounds.
        wrapLatLngBounds: function(latlng) {
          return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates according to
        // the map's CRS. By default this measures distance in meters.
        distance: function(latlng1, latlng2) {
          return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
        },
        // @method containerPointToLayerPoint(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns the corresponding
        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
        containerPointToLayerPoint: function(point2) {
          return toPoint(point2).subtract(this._getMapPanePos());
        },
        // @method layerPointToContainerPoint(point: Point): Point
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding pixel coordinate relative to the map container.
        layerPointToContainerPoint: function(point2) {
          return toPoint(point2).add(this._getMapPanePos());
        },
        // @method containerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the map container, returns
        // the corresponding geographical coordinate (for the current zoom level).
        containerPointToLatLng: function(point2) {
          var layerPoint = this.containerPointToLayerPoint(toPoint(point2));
          return this.layerPointToLatLng(layerPoint);
        },
        // @method latLngToContainerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the map container.
        latLngToContainerPoint: function(latlng) {
          return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
        },
        // @method mouseEventToContainerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to the
        // map container where the event took place.
        mouseEventToContainerPoint: function(e3) {
          return getMousePosition(e3, this._container);
        },
        // @method mouseEventToLayerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to
        // the [origin pixel](#map-getpixelorigin) where the event took place.
        mouseEventToLayerPoint: function(e3) {
          return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e3));
        },
        // @method mouseEventToLatLng(ev: MouseEvent): LatLng
        // Given a MouseEvent object, returns geographical coordinate where the
        // event took place.
        mouseEventToLatLng: function(e3) {
          return this.layerPointToLatLng(this.mouseEventToLayerPoint(e3));
        },
        // map initialization methods
        _initContainer: function(id) {
          var container = this._container = get2(id);
          if (!container) {
            throw new Error("Map container not found.");
          } else if (container._leaflet_id) {
            throw new Error("Map container is already initialized.");
          }
          on(container, "scroll", this._onScroll, this);
          this._containerId = stamp(container);
        },
        _initLayout: function() {
          var container = this._container;
          this._fadeAnimated = this.options.fadeAnimation && Browser2.any3d;
          addClass(container, "leaflet-container" + (Browser2.touch ? " leaflet-touch" : "") + (Browser2.retina ? " leaflet-retina" : "") + (Browser2.ielt9 ? " leaflet-oldie" : "") + (Browser2.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
          var position = getStyle(container, "position");
          if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
            container.style.position = "relative";
          }
          this._initPanes();
          if (this._initControlPos) {
            this._initControlPos();
          }
        },
        _initPanes: function() {
          var panes = this._panes = {};
          this._paneRenderers = {};
          this._mapPane = this.createPane("mapPane", this._container);
          setPosition(this._mapPane, new Point(0, 0));
          this.createPane("tilePane");
          this.createPane("overlayPane");
          this.createPane("shadowPane");
          this.createPane("markerPane");
          this.createPane("tooltipPane");
          this.createPane("popupPane");
          if (!this.options.markerZoomAnimation) {
            addClass(panes.markerPane, "leaflet-zoom-hide");
            addClass(panes.shadowPane, "leaflet-zoom-hide");
          }
        },
        // private methods that modify map state
        // @section Map state change events
        _resetView: function(center, zoom2, noMoveStart) {
          setPosition(this._mapPane, new Point(0, 0));
          var loading = !this._loaded;
          this._loaded = true;
          zoom2 = this._limitZoom(zoom2);
          this.fire("viewprereset");
          var zoomChanged = this._zoom !== zoom2;
          this._moveStart(zoomChanged, noMoveStart)._move(center, zoom2)._moveEnd(zoomChanged);
          this.fire("viewreset");
          if (loading) {
            this.fire("load");
          }
        },
        _moveStart: function(zoomChanged, noMoveStart) {
          if (zoomChanged) {
            this.fire("zoomstart");
          }
          if (!noMoveStart) {
            this.fire("movestart");
          }
          return this;
        },
        _move: function(center, zoom2, data, supressEvent) {
          if (zoom2 === void 0) {
            zoom2 = this._zoom;
          }
          var zoomChanged = this._zoom !== zoom2;
          this._zoom = zoom2;
          this._lastCenter = center;
          this._pixelOrigin = this._getNewPixelOrigin(center);
          if (!supressEvent) {
            if (zoomChanged || data && data.pinch) {
              this.fire("zoom", data);
            }
            this.fire("move", data);
          } else if (data && data.pinch) {
            this.fire("zoom", data);
          }
          return this;
        },
        _moveEnd: function(zoomChanged) {
          if (zoomChanged) {
            this.fire("zoomend");
          }
          return this.fire("moveend");
        },
        _stop: function() {
          cancelAnimFrame(this._flyToFrame);
          if (this._panAnim) {
            this._panAnim.stop();
          }
          return this;
        },
        _rawPanBy: function(offset) {
          setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
        },
        _getZoomSpan: function() {
          return this.getMaxZoom() - this.getMinZoom();
        },
        _panInsideMaxBounds: function() {
          if (!this._enforcingBounds) {
            this.panInsideBounds(this.options.maxBounds);
          }
        },
        _checkIfLoaded: function() {
          if (!this._loaded) {
            throw new Error("Set map center and zoom first.");
          }
        },
        // DOM event handling
        // @section Interaction events
        _initEvents: function(remove2) {
          this._targets = {};
          this._targets[stamp(this._container)] = this;
          var onOff = remove2 ? off : on;
          onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
          if (this.options.trackResize) {
            onOff(window, "resize", this._onResize, this);
          }
          if (Browser2.any3d && this.options.transform3DLimit) {
            (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
          }
        },
        _onResize: function() {
          cancelAnimFrame(this._resizeRequest);
          this._resizeRequest = requestAnimFrame(
            function() {
              this.invalidateSize({ debounceMoveend: true });
            },
            this
          );
        },
        _onScroll: function() {
          this._container.scrollTop = 0;
          this._container.scrollLeft = 0;
        },
        _onMoveEnd: function() {
          var pos = this._getMapPanePos();
          if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
            this._resetView(this.getCenter(), this.getZoom());
          }
        },
        _findEventTargets: function(e3, type) {
          var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e3.target || e3.srcElement, dragging = false;
          while (src) {
            target = this._targets[stamp(src)];
            if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
              dragging = true;
              break;
            }
            if (target && target.listens(type, true)) {
              if (isHover && !isExternalTarget(src, e3)) {
                break;
              }
              targets.push(target);
              if (isHover) {
                break;
              }
            }
            if (src === this._container) {
              break;
            }
            src = src.parentNode;
          }
          if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
            targets = [this];
          }
          return targets;
        },
        _isClickDisabled: function(el) {
          while (el && el !== this._container) {
            if (el["_leaflet_disable_click"]) {
              return true;
            }
            el = el.parentNode;
          }
        },
        _handleDOMEvent: function(e3) {
          var el = e3.target || e3.srcElement;
          if (!this._loaded || el["_leaflet_disable_events"] || e3.type === "click" && this._isClickDisabled(el)) {
            return;
          }
          var type = e3.type;
          if (type === "mousedown") {
            preventOutline(el);
          }
          this._fireDOMEvent(e3, type);
        },
        _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
        _fireDOMEvent: function(e3, type, canvasTargets) {
          if (e3.type === "click") {
            var synth = extend2({}, e3);
            synth.type = "preclick";
            this._fireDOMEvent(synth, synth.type, canvasTargets);
          }
          var targets = this._findEventTargets(e3, type);
          if (canvasTargets) {
            var filtered = [];
            for (var i2 = 0; i2 < canvasTargets.length; i2++) {
              if (canvasTargets[i2].listens(type, true)) {
                filtered.push(canvasTargets[i2]);
              }
            }
            targets = filtered.concat(targets);
          }
          if (!targets.length) {
            return;
          }
          if (type === "contextmenu") {
            preventDefault(e3);
          }
          var target = targets[0];
          var data = {
            originalEvent: e3
          };
          if (e3.type !== "keypress" && e3.type !== "keydown" && e3.type !== "keyup") {
            var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
            data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e3);
            data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
            data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
          }
          for (i2 = 0; i2 < targets.length; i2++) {
            targets[i2].fire(type, data, true);
            if (data.originalEvent._stopped || targets[i2].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
              return;
            }
          }
        },
        _draggableMoved: function(obj) {
          obj = obj.dragging && obj.dragging.enabled() ? obj : this;
          return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
        },
        _clearHandlers: function() {
          for (var i2 = 0, len = this._handlers.length; i2 < len; i2++) {
            this._handlers[i2].disable();
          }
        },
        // @section Other Methods
        // @method whenReady(fn: Function, context?: Object): this
        // Runs the given function `fn` when the map gets initialized with
        // a view (center and zoom) and at least one layer, or immediately
        // if it's already initialized, optionally passing a function context.
        whenReady: function(callback, context) {
          if (this._loaded) {
            callback.call(context || this, { target: this });
          } else {
            this.on("load", callback, context);
          }
          return this;
        },
        // private methods for getting map state
        _getMapPanePos: function() {
          return getPosition(this._mapPane) || new Point(0, 0);
        },
        _moved: function() {
          var pos = this._getMapPanePos();
          return pos && !pos.equals([0, 0]);
        },
        _getTopLeftPoint: function(center, zoom2) {
          var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
          return pixelOrigin.subtract(this._getMapPanePos());
        },
        _getNewPixelOrigin: function(center, zoom2) {
          var viewHalf = this.getSize()._divideBy(2);
          return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
        },
        _latLngToNewLayerPoint: function(latlng, zoom2, center) {
          var topLeft = this._getNewPixelOrigin(center, zoom2);
          return this.project(latlng, zoom2)._subtract(topLeft);
        },
        _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center) {
          var topLeft = this._getNewPixelOrigin(center, zoom2);
          return toBounds([
            this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
          ]);
        },
        // layer point of the current center
        _getCenterLayerPoint: function() {
          return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        // offset of the specified place to the current center in pixels
        _getCenterOffset: function(latlng) {
          return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
        },
        // adjust center for view to get inside bounds
        _limitCenter: function(center, zoom2, bounds) {
          if (!bounds) {
            return center;
          }
          var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
          if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
            return center;
          }
          return this.unproject(centerPoint.add(offset), zoom2);
        },
        // adjust offset for view to get inside bounds
        _limitOffset: function(offset, bounds) {
          if (!bounds) {
            return offset;
          }
          var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
          return offset.add(this._getBoundsOffset(newBounds, bounds));
        },
        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
          var projectedMaxBounds = toBounds(
            this.project(maxBounds.getNorthEast(), zoom2),
            this.project(maxBounds.getSouthWest(), zoom2)
          ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
          return new Point(dx, dy);
        },
        _rebound: function(left, right) {
          return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
        },
        _limitZoom: function(zoom2) {
          var min2 = this.getMinZoom(), max2 = this.getMaxZoom(), snap = Browser2.any3d ? this.options.zoomSnap : 1;
          if (snap) {
            zoom2 = Math.round(zoom2 / snap) * snap;
          }
          return Math.max(min2, Math.min(max2, zoom2));
        },
        _onPanTransitionStep: function() {
          this.fire("move");
        },
        _onPanTransitionEnd: function() {
          removeClass(this._mapPane, "leaflet-pan-anim");
          this.fire("moveend");
        },
        _tryAnimatedPan: function(center, options) {
          var offset = this._getCenterOffset(center)._trunc();
          if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
            return false;
          }
          this.panBy(offset, options);
          return true;
        },
        _createAnimProxy: function() {
          var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
          this._panes.mapPane.appendChild(proxy);
          this.on("zoomanim", function(e3) {
            var prop = TRANSFORM, transform = this._proxy.style[prop];
            setTransform(this._proxy, this.project(e3.center, e3.zoom), this.getZoomScale(e3.zoom, 1));
            if (transform === this._proxy.style[prop] && this._animatingZoom) {
              this._onZoomTransitionEnd();
            }
          }, this);
          this.on("load moveend", this._animMoveEnd, this);
          this._on("unload", this._destroyAnimProxy, this);
        },
        _destroyAnimProxy: function() {
          remove(this._proxy);
          this.off("load moveend", this._animMoveEnd, this);
          delete this._proxy;
        },
        _animMoveEnd: function() {
          var c2 = this.getCenter(), z2 = this.getZoom();
          setTransform(this._proxy, this.project(c2, z2), this.getZoomScale(z2, 1));
        },
        _catchTransitionEnd: function(e3) {
          if (this._animatingZoom && e3.propertyName.indexOf("transform") >= 0) {
            this._onZoomTransitionEnd();
          }
        },
        _nothingToAnimate: function() {
          return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function(center, zoom2, options) {
          if (this._animatingZoom) {
            return true;
          }
          options = options || {};
          if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
            return false;
          }
          var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale2);
          if (options.animate !== true && !this.getSize().contains(offset)) {
            return false;
          }
          requestAnimFrame(function() {
            this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom2, true);
          }, this);
          return true;
        },
        _animateZoom: function(center, zoom2, startAnim, noUpdate) {
          if (!this._mapPane) {
            return;
          }
          if (startAnim) {
            this._animatingZoom = true;
            this._animateToCenter = center;
            this._animateToZoom = zoom2;
            addClass(this._mapPane, "leaflet-zoom-anim");
          }
          this.fire("zoomanim", {
            center,
            zoom: zoom2,
            noUpdate
          });
          if (!this._tempFireZoomEvent) {
            this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
          }
          this._move(this._animateToCenter, this._animateToZoom, void 0, true);
          setTimeout(bind(this._onZoomTransitionEnd, this), 250);
        },
        _onZoomTransitionEnd: function() {
          if (!this._animatingZoom) {
            return;
          }
          if (this._mapPane) {
            removeClass(this._mapPane, "leaflet-zoom-anim");
          }
          this._animatingZoom = false;
          this._move(this._animateToCenter, this._animateToZoom, void 0, true);
          if (this._tempFireZoomEvent) {
            this.fire("zoom");
          }
          delete this._tempFireZoomEvent;
          this.fire("move");
          this._moveEnd(true);
        }
      });
      function createMap(id, options) {
        return new Map2(id, options);
      }
      var Control = Class.extend({
        // @section
        // @aka Control Options
        options: {
          // @option position: String = 'topright'
          // The position of the control (one of the map corners). Possible values are `'topleft'`,
          // `'topright'`, `'bottomleft'` or `'bottomright'`
          position: "topright"
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        /* @section
         * Classes extending L.Control will inherit the following methods:
         *
         * @method getPosition: string
         * Returns the position of the control.
         */
        getPosition: function() {
          return this.options.position;
        },
        // @method setPosition(position: string): this
        // Sets the position of the control.
        setPosition: function(position) {
          var map2 = this._map;
          if (map2) {
            map2.removeControl(this);
          }
          this.options.position = position;
          if (map2) {
            map2.addControl(this);
          }
          return this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTMLElement that contains the control.
        getContainer: function() {
          return this._container;
        },
        // @method addTo(map: Map): this
        // Adds the control to the given map.
        addTo: function(map2) {
          this.remove();
          this._map = map2;
          var container = this._container = this.onAdd(map2), pos = this.getPosition(), corner = map2._controlCorners[pos];
          addClass(container, "leaflet-control");
          if (pos.indexOf("bottom") !== -1) {
            corner.insertBefore(container, corner.firstChild);
          } else {
            corner.appendChild(container);
          }
          this._map.on("unload", this.remove, this);
          return this;
        },
        // @method remove: this
        // Removes the control from the map it is currently active on.
        remove: function() {
          if (!this._map) {
            return this;
          }
          remove(this._container);
          if (this.onRemove) {
            this.onRemove(this._map);
          }
          this._map.off("unload", this.remove, this);
          this._map = null;
          return this;
        },
        _refocusOnMap: function(e3) {
          if (this._map && e3 && e3.screenX > 0 && e3.screenY > 0) {
            this._map.getContainer().focus();
          }
        }
      });
      var control = function(options) {
        return new Control(options);
      };
      Map2.include({
        // @method addControl(control: Control): this
        // Adds the given control to the map
        addControl: function(control2) {
          control2.addTo(this);
          return this;
        },
        // @method removeControl(control: Control): this
        // Removes the given control from the map
        removeControl: function(control2) {
          control2.remove();
          return this;
        },
        _initControlPos: function() {
          var corners = this._controlCorners = {}, l2 = "leaflet-", container = this._controlContainer = create$1("div", l2 + "control-container", this._container);
          function createCorner(vSide, hSide) {
            var className = l2 + vSide + " " + l2 + hSide;
            corners[vSide + hSide] = create$1("div", className, container);
          }
          createCorner("top", "left");
          createCorner("top", "right");
          createCorner("bottom", "left");
          createCorner("bottom", "right");
        },
        _clearControlPos: function() {
          for (var i2 in this._controlCorners) {
            remove(this._controlCorners[i2]);
          }
          remove(this._controlContainer);
          delete this._controlCorners;
          delete this._controlContainer;
        }
      });
      var Layers = Control.extend({
        // @section
        // @aka Control.Layers options
        options: {
          // @option collapsed: Boolean = true
          // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
          collapsed: true,
          position: "topright",
          // @option autoZIndex: Boolean = true
          // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
          autoZIndex: true,
          // @option hideSingleBase: Boolean = false
          // If `true`, the base layers in the control will be hidden when there is only one.
          hideSingleBase: false,
          // @option sortLayers: Boolean = false
          // Whether to sort the layers. When `false`, layers will keep the order
          // in which they were added to the control.
          sortLayers: false,
          // @option sortFunction: Function = *
          // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
          // that will be used for sorting the layers, when `sortLayers` is `true`.
          // The function receives both the `L.Layer` instances and their names, as in
          // `sortFunction(layerA, layerB, nameA, nameB)`.
          // By default, it sorts layers alphabetically by their name.
          sortFunction: function(layerA, layerB, nameA, nameB) {
            return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
          }
        },
        initialize: function(baseLayers, overlays, options) {
          setOptions(this, options);
          this._layerControlInputs = [];
          this._layers = [];
          this._lastZIndex = 0;
          this._handlingClick = false;
          this._preventClick = false;
          for (var i2 in baseLayers) {
            this._addLayer(baseLayers[i2], i2);
          }
          for (i2 in overlays) {
            this._addLayer(overlays[i2], i2, true);
          }
        },
        onAdd: function(map2) {
          this._initLayout();
          this._update();
          this._map = map2;
          map2.on("zoomend", this._checkDisabledLayers, this);
          for (var i2 = 0; i2 < this._layers.length; i2++) {
            this._layers[i2].layer.on("add remove", this._onLayerChange, this);
          }
          return this._container;
        },
        addTo: function(map2) {
          Control.prototype.addTo.call(this, map2);
          return this._expandIfNotCollapsed();
        },
        onRemove: function() {
          this._map.off("zoomend", this._checkDisabledLayers, this);
          for (var i2 = 0; i2 < this._layers.length; i2++) {
            this._layers[i2].layer.off("add remove", this._onLayerChange, this);
          }
        },
        // @method addBaseLayer(layer: Layer, name: String): this
        // Adds a base layer (radio button entry) with the given name to the control.
        addBaseLayer: function(layer, name) {
          this._addLayer(layer, name);
          return this._map ? this._update() : this;
        },
        // @method addOverlay(layer: Layer, name: String): this
        // Adds an overlay (checkbox entry) with the given name to the control.
        addOverlay: function(layer, name) {
          this._addLayer(layer, name, true);
          return this._map ? this._update() : this;
        },
        // @method removeLayer(layer: Layer): this
        // Remove the given layer from the control.
        removeLayer: function(layer) {
          layer.off("add remove", this._onLayerChange, this);
          var obj = this._getLayer(stamp(layer));
          if (obj) {
            this._layers.splice(this._layers.indexOf(obj), 1);
          }
          return this._map ? this._update() : this;
        },
        // @method expand(): this
        // Expand the control container if collapsed.
        expand: function() {
          addClass(this._container, "leaflet-control-layers-expanded");
          this._section.style.height = null;
          var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
          if (acceptableHeight < this._section.clientHeight) {
            addClass(this._section, "leaflet-control-layers-scrollbar");
            this._section.style.height = acceptableHeight + "px";
          } else {
            removeClass(this._section, "leaflet-control-layers-scrollbar");
          }
          this._checkDisabledLayers();
          return this;
        },
        // @method collapse(): this
        // Collapse the control container if expanded.
        collapse: function() {
          removeClass(this._container, "leaflet-control-layers-expanded");
          return this;
        },
        _initLayout: function() {
          var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
          container.setAttribute("aria-haspopup", true);
          disableClickPropagation(container);
          disableScrollPropagation(container);
          var section = this._section = create$1("section", className + "-list");
          if (collapsed) {
            this._map.on("click", this.collapse, this);
            on(container, {
              mouseenter: this._expandSafely,
              mouseleave: this.collapse
            }, this);
          }
          var link = this._layersLink = create$1("a", className + "-toggle", container);
          link.href = "#";
          link.title = "Layers";
          link.setAttribute("role", "button");
          on(link, {
            keydown: function(e3) {
              if (e3.keyCode === 13) {
                this._expandSafely();
              }
            },
            // Certain screen readers intercept the key event and instead send a click event
            click: function(e3) {
              preventDefault(e3);
              this._expandSafely();
            }
          }, this);
          if (!collapsed) {
            this.expand();
          }
          this._baseLayersList = create$1("div", className + "-base", section);
          this._separator = create$1("div", className + "-separator", section);
          this._overlaysList = create$1("div", className + "-overlays", section);
          container.appendChild(section);
        },
        _getLayer: function(id) {
          for (var i2 = 0; i2 < this._layers.length; i2++) {
            if (this._layers[i2] && stamp(this._layers[i2].layer) === id) {
              return this._layers[i2];
            }
          }
        },
        _addLayer: function(layer, name, overlay) {
          if (this._map) {
            layer.on("add remove", this._onLayerChange, this);
          }
          this._layers.push({
            layer,
            name,
            overlay
          });
          if (this.options.sortLayers) {
            this._layers.sort(bind(function(a2, b2) {
              return this.options.sortFunction(a2.layer, b2.layer, a2.name, b2.name);
            }, this));
          }
          if (this.options.autoZIndex && layer.setZIndex) {
            this._lastZIndex++;
            layer.setZIndex(this._lastZIndex);
          }
          this._expandIfNotCollapsed();
        },
        _update: function() {
          if (!this._container) {
            return this;
          }
          empty(this._baseLayersList);
          empty(this._overlaysList);
          this._layerControlInputs = [];
          var baseLayersPresent, overlaysPresent, i2, obj, baseLayersCount = 0;
          for (i2 = 0; i2 < this._layers.length; i2++) {
            obj = this._layers[i2];
            this._addItem(obj);
            overlaysPresent = overlaysPresent || obj.overlay;
            baseLayersPresent = baseLayersPresent || !obj.overlay;
            baseLayersCount += !obj.overlay ? 1 : 0;
          }
          if (this.options.hideSingleBase) {
            baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
            this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
          }
          this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
          return this;
        },
        _onLayerChange: function(e3) {
          if (!this._handlingClick) {
            this._update();
          }
          var obj = this._getLayer(stamp(e3.target));
          var type = obj.overlay ? e3.type === "add" ? "overlayadd" : "overlayremove" : e3.type === "add" ? "baselayerchange" : null;
          if (type) {
            this._map.fire(type, obj);
          }
        },
        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
        _createRadioElement: function(name, checked) {
          var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
          var radioFragment = document.createElement("div");
          radioFragment.innerHTML = radioHtml;
          return radioFragment.firstChild;
        },
        _addItem: function(obj) {
          var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
          if (obj.overlay) {
            input = document.createElement("input");
            input.type = "checkbox";
            input.className = "leaflet-control-layers-selector";
            input.defaultChecked = checked;
          } else {
            input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
          }
          this._layerControlInputs.push(input);
          input.layerId = stamp(obj.layer);
          on(input, "click", this._onInputClick, this);
          var name = document.createElement("span");
          name.innerHTML = " " + obj.name;
          var holder = document.createElement("span");
          label.appendChild(holder);
          holder.appendChild(input);
          holder.appendChild(name);
          var container = obj.overlay ? this._overlaysList : this._baseLayersList;
          container.appendChild(label);
          this._checkDisabledLayers();
          return label;
        },
        _onInputClick: function() {
          if (this._preventClick) {
            return;
          }
          var inputs = this._layerControlInputs, input, layer;
          var addedLayers = [], removedLayers = [];
          this._handlingClick = true;
          for (var i2 = inputs.length - 1; i2 >= 0; i2--) {
            input = inputs[i2];
            layer = this._getLayer(input.layerId).layer;
            if (input.checked) {
              addedLayers.push(layer);
            } else if (!input.checked) {
              removedLayers.push(layer);
            }
          }
          for (i2 = 0; i2 < removedLayers.length; i2++) {
            if (this._map.hasLayer(removedLayers[i2])) {
              this._map.removeLayer(removedLayers[i2]);
            }
          }
          for (i2 = 0; i2 < addedLayers.length; i2++) {
            if (!this._map.hasLayer(addedLayers[i2])) {
              this._map.addLayer(addedLayers[i2]);
            }
          }
          this._handlingClick = false;
          this._refocusOnMap();
        },
        _checkDisabledLayers: function() {
          var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
          for (var i2 = inputs.length - 1; i2 >= 0; i2--) {
            input = inputs[i2];
            layer = this._getLayer(input.layerId).layer;
            input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
          }
        },
        _expandIfNotCollapsed: function() {
          if (this._map && !this.options.collapsed) {
            this.expand();
          }
          return this;
        },
        _expandSafely: function() {
          var section = this._section;
          this._preventClick = true;
          on(section, "click", preventDefault);
          this.expand();
          var that = this;
          setTimeout(function() {
            off(section, "click", preventDefault);
            that._preventClick = false;
          });
        }
      });
      var layers = function(baseLayers, overlays, options) {
        return new Layers(baseLayers, overlays, options);
      };
      var Zoom = Control.extend({
        // @section
        // @aka Control.Zoom options
        options: {
          position: "topleft",
          // @option zoomInText: String = '<span aria-hidden="true">+</span>'
          // The text set on the 'zoom in' button.
          zoomInText: '<span aria-hidden="true">+</span>',
          // @option zoomInTitle: String = 'Zoom in'
          // The title set on the 'zoom in' button.
          zoomInTitle: "Zoom in",
          // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
          // The text set on the 'zoom out' button.
          zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
          // @option zoomOutTitle: String = 'Zoom out'
          // The title set on the 'zoom out' button.
          zoomOutTitle: "Zoom out"
        },
        onAdd: function(map2) {
          var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
          this._zoomInButton = this._createButton(
            options.zoomInText,
            options.zoomInTitle,
            zoomName + "-in",
            container,
            this._zoomIn
          );
          this._zoomOutButton = this._createButton(
            options.zoomOutText,
            options.zoomOutTitle,
            zoomName + "-out",
            container,
            this._zoomOut
          );
          this._updateDisabled();
          map2.on("zoomend zoomlevelschange", this._updateDisabled, this);
          return container;
        },
        onRemove: function(map2) {
          map2.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        disable: function() {
          this._disabled = true;
          this._updateDisabled();
          return this;
        },
        enable: function() {
          this._disabled = false;
          this._updateDisabled();
          return this;
        },
        _zoomIn: function(e3) {
          if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
            this._map.zoomIn(this._map.options.zoomDelta * (e3.shiftKey ? 3 : 1));
          }
        },
        _zoomOut: function(e3) {
          if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
            this._map.zoomOut(this._map.options.zoomDelta * (e3.shiftKey ? 3 : 1));
          }
        },
        _createButton: function(html, title, className, container, fn) {
          var link = create$1("a", className, container);
          link.innerHTML = html;
          link.href = "#";
          link.title = title;
          link.setAttribute("role", "button");
          link.setAttribute("aria-label", title);
          disableClickPropagation(link);
          on(link, "click", stop);
          on(link, "click", fn, this);
          on(link, "click", this._refocusOnMap, this);
          return link;
        },
        _updateDisabled: function() {
          var map2 = this._map, className = "leaflet-disabled";
          removeClass(this._zoomInButton, className);
          removeClass(this._zoomOutButton, className);
          this._zoomInButton.setAttribute("aria-disabled", "false");
          this._zoomOutButton.setAttribute("aria-disabled", "false");
          if (this._disabled || map2._zoom === map2.getMinZoom()) {
            addClass(this._zoomOutButton, className);
            this._zoomOutButton.setAttribute("aria-disabled", "true");
          }
          if (this._disabled || map2._zoom === map2.getMaxZoom()) {
            addClass(this._zoomInButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "true");
          }
        }
      });
      Map2.mergeOptions({
        zoomControl: true
      });
      Map2.addInitHook(function() {
        if (this.options.zoomControl) {
          this.zoomControl = new Zoom();
          this.addControl(this.zoomControl);
        }
      });
      var zoom = function(options) {
        return new Zoom(options);
      };
      var Scale = Control.extend({
        // @section
        // @aka Control.Scale options
        options: {
          position: "bottomleft",
          // @option maxWidth: Number = 100
          // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
          maxWidth: 100,
          // @option metric: Boolean = True
          // Whether to show the metric scale line (m/km).
          metric: true,
          // @option imperial: Boolean = True
          // Whether to show the imperial scale line (mi/ft).
          imperial: true
          // @option updateWhenIdle: Boolean = false
          // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
        },
        onAdd: function(map2) {
          var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
          this._addScales(options, className + "-line", container);
          map2.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
          map2.whenReady(this._update, this);
          return container;
        },
        onRemove: function(map2) {
          map2.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function(options, className, container) {
          if (options.metric) {
            this._mScale = create$1("div", className, container);
          }
          if (options.imperial) {
            this._iScale = create$1("div", className, container);
          }
        },
        _update: function() {
          var map2 = this._map, y2 = map2.getSize().y / 2;
          var maxMeters = map2.distance(
            map2.containerPointToLatLng([0, y2]),
            map2.containerPointToLatLng([this.options.maxWidth, y2])
          );
          this._updateScales(maxMeters);
        },
        _updateScales: function(maxMeters) {
          if (this.options.metric && maxMeters) {
            this._updateMetric(maxMeters);
          }
          if (this.options.imperial && maxMeters) {
            this._updateImperial(maxMeters);
          }
        },
        _updateMetric: function(maxMeters) {
          var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
          this._updateScale(this._mScale, label, meters / maxMeters);
        },
        _updateImperial: function(maxMeters) {
          var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
          if (maxFeet > 5280) {
            maxMiles = maxFeet / 5280;
            miles = this._getRoundNum(maxMiles);
            this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
          } else {
            feet = this._getRoundNum(maxFeet);
            this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
          }
        },
        _updateScale: function(scale2, text, ratio) {
          scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
          scale2.innerHTML = text;
        },
        _getRoundNum: function(num) {
          var pow102 = Math.pow(10, (Math.floor(num) + "").length - 1), d2 = num / pow102;
          d2 = d2 >= 10 ? 10 : d2 >= 5 ? 5 : d2 >= 3 ? 3 : d2 >= 2 ? 2 : 1;
          return pow102 * d2;
        }
      });
      var scale = function(options) {
        return new Scale(options);
      };
      var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
      var Attribution = Control.extend({
        // @section
        // @aka Control.Attribution options
        options: {
          position: "bottomright",
          // @option prefix: String|false = 'Leaflet'
          // The HTML text shown before the attributions. Pass `false` to disable.
          prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser2.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
        },
        initialize: function(options) {
          setOptions(this, options);
          this._attributions = {};
        },
        onAdd: function(map2) {
          map2.attributionControl = this;
          this._container = create$1("div", "leaflet-control-attribution");
          disableClickPropagation(this._container);
          for (var i2 in map2._layers) {
            if (map2._layers[i2].getAttribution) {
              this.addAttribution(map2._layers[i2].getAttribution());
            }
          }
          this._update();
          map2.on("layeradd", this._addAttribution, this);
          return this._container;
        },
        onRemove: function(map2) {
          map2.off("layeradd", this._addAttribution, this);
        },
        _addAttribution: function(ev) {
          if (ev.layer.getAttribution) {
            this.addAttribution(ev.layer.getAttribution());
            ev.layer.once("remove", function() {
              this.removeAttribution(ev.layer.getAttribution());
            }, this);
          }
        },
        // @method setPrefix(prefix: String|false): this
        // The HTML text shown before the attributions. Pass `false` to disable.
        setPrefix: function(prefix2) {
          this.options.prefix = prefix2;
          this._update();
          return this;
        },
        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
        addAttribution: function(text) {
          if (!text) {
            return this;
          }
          if (!this._attributions[text]) {
            this._attributions[text] = 0;
          }
          this._attributions[text]++;
          this._update();
          return this;
        },
        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function(text) {
          if (!text) {
            return this;
          }
          if (this._attributions[text]) {
            this._attributions[text]--;
            this._update();
          }
          return this;
        },
        _update: function() {
          if (!this._map) {
            return;
          }
          var attribs = [];
          for (var i2 in this._attributions) {
            if (this._attributions[i2]) {
              attribs.push(i2);
            }
          }
          var prefixAndAttribs = [];
          if (this.options.prefix) {
            prefixAndAttribs.push(this.options.prefix);
          }
          if (attribs.length) {
            prefixAndAttribs.push(attribs.join(", "));
          }
          this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
        }
      });
      Map2.mergeOptions({
        attributionControl: true
      });
      Map2.addInitHook(function() {
        if (this.options.attributionControl) {
          new Attribution().addTo(this);
        }
      });
      var attribution = function(options) {
        return new Attribution(options);
      };
      Control.Layers = Layers;
      Control.Zoom = Zoom;
      Control.Scale = Scale;
      Control.Attribution = Attribution;
      control.layers = layers;
      control.zoom = zoom;
      control.scale = scale;
      control.attribution = attribution;
      var Handler = Class.extend({
        initialize: function(map2) {
          this._map = map2;
        },
        // @method enable(): this
        // Enables the handler
        enable: function() {
          if (this._enabled) {
            return this;
          }
          this._enabled = true;
          this.addHooks();
          return this;
        },
        // @method disable(): this
        // Disables the handler
        disable: function() {
          if (!this._enabled) {
            return this;
          }
          this._enabled = false;
          this.removeHooks();
          return this;
        },
        // @method enabled(): Boolean
        // Returns `true` if the handler is enabled
        enabled: function() {
          return !!this._enabled;
        }
        // @section Extension methods
        // Classes inheriting from `Handler` must implement the two following methods:
        // @method addHooks()
        // Called when the handler is enabled, should add event hooks.
        // @method removeHooks()
        // Called when the handler is disabled, should remove the event hooks added previously.
      });
      Handler.addTo = function(map2, name) {
        map2.addHandler(name, this);
        return this;
      };
      var Mixin = { Events };
      var START = Browser2.touch ? "touchstart mousedown" : "mousedown";
      var Draggable = Evented.extend({
        options: {
          // @section
          // @aka Draggable options
          // @option clickTolerance: Number = 3
          // The max number of pixels a user can shift the mouse pointer during a click
          // for it to be considered a valid click (as opposed to a mouse drag).
          clickTolerance: 3
        },
        // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
        // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
        initialize: function(element, dragStartTarget, preventOutline2, options) {
          setOptions(this, options);
          this._element = element;
          this._dragStartTarget = dragStartTarget || element;
          this._preventOutline = preventOutline2;
        },
        // @method enable()
        // Enables the dragging ability
        enable: function() {
          if (this._enabled) {
            return;
          }
          on(this._dragStartTarget, START, this._onDown, this);
          this._enabled = true;
        },
        // @method disable()
        // Disables the dragging ability
        disable: function() {
          if (!this._enabled) {
            return;
          }
          if (Draggable._dragging === this) {
            this.finishDrag(true);
          }
          off(this._dragStartTarget, START, this._onDown, this);
          this._enabled = false;
          this._moved = false;
        },
        _onDown: function(e3) {
          if (!this._enabled) {
            return;
          }
          this._moved = false;
          if (hasClass(this._element, "leaflet-zoom-anim")) {
            return;
          }
          if (e3.touches && e3.touches.length !== 1) {
            if (Draggable._dragging === this) {
              this.finishDrag();
            }
            return;
          }
          if (Draggable._dragging || e3.shiftKey || e3.which !== 1 && e3.button !== 1 && !e3.touches) {
            return;
          }
          Draggable._dragging = this;
          if (this._preventOutline) {
            preventOutline(this._element);
          }
          disableImageDrag();
          disableTextSelection();
          if (this._moving) {
            return;
          }
          this.fire("down");
          var first = e3.touches ? e3.touches[0] : e3, sizedParent = getSizedParentNode(this._element);
          this._startPoint = new Point(first.clientX, first.clientY);
          this._startPos = getPosition(this._element);
          this._parentScale = getScale(sizedParent);
          var mouseevent = e3.type === "mousedown";
          on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
          on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
        },
        _onMove: function(e3) {
          if (!this._enabled) {
            return;
          }
          if (e3.touches && e3.touches.length > 1) {
            this._moved = true;
            return;
          }
          var first = e3.touches && e3.touches.length === 1 ? e3.touches[0] : e3, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
          if (!offset.x && !offset.y) {
            return;
          }
          if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
            return;
          }
          offset.x /= this._parentScale.x;
          offset.y /= this._parentScale.y;
          preventDefault(e3);
          if (!this._moved) {
            this.fire("dragstart");
            this._moved = true;
            addClass(document.body, "leaflet-dragging");
            this._lastTarget = e3.target || e3.srcElement;
            if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
              this._lastTarget = this._lastTarget.correspondingUseElement;
            }
            addClass(this._lastTarget, "leaflet-drag-target");
          }
          this._newPos = this._startPos.add(offset);
          this._moving = true;
          this._lastEvent = e3;
          this._updatePosition();
        },
        _updatePosition: function() {
          var e3 = { originalEvent: this._lastEvent };
          this.fire("predrag", e3);
          setPosition(this._element, this._newPos);
          this.fire("drag", e3);
        },
        _onUp: function() {
          if (!this._enabled) {
            return;
          }
          this.finishDrag();
        },
        finishDrag: function(noInertia) {
          removeClass(document.body, "leaflet-dragging");
          if (this._lastTarget) {
            removeClass(this._lastTarget, "leaflet-drag-target");
            this._lastTarget = null;
          }
          off(document, "mousemove touchmove", this._onMove, this);
          off(document, "mouseup touchend touchcancel", this._onUp, this);
          enableImageDrag();
          enableTextSelection();
          var fireDragend = this._moved && this._moving;
          this._moving = false;
          Draggable._dragging = false;
          if (fireDragend) {
            this.fire("dragend", {
              noInertia,
              distance: this._newPos.distanceTo(this._startPos)
            });
          }
        }
      });
      function clipPolygon(points, bounds, round2) {
        var clippedPoints, edges = [1, 4, 2, 8], i2, j2, k2, a2, b2, len, edge2, p2;
        for (i2 = 0, len = points.length; i2 < len; i2++) {
          points[i2]._code = _getBitCode(points[i2], bounds);
        }
        for (k2 = 0; k2 < 4; k2++) {
          edge2 = edges[k2];
          clippedPoints = [];
          for (i2 = 0, len = points.length, j2 = len - 1; i2 < len; j2 = i2++) {
            a2 = points[i2];
            b2 = points[j2];
            if (!(a2._code & edge2)) {
              if (b2._code & edge2) {
                p2 = _getEdgeIntersection(b2, a2, edge2, bounds, round2);
                p2._code = _getBitCode(p2, bounds);
                clippedPoints.push(p2);
              }
              clippedPoints.push(a2);
            } else if (!(b2._code & edge2)) {
              p2 = _getEdgeIntersection(b2, a2, edge2, bounds, round2);
              p2._code = _getBitCode(p2, bounds);
              clippedPoints.push(p2);
            }
          }
          points = clippedPoints;
        }
        return points;
      }
      function polygonCenter(latlngs, crs) {
        var i2, j2, p1, p2, f2, area, x2, y2, center;
        if (!latlngs || latlngs.length === 0) {
          throw new Error("latlngs not passed");
        }
        if (!isFlat(latlngs)) {
          console.warn("latlngs are not flat! Only the first ring will be used");
          latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([0, 0]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        if (areaBounds < 1700) {
          centroidLatLng = centroid(latlngs);
        }
        var len = latlngs.length;
        var points = [];
        for (i2 = 0; i2 < len; i2++) {
          var latlng = toLatLng(latlngs[i2]);
          points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
        }
        area = x2 = y2 = 0;
        for (i2 = 0, j2 = len - 1; i2 < len; j2 = i2++) {
          p1 = points[i2];
          p2 = points[j2];
          f2 = p1.y * p2.x - p2.y * p1.x;
          x2 += (p1.x + p2.x) * f2;
          y2 += (p1.y + p2.y) * f2;
          area += f2 * 3;
        }
        if (area === 0) {
          center = points[0];
        } else {
          center = [x2 / area, y2 / area];
        }
        var latlngCenter = crs.unproject(toPoint(center));
        return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
      }
      function centroid(coords) {
        var latSum = 0;
        var lngSum = 0;
        var len = 0;
        for (var i2 = 0; i2 < coords.length; i2++) {
          var latlng = toLatLng(coords[i2]);
          latSum += latlng.lat;
          lngSum += latlng.lng;
          len++;
        }
        return toLatLng([latSum / len, lngSum / len]);
      }
      var PolyUtil = {
        __proto__: null,
        clipPolygon,
        polygonCenter,
        centroid
      };
      function simplify(points, tolerance) {
        if (!tolerance || !points.length) {
          return points.slice();
        }
        var sqTolerance = tolerance * tolerance;
        points = _reducePoints(points, sqTolerance);
        points = _simplifyDP(points, sqTolerance);
        return points;
      }
      function pointToSegmentDistance(p2, p1, p22) {
        return Math.sqrt(_sqClosestPointOnSegment(p2, p1, p22, true));
      }
      function closestPointOnSegment(p2, p1, p22) {
        return _sqClosestPointOnSegment(p2, p1, p22);
      }
      function _simplifyDP(points, sqTolerance) {
        var len = points.length, ArrayConstructor = typeof Uint8Array !== "undefined" ? Uint8Array : Array, markers = new ArrayConstructor(len);
        markers[0] = markers[len - 1] = 1;
        _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
        var i2, newPoints = [];
        for (i2 = 0; i2 < len; i2++) {
          if (markers[i2]) {
            newPoints.push(points[i2]);
          }
        }
        return newPoints;
      }
      function _simplifyDPStep(points, markers, sqTolerance, first, last2) {
        var maxSqDist = 0, index2, i2, sqDist;
        for (i2 = first + 1; i2 <= last2 - 1; i2++) {
          sqDist = _sqClosestPointOnSegment(points[i2], points[first], points[last2], true);
          if (sqDist > maxSqDist) {
            index2 = i2;
            maxSqDist = sqDist;
          }
        }
        if (maxSqDist > sqTolerance) {
          markers[index2] = 1;
          _simplifyDPStep(points, markers, sqTolerance, first, index2);
          _simplifyDPStep(points, markers, sqTolerance, index2, last2);
        }
      }
      function _reducePoints(points, sqTolerance) {
        var reducedPoints = [points[0]];
        for (var i2 = 1, prev = 0, len = points.length; i2 < len; i2++) {
          if (_sqDist(points[i2], points[prev]) > sqTolerance) {
            reducedPoints.push(points[i2]);
            prev = i2;
          }
        }
        if (prev < len - 1) {
          reducedPoints.push(points[len - 1]);
        }
        return reducedPoints;
      }
      var _lastCode;
      function clipSegment(a2, b2, bounds, useLastCode, round2) {
        var codeA = useLastCode ? _lastCode : _getBitCode(a2, bounds), codeB = _getBitCode(b2, bounds), codeOut, p2, newCode;
        _lastCode = codeB;
        while (true) {
          if (!(codeA | codeB)) {
            return [a2, b2];
          }
          if (codeA & codeB) {
            return false;
          }
          codeOut = codeA || codeB;
          p2 = _getEdgeIntersection(a2, b2, codeOut, bounds, round2);
          newCode = _getBitCode(p2, bounds);
          if (codeOut === codeA) {
            a2 = p2;
            codeA = newCode;
          } else {
            b2 = p2;
            codeB = newCode;
          }
        }
      }
      function _getEdgeIntersection(a2, b2, code, bounds, round2) {
        var dx = b2.x - a2.x, dy = b2.y - a2.y, min2 = bounds.min, max2 = bounds.max, x2, y2;
        if (code & 8) {
          x2 = a2.x + dx * (max2.y - a2.y) / dy;
          y2 = max2.y;
        } else if (code & 4) {
          x2 = a2.x + dx * (min2.y - a2.y) / dy;
          y2 = min2.y;
        } else if (code & 2) {
          x2 = max2.x;
          y2 = a2.y + dy * (max2.x - a2.x) / dx;
        } else if (code & 1) {
          x2 = min2.x;
          y2 = a2.y + dy * (min2.x - a2.x) / dx;
        }
        return new Point(x2, y2, round2);
      }
      function _getBitCode(p2, bounds) {
        var code = 0;
        if (p2.x < bounds.min.x) {
          code |= 1;
        } else if (p2.x > bounds.max.x) {
          code |= 2;
        }
        if (p2.y < bounds.min.y) {
          code |= 4;
        } else if (p2.y > bounds.max.y) {
          code |= 8;
        }
        return code;
      }
      function _sqDist(p1, p2) {
        var dx = p2.x - p1.x, dy = p2.y - p1.y;
        return dx * dx + dy * dy;
      }
      function _sqClosestPointOnSegment(p2, p1, p22, sqDist) {
        var x2 = p1.x, y2 = p1.y, dx = p22.x - x2, dy = p22.y - y2, dot = dx * dx + dy * dy, t2;
        if (dot > 0) {
          t2 = ((p2.x - x2) * dx + (p2.y - y2) * dy) / dot;
          if (t2 > 1) {
            x2 = p22.x;
            y2 = p22.y;
          } else if (t2 > 0) {
            x2 += dx * t2;
            y2 += dy * t2;
          }
        }
        dx = p2.x - x2;
        dy = p2.y - y2;
        return sqDist ? dx * dx + dy * dy : new Point(x2, y2);
      }
      function isFlat(latlngs) {
        return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
      }
      function _flat(latlngs) {
        console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
        return isFlat(latlngs);
      }
      function polylineCenter(latlngs, crs) {
        var i2, halfDist, segDist, dist, p1, p2, ratio, center;
        if (!latlngs || latlngs.length === 0) {
          throw new Error("latlngs not passed");
        }
        if (!isFlat(latlngs)) {
          console.warn("latlngs are not flat! Only the first ring will be used");
          latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([0, 0]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        if (areaBounds < 1700) {
          centroidLatLng = centroid(latlngs);
        }
        var len = latlngs.length;
        var points = [];
        for (i2 = 0; i2 < len; i2++) {
          var latlng = toLatLng(latlngs[i2]);
          points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
        }
        for (i2 = 0, halfDist = 0; i2 < len - 1; i2++) {
          halfDist += points[i2].distanceTo(points[i2 + 1]) / 2;
        }
        if (halfDist === 0) {
          center = points[0];
        } else {
          for (i2 = 0, dist = 0; i2 < len - 1; i2++) {
            p1 = points[i2];
            p2 = points[i2 + 1];
            segDist = p1.distanceTo(p2);
            dist += segDist;
            if (dist > halfDist) {
              ratio = (dist - halfDist) / segDist;
              center = [
                p2.x - ratio * (p2.x - p1.x),
                p2.y - ratio * (p2.y - p1.y)
              ];
              break;
            }
          }
        }
        var latlngCenter = crs.unproject(toPoint(center));
        return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
      }
      var LineUtil = {
        __proto__: null,
        simplify,
        pointToSegmentDistance,
        closestPointOnSegment,
        clipSegment,
        _getEdgeIntersection,
        _getBitCode,
        _sqClosestPointOnSegment,
        isFlat,
        _flat,
        polylineCenter
      };
      var LonLat = {
        project: function(latlng) {
          return new Point(latlng.lng, latlng.lat);
        },
        unproject: function(point2) {
          return new LatLng(point2.y, point2.x);
        },
        bounds: new Bounds([-180, -90], [180, 90])
      };
      var Mercator = {
        R: 6378137,
        R_MINOR: 6356752314245179e-9,
        bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
        project: function(latlng) {
          var d2 = Math.PI / 180, r2 = this.R, y2 = latlng.lat * d2, tmp = this.R_MINOR / r2, e3 = Math.sqrt(1 - tmp * tmp), con = e3 * Math.sin(y2);
          var ts = Math.tan(Math.PI / 4 - y2 / 2) / Math.pow((1 - con) / (1 + con), e3 / 2);
          y2 = -r2 * Math.log(Math.max(ts, 1e-10));
          return new Point(latlng.lng * d2 * r2, y2);
        },
        unproject: function(point2) {
          var d2 = 180 / Math.PI, r2 = this.R, tmp = this.R_MINOR / r2, e3 = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point2.y / r2), phi = Math.PI / 2 - 2 * Math.atan(ts);
          for (var i2 = 0, dphi = 0.1, con; i2 < 15 && Math.abs(dphi) > 1e-7; i2++) {
            con = e3 * Math.sin(phi);
            con = Math.pow((1 - con) / (1 + con), e3 / 2);
            dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
            phi += dphi;
          }
          return new LatLng(phi * d2, point2.x * d2 / r2);
        }
      };
      var index = {
        __proto__: null,
        LonLat,
        Mercator,
        SphericalMercator
      };
      var EPSG3395 = extend2({}, Earth, {
        code: "EPSG:3395",
        projection: Mercator,
        transformation: (function() {
          var scale2 = 0.5 / (Math.PI * Mercator.R);
          return toTransformation(scale2, 0.5, -scale2, 0.5);
        })()
      });
      var EPSG4326 = extend2({}, Earth, {
        code: "EPSG:4326",
        projection: LonLat,
        transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
      });
      var Simple = extend2({}, CRS, {
        projection: LonLat,
        transformation: toTransformation(1, 0, -1, 0),
        scale: function(zoom2) {
          return Math.pow(2, zoom2);
        },
        zoom: function(scale2) {
          return Math.log(scale2) / Math.LN2;
        },
        distance: function(latlng1, latlng2) {
          var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
          return Math.sqrt(dx * dx + dy * dy);
        },
        infinite: true
      });
      CRS.Earth = Earth;
      CRS.EPSG3395 = EPSG3395;
      CRS.EPSG3857 = EPSG3857;
      CRS.EPSG900913 = EPSG900913;
      CRS.EPSG4326 = EPSG4326;
      CRS.Simple = Simple;
      var Layer2 = Evented.extend({
        // Classes extending `L.Layer` will inherit the following options:
        options: {
          // @option pane: String = 'overlayPane'
          // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
          pane: "overlayPane",
          // @option attribution: String = null
          // String to be shown in the attribution control, e.g. " OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
          attribution: null,
          bubblingMouseEvents: true
        },
        /* @section
         * Classes extending `L.Layer` will inherit the following methods:
         *
         * @method addTo(map: Map|LayerGroup): this
         * Adds the layer to the given map or layer group.
         */
        addTo: function(map2) {
          map2.addLayer(this);
          return this;
        },
        // @method remove: this
        // Removes the layer from the map it is currently active on.
        remove: function() {
          return this.removeFrom(this._map || this._mapToAdd);
        },
        // @method removeFrom(map: Map): this
        // Removes the layer from the given map
        //
        // @alternative
        // @method removeFrom(group: LayerGroup): this
        // Removes the layer from the given `LayerGroup`
        removeFrom: function(obj) {
          if (obj) {
            obj.removeLayer(this);
          }
          return this;
        },
        // @method getPane(name? : String): HTMLElement
        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
        getPane: function(name) {
          return this._map.getPane(name ? this.options[name] || name : this.options.pane);
        },
        addInteractiveTarget: function(targetEl) {
          this._map._targets[stamp(targetEl)] = this;
          return this;
        },
        removeInteractiveTarget: function(targetEl) {
          delete this._map._targets[stamp(targetEl)];
          return this;
        },
        // @method getAttribution: String
        // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
        getAttribution: function() {
          return this.options.attribution;
        },
        _layerAdd: function(e3) {
          var map2 = e3.target;
          if (!map2.hasLayer(this)) {
            return;
          }
          this._map = map2;
          this._zoomAnimated = map2._zoomAnimated;
          if (this.getEvents) {
            var events = this.getEvents();
            map2.on(events, this);
            this.once("remove", function() {
              map2.off(events, this);
            }, this);
          }
          this.onAdd(map2);
          this.fire("add");
          map2.fire("layeradd", { layer: this });
        }
      });
      Map2.include({
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the map
        addLayer: function(layer) {
          if (!layer._layerAdd) {
            throw new Error("The provided object is not a Layer.");
          }
          var id = stamp(layer);
          if (this._layers[id]) {
            return this;
          }
          this._layers[id] = layer;
          layer._mapToAdd = this;
          if (layer.beforeAdd) {
            layer.beforeAdd(this);
          }
          this.whenReady(layer._layerAdd, layer);
          return this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the map.
        removeLayer: function(layer) {
          var id = stamp(layer);
          if (!this._layers[id]) {
            return this;
          }
          if (this._loaded) {
            layer.onRemove(this);
          }
          delete this._layers[id];
          if (this._loaded) {
            this.fire("layerremove", { layer });
            layer.fire("remove");
          }
          layer._map = layer._mapToAdd = null;
          return this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the map
        hasLayer: function(layer) {
          return stamp(layer) in this._layers;
        },
        /* @method eachLayer(fn: Function, context?: Object): this
         * Iterates over the layers of the map, optionally specifying context of the iterator function.
         * ```
         * map.eachLayer(function(layer){
         *     layer.bindPopup('Hello');
         * });
         * ```
         */
        eachLayer: function(method, context) {
          for (var i2 in this._layers) {
            method.call(context, this._layers[i2]);
          }
          return this;
        },
        _addLayers: function(layers2) {
          layers2 = layers2 ? isArray(layers2) ? layers2 : [layers2] : [];
          for (var i2 = 0, len = layers2.length; i2 < len; i2++) {
            this.addLayer(layers2[i2]);
          }
        },
        _addZoomLimit: function(layer) {
          if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
            this._zoomBoundLayers[stamp(layer)] = layer;
            this._updateZoomLevels();
          }
        },
        _removeZoomLimit: function(layer) {
          var id = stamp(layer);
          if (this._zoomBoundLayers[id]) {
            delete this._zoomBoundLayers[id];
            this._updateZoomLevels();
          }
        },
        _updateZoomLevels: function() {
          var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
          for (var i2 in this._zoomBoundLayers) {
            var options = this._zoomBoundLayers[i2].options;
            minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
            maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
          }
          this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
          this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
          if (oldZoomSpan !== this._getZoomSpan()) {
            this.fire("zoomlevelschange");
          }
          if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
            this.setZoom(this._layersMaxZoom);
          }
          if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
            this.setZoom(this._layersMinZoom);
          }
        }
      });
      var LayerGroup = Layer2.extend({
        initialize: function(layers2, options) {
          setOptions(this, options);
          this._layers = {};
          var i2, len;
          if (layers2) {
            for (i2 = 0, len = layers2.length; i2 < len; i2++) {
              this.addLayer(layers2[i2]);
            }
          }
        },
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the group.
        addLayer: function(layer) {
          var id = this.getLayerId(layer);
          this._layers[id] = layer;
          if (this._map) {
            this._map.addLayer(layer);
          }
          return this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the group.
        // @alternative
        // @method removeLayer(id: Number): this
        // Removes the layer with the given internal ID from the group.
        removeLayer: function(layer) {
          var id = layer in this._layers ? layer : this.getLayerId(layer);
          if (this._map && this._layers[id]) {
            this._map.removeLayer(this._layers[id]);
          }
          delete this._layers[id];
          return this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the group.
        // @alternative
        // @method hasLayer(id: Number): Boolean
        // Returns `true` if the given internal ID is currently added to the group.
        hasLayer: function(layer) {
          var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
          return layerId in this._layers;
        },
        // @method clearLayers(): this
        // Removes all the layers from the group.
        clearLayers: function() {
          return this.eachLayer(this.removeLayer, this);
        },
        // @method invoke(methodName: String, ): this
        // Calls `methodName` on every layer contained in this group, passing any
        // additional parameters. Has no effect if the layers contained do not
        // implement `methodName`.
        invoke: function(methodName) {
          var args = Array.prototype.slice.call(arguments, 1), i2, layer;
          for (i2 in this._layers) {
            layer = this._layers[i2];
            if (layer[methodName]) {
              layer[methodName].apply(layer, args);
            }
          }
          return this;
        },
        onAdd: function(map2) {
          this.eachLayer(map2.addLayer, map2);
        },
        onRemove: function(map2) {
          this.eachLayer(map2.removeLayer, map2);
        },
        // @method eachLayer(fn: Function, context?: Object): this
        // Iterates over the layers of the group, optionally specifying context of the iterator function.
        // ```js
        // group.eachLayer(function (layer) {
        // 	layer.bindPopup('Hello');
        // });
        // ```
        eachLayer: function(method, context) {
          for (var i2 in this._layers) {
            method.call(context, this._layers[i2]);
          }
          return this;
        },
        // @method getLayer(id: Number): Layer
        // Returns the layer with the given internal ID.
        getLayer: function(id) {
          return this._layers[id];
        },
        // @method getLayers(): Layer[]
        // Returns an array of all the layers added to the group.
        getLayers: function() {
          var layers2 = [];
          this.eachLayer(layers2.push, layers2);
          return layers2;
        },
        // @method setZIndex(zIndex: Number): this
        // Calls `setZIndex` on every layer contained in this group, passing the z-index.
        setZIndex: function(zIndex) {
          return this.invoke("setZIndex", zIndex);
        },
        // @method getLayerId(layer: Layer): Number
        // Returns the internal ID for a layer
        getLayerId: function(layer) {
          return stamp(layer);
        }
      });
      var layerGroup = function(layers2, options) {
        return new LayerGroup(layers2, options);
      };
      var FeatureGroup = LayerGroup.extend({
        addLayer: function(layer) {
          if (this.hasLayer(layer)) {
            return this;
          }
          layer.addEventParent(this);
          LayerGroup.prototype.addLayer.call(this, layer);
          return this.fire("layeradd", { layer });
        },
        removeLayer: function(layer) {
          if (!this.hasLayer(layer)) {
            return this;
          }
          if (layer in this._layers) {
            layer = this._layers[layer];
          }
          layer.removeEventParent(this);
          LayerGroup.prototype.removeLayer.call(this, layer);
          return this.fire("layerremove", { layer });
        },
        // @method setStyle(style: Path options): this
        // Sets the given path options to each layer of the group that has a `setStyle` method.
        setStyle: function(style2) {
          return this.invoke("setStyle", style2);
        },
        // @method bringToFront(): this
        // Brings the layer group to the top of all other layers
        bringToFront: function() {
          return this.invoke("bringToFront");
        },
        // @method bringToBack(): this
        // Brings the layer group to the back of all other layers
        bringToBack: function() {
          return this.invoke("bringToBack");
        },
        // @method getBounds(): LatLngBounds
        // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
        getBounds: function() {
          var bounds = new LatLngBounds();
          for (var id in this._layers) {
            var layer = this._layers[id];
            bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
          }
          return bounds;
        }
      });
      var featureGroup = function(layers2, options) {
        return new FeatureGroup(layers2, options);
      };
      var Icon = Class.extend({
        /* @section
         * @aka Icon options
         *
         * @option iconUrl: String = null
         * **(required)** The URL to the icon image (absolute or relative to your script path).
         *
         * @option iconRetinaUrl: String = null
         * The URL to a retina sized version of the icon image (absolute or relative to your
         * script path). Used for Retina screen devices.
         *
         * @option iconSize: Point = null
         * Size of the icon image in pixels.
         *
         * @option iconAnchor: Point = null
         * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
         * will be aligned so that this point is at the marker's geographical location. Centered
         * by default if size is specified, also can be set in CSS with negative margins.
         *
         * @option popupAnchor: Point = [0, 0]
         * The coordinates of the point from which popups will "open", relative to the icon anchor.
         *
         * @option tooltipAnchor: Point = [0, 0]
         * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
         *
         * @option shadowUrl: String = null
         * The URL to the icon shadow image. If not specified, no shadow image will be created.
         *
         * @option shadowRetinaUrl: String = null
         *
         * @option shadowSize: Point = null
         * Size of the shadow image in pixels.
         *
         * @option shadowAnchor: Point = null
         * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
         * as iconAnchor if not specified).
         *
         * @option className: String = ''
         * A custom class name to assign to both icon and shadow images. Empty by default.
         */
        options: {
          popupAnchor: [0, 0],
          tooltipAnchor: [0, 0],
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        // @method createIcon(oldIcon?: HTMLElement): HTMLElement
        // Called internally when the icon has to be shown, returns a `<img>` HTML element
        // styled according to the options.
        createIcon: function(oldIcon) {
          return this._createIcon("icon", oldIcon);
        },
        // @method createShadow(oldIcon?: HTMLElement): HTMLElement
        // As `createIcon`, but for the shadow beneath it.
        createShadow: function(oldIcon) {
          return this._createIcon("shadow", oldIcon);
        },
        _createIcon: function(name, oldIcon) {
          var src = this._getIconUrl(name);
          if (!src) {
            if (name === "icon") {
              throw new Error("iconUrl not set in Icon options (see the docs).");
            }
            return null;
          }
          var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
          this._setIconStyles(img, name);
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          return img;
        },
        _setIconStyles: function(img, name) {
          var options = this.options;
          var sizeOption = options[name + "Size"];
          if (typeof sizeOption === "number") {
            sizeOption = [sizeOption, sizeOption];
          }
          var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
          img.className = "leaflet-marker-" + name + " " + (options.className || "");
          if (anchor) {
            img.style.marginLeft = -anchor.x + "px";
            img.style.marginTop = -anchor.y + "px";
          }
          if (size) {
            img.style.width = size.x + "px";
            img.style.height = size.y + "px";
          }
        },
        _createImg: function(src, el) {
          el = el || document.createElement("img");
          el.src = src;
          return el;
        },
        _getIconUrl: function(name) {
          return Browser2.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
        }
      });
      function icon(options) {
        return new Icon(options);
      }
      var IconDefault = Icon.extend({
        options: {
          iconUrl: "marker-icon.png",
          iconRetinaUrl: "marker-icon-2x.png",
          shadowUrl: "marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          tooltipAnchor: [16, -28],
          shadowSize: [41, 41]
        },
        _getIconUrl: function(name) {
          if (typeof IconDefault.imagePath !== "string") {
            IconDefault.imagePath = this._detectIconPath();
          }
          return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
        },
        _stripUrl: function(path2) {
          var strip = function(str, re2, idx) {
            var match = re2.exec(str);
            return match && match[idx];
          };
          path2 = strip(path2, /^url\((['"])?(.+)\1\)$/, 2);
          return path2 && strip(path2, /^(.*)marker-icon\.png$/, 1);
        },
        _detectIconPath: function() {
          var el = create$1("div", "leaflet-default-icon-path", document.body);
          var path2 = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
          document.body.removeChild(el);
          path2 = this._stripUrl(path2);
          if (path2) {
            return path2;
          }
          var link = document.querySelector('link[href$="leaflet.css"]');
          if (!link) {
            return "";
          }
          return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
        }
      });
      var MarkerDrag = Handler.extend({
        initialize: function(marker2) {
          this._marker = marker2;
        },
        addHooks: function() {
          var icon2 = this._marker._icon;
          if (!this._draggable) {
            this._draggable = new Draggable(icon2, icon2, true);
          }
          this._draggable.on({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).enable();
          addClass(icon2, "leaflet-marker-draggable");
        },
        removeHooks: function() {
          this._draggable.off({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).disable();
          if (this._marker._icon) {
            removeClass(this._marker._icon, "leaflet-marker-draggable");
          }
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        _adjustPan: function(e3) {
          var marker2 = this._marker, map2 = marker2._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker2._icon), bounds = map2.getPixelBounds(), origin = map2.getPixelOrigin();
          var panBounds = toBounds(
            bounds.min._subtract(origin).add(padding),
            bounds.max._subtract(origin).subtract(padding)
          );
          if (!panBounds.contains(iconPos)) {
            var movement = toPoint(
              (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),
              (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
            ).multiplyBy(speed);
            map2.panBy(movement, { animate: false });
            this._draggable._newPos._add(movement);
            this._draggable._startPos._add(movement);
            setPosition(marker2._icon, this._draggable._newPos);
            this._onDrag(e3);
            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e3));
          }
        },
        _onDragStart: function() {
          this._oldLatLng = this._marker.getLatLng();
          this._marker.closePopup && this._marker.closePopup();
          this._marker.fire("movestart").fire("dragstart");
        },
        _onPreDrag: function(e3) {
          if (this._marker.options.autoPan) {
            cancelAnimFrame(this._panRequest);
            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e3));
          }
        },
        _onDrag: function(e3) {
          var marker2 = this._marker, shadow = marker2._shadow, iconPos = getPosition(marker2._icon), latlng = marker2._map.layerPointToLatLng(iconPos);
          if (shadow) {
            setPosition(shadow, iconPos);
          }
          marker2._latlng = latlng;
          e3.latlng = latlng;
          e3.oldLatLng = this._oldLatLng;
          marker2.fire("move", e3).fire("drag", e3);
        },
        _onDragEnd: function(e3) {
          cancelAnimFrame(this._panRequest);
          delete this._oldLatLng;
          this._marker.fire("moveend").fire("dragend", e3);
        }
      });
      var Marker2 = Layer2.extend({
        // @section
        // @aka Marker options
        options: {
          // @option icon: Icon = *
          // Icon instance to use for rendering the marker.
          // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
          // If not specified, a common instance of `L.Icon.Default` is used.
          icon: new IconDefault(),
          // Option inherited from "Interactive layer" abstract class
          interactive: true,
          // @option keyboard: Boolean = true
          // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
          keyboard: true,
          // @option title: String = ''
          // Text for the browser tooltip that appear on marker hover (no tooltip by default).
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          title: "",
          // @option alt: String = 'Marker'
          // Text for the `alt` attribute of the icon image.
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          alt: "Marker",
          // @option zIndexOffset: Number = 0
          // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
          zIndexOffset: 0,
          // @option opacity: Number = 1.0
          // The opacity of the marker.
          opacity: 1,
          // @option riseOnHover: Boolean = false
          // If `true`, the marker will get on top of others when you hover the mouse over it.
          riseOnHover: false,
          // @option riseOffset: Number = 250
          // The z-index offset used for the `riseOnHover` feature.
          riseOffset: 250,
          // @option pane: String = 'markerPane'
          // `Map pane` where the markers icon will be added.
          pane: "markerPane",
          // @option shadowPane: String = 'shadowPane'
          // `Map pane` where the markers shadow will be added.
          shadowPane: "shadowPane",
          // @option bubblingMouseEvents: Boolean = false
          // When `true`, a mouse event on this marker will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: false,
          // @option autoPanOnFocus: Boolean = true
          // When `true`, the map will pan whenever the marker is focused (via
          // e.g. pressing `tab` on the keyboard) to ensure the marker is
          // visible within the map's bounds
          autoPanOnFocus: true,
          // @section Draggable marker options
          // @option draggable: Boolean = false
          // Whether the marker is draggable with mouse/touch or not.
          draggable: false,
          // @option autoPan: Boolean = false
          // Whether to pan the map when dragging this marker near its edge or not.
          autoPan: false,
          // @option autoPanPadding: Point = Point(50, 50)
          // Distance (in pixels to the left/right and to the top/bottom) of the
          // map edge to start panning the map.
          autoPanPadding: [50, 50],
          // @option autoPanSpeed: Number = 10
          // Number of pixels the map should pan by.
          autoPanSpeed: 10
        },
        /* @section
         *
         * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
         */
        initialize: function(latlng, options) {
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
        },
        onAdd: function(map2) {
          this._zoomAnimated = this._zoomAnimated && map2.options.markerZoomAnimation;
          if (this._zoomAnimated) {
            map2.on("zoomanim", this._animateZoom, this);
          }
          this._initIcon();
          this.update();
        },
        onRemove: function(map2) {
          if (this.dragging && this.dragging.enabled()) {
            this.options.draggable = true;
            this.dragging.removeHooks();
          }
          delete this.dragging;
          if (this._zoomAnimated) {
            map2.off("zoomanim", this._animateZoom, this);
          }
          this._removeIcon();
          this._removeShadow();
        },
        getEvents: function() {
          return {
            zoom: this.update,
            viewreset: this.update
          };
        },
        // @method getLatLng: LatLng
        // Returns the current geographical position of the marker.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Changes the marker position to the given point.
        setLatLng: function(latlng) {
          var oldLatLng = this._latlng;
          this._latlng = toLatLng(latlng);
          this.update();
          return this.fire("move", { oldLatLng, latlng: this._latlng });
        },
        // @method setZIndexOffset(offset: Number): this
        // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
        setZIndexOffset: function(offset) {
          this.options.zIndexOffset = offset;
          return this.update();
        },
        // @method getIcon: Icon
        // Returns the current icon used by the marker
        getIcon: function() {
          return this.options.icon;
        },
        // @method setIcon(icon: Icon): this
        // Changes the marker icon.
        setIcon: function(icon2) {
          this.options.icon = icon2;
          if (this._map) {
            this._initIcon();
            this.update();
          }
          if (this._popup) {
            this.bindPopup(this._popup, this._popup.options);
          }
          return this;
        },
        getElement: function() {
          return this._icon;
        },
        update: function() {
          if (this._icon && this._map) {
            var pos = this._map.latLngToLayerPoint(this._latlng).round();
            this._setPos(pos);
          }
          return this;
        },
        _initIcon: function() {
          var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          var icon2 = options.icon.createIcon(this._icon), addIcon = false;
          if (icon2 !== this._icon) {
            if (this._icon) {
              this._removeIcon();
            }
            addIcon = true;
            if (options.title) {
              icon2.title = options.title;
            }
            if (icon2.tagName === "IMG") {
              icon2.alt = options.alt || "";
            }
          }
          addClass(icon2, classToAdd);
          if (options.keyboard) {
            icon2.tabIndex = "0";
            icon2.setAttribute("role", "button");
          }
          this._icon = icon2;
          if (options.riseOnHover) {
            this.on({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            });
          }
          if (this.options.autoPanOnFocus) {
            on(icon2, "focus", this._panOnFocus, this);
          }
          var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
          if (newShadow !== this._shadow) {
            this._removeShadow();
            addShadow = true;
          }
          if (newShadow) {
            addClass(newShadow, classToAdd);
            newShadow.alt = "";
          }
          this._shadow = newShadow;
          if (options.opacity < 1) {
            this._updateOpacity();
          }
          if (addIcon) {
            this.getPane().appendChild(this._icon);
          }
          this._initInteraction();
          if (newShadow && addShadow) {
            this.getPane(options.shadowPane).appendChild(this._shadow);
          }
        },
        _removeIcon: function() {
          if (this.options.riseOnHover) {
            this.off({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            });
          }
          if (this.options.autoPanOnFocus) {
            off(this._icon, "focus", this._panOnFocus, this);
          }
          remove(this._icon);
          this.removeInteractiveTarget(this._icon);
          this._icon = null;
        },
        _removeShadow: function() {
          if (this._shadow) {
            remove(this._shadow);
          }
          this._shadow = null;
        },
        _setPos: function(pos) {
          if (this._icon) {
            setPosition(this._icon, pos);
          }
          if (this._shadow) {
            setPosition(this._shadow, pos);
          }
          this._zIndex = pos.y + this.options.zIndexOffset;
          this._resetZIndex();
        },
        _updateZIndex: function(offset) {
          if (this._icon) {
            this._icon.style.zIndex = this._zIndex + offset;
          }
        },
        _animateZoom: function(opt) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
          this._setPos(pos);
        },
        _initInteraction: function() {
          if (!this.options.interactive) {
            return;
          }
          addClass(this._icon, "leaflet-interactive");
          this.addInteractiveTarget(this._icon);
          if (MarkerDrag) {
            var draggable = this.options.draggable;
            if (this.dragging) {
              draggable = this.dragging.enabled();
              this.dragging.disable();
            }
            this.dragging = new MarkerDrag(this);
            if (draggable) {
              this.dragging.enable();
            }
          }
        },
        // @method setOpacity(opacity: Number): this
        // Changes the opacity of the marker.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._map) {
            this._updateOpacity();
          }
          return this;
        },
        _updateOpacity: function() {
          var opacity = this.options.opacity;
          if (this._icon) {
            setOpacity(this._icon, opacity);
          }
          if (this._shadow) {
            setOpacity(this._shadow, opacity);
          }
        },
        _bringToFront: function() {
          this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function() {
          this._updateZIndex(0);
        },
        _panOnFocus: function() {
          var map2 = this._map;
          if (!map2) {
            return;
          }
          var iconOpts = this.options.icon.options;
          var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
          var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
          map2.panInside(this._latlng, {
            paddingTopLeft: anchor,
            paddingBottomRight: size.subtract(anchor)
          });
        },
        _getPopupAnchor: function() {
          return this.options.icon.options.popupAnchor;
        },
        _getTooltipAnchor: function() {
          return this.options.icon.options.tooltipAnchor;
        }
      });
      function marker(latlng, options) {
        return new Marker2(latlng, options);
      }
      var Path2 = Layer2.extend({
        // @section
        // @aka Path options
        options: {
          // @option stroke: Boolean = true
          // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
          stroke: true,
          // @option color: String = '#3388ff'
          // Stroke color
          color: "#3388ff",
          // @option weight: Number = 3
          // Stroke width in pixels
          weight: 3,
          // @option opacity: Number = 1.0
          // Stroke opacity
          opacity: 1,
          // @option lineCap: String= 'round'
          // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
          lineCap: "round",
          // @option lineJoin: String = 'round'
          // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
          lineJoin: "round",
          // @option dashArray: String = null
          // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashArray: null,
          // @option dashOffset: String = null
          // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashOffset: null,
          // @option fill: Boolean = depends
          // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
          fill: false,
          // @option fillColor: String = *
          // Fill color. Defaults to the value of the [`color`](#path-color) option
          fillColor: null,
          // @option fillOpacity: Number = 0.2
          // Fill opacity.
          fillOpacity: 0.2,
          // @option fillRule: String = 'evenodd'
          // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
          fillRule: "evenodd",
          // className: '',
          // Option inherited from "Interactive layer" abstract class
          interactive: true,
          // @option bubblingMouseEvents: Boolean = true
          // When `true`, a mouse event on this path will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: true
        },
        beforeAdd: function(map2) {
          this._renderer = map2.getRenderer(this);
        },
        onAdd: function() {
          this._renderer._initPath(this);
          this._reset();
          this._renderer._addPath(this);
        },
        onRemove: function() {
          this._renderer._removePath(this);
        },
        // @method redraw(): this
        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
        redraw: function() {
          if (this._map) {
            this._renderer._updatePath(this);
          }
          return this;
        },
        // @method setStyle(style: Path options): this
        // Changes the appearance of a Path based on the options in the `Path options` object.
        setStyle: function(style2) {
          setOptions(this, style2);
          if (this._renderer) {
            this._renderer._updateStyle(this);
            if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
              this._updateBounds();
            }
          }
          return this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all path layers.
        bringToFront: function() {
          if (this._renderer) {
            this._renderer._bringToFront(this);
          }
          return this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all path layers.
        bringToBack: function() {
          if (this._renderer) {
            this._renderer._bringToBack(this);
          }
          return this;
        },
        getElement: function() {
          return this._path;
        },
        _reset: function() {
          this._project();
          this._update();
        },
        _clickTolerance: function() {
          return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
        }
      });
      var CircleMarker = Path2.extend({
        // @section
        // @aka CircleMarker options
        options: {
          fill: true,
          // @option radius: Number = 10
          // Radius of the circle marker, in pixels
          radius: 10
        },
        initialize: function(latlng, options) {
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
          this._radius = this.options.radius;
        },
        // @method setLatLng(latLng: LatLng): this
        // Sets the position of a circle marker to a new location.
        setLatLng: function(latlng) {
          var oldLatLng = this._latlng;
          this._latlng = toLatLng(latlng);
          this.redraw();
          return this.fire("move", { oldLatLng, latlng: this._latlng });
        },
        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function() {
          return this._latlng;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle marker. Units are in pixels.
        setRadius: function(radius) {
          this.options.radius = this._radius = radius;
          return this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of the circle
        getRadius: function() {
          return this._radius;
        },
        setStyle: function(options) {
          var radius = options && options.radius || this._radius;
          Path2.prototype.setStyle.call(this, options);
          this.setRadius(radius);
          return this;
        },
        _project: function() {
          this._point = this._map.latLngToLayerPoint(this._latlng);
          this._updateBounds();
        },
        _updateBounds: function() {
          var r2 = this._radius, r22 = this._radiusY || r2, w2 = this._clickTolerance(), p2 = [r2 + w2, r22 + w2];
          this._pxBounds = new Bounds(this._point.subtract(p2), this._point.add(p2));
        },
        _update: function() {
          if (this._map) {
            this._updatePath();
          }
        },
        _updatePath: function() {
          this._renderer._updateCircle(this);
        },
        _empty: function() {
          return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p2) {
          return p2.distanceTo(this._point) <= this._radius + this._clickTolerance();
        }
      });
      function circleMarker(latlng, options) {
        return new CircleMarker(latlng, options);
      }
      var Circle2 = CircleMarker.extend({
        initialize: function(latlng, options, legacyOptions) {
          if (typeof options === "number") {
            options = extend2({}, legacyOptions, { radius: options });
          }
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
          if (isNaN(this.options.radius)) {
            throw new Error("Circle radius cannot be NaN");
          }
          this._mRadius = this.options.radius;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle. Units are in meters.
        setRadius: function(radius) {
          this._mRadius = radius;
          return this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of a circle. Units are in meters.
        getRadius: function() {
          return this._mRadius;
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          var half = [this._radius, this._radiusY || this._radius];
          return new LatLngBounds(
            this._map.layerPointToLatLng(this._point.subtract(half)),
            this._map.layerPointToLatLng(this._point.add(half))
          );
        },
        setStyle: Path2.prototype.setStyle,
        _project: function() {
          var lng = this._latlng.lng, lat = this._latlng.lat, map2 = this._map, crs = map2.options.crs;
          if (crs.distance === Earth.distance) {
            var d2 = Math.PI / 180, latR = this._mRadius / Earth.R / d2, top = map2.project([lat + latR, lng]), bottom = map2.project([lat - latR, lng]), p2 = top.add(bottom).divideBy(2), lat2 = map2.unproject(p2).lat, lngR = Math.acos((Math.cos(latR * d2) - Math.sin(lat * d2) * Math.sin(lat2 * d2)) / (Math.cos(lat * d2) * Math.cos(lat2 * d2))) / d2;
            if (isNaN(lngR) || lngR === 0) {
              lngR = latR / Math.cos(Math.PI / 180 * lat);
            }
            this._point = p2.subtract(map2.getPixelOrigin());
            this._radius = isNaN(lngR) ? 0 : p2.x - map2.project([lat2, lng - lngR]).x;
            this._radiusY = p2.y - top.y;
          } else {
            var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
            this._point = map2.latLngToLayerPoint(this._latlng);
            this._radius = this._point.x - map2.latLngToLayerPoint(latlng2).x;
          }
          this._updateBounds();
        }
      });
      function circle(latlng, options, legacyOptions) {
        return new Circle2(latlng, options, legacyOptions);
      }
      var Polyline = Path2.extend({
        // @section
        // @aka Polyline options
        options: {
          // @option smoothFactor: Number = 1.0
          // How much to simplify the polyline on each zoom level. More means
          // better performance and smoother look, and less means more accurate representation.
          smoothFactor: 1,
          // @option noClip: Boolean = false
          // Disable polyline clipping.
          noClip: false
        },
        initialize: function(latlngs, options) {
          setOptions(this, options);
          this._setLatLngs(latlngs);
        },
        // @method getLatLngs(): LatLng[]
        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
        getLatLngs: function() {
          return this._latlngs;
        },
        // @method setLatLngs(latlngs: LatLng[]): this
        // Replaces all the points in the polyline with the given array of geographical points.
        setLatLngs: function(latlngs) {
          this._setLatLngs(latlngs);
          return this.redraw();
        },
        // @method isEmpty(): Boolean
        // Returns `true` if the Polyline has no LatLngs.
        isEmpty: function() {
          return !this._latlngs.length;
        },
        // @method closestLayerPoint(p: Point): Point
        // Returns the point closest to `p` on the Polyline.
        closestLayerPoint: function(p2) {
          var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p22;
          for (var j2 = 0, jLen = this._parts.length; j2 < jLen; j2++) {
            var points = this._parts[j2];
            for (var i2 = 1, len = points.length; i2 < len; i2++) {
              p1 = points[i2 - 1];
              p22 = points[i2];
              var sqDist = closest(p2, p1, p22, true);
              if (sqDist < minDistance) {
                minDistance = sqDist;
                minPoint = closest(p2, p1, p22);
              }
            }
          }
          if (minPoint) {
            minPoint.distance = Math.sqrt(minDistance);
          }
          return minPoint;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
        getCenter: function() {
          if (!this._map) {
            throw new Error("Must add layer to map before using getCenter()");
          }
          return polylineCenter(this._defaultShape(), this._map.options.crs);
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          return this._bounds;
        },
        // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
        // Adds a given point to the polyline. By default, adds to the first ring of
        // the polyline in case of a multi-polyline, but can be overridden by passing
        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
        addLatLng: function(latlng, latlngs) {
          latlngs = latlngs || this._defaultShape();
          latlng = toLatLng(latlng);
          latlngs.push(latlng);
          this._bounds.extend(latlng);
          return this.redraw();
        },
        _setLatLngs: function(latlngs) {
          this._bounds = new LatLngBounds();
          this._latlngs = this._convertLatLngs(latlngs);
        },
        _defaultShape: function() {
          return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
        },
        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
        _convertLatLngs: function(latlngs) {
          var result = [], flat = isFlat(latlngs);
          for (var i2 = 0, len = latlngs.length; i2 < len; i2++) {
            if (flat) {
              result[i2] = toLatLng(latlngs[i2]);
              this._bounds.extend(result[i2]);
            } else {
              result[i2] = this._convertLatLngs(latlngs[i2]);
            }
          }
          return result;
        },
        _project: function() {
          var pxBounds = new Bounds();
          this._rings = [];
          this._projectLatlngs(this._latlngs, this._rings, pxBounds);
          if (this._bounds.isValid() && pxBounds.isValid()) {
            this._rawPxBounds = pxBounds;
            this._updateBounds();
          }
        },
        _updateBounds: function() {
          var w2 = this._clickTolerance(), p2 = new Point(w2, w2);
          if (!this._rawPxBounds) {
            return;
          }
          this._pxBounds = new Bounds([
            this._rawPxBounds.min.subtract(p2),
            this._rawPxBounds.max.add(p2)
          ]);
        },
        // recursively turns latlngs into a set of rings with projected coordinates
        _projectLatlngs: function(latlngs, result, projectedBounds) {
          var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i2, ring;
          if (flat) {
            ring = [];
            for (i2 = 0; i2 < len; i2++) {
              ring[i2] = this._map.latLngToLayerPoint(latlngs[i2]);
              projectedBounds.extend(ring[i2]);
            }
            result.push(ring);
          } else {
            for (i2 = 0; i2 < len; i2++) {
              this._projectLatlngs(latlngs[i2], result, projectedBounds);
            }
          }
        },
        // clip polyline by renderer bounds so that we have less to render for performance
        _clipPoints: function() {
          var bounds = this._renderer._bounds;
          this._parts = [];
          if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
            return;
          }
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          var parts = this._parts, i2, j2, k2, len, len2, segment, points;
          for (i2 = 0, k2 = 0, len = this._rings.length; i2 < len; i2++) {
            points = this._rings[i2];
            for (j2 = 0, len2 = points.length; j2 < len2 - 1; j2++) {
              segment = clipSegment(points[j2], points[j2 + 1], bounds, j2, true);
              if (!segment) {
                continue;
              }
              parts[k2] = parts[k2] || [];
              parts[k2].push(segment[0]);
              if (segment[1] !== points[j2 + 1] || j2 === len2 - 2) {
                parts[k2].push(segment[1]);
                k2++;
              }
            }
          }
        },
        // simplify each clipped part of the polyline for performance
        _simplifyPoints: function() {
          var parts = this._parts, tolerance = this.options.smoothFactor;
          for (var i2 = 0, len = parts.length; i2 < len; i2++) {
            parts[i2] = simplify(parts[i2], tolerance);
          }
        },
        _update: function() {
          if (!this._map) {
            return;
          }
          this._clipPoints();
          this._simplifyPoints();
          this._updatePath();
        },
        _updatePath: function() {
          this._renderer._updatePoly(this);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p2, closed) {
          var i2, j2, k2, len, len2, part, w2 = this._clickTolerance();
          if (!this._pxBounds || !this._pxBounds.contains(p2)) {
            return false;
          }
          for (i2 = 0, len = this._parts.length; i2 < len; i2++) {
            part = this._parts[i2];
            for (j2 = 0, len2 = part.length, k2 = len2 - 1; j2 < len2; k2 = j2++) {
              if (!closed && j2 === 0) {
                continue;
              }
              if (pointToSegmentDistance(p2, part[k2], part[j2]) <= w2) {
                return true;
              }
            }
          }
          return false;
        }
      });
      function polyline(latlngs, options) {
        return new Polyline(latlngs, options);
      }
      Polyline._flat = _flat;
      var Polygon = Polyline.extend({
        options: {
          fill: true
        },
        isEmpty: function() {
          return !this._latlngs.length || !this._latlngs[0].length;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
        getCenter: function() {
          if (!this._map) {
            throw new Error("Must add layer to map before using getCenter()");
          }
          return polygonCenter(this._defaultShape(), this._map.options.crs);
        },
        _convertLatLngs: function(latlngs) {
          var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
          if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
            result.pop();
          }
          return result;
        },
        _setLatLngs: function(latlngs) {
          Polyline.prototype._setLatLngs.call(this, latlngs);
          if (isFlat(this._latlngs)) {
            this._latlngs = [this._latlngs];
          }
        },
        _defaultShape: function() {
          return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },
        _clipPoints: function() {
          var bounds = this._renderer._bounds, w2 = this.options.weight, p2 = new Point(w2, w2);
          bounds = new Bounds(bounds.min.subtract(p2), bounds.max.add(p2));
          this._parts = [];
          if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
            return;
          }
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          for (var i2 = 0, len = this._rings.length, clipped; i2 < len; i2++) {
            clipped = clipPolygon(this._rings[i2], bounds, true);
            if (clipped.length) {
              this._parts.push(clipped);
            }
          }
        },
        _updatePath: function() {
          this._renderer._updatePoly(this, true);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p2) {
          var inside = false, part, p1, p22, i2, j2, k2, len, len2;
          if (!this._pxBounds || !this._pxBounds.contains(p2)) {
            return false;
          }
          for (i2 = 0, len = this._parts.length; i2 < len; i2++) {
            part = this._parts[i2];
            for (j2 = 0, len2 = part.length, k2 = len2 - 1; j2 < len2; k2 = j2++) {
              p1 = part[j2];
              p22 = part[k2];
              if (p1.y > p2.y !== p22.y > p2.y && p2.x < (p22.x - p1.x) * (p2.y - p1.y) / (p22.y - p1.y) + p1.x) {
                inside = !inside;
              }
            }
          }
          return inside || Polyline.prototype._containsPoint.call(this, p2, true);
        }
      });
      function polygon(latlngs, options) {
        return new Polygon(latlngs, options);
      }
      var GeoJSON = FeatureGroup.extend({
        /* @section
         * @aka GeoJSON options
         *
         * @option pointToLayer: Function = *
         * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
         * called when data is added, passing the GeoJSON point feature and its `LatLng`.
         * The default is to spawn a default `Marker`:
         * ```js
         * function(geoJsonPoint, latlng) {
         * 	return L.marker(latlng);
         * }
         * ```
         *
         * @option style: Function = *
         * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
         * called internally when data is added.
         * The default value is to not override any defaults:
         * ```js
         * function (geoJsonFeature) {
         * 	return {}
         * }
         * ```
         *
         * @option onEachFeature: Function = *
         * A `Function` that will be called once for each created `Feature`, after it has
         * been created and styled. Useful for attaching events and popups to features.
         * The default is to do nothing with the newly created layers:
         * ```js
         * function (feature, layer) {}
         * ```
         *
         * @option filter: Function = *
         * A `Function` that will be used to decide whether to include a feature or not.
         * The default is to include all features:
         * ```js
         * function (geoJsonFeature) {
         * 	return true;
         * }
         * ```
         * Note: dynamically changing the `filter` option will have effect only on newly
         * added data. It will _not_ re-evaluate already included features.
         *
         * @option coordsToLatLng: Function = *
         * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
         * The default is the `coordsToLatLng` static method.
         *
         * @option markersInheritOptions: Boolean = false
         * Whether default Markers for "Point" type Features inherit from group options.
         */
        initialize: function(geojson, options) {
          setOptions(this, options);
          this._layers = {};
          if (geojson) {
            this.addData(geojson);
          }
        },
        // @method addData( <GeoJSON> data ): this
        // Adds a GeoJSON object to the layer.
        addData: function(geojson) {
          var features = isArray(geojson) ? geojson : geojson.features, i2, len, feature;
          if (features) {
            for (i2 = 0, len = features.length; i2 < len; i2++) {
              feature = features[i2];
              if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                this.addData(feature);
              }
            }
            return this;
          }
          var options = this.options;
          if (options.filter && !options.filter(geojson)) {
            return this;
          }
          var layer = geometryToLayer(geojson, options);
          if (!layer) {
            return this;
          }
          layer.feature = asFeature(geojson);
          layer.defaultOptions = layer.options;
          this.resetStyle(layer);
          if (options.onEachFeature) {
            options.onEachFeature(geojson, layer);
          }
          return this.addLayer(layer);
        },
        // @method resetStyle( <Path> layer? ): this
        // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
        // If `layer` is omitted, the style of all features in the current layer is reset.
        resetStyle: function(layer) {
          if (layer === void 0) {
            return this.eachLayer(this.resetStyle, this);
          }
          layer.options = extend2({}, layer.defaultOptions);
          this._setLayerStyle(layer, this.options.style);
          return this;
        },
        // @method setStyle( <Function> style ): this
        // Changes styles of GeoJSON vector layers with the given style function.
        setStyle: function(style2) {
          return this.eachLayer(function(layer) {
            this._setLayerStyle(layer, style2);
          }, this);
        },
        _setLayerStyle: function(layer, style2) {
          if (layer.setStyle) {
            if (typeof style2 === "function") {
              style2 = style2(layer.feature);
            }
            layer.setStyle(style2);
          }
        }
      });
      function geometryToLayer(geojson, options) {
        var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i2, len;
        if (!coords && !geometry) {
          return null;
        }
        switch (geometry.type) {
          case "Point":
            latlng = _coordsToLatLng(coords);
            return _pointToLayer(pointToLayer, geojson, latlng, options);
          case "MultiPoint":
            for (i2 = 0, len = coords.length; i2 < len; i2++) {
              latlng = _coordsToLatLng(coords[i2]);
              layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
            }
            return new FeatureGroup(layers2);
          case "LineString":
          case "MultiLineString":
            latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
            return new Polyline(latlngs, options);
          case "Polygon":
          case "MultiPolygon":
            latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
            return new Polygon(latlngs, options);
          case "GeometryCollection":
            for (i2 = 0, len = geometry.geometries.length; i2 < len; i2++) {
              var geoLayer = geometryToLayer({
                geometry: geometry.geometries[i2],
                type: "Feature",
                properties: geojson.properties
              }, options);
              if (geoLayer) {
                layers2.push(geoLayer);
              }
            }
            return new FeatureGroup(layers2);
          case "FeatureCollection":
            for (i2 = 0, len = geometry.features.length; i2 < len; i2++) {
              var featureLayer = geometryToLayer(geometry.features[i2], options);
              if (featureLayer) {
                layers2.push(featureLayer);
              }
            }
            return new FeatureGroup(layers2);
          default:
            throw new Error("Invalid GeoJSON object.");
        }
      }
      function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
        return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker2(latlng, options && options.markersInheritOptions && options);
      }
      function coordsToLatLng(coords) {
        return new LatLng(coords[1], coords[0], coords[2]);
      }
      function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
        var latlngs = [];
        for (var i2 = 0, len = coords.length, latlng; i2 < len; i2++) {
          latlng = levelsDeep ? coordsToLatLngs(coords[i2], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i2]);
          latlngs.push(latlng);
        }
        return latlngs;
      }
      function latLngToCoords(latlng, precision) {
        latlng = toLatLng(latlng);
        return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
      }
      function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
        var coords = [];
        for (var i2 = 0, len = latlngs.length; i2 < len; i2++) {
          coords.push(levelsDeep ? latLngsToCoords(latlngs[i2], isFlat(latlngs[i2]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i2], precision));
        }
        if (!levelsDeep && closed && coords.length > 0) {
          coords.push(coords[0].slice());
        }
        return coords;
      }
      function getFeature(layer, newGeometry) {
        return layer.feature ? extend2({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
      }
      function asFeature(geojson) {
        if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
          return geojson;
        }
        return {
          type: "Feature",
          properties: {},
          geometry: geojson
        };
      }
      var PointToGeoJSON = {
        toGeoJSON: function(precision) {
          return getFeature(this, {
            type: "Point",
            coordinates: latLngToCoords(this.getLatLng(), precision)
          });
        }
      };
      Marker2.include(PointToGeoJSON);
      Circle2.include(PointToGeoJSON);
      CircleMarker.include(PointToGeoJSON);
      Polyline.include({
        toGeoJSON: function(precision) {
          var multi = !isFlat(this._latlngs);
          var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
          return getFeature(this, {
            type: (multi ? "Multi" : "") + "LineString",
            coordinates: coords
          });
        }
      });
      Polygon.include({
        toGeoJSON: function(precision) {
          var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
          var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
          if (!holes) {
            coords = [coords];
          }
          return getFeature(this, {
            type: (multi ? "Multi" : "") + "Polygon",
            coordinates: coords
          });
        }
      });
      LayerGroup.include({
        toMultiPoint: function(precision) {
          var coords = [];
          this.eachLayer(function(layer) {
            coords.push(layer.toGeoJSON(precision).geometry.coordinates);
          });
          return getFeature(this, {
            type: "MultiPoint",
            coordinates: coords
          });
        },
        // @method toGeoJSON(precision?: Number|false): Object
        // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
        // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
        toGeoJSON: function(precision) {
          var type = this.feature && this.feature.geometry && this.feature.geometry.type;
          if (type === "MultiPoint") {
            return this.toMultiPoint(precision);
          }
          var isGeometryCollection = type === "GeometryCollection", jsons = [];
          this.eachLayer(function(layer) {
            if (layer.toGeoJSON) {
              var json = layer.toGeoJSON(precision);
              if (isGeometryCollection) {
                jsons.push(json.geometry);
              } else {
                var feature = asFeature(json);
                if (feature.type === "FeatureCollection") {
                  jsons.push.apply(jsons, feature.features);
                } else {
                  jsons.push(feature);
                }
              }
            }
          });
          if (isGeometryCollection) {
            return getFeature(this, {
              geometries: jsons,
              type: "GeometryCollection"
            });
          }
          return {
            type: "FeatureCollection",
            features: jsons
          };
        }
      });
      function geoJSON(geojson, options) {
        return new GeoJSON(geojson, options);
      }
      var geoJson = geoJSON;
      var ImageOverlay = Layer2.extend({
        // @section
        // @aka ImageOverlay options
        options: {
          // @option opacity: Number = 1.0
          // The opacity of the image overlay.
          opacity: 1,
          // @option alt: String = ''
          // Text for the `alt` attribute of the image (useful for accessibility).
          alt: "",
          // @option interactive: Boolean = false
          // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
          interactive: false,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the image.
          // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false,
          // @option errorOverlayUrl: String = ''
          // URL to the overlay image to show in place of the overlay that failed to load.
          errorOverlayUrl: "",
          // @option zIndex: Number = 1
          // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
          zIndex: 1,
          // @option className: String = ''
          // A custom class name to assign to the image. Empty by default.
          className: ""
        },
        initialize: function(url, bounds, options) {
          this._url = url;
          this._bounds = toLatLngBounds(bounds);
          setOptions(this, options);
        },
        onAdd: function() {
          if (!this._image) {
            this._initImage();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
          }
          if (this.options.interactive) {
            addClass(this._image, "leaflet-interactive");
            this.addInteractiveTarget(this._image);
          }
          this.getPane().appendChild(this._image);
          this._reset();
        },
        onRemove: function() {
          remove(this._image);
          if (this.options.interactive) {
            this.removeInteractiveTarget(this._image);
          }
        },
        // @method setOpacity(opacity: Number): this
        // Sets the opacity of the overlay.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._image) {
            this._updateOpacity();
          }
          return this;
        },
        setStyle: function(styleOpts) {
          if (styleOpts.opacity) {
            this.setOpacity(styleOpts.opacity);
          }
          return this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all overlays.
        bringToFront: function() {
          if (this._map) {
            toFront(this._image);
          }
          return this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all overlays.
        bringToBack: function() {
          if (this._map) {
            toBack(this._image);
          }
          return this;
        },
        // @method setUrl(url: String): this
        // Changes the URL of the image.
        setUrl: function(url) {
          this._url = url;
          if (this._image) {
            this._image.src = url;
          }
          return this;
        },
        // @method setBounds(bounds: LatLngBounds): this
        // Update the bounds that this ImageOverlay covers
        setBounds: function(bounds) {
          this._bounds = toLatLngBounds(bounds);
          if (this._map) {
            this._reset();
          }
          return this;
        },
        getEvents: function() {
          var events = {
            zoom: this._reset,
            viewreset: this._reset
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @method setZIndex(value: Number): this
        // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
        setZIndex: function(value) {
          this.options.zIndex = value;
          this._updateZIndex();
          return this;
        },
        // @method getBounds(): LatLngBounds
        // Get the bounds that this ImageOverlay covers
        getBounds: function() {
          return this._bounds;
        },
        // @method getElement(): HTMLElement
        // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
        // used by this overlay.
        getElement: function() {
          return this._image;
        },
        _initImage: function() {
          var wasElementSupplied = this._url.tagName === "IMG";
          var img = this._image = wasElementSupplied ? this._url : create$1("img");
          addClass(img, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(img, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(img, this.options.className);
          }
          img.onselectstart = falseFn;
          img.onmousemove = falseFn;
          img.onload = bind(this.fire, this, "load");
          img.onerror = bind(this._overlayOnError, this, "error");
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          if (this.options.zIndex) {
            this._updateZIndex();
          }
          if (wasElementSupplied) {
            this._url = img.src;
            return;
          }
          img.src = this._url;
          img.alt = this.options.alt;
        },
        _animateZoom: function(e3) {
          var scale2 = this._map.getZoomScale(e3.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e3.zoom, e3.center).min;
          setTransform(this._image, offset, scale2);
        },
        _reset: function() {
          var image = this._image, bounds = new Bounds(
            this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
            this._map.latLngToLayerPoint(this._bounds.getSouthEast())
          ), size = bounds.getSize();
          setPosition(image, bounds.min);
          image.style.width = size.x + "px";
          image.style.height = size.y + "px";
        },
        _updateOpacity: function() {
          setOpacity(this._image, this.options.opacity);
        },
        _updateZIndex: function() {
          if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
            this._image.style.zIndex = this.options.zIndex;
          }
        },
        _overlayOnError: function() {
          this.fire("error");
          var errorUrl = this.options.errorOverlayUrl;
          if (errorUrl && this._url !== errorUrl) {
            this._url = errorUrl;
            this._image.src = errorUrl;
          }
        },
        // @method getCenter(): LatLng
        // Returns the center of the ImageOverlay.
        getCenter: function() {
          return this._bounds.getCenter();
        }
      });
      var imageOverlay = function(url, bounds, options) {
        return new ImageOverlay(url, bounds, options);
      };
      var VideoOverlay = ImageOverlay.extend({
        // @section
        // @aka VideoOverlay options
        options: {
          // @option autoplay: Boolean = true
          // Whether the video starts playing automatically when loaded.
          // On some browsers autoplay will only work with `muted: true`
          autoplay: true,
          // @option loop: Boolean = true
          // Whether the video will loop back to the beginning when played.
          loop: true,
          // @option keepAspectRatio: Boolean = true
          // Whether the video will save aspect ratio after the projection.
          // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
          keepAspectRatio: true,
          // @option muted: Boolean = false
          // Whether the video starts on mute when loaded.
          muted: false,
          // @option playsInline: Boolean = true
          // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
          playsInline: true
        },
        _initImage: function() {
          var wasElementSupplied = this._url.tagName === "VIDEO";
          var vid = this._image = wasElementSupplied ? this._url : create$1("video");
          addClass(vid, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(vid, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(vid, this.options.className);
          }
          vid.onselectstart = falseFn;
          vid.onmousemove = falseFn;
          vid.onloadeddata = bind(this.fire, this, "load");
          if (wasElementSupplied) {
            var sourceElements = vid.getElementsByTagName("source");
            var sources = [];
            for (var j2 = 0; j2 < sourceElements.length; j2++) {
              sources.push(sourceElements[j2].src);
            }
            this._url = sourceElements.length > 0 ? sources : [vid.src];
            return;
          }
          if (!isArray(this._url)) {
            this._url = [this._url];
          }
          if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
            vid.style["objectFit"] = "fill";
          }
          vid.autoplay = !!this.options.autoplay;
          vid.loop = !!this.options.loop;
          vid.muted = !!this.options.muted;
          vid.playsInline = !!this.options.playsInline;
          for (var i2 = 0; i2 < this._url.length; i2++) {
            var source = create$1("source");
            source.src = this._url[i2];
            vid.appendChild(source);
          }
        }
        // @method getElement(): HTMLVideoElement
        // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
        // used by this overlay.
      });
      function videoOverlay(video, bounds, options) {
        return new VideoOverlay(video, bounds, options);
      }
      var SVGOverlay = ImageOverlay.extend({
        _initImage: function() {
          var el = this._image = this._url;
          addClass(el, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(el, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(el, this.options.className);
          }
          el.onselectstart = falseFn;
          el.onmousemove = falseFn;
        }
        // @method getElement(): SVGElement
        // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
        // used by this overlay.
      });
      function svgOverlay(el, bounds, options) {
        return new SVGOverlay(el, bounds, options);
      }
      var DivOverlay = Layer2.extend({
        // @section
        // @aka DivOverlay options
        options: {
          // @option interactive: Boolean = false
          // If true, the popup/tooltip will listen to the mouse events.
          interactive: false,
          // @option offset: Point = Point(0, 0)
          // The offset of the overlay position.
          offset: [0, 0],
          // @option className: String = ''
          // A custom CSS class name to assign to the overlay.
          className: "",
          // @option pane: String = undefined
          // `Map pane` where the overlay will be added.
          pane: void 0,
          // @option content: String|HTMLElement|Function = ''
          // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
          // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
          content: ""
        },
        initialize: function(options, source) {
          if (options && (options instanceof LatLng || isArray(options))) {
            this._latlng = toLatLng(options);
            setOptions(this, source);
          } else {
            setOptions(this, options);
            this._source = source;
          }
          if (this.options.content) {
            this._content = this.options.content;
          }
        },
        // @method openOn(map: Map): this
        // Adds the overlay to the map.
        // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
        openOn: function(map2) {
          map2 = arguments.length ? map2 : this._source._map;
          if (!map2.hasLayer(this)) {
            map2.addLayer(this);
          }
          return this;
        },
        // @method close(): this
        // Closes the overlay.
        // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
        // and `layer.closePopup()`/`.closeTooltip()`.
        close: function() {
          if (this._map) {
            this._map.removeLayer(this);
          }
          return this;
        },
        // @method toggle(layer?: Layer): this
        // Opens or closes the overlay bound to layer depending on its current state.
        // Argument may be omitted only for overlay bound to layer.
        // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
        toggle: function(layer) {
          if (this._map) {
            this.close();
          } else {
            if (arguments.length) {
              this._source = layer;
            } else {
              layer = this._source;
            }
            this._prepareOpen();
            this.openOn(layer._map);
          }
          return this;
        },
        onAdd: function(map2) {
          this._zoomAnimated = map2._zoomAnimated;
          if (!this._container) {
            this._initLayout();
          }
          if (map2._fadeAnimated) {
            setOpacity(this._container, 0);
          }
          clearTimeout(this._removeTimeout);
          this.getPane().appendChild(this._container);
          this.update();
          if (map2._fadeAnimated) {
            setOpacity(this._container, 1);
          }
          this.bringToFront();
          if (this.options.interactive) {
            addClass(this._container, "leaflet-interactive");
            this.addInteractiveTarget(this._container);
          }
        },
        onRemove: function(map2) {
          if (map2._fadeAnimated) {
            setOpacity(this._container, 0);
            this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
          } else {
            remove(this._container);
          }
          if (this.options.interactive) {
            removeClass(this._container, "leaflet-interactive");
            this.removeInteractiveTarget(this._container);
          }
        },
        // @namespace DivOverlay
        // @method getLatLng: LatLng
        // Returns the geographical point of the overlay.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Sets the geographical point where the overlay will open.
        setLatLng: function(latlng) {
          this._latlng = toLatLng(latlng);
          if (this._map) {
            this._updatePosition();
            this._adjustPan();
          }
          return this;
        },
        // @method getContent: String|HTMLElement
        // Returns the content of the overlay.
        getContent: function() {
          return this._content;
        },
        // @method setContent(htmlContent: String|HTMLElement|Function): this
        // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
        // The function should return a `String` or `HTMLElement` to be used in the overlay.
        setContent: function(content) {
          this._content = content;
          this.update();
          return this;
        },
        // @method getElement: String|HTMLElement
        // Returns the HTML container of the overlay.
        getElement: function() {
          return this._container;
        },
        // @method update: null
        // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
        update: function() {
          if (!this._map) {
            return;
          }
          this._container.style.visibility = "hidden";
          this._updateContent();
          this._updateLayout();
          this._updatePosition();
          this._container.style.visibility = "";
          this._adjustPan();
        },
        getEvents: function() {
          var events = {
            zoom: this._updatePosition,
            viewreset: this._updatePosition
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @method isOpen: Boolean
        // Returns `true` when the overlay is visible on the map.
        isOpen: function() {
          return !!this._map && this._map.hasLayer(this);
        },
        // @method bringToFront: this
        // Brings this overlay in front of other overlays (in the same map pane).
        bringToFront: function() {
          if (this._map) {
            toFront(this._container);
          }
          return this;
        },
        // @method bringToBack: this
        // Brings this overlay to the back of other overlays (in the same map pane).
        bringToBack: function() {
          if (this._map) {
            toBack(this._container);
          }
          return this;
        },
        // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
        _prepareOpen: function(latlng) {
          var source = this._source;
          if (!source._map) {
            return false;
          }
          if (source instanceof FeatureGroup) {
            source = null;
            var layers2 = this._source._layers;
            for (var id in layers2) {
              if (layers2[id]._map) {
                source = layers2[id];
                break;
              }
            }
            if (!source) {
              return false;
            }
            this._source = source;
          }
          if (!latlng) {
            if (source.getCenter) {
              latlng = source.getCenter();
            } else if (source.getLatLng) {
              latlng = source.getLatLng();
            } else if (source.getBounds) {
              latlng = source.getBounds().getCenter();
            } else {
              throw new Error("Unable to get source layer LatLng.");
            }
          }
          this.setLatLng(latlng);
          if (this._map) {
            this.update();
          }
          return true;
        },
        _updateContent: function() {
          if (!this._content) {
            return;
          }
          var node = this._contentNode;
          var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
          if (typeof content === "string") {
            node.innerHTML = content;
          } else {
            while (node.hasChildNodes()) {
              node.removeChild(node.firstChild);
            }
            node.appendChild(content);
          }
          this.fire("contentupdate");
        },
        _updatePosition: function() {
          if (!this._map) {
            return;
          }
          var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
          if (this._zoomAnimated) {
            setPosition(this._container, pos.add(anchor));
          } else {
            offset = offset.add(pos).add(anchor);
          }
          var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
          this._container.style.bottom = bottom + "px";
          this._container.style.left = left + "px";
        },
        _getAnchor: function() {
          return [0, 0];
        }
      });
      Map2.include({
        _initOverlay: function(OverlayClass, content, latlng, options) {
          var overlay = content;
          if (!(overlay instanceof OverlayClass)) {
            overlay = new OverlayClass(options).setContent(content);
          }
          if (latlng) {
            overlay.setLatLng(latlng);
          }
          return overlay;
        }
      });
      Layer2.include({
        _initOverlay: function(OverlayClass, old, content, options) {
          var overlay = content;
          if (overlay instanceof OverlayClass) {
            setOptions(overlay, options);
            overlay._source = this;
          } else {
            overlay = old && !options ? old : new OverlayClass(options, this);
            overlay.setContent(content);
          }
          return overlay;
        }
      });
      var Popup2 = DivOverlay.extend({
        // @section
        // @aka Popup options
        options: {
          // @option pane: String = 'popupPane'
          // `Map pane` where the popup will be added.
          pane: "popupPane",
          // @option offset: Point = Point(0, 7)
          // The offset of the popup position.
          offset: [0, 7],
          // @option maxWidth: Number = 300
          // Max width of the popup, in pixels.
          maxWidth: 300,
          // @option minWidth: Number = 50
          // Min width of the popup, in pixels.
          minWidth: 50,
          // @option maxHeight: Number = null
          // If set, creates a scrollable container of the given height
          // inside a popup if its content exceeds it.
          // The scrollable container can be styled using the
          // `leaflet-popup-scrolled` CSS class selector.
          maxHeight: null,
          // @option autoPan: Boolean = true
          // Set it to `false` if you don't want the map to do panning animation
          // to fit the opened popup.
          autoPan: true,
          // @option autoPanPaddingTopLeft: Point = null
          // The margin between the popup and the top left corner of the map
          // view after autopanning was performed.
          autoPanPaddingTopLeft: null,
          // @option autoPanPaddingBottomRight: Point = null
          // The margin between the popup and the bottom right corner of the map
          // view after autopanning was performed.
          autoPanPaddingBottomRight: null,
          // @option autoPanPadding: Point = Point(5, 5)
          // Equivalent of setting both top left and bottom right autopan padding to the same value.
          autoPanPadding: [5, 5],
          // @option keepInView: Boolean = false
          // Set it to `true` if you want to prevent users from panning the popup
          // off of the screen while it is open.
          keepInView: false,
          // @option closeButton: Boolean = true
          // Controls the presence of a close button in the popup.
          closeButton: true,
          // @option autoClose: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the popup closing when another popup is opened.
          autoClose: true,
          // @option closeOnEscapeKey: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the ESC key for closing of the popup.
          closeOnEscapeKey: true,
          // @option closeOnClick: Boolean = *
          // Set it if you want to override the default behavior of the popup closing when user clicks
          // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
          // @option className: String = ''
          // A custom CSS class name to assign to the popup.
          className: ""
        },
        // @namespace Popup
        // @method openOn(map: Map): this
        // Alternative to `map.openPopup(popup)`.
        // Adds the popup to the map and closes the previous one.
        openOn: function(map2) {
          map2 = arguments.length ? map2 : this._source._map;
          if (!map2.hasLayer(this) && map2._popup && map2._popup.options.autoClose) {
            map2.removeLayer(map2._popup);
          }
          map2._popup = this;
          return DivOverlay.prototype.openOn.call(this, map2);
        },
        onAdd: function(map2) {
          DivOverlay.prototype.onAdd.call(this, map2);
          map2.fire("popupopen", { popup: this });
          if (this._source) {
            this._source.fire("popupopen", { popup: this }, true);
            if (!(this._source instanceof Path2)) {
              this._source.on("preclick", stopPropagation);
            }
          }
        },
        onRemove: function(map2) {
          DivOverlay.prototype.onRemove.call(this, map2);
          map2.fire("popupclose", { popup: this });
          if (this._source) {
            this._source.fire("popupclose", { popup: this }, true);
            if (!(this._source instanceof Path2)) {
              this._source.off("preclick", stopPropagation);
            }
          }
        },
        getEvents: function() {
          var events = DivOverlay.prototype.getEvents.call(this);
          if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
            events.preclick = this.close;
          }
          if (this.options.keepInView) {
            events.moveend = this._adjustPan;
          }
          return events;
        },
        _initLayout: function() {
          var prefix2 = "leaflet-popup", container = this._container = create$1(
            "div",
            prefix2 + " " + (this.options.className || "") + " leaflet-zoom-animated"
          );
          var wrapper = this._wrapper = create$1("div", prefix2 + "-content-wrapper", container);
          this._contentNode = create$1("div", prefix2 + "-content", wrapper);
          disableClickPropagation(container);
          disableScrollPropagation(this._contentNode);
          on(container, "contextmenu", stopPropagation);
          this._tipContainer = create$1("div", prefix2 + "-tip-container", container);
          this._tip = create$1("div", prefix2 + "-tip", this._tipContainer);
          if (this.options.closeButton) {
            var closeButton = this._closeButton = create$1("a", prefix2 + "-close-button", container);
            closeButton.setAttribute("role", "button");
            closeButton.setAttribute("aria-label", "Close popup");
            closeButton.href = "#close";
            closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
            on(closeButton, "click", function(ev) {
              preventDefault(ev);
              this.close();
            }, this);
          }
        },
        _updateLayout: function() {
          var container = this._contentNode, style2 = container.style;
          style2.width = "";
          style2.whiteSpace = "nowrap";
          var width = container.offsetWidth;
          width = Math.min(width, this.options.maxWidth);
          width = Math.max(width, this.options.minWidth);
          style2.width = width + 1 + "px";
          style2.whiteSpace = "";
          style2.height = "";
          var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
          if (maxHeight && height > maxHeight) {
            style2.height = maxHeight + "px";
            addClass(container, scrolledClass);
          } else {
            removeClass(container, scrolledClass);
          }
          this._containerWidth = this._container.offsetWidth;
        },
        _animateZoom: function(e3) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, e3.zoom, e3.center), anchor = this._getAnchor();
          setPosition(this._container, pos.add(anchor));
        },
        _adjustPan: function() {
          if (!this.options.autoPan) {
            return;
          }
          if (this._map._panAnim) {
            this._map._panAnim.stop();
          }
          if (this._autopanning) {
            this._autopanning = false;
            return;
          }
          var map2 = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
          layerPos._add(getPosition(this._container));
          var containerPos = map2.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map2.getSize(), dx = 0, dy = 0;
          if (containerPos.x + containerWidth + paddingBR.x > size.x) {
            dx = containerPos.x + containerWidth - size.x + paddingBR.x;
          }
          if (containerPos.x - dx - paddingTL.x < 0) {
            dx = containerPos.x - paddingTL.x;
          }
          if (containerPos.y + containerHeight + paddingBR.y > size.y) {
            dy = containerPos.y + containerHeight - size.y + paddingBR.y;
          }
          if (containerPos.y - dy - paddingTL.y < 0) {
            dy = containerPos.y - paddingTL.y;
          }
          if (dx || dy) {
            if (this.options.keepInView) {
              this._autopanning = true;
            }
            map2.fire("autopanstart").panBy([dx, dy]);
          }
        },
        _getAnchor: function() {
          return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
        }
      });
      var popup2 = function(options, source) {
        return new Popup2(options, source);
      };
      Map2.mergeOptions({
        closePopupOnClick: true
      });
      Map2.include({
        // @method openPopup(popup: Popup): this
        // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
        // @alternative
        // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
        // Creates a popup with the specified content and options and opens it in the given point on a map.
        openPopup: function(popup22, latlng, options) {
          this._initOverlay(Popup2, popup22, latlng, options).openOn(this);
          return this;
        },
        // @method closePopup(popup?: Popup): this
        // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
        closePopup: function(popup22) {
          popup22 = arguments.length ? popup22 : this._popup;
          if (popup22) {
            popup22.close();
          }
          return this;
        }
      });
      Layer2.include({
        // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
        // Binds a popup to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindPopup: function(content, options) {
          this._popup = this._initOverlay(Popup2, this._popup, content, options);
          if (!this._popupHandlersAdded) {
            this.on({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            });
            this._popupHandlersAdded = true;
          }
          return this;
        },
        // @method unbindPopup(): this
        // Removes the popup previously bound with `bindPopup`.
        unbindPopup: function() {
          if (this._popup) {
            this.off({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            });
            this._popupHandlersAdded = false;
            this._popup = null;
          }
          return this;
        },
        // @method openPopup(latlng?: LatLng): this
        // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
        openPopup: function(latlng) {
          if (this._popup) {
            if (!(this instanceof FeatureGroup)) {
              this._popup._source = this;
            }
            if (this._popup._prepareOpen(latlng || this._latlng)) {
              this._popup.openOn(this._map);
            }
          }
          return this;
        },
        // @method closePopup(): this
        // Closes the popup bound to this layer if it is open.
        closePopup: function() {
          if (this._popup) {
            this._popup.close();
          }
          return this;
        },
        // @method togglePopup(): this
        // Opens or closes the popup bound to this layer depending on its current state.
        togglePopup: function() {
          if (this._popup) {
            this._popup.toggle(this);
          }
          return this;
        },
        // @method isPopupOpen(): boolean
        // Returns `true` if the popup bound to this layer is currently open.
        isPopupOpen: function() {
          return this._popup ? this._popup.isOpen() : false;
        },
        // @method setPopupContent(content: String|HTMLElement|Popup): this
        // Sets the content of the popup bound to this layer.
        setPopupContent: function(content) {
          if (this._popup) {
            this._popup.setContent(content);
          }
          return this;
        },
        // @method getPopup(): Popup
        // Returns the popup bound to this layer.
        getPopup: function() {
          return this._popup;
        },
        _openPopup: function(e3) {
          if (!this._popup || !this._map) {
            return;
          }
          stop(e3);
          var target = e3.layer || e3.target;
          if (this._popup._source === target && !(target instanceof Path2)) {
            if (this._map.hasLayer(this._popup)) {
              this.closePopup();
            } else {
              this.openPopup(e3.latlng);
            }
            return;
          }
          this._popup._source = target;
          this.openPopup(e3.latlng);
        },
        _movePopup: function(e3) {
          this._popup.setLatLng(e3.latlng);
        },
        _onKeyPress: function(e3) {
          if (e3.originalEvent.keyCode === 13) {
            this._openPopup(e3);
          }
        }
      });
      var Tooltip2 = DivOverlay.extend({
        // @section
        // @aka Tooltip options
        options: {
          // @option pane: String = 'tooltipPane'
          // `Map pane` where the tooltip will be added.
          pane: "tooltipPane",
          // @option offset: Point = Point(0, 0)
          // Optional offset of the tooltip position.
          offset: [0, 0],
          // @option direction: String = 'auto'
          // Direction where to open the tooltip. Possible values are: `right`, `left`,
          // `top`, `bottom`, `center`, `auto`.
          // `auto` will dynamically switch between `right` and `left` according to the tooltip
          // position on the map.
          direction: "auto",
          // @option permanent: Boolean = false
          // Whether to open the tooltip permanently or only on mouseover.
          permanent: false,
          // @option sticky: Boolean = false
          // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
          sticky: false,
          // @option opacity: Number = 0.9
          // Tooltip container opacity.
          opacity: 0.9
        },
        onAdd: function(map2) {
          DivOverlay.prototype.onAdd.call(this, map2);
          this.setOpacity(this.options.opacity);
          map2.fire("tooltipopen", { tooltip: this });
          if (this._source) {
            this.addEventParent(this._source);
            this._source.fire("tooltipopen", { tooltip: this }, true);
          }
        },
        onRemove: function(map2) {
          DivOverlay.prototype.onRemove.call(this, map2);
          map2.fire("tooltipclose", { tooltip: this });
          if (this._source) {
            this.removeEventParent(this._source);
            this._source.fire("tooltipclose", { tooltip: this }, true);
          }
        },
        getEvents: function() {
          var events = DivOverlay.prototype.getEvents.call(this);
          if (!this.options.permanent) {
            events.preclick = this.close;
          }
          return events;
        },
        _initLayout: function() {
          var prefix2 = "leaflet-tooltip", className = prefix2 + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          this._contentNode = this._container = create$1("div", className);
          this._container.setAttribute("role", "tooltip");
          this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
        },
        _updateLayout: function() {
        },
        _adjustPan: function() {
        },
        _setPosition: function(pos) {
          var subX, subY, map2 = this._map, container = this._container, centerPoint = map2.latLngToContainerPoint(map2.getCenter()), tooltipPoint = map2.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
          if (direction === "top") {
            subX = tooltipWidth / 2;
            subY = tooltipHeight;
          } else if (direction === "bottom") {
            subX = tooltipWidth / 2;
            subY = 0;
          } else if (direction === "center") {
            subX = tooltipWidth / 2;
            subY = tooltipHeight / 2;
          } else if (direction === "right") {
            subX = 0;
            subY = tooltipHeight / 2;
          } else if (direction === "left") {
            subX = tooltipWidth;
            subY = tooltipHeight / 2;
          } else if (tooltipPoint.x < centerPoint.x) {
            direction = "right";
            subX = 0;
            subY = tooltipHeight / 2;
          } else {
            direction = "left";
            subX = tooltipWidth + (offset.x + anchor.x) * 2;
            subY = tooltipHeight / 2;
          }
          pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
          removeClass(container, "leaflet-tooltip-right");
          removeClass(container, "leaflet-tooltip-left");
          removeClass(container, "leaflet-tooltip-top");
          removeClass(container, "leaflet-tooltip-bottom");
          addClass(container, "leaflet-tooltip-" + direction);
          setPosition(container, pos);
        },
        _updatePosition: function() {
          var pos = this._map.latLngToLayerPoint(this._latlng);
          this._setPosition(pos);
        },
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._container) {
            setOpacity(this._container, opacity);
          }
        },
        _animateZoom: function(e3) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, e3.zoom, e3.center);
          this._setPosition(pos);
        },
        _getAnchor: function() {
          return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
        }
      });
      var tooltip = function(options, source) {
        return new Tooltip2(options, source);
      };
      Map2.include({
        // @method openTooltip(tooltip: Tooltip): this
        // Opens the specified tooltip.
        // @alternative
        // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
        // Creates a tooltip with the specified content and options and open it.
        openTooltip: function(tooltip2, latlng, options) {
          this._initOverlay(Tooltip2, tooltip2, latlng, options).openOn(this);
          return this;
        },
        // @method closeTooltip(tooltip: Tooltip): this
        // Closes the tooltip given as parameter.
        closeTooltip: function(tooltip2) {
          tooltip2.close();
          return this;
        }
      });
      Layer2.include({
        // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
        // Binds a tooltip to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindTooltip: function(content, options) {
          if (this._tooltip && this.isTooltipOpen()) {
            this.unbindTooltip();
          }
          this._tooltip = this._initOverlay(Tooltip2, this._tooltip, content, options);
          this._initTooltipInteractions();
          if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
            this.openTooltip();
          }
          return this;
        },
        // @method unbindTooltip(): this
        // Removes the tooltip previously bound with `bindTooltip`.
        unbindTooltip: function() {
          if (this._tooltip) {
            this._initTooltipInteractions(true);
            this.closeTooltip();
            this._tooltip = null;
          }
          return this;
        },
        _initTooltipInteractions: function(remove2) {
          if (!remove2 && this._tooltipHandlersAdded) {
            return;
          }
          var onOff = remove2 ? "off" : "on", events = {
            remove: this.closeTooltip,
            move: this._moveTooltip
          };
          if (!this._tooltip.options.permanent) {
            events.mouseover = this._openTooltip;
            events.mouseout = this.closeTooltip;
            events.click = this._openTooltip;
            if (this._map) {
              this._addFocusListeners();
            } else {
              events.add = this._addFocusListeners;
            }
          } else {
            events.add = this._openTooltip;
          }
          if (this._tooltip.options.sticky) {
            events.mousemove = this._moveTooltip;
          }
          this[onOff](events);
          this._tooltipHandlersAdded = !remove2;
        },
        // @method openTooltip(latlng?: LatLng): this
        // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
        openTooltip: function(latlng) {
          if (this._tooltip) {
            if (!(this instanceof FeatureGroup)) {
              this._tooltip._source = this;
            }
            if (this._tooltip._prepareOpen(latlng)) {
              this._tooltip.openOn(this._map);
              if (this.getElement) {
                this._setAriaDescribedByOnLayer(this);
              } else if (this.eachLayer) {
                this.eachLayer(this._setAriaDescribedByOnLayer, this);
              }
            }
          }
          return this;
        },
        // @method closeTooltip(): this
        // Closes the tooltip bound to this layer if it is open.
        closeTooltip: function() {
          if (this._tooltip) {
            return this._tooltip.close();
          }
        },
        // @method toggleTooltip(): this
        // Opens or closes the tooltip bound to this layer depending on its current state.
        toggleTooltip: function() {
          if (this._tooltip) {
            this._tooltip.toggle(this);
          }
          return this;
        },
        // @method isTooltipOpen(): boolean
        // Returns `true` if the tooltip bound to this layer is currently open.
        isTooltipOpen: function() {
          return this._tooltip.isOpen();
        },
        // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
        // Sets the content of the tooltip bound to this layer.
        setTooltipContent: function(content) {
          if (this._tooltip) {
            this._tooltip.setContent(content);
          }
          return this;
        },
        // @method getTooltip(): Tooltip
        // Returns the tooltip bound to this layer.
        getTooltip: function() {
          return this._tooltip;
        },
        _addFocusListeners: function() {
          if (this.getElement) {
            this._addFocusListenersOnLayer(this);
          } else if (this.eachLayer) {
            this.eachLayer(this._addFocusListenersOnLayer, this);
          }
        },
        _addFocusListenersOnLayer: function(layer) {
          var el = typeof layer.getElement === "function" && layer.getElement();
          if (el) {
            on(el, "focus", function() {
              this._tooltip._source = layer;
              this.openTooltip();
            }, this);
            on(el, "blur", this.closeTooltip, this);
          }
        },
        _setAriaDescribedByOnLayer: function(layer) {
          var el = typeof layer.getElement === "function" && layer.getElement();
          if (el) {
            el.setAttribute("aria-describedby", this._tooltip._container.id);
          }
        },
        _openTooltip: function(e3) {
          if (!this._tooltip || !this._map) {
            return;
          }
          if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
            this._openOnceFlag = true;
            var that = this;
            this._map.once("moveend", function() {
              that._openOnceFlag = false;
              that._openTooltip(e3);
            });
            return;
          }
          this._tooltip._source = e3.layer || e3.target;
          this.openTooltip(this._tooltip.options.sticky ? e3.latlng : void 0);
        },
        _moveTooltip: function(e3) {
          var latlng = e3.latlng, containerPoint, layerPoint;
          if (this._tooltip.options.sticky && e3.originalEvent) {
            containerPoint = this._map.mouseEventToContainerPoint(e3.originalEvent);
            layerPoint = this._map.containerPointToLayerPoint(containerPoint);
            latlng = this._map.layerPointToLatLng(layerPoint);
          }
          this._tooltip.setLatLng(latlng);
        }
      });
      var DivIcon = Icon.extend({
        options: {
          // @section
          // @aka DivIcon options
          iconSize: [12, 12],
          // also can be set through CSS
          // iconAnchor: (Point),
          // popupAnchor: (Point),
          // @option html: String|HTMLElement = ''
          // Custom HTML code to put inside the div element, empty by default. Alternatively,
          // an instance of `HTMLElement`.
          html: false,
          // @option bgPos: Point = [0, 0]
          // Optional relative position of the background, in pixels
          bgPos: null,
          className: "leaflet-div-icon"
        },
        createIcon: function(oldIcon) {
          var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
          if (options.html instanceof Element) {
            empty(div);
            div.appendChild(options.html);
          } else {
            div.innerHTML = options.html !== false ? options.html : "";
          }
          if (options.bgPos) {
            var bgPos = toPoint(options.bgPos);
            div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
          }
          this._setIconStyles(div, "icon");
          return div;
        },
        createShadow: function() {
          return null;
        }
      });
      function divIcon(options) {
        return new DivIcon(options);
      }
      Icon.Default = IconDefault;
      var GridLayer = Layer2.extend({
        // @section
        // @aka GridLayer options
        options: {
          // @option tileSize: Number|Point = 256
          // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
          tileSize: 256,
          // @option opacity: Number = 1.0
          // Opacity of the tiles. Can be used in the `createTile()` function.
          opacity: 1,
          // @option updateWhenIdle: Boolean = (depends)
          // Load new tiles only when panning ends.
          // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
          // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
          // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
          updateWhenIdle: Browser2.mobile,
          // @option updateWhenZooming: Boolean = true
          // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
          updateWhenZooming: true,
          // @option updateInterval: Number = 200
          // Tiles will not update more than once every `updateInterval` milliseconds when panning.
          updateInterval: 200,
          // @option zIndex: Number = 1
          // The explicit zIndex of the tile layer.
          zIndex: 1,
          // @option bounds: LatLngBounds = undefined
          // If set, tiles will only be loaded inside the set `LatLngBounds`.
          bounds: null,
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = undefined
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: void 0,
          // @option maxNativeZoom: Number = undefined
          // Maximum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
          // from `maxNativeZoom` level and auto-scaled.
          maxNativeZoom: void 0,
          // @option minNativeZoom: Number = undefined
          // Minimum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
          // from `minNativeZoom` level and auto-scaled.
          minNativeZoom: void 0,
          // @option noWrap: Boolean = false
          // Whether the layer is wrapped around the antimeridian. If `true`, the
          // GridLayer will only be displayed once at low zoom levels. Has no
          // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
          // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
          // tiles outside the CRS limits.
          noWrap: false,
          // @option pane: String = 'tilePane'
          // `Map pane` where the grid layer will be added.
          pane: "tilePane",
          // @option className: String = ''
          // A custom class name to assign to the tile layer. Empty by default.
          className: "",
          // @option keepBuffer: Number = 2
          // When panning the map, keep this many rows and columns of tiles before unloading them.
          keepBuffer: 2
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        onAdd: function() {
          this._initContainer();
          this._levels = {};
          this._tiles = {};
          this._resetView();
        },
        beforeAdd: function(map2) {
          map2._addZoomLimit(this);
        },
        onRemove: function(map2) {
          this._removeAllTiles();
          remove(this._container);
          map2._removeZoomLimit(this);
          this._container = null;
          this._tileZoom = void 0;
        },
        // @method bringToFront: this
        // Brings the tile layer to the top of all tile layers.
        bringToFront: function() {
          if (this._map) {
            toFront(this._container);
            this._setAutoZIndex(Math.max);
          }
          return this;
        },
        // @method bringToBack: this
        // Brings the tile layer to the bottom of all tile layers.
        bringToBack: function() {
          if (this._map) {
            toBack(this._container);
            this._setAutoZIndex(Math.min);
          }
          return this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the tiles for this layer.
        getContainer: function() {
          return this._container;
        },
        // @method setOpacity(opacity: Number): this
        // Changes the [opacity](#gridlayer-opacity) of the grid layer.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          this._updateOpacity();
          return this;
        },
        // @method setZIndex(zIndex: Number): this
        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
        setZIndex: function(zIndex) {
          this.options.zIndex = zIndex;
          this._updateZIndex();
          return this;
        },
        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: function() {
          return this._loading;
        },
        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: function() {
          if (this._map) {
            this._removeAllTiles();
            var tileZoom = this._clampZoom(this._map.getZoom());
            if (tileZoom !== this._tileZoom) {
              this._tileZoom = tileZoom;
              this._updateLevels();
            }
            this._update();
          }
          return this;
        },
        getEvents: function() {
          var events = {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
          };
          if (!this.options.updateWhenIdle) {
            if (!this._onMove) {
              this._onMove = throttle2(this._onMoveEnd, this.options.updateInterval, this);
            }
            events.move = this._onMove;
          }
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @section Extension methods
        // Layers extending `GridLayer` shall reimplement the following method.
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, must be overridden by classes extending `GridLayer`.
        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
        // is specified, it must be called when the tile has finished loading and drawing.
        createTile: function() {
          return document.createElement("div");
        },
        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: function() {
          var s2 = this.options.tileSize;
          return s2 instanceof Point ? s2 : new Point(s2, s2);
        },
        _updateZIndex: function() {
          if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
            this._container.style.zIndex = this.options.zIndex;
          }
        },
        _setAutoZIndex: function(compare) {
          var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
          for (var i2 = 0, len = layers2.length, zIndex; i2 < len; i2++) {
            zIndex = layers2[i2].style.zIndex;
            if (layers2[i2] !== this._container && zIndex) {
              edgeZIndex = compare(edgeZIndex, +zIndex);
            }
          }
          if (isFinite(edgeZIndex)) {
            this.options.zIndex = edgeZIndex + compare(-1, 1);
            this._updateZIndex();
          }
        },
        _updateOpacity: function() {
          if (!this._map) {
            return;
          }
          if (Browser2.ielt9) {
            return;
          }
          setOpacity(this._container, this.options.opacity);
          var now = +/* @__PURE__ */ new Date(), nextFrame = false, willPrune = false;
          for (var key in this._tiles) {
            var tile = this._tiles[key];
            if (!tile.current || !tile.loaded) {
              continue;
            }
            var fade = Math.min(1, (now - tile.loaded) / 200);
            setOpacity(tile.el, fade);
            if (fade < 1) {
              nextFrame = true;
            } else {
              if (tile.active) {
                willPrune = true;
              } else {
                this._onOpaqueTile(tile);
              }
              tile.active = true;
            }
          }
          if (willPrune && !this._noPrune) {
            this._pruneTiles();
          }
          if (nextFrame) {
            cancelAnimFrame(this._fadeFrame);
            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
          }
        },
        _onOpaqueTile: falseFn,
        _initContainer: function() {
          if (this._container) {
            return;
          }
          this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
          this._updateZIndex();
          if (this.options.opacity < 1) {
            this._updateOpacity();
          }
          this.getPane().appendChild(this._container);
        },
        _updateLevels: function() {
          var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
          if (zoom2 === void 0) {
            return void 0;
          }
          for (var z2 in this._levels) {
            z2 = Number(z2);
            if (this._levels[z2].el.children.length || z2 === zoom2) {
              this._levels[z2].el.style.zIndex = maxZoom - Math.abs(zoom2 - z2);
              this._onUpdateLevel(z2);
            } else {
              remove(this._levels[z2].el);
              this._removeTilesAtZoom(z2);
              this._onRemoveLevel(z2);
              delete this._levels[z2];
            }
          }
          var level = this._levels[zoom2], map2 = this._map;
          if (!level) {
            level = this._levels[zoom2] = {};
            level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
            level.el.style.zIndex = maxZoom;
            level.origin = map2.project(map2.unproject(map2.getPixelOrigin()), zoom2).round();
            level.zoom = zoom2;
            this._setZoomTransform(level, map2.getCenter(), map2.getZoom());
            falseFn(level.el.offsetWidth);
            this._onCreateLevel(level);
          }
          this._level = level;
          return level;
        },
        _onUpdateLevel: falseFn,
        _onRemoveLevel: falseFn,
        _onCreateLevel: falseFn,
        _pruneTiles: function() {
          if (!this._map) {
            return;
          }
          var key, tile;
          var zoom2 = this._map.getZoom();
          if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
            this._removeAllTiles();
            return;
          }
          for (key in this._tiles) {
            tile = this._tiles[key];
            tile.retain = tile.current;
          }
          for (key in this._tiles) {
            tile = this._tiles[key];
            if (tile.current && !tile.active) {
              var coords = tile.coords;
              if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
              }
            }
          }
          for (key in this._tiles) {
            if (!this._tiles[key].retain) {
              this._removeTile(key);
            }
          }
        },
        _removeTilesAtZoom: function(zoom2) {
          for (var key in this._tiles) {
            if (this._tiles[key].coords.z !== zoom2) {
              continue;
            }
            this._removeTile(key);
          }
        },
        _removeAllTiles: function() {
          for (var key in this._tiles) {
            this._removeTile(key);
          }
        },
        _invalidateAll: function() {
          for (var z2 in this._levels) {
            remove(this._levels[z2].el);
            this._onRemoveLevel(Number(z2));
            delete this._levels[z2];
          }
          this._removeAllTiles();
          this._tileZoom = void 0;
        },
        _retainParent: function(x2, y2, z2, minZoom) {
          var x22 = Math.floor(x2 / 2), y22 = Math.floor(y2 / 2), z22 = z2 - 1, coords2 = new Point(+x22, +y22);
          coords2.z = +z22;
          var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
          if (tile && tile.active) {
            tile.retain = true;
            return true;
          } else if (tile && tile.loaded) {
            tile.retain = true;
          }
          if (z22 > minZoom) {
            return this._retainParent(x22, y22, z22, minZoom);
          }
          return false;
        },
        _retainChildren: function(x2, y2, z2, maxZoom) {
          for (var i2 = 2 * x2; i2 < 2 * x2 + 2; i2++) {
            for (var j2 = 2 * y2; j2 < 2 * y2 + 2; j2++) {
              var coords = new Point(i2, j2);
              coords.z = z2 + 1;
              var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
              if (tile && tile.active) {
                tile.retain = true;
                continue;
              } else if (tile && tile.loaded) {
                tile.retain = true;
              }
              if (z2 + 1 < maxZoom) {
                this._retainChildren(i2, j2, z2 + 1, maxZoom);
              }
            }
          }
        },
        _resetView: function(e3) {
          var animating = e3 && (e3.pinch || e3.flyTo);
          this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
        },
        _animateZoom: function(e3) {
          this._setView(e3.center, e3.zoom, true, e3.noUpdate);
        },
        _clampZoom: function(zoom2) {
          var options = this.options;
          if (void 0 !== options.minNativeZoom && zoom2 < options.minNativeZoom) {
            return options.minNativeZoom;
          }
          if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom2) {
            return options.maxNativeZoom;
          }
          return zoom2;
        },
        _setView: function(center, zoom2, noPrune, noUpdate) {
          var tileZoom = Math.round(zoom2);
          if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
            tileZoom = void 0;
          } else {
            tileZoom = this._clampZoom(tileZoom);
          }
          var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
          if (!noUpdate || tileZoomChanged) {
            this._tileZoom = tileZoom;
            if (this._abortLoading) {
              this._abortLoading();
            }
            this._updateLevels();
            this._resetGrid();
            if (tileZoom !== void 0) {
              this._update(center);
            }
            if (!noPrune) {
              this._pruneTiles();
            }
            this._noPrune = !!noPrune;
          }
          this._setZoomTransforms(center, zoom2);
        },
        _setZoomTransforms: function(center, zoom2) {
          for (var i2 in this._levels) {
            this._setZoomTransform(this._levels[i2], center, zoom2);
          }
        },
        _setZoomTransform: function(level, center, zoom2) {
          var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
          if (Browser2.any3d) {
            setTransform(level.el, translate, scale2);
          } else {
            setPosition(level.el, translate);
          }
        },
        _resetGrid: function() {
          var map2 = this._map, crs = map2.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
          var bounds = this._map.getPixelWorldBounds(this._tileZoom);
          if (bounds) {
            this._globalTileRange = this._pxBoundsToTileRange(bounds);
          }
          this._wrapX = crs.wrapLng && !this.options.noWrap && [
            Math.floor(map2.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
            Math.ceil(map2.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
          ];
          this._wrapY = crs.wrapLat && !this.options.noWrap && [
            Math.floor(map2.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
            Math.ceil(map2.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
          ];
        },
        _onMoveEnd: function() {
          if (!this._map || this._map._animatingZoom) {
            return;
          }
          this._update();
        },
        _getTiledPixelBounds: function(center) {
          var map2 = this._map, mapZoom = map2._animatingZoom ? Math.max(map2._animateToZoom, map2.getZoom()) : map2.getZoom(), scale2 = map2.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map2.project(center, this._tileZoom).floor(), halfSize = map2.getSize().divideBy(scale2 * 2);
          return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
        },
        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function(center) {
          var map2 = this._map;
          if (!map2) {
            return;
          }
          var zoom2 = this._clampZoom(map2.getZoom());
          if (center === void 0) {
            center = map2.getCenter();
          }
          if (this._tileZoom === void 0) {
            return;
          }
          var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(
            tileRange.getBottomLeft().subtract([margin, -margin]),
            tileRange.getTopRight().add([margin, -margin])
          );
          if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
            throw new Error("Attempted to load an infinite number of tiles");
          }
          for (var key in this._tiles) {
            var c2 = this._tiles[key].coords;
            if (c2.z !== this._tileZoom || !noPruneRange.contains(new Point(c2.x, c2.y))) {
              this._tiles[key].current = false;
            }
          }
          if (Math.abs(zoom2 - this._tileZoom) > 1) {
            this._setView(center, zoom2);
            return;
          }
          for (var j2 = tileRange.min.y; j2 <= tileRange.max.y; j2++) {
            for (var i2 = tileRange.min.x; i2 <= tileRange.max.x; i2++) {
              var coords = new Point(i2, j2);
              coords.z = this._tileZoom;
              if (!this._isValidTile(coords)) {
                continue;
              }
              var tile = this._tiles[this._tileCoordsToKey(coords)];
              if (tile) {
                tile.current = true;
              } else {
                queue.push(coords);
              }
            }
          }
          queue.sort(function(a2, b2) {
            return a2.distanceTo(tileCenter) - b2.distanceTo(tileCenter);
          });
          if (queue.length !== 0) {
            if (!this._loading) {
              this._loading = true;
              this.fire("loading");
            }
            var fragment = document.createDocumentFragment();
            for (i2 = 0; i2 < queue.length; i2++) {
              this._addTile(queue[i2], fragment);
            }
            this._level.el.appendChild(fragment);
          }
        },
        _isValidTile: function(coords) {
          var crs = this._map.options.crs;
          if (!crs.infinite) {
            var bounds = this._globalTileRange;
            if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
              return false;
            }
          }
          if (!this.options.bounds) {
            return true;
          }
          var tileBounds = this._tileCoordsToBounds(coords);
          return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
        },
        _keyToBounds: function(key) {
          return this._tileCoordsToBounds(this._keyToTileCoords(key));
        },
        _tileCoordsToNwSe: function(coords) {
          var map2 = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map2.unproject(nwPoint, coords.z), se = map2.unproject(sePoint, coords.z);
          return [nw, se];
        },
        // converts tile coordinates to its geographical bounds
        _tileCoordsToBounds: function(coords) {
          var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
          if (!this.options.noWrap) {
            bounds = this._map.wrapLatLngBounds(bounds);
          }
          return bounds;
        },
        // converts tile coordinates to key for the tile cache
        _tileCoordsToKey: function(coords) {
          return coords.x + ":" + coords.y + ":" + coords.z;
        },
        // converts tile cache key to coordinates
        _keyToTileCoords: function(key) {
          var k2 = key.split(":"), coords = new Point(+k2[0], +k2[1]);
          coords.z = +k2[2];
          return coords;
        },
        _removeTile: function(key) {
          var tile = this._tiles[key];
          if (!tile) {
            return;
          }
          remove(tile.el);
          delete this._tiles[key];
          this.fire("tileunload", {
            tile: tile.el,
            coords: this._keyToTileCoords(key)
          });
        },
        _initTile: function(tile) {
          addClass(tile, "leaflet-tile");
          var tileSize = this.getTileSize();
          tile.style.width = tileSize.x + "px";
          tile.style.height = tileSize.y + "px";
          tile.onselectstart = falseFn;
          tile.onmousemove = falseFn;
          if (Browser2.ielt9 && this.options.opacity < 1) {
            setOpacity(tile, this.options.opacity);
          }
        },
        _addTile: function(coords, container) {
          var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
          var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
          this._initTile(tile);
          if (this.createTile.length < 2) {
            requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
          }
          setPosition(tile, tilePos);
          this._tiles[key] = {
            el: tile,
            coords,
            current: true
          };
          container.appendChild(tile);
          this.fire("tileloadstart", {
            tile,
            coords
          });
        },
        _tileReady: function(coords, err, tile) {
          if (err) {
            this.fire("tileerror", {
              error: err,
              tile,
              coords
            });
          }
          var key = this._tileCoordsToKey(coords);
          tile = this._tiles[key];
          if (!tile) {
            return;
          }
          tile.loaded = +/* @__PURE__ */ new Date();
          if (this._map._fadeAnimated) {
            setOpacity(tile.el, 0);
            cancelAnimFrame(this._fadeFrame);
            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
          } else {
            tile.active = true;
            this._pruneTiles();
          }
          if (!err) {
            addClass(tile.el, "leaflet-tile-loaded");
            this.fire("tileload", {
              tile: tile.el,
              coords
            });
          }
          if (this._noTilesToLoad()) {
            this._loading = false;
            this.fire("load");
            if (Browser2.ielt9 || !this._map._fadeAnimated) {
              requestAnimFrame(this._pruneTiles, this);
            } else {
              setTimeout(bind(this._pruneTiles, this), 250);
            }
          }
        },
        _getTilePos: function(coords) {
          return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },
        _wrapCoords: function(coords) {
          var newCoords = new Point(
            this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
            this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
          );
          newCoords.z = coords.z;
          return newCoords;
        },
        _pxBoundsToTileRange: function(bounds) {
          var tileSize = this.getTileSize();
          return new Bounds(
            bounds.min.unscaleBy(tileSize).floor(),
            bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
          );
        },
        _noTilesToLoad: function() {
          for (var key in this._tiles) {
            if (!this._tiles[key].loaded) {
              return false;
            }
          }
          return true;
        }
      });
      function gridLayer(options) {
        return new GridLayer(options);
      }
      var TileLayer2 = GridLayer.extend({
        // @section
        // @aka TileLayer options
        options: {
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = 18
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: 18,
          // @option subdomains: String|String[] = 'abc'
          // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
          subdomains: "abc",
          // @option errorTileUrl: String = ''
          // URL to the tile image to show in place of the tile that failed to load.
          errorTileUrl: "",
          // @option zoomOffset: Number = 0
          // The zoom number used in tile URLs will be offset with this value.
          zoomOffset: 0,
          // @option tms: Boolean = false
          // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
          tms: false,
          // @option zoomReverse: Boolean = false
          // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
          zoomReverse: false,
          // @option detectRetina: Boolean = false
          // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
          detectRetina: false,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false,
          // @option referrerPolicy: Boolean|String = false
          // Whether the referrerPolicy attribute will be added to the tiles.
          // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
          // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
          // (e.g. to validate an API token).
          // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
          referrerPolicy: false
        },
        initialize: function(url, options) {
          this._url = url;
          options = setOptions(this, options);
          if (options.detectRetina && Browser2.retina && options.maxZoom > 0) {
            options.tileSize = Math.floor(options.tileSize / 2);
            if (!options.zoomReverse) {
              options.zoomOffset++;
              options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
            } else {
              options.zoomOffset--;
              options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
            }
            options.minZoom = Math.max(0, options.minZoom);
          } else if (!options.zoomReverse) {
            options.maxZoom = Math.max(options.minZoom, options.maxZoom);
          } else {
            options.minZoom = Math.min(options.maxZoom, options.minZoom);
          }
          if (typeof options.subdomains === "string") {
            options.subdomains = options.subdomains.split("");
          }
          this.on("tileunload", this._onTileRemove);
        },
        // @method setUrl(url: String, noRedraw?: Boolean): this
        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
        // If the URL does not change, the layer will not be redrawn unless
        // the noRedraw parameter is set to false.
        setUrl: function(url, noRedraw) {
          if (this._url === url && noRedraw === void 0) {
            noRedraw = true;
          }
          this._url = url;
          if (!noRedraw) {
            this.redraw();
          }
          return this;
        },
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
        // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
        // callback is called when the tile has been loaded.
        createTile: function(coords, done) {
          var tile = document.createElement("img");
          on(tile, "load", bind(this._tileOnLoad, this, done, tile));
          on(tile, "error", bind(this._tileOnError, this, done, tile));
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          if (typeof this.options.referrerPolicy === "string") {
            tile.referrerPolicy = this.options.referrerPolicy;
          }
          tile.alt = "";
          tile.src = this.getTileUrl(coords);
          return tile;
        },
        // @section Extension methods
        // @uninheritable
        // Layers extending `TileLayer` might reimplement the following method.
        // @method getTileUrl(coords: Object): String
        // Called only internally, returns the URL for a tile given its coordinates.
        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
        getTileUrl: function(coords) {
          var data = {
            r: Browser2.retina ? "@2x" : "",
            s: this._getSubdomain(coords),
            x: coords.x,
            y: coords.y,
            z: this._getZoomForUrl()
          };
          if (this._map && !this._map.options.crs.infinite) {
            var invertedY = this._globalTileRange.max.y - coords.y;
            if (this.options.tms) {
              data["y"] = invertedY;
            }
            data["-y"] = invertedY;
          }
          return template(this._url, extend2(data, this.options));
        },
        _tileOnLoad: function(done, tile) {
          if (Browser2.ielt9) {
            setTimeout(bind(done, this, null, tile), 0);
          } else {
            done(null, tile);
          }
        },
        _tileOnError: function(done, tile, e3) {
          var errorUrl = this.options.errorTileUrl;
          if (errorUrl && tile.getAttribute("src") !== errorUrl) {
            tile.src = errorUrl;
          }
          done(e3, tile);
        },
        _onTileRemove: function(e3) {
          e3.tile.onload = null;
        },
        _getZoomForUrl: function() {
          var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
          if (zoomReverse) {
            zoom2 = maxZoom - zoom2;
          }
          return zoom2 + zoomOffset;
        },
        _getSubdomain: function(tilePoint) {
          var index2 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
          return this.options.subdomains[index2];
        },
        // stops loading all tiles in the background layer
        _abortLoading: function() {
          var i2, tile;
          for (i2 in this._tiles) {
            if (this._tiles[i2].coords.z !== this._tileZoom) {
              tile = this._tiles[i2].el;
              tile.onload = falseFn;
              tile.onerror = falseFn;
              if (!tile.complete) {
                tile.src = emptyImageUrl;
                var coords = this._tiles[i2].coords;
                remove(tile);
                delete this._tiles[i2];
                this.fire("tileabort", {
                  tile,
                  coords
                });
              }
            }
          }
        },
        _removeTile: function(key) {
          var tile = this._tiles[key];
          if (!tile) {
            return;
          }
          tile.el.setAttribute("src", emptyImageUrl);
          return GridLayer.prototype._removeTile.call(this, key);
        },
        _tileReady: function(coords, err, tile) {
          if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
            return;
          }
          return GridLayer.prototype._tileReady.call(this, coords, err, tile);
        }
      });
      function tileLayer(url, options) {
        return new TileLayer2(url, options);
      }
      var TileLayerWMS = TileLayer2.extend({
        // @section
        // @aka TileLayer.WMS options
        // If any custom options not documented here are used, they will be sent to the
        // WMS server as extra parameters in each request URL. This can be useful for
        // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
        defaultWmsParams: {
          service: "WMS",
          request: "GetMap",
          // @option layers: String = ''
          // **(required)** Comma-separated list of WMS layers to show.
          layers: "",
          // @option styles: String = ''
          // Comma-separated list of WMS styles.
          styles: "",
          // @option format: String = 'image/jpeg'
          // WMS image format (use `'image/png'` for layers with transparency).
          format: "image/jpeg",
          // @option transparent: Boolean = false
          // If `true`, the WMS service will return images with transparency.
          transparent: false,
          // @option version: String = '1.1.1'
          // Version of the WMS service to use
          version: "1.1.1"
        },
        options: {
          // @option crs: CRS = null
          // Coordinate Reference System to use for the WMS requests, defaults to
          // map CRS. Don't change this if you're not sure what it means.
          crs: null,
          // @option uppercase: Boolean = false
          // If `true`, WMS request parameter keys will be uppercase.
          uppercase: false
        },
        initialize: function(url, options) {
          this._url = url;
          var wmsParams = extend2({}, this.defaultWmsParams);
          for (var i2 in options) {
            if (!(i2 in this.options)) {
              wmsParams[i2] = options[i2];
            }
          }
          options = setOptions(this, options);
          var realRetina = options.detectRetina && Browser2.retina ? 2 : 1;
          var tileSize = this.getTileSize();
          wmsParams.width = tileSize.x * realRetina;
          wmsParams.height = tileSize.y * realRetina;
          this.wmsParams = wmsParams;
        },
        onAdd: function(map2) {
          this._crs = this.options.crs || map2.options.crs;
          this._wmsVersion = parseFloat(this.wmsParams.version);
          var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
          this.wmsParams[projectionKey] = this._crs.code;
          TileLayer2.prototype.onAdd.call(this, map2);
        },
        getTileUrl: function(coords) {
          var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min2 = bounds.min, max2 = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min2.y, min2.x, max2.y, max2.x] : [min2.x, min2.y, max2.x, max2.y]).join(","), url = TileLayer2.prototype.getTileUrl.call(this, coords);
          return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
        },
        // @method setParams(params: Object, noRedraw?: Boolean): this
        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
        setParams: function(params, noRedraw) {
          extend2(this.wmsParams, params);
          if (!noRedraw) {
            this.redraw();
          }
          return this;
        }
      });
      function tileLayerWMS(url, options) {
        return new TileLayerWMS(url, options);
      }
      TileLayer2.WMS = TileLayerWMS;
      tileLayer.wms = tileLayerWMS;
      var Renderer = Layer2.extend({
        // @section
        // @aka Renderer options
        options: {
          // @option padding: Number = 0.1
          // How much to extend the clip area around the map view (relative to its size)
          // e.g. 0.1 would be 10% of map view in each direction
          padding: 0.1
        },
        initialize: function(options) {
          setOptions(this, options);
          stamp(this);
          this._layers = this._layers || {};
        },
        onAdd: function() {
          if (!this._container) {
            this._initContainer();
            addClass(this._container, "leaflet-zoom-animated");
          }
          this.getPane().appendChild(this._container);
          this._update();
          this.on("update", this._updatePaths, this);
        },
        onRemove: function() {
          this.off("update", this._updatePaths, this);
          this._destroyContainer();
        },
        getEvents: function() {
          var events = {
            viewreset: this._reset,
            zoom: this._onZoom,
            moveend: this._update,
            zoomend: this._onZoomEnd
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._onAnimZoom;
          }
          return events;
        },
        _onAnimZoom: function(ev) {
          this._updateTransform(ev.center, ev.zoom);
        },
        _onZoom: function() {
          this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },
        _updateTransform: function(center, zoom2) {
          var scale2 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale2).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom2));
          if (Browser2.any3d) {
            setTransform(this._container, topLeftOffset, scale2);
          } else {
            setPosition(this._container, topLeftOffset);
          }
        },
        _reset: function() {
          this._update();
          this._updateTransform(this._center, this._zoom);
          for (var id in this._layers) {
            this._layers[id]._reset();
          }
        },
        _onZoomEnd: function() {
          for (var id in this._layers) {
            this._layers[id]._project();
          }
        },
        _updatePaths: function() {
          for (var id in this._layers) {
            this._layers[id]._update();
          }
        },
        _update: function() {
          var p2 = this.options.padding, size = this._map.getSize(), min2 = this._map.containerPointToLayerPoint(size.multiplyBy(-p2)).round();
          this._bounds = new Bounds(min2, min2.add(size.multiplyBy(1 + p2 * 2)).round());
          this._center = this._map.getCenter();
          this._zoom = this._map.getZoom();
        }
      });
      var Canvas = Renderer.extend({
        // @section
        // @aka Canvas options
        options: {
          // @option tolerance: Number = 0
          // How much to extend the click tolerance around a path/object on the map.
          tolerance: 0
        },
        getEvents: function() {
          var events = Renderer.prototype.getEvents.call(this);
          events.viewprereset = this._onViewPreReset;
          return events;
        },
        _onViewPreReset: function() {
          this._postponeUpdatePaths = true;
        },
        onAdd: function() {
          Renderer.prototype.onAdd.call(this);
          this._draw();
        },
        _initContainer: function() {
          var container = this._container = document.createElement("canvas");
          on(container, "mousemove", this._onMouseMove, this);
          on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
          on(container, "mouseout", this._handleMouseOut, this);
          container["_leaflet_disable_events"] = true;
          this._ctx = container.getContext("2d");
        },
        _destroyContainer: function() {
          cancelAnimFrame(this._redrawRequest);
          delete this._ctx;
          remove(this._container);
          off(this._container);
          delete this._container;
        },
        _updatePaths: function() {
          if (this._postponeUpdatePaths) {
            return;
          }
          var layer;
          this._redrawBounds = null;
          for (var id in this._layers) {
            layer = this._layers[id];
            layer._update();
          }
          this._redraw();
        },
        _update: function() {
          if (this._map._animatingZoom && this._bounds) {
            return;
          }
          Renderer.prototype._update.call(this);
          var b2 = this._bounds, container = this._container, size = b2.getSize(), m2 = Browser2.retina ? 2 : 1;
          setPosition(container, b2.min);
          container.width = m2 * size.x;
          container.height = m2 * size.y;
          container.style.width = size.x + "px";
          container.style.height = size.y + "px";
          if (Browser2.retina) {
            this._ctx.scale(2, 2);
          }
          this._ctx.translate(-b2.min.x, -b2.min.y);
          this.fire("update");
        },
        _reset: function() {
          Renderer.prototype._reset.call(this);
          if (this._postponeUpdatePaths) {
            this._postponeUpdatePaths = false;
            this._updatePaths();
          }
        },
        _initPath: function(layer) {
          this._updateDashArray(layer);
          this._layers[stamp(layer)] = layer;
          var order2 = layer._order = {
            layer,
            prev: this._drawLast,
            next: null
          };
          if (this._drawLast) {
            this._drawLast.next = order2;
          }
          this._drawLast = order2;
          this._drawFirst = this._drawFirst || this._drawLast;
        },
        _addPath: function(layer) {
          this._requestRedraw(layer);
        },
        _removePath: function(layer) {
          var order2 = layer._order;
          var next = order2.next;
          var prev = order2.prev;
          if (next) {
            next.prev = prev;
          } else {
            this._drawLast = prev;
          }
          if (prev) {
            prev.next = next;
          } else {
            this._drawFirst = next;
          }
          delete layer._order;
          delete this._layers[stamp(layer)];
          this._requestRedraw(layer);
        },
        _updatePath: function(layer) {
          this._extendRedrawBounds(layer);
          layer._project();
          layer._update();
          this._requestRedraw(layer);
        },
        _updateStyle: function(layer) {
          this._updateDashArray(layer);
          this._requestRedraw(layer);
        },
        _updateDashArray: function(layer) {
          if (typeof layer.options.dashArray === "string") {
            var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i2;
            for (i2 = 0; i2 < parts.length; i2++) {
              dashValue = Number(parts[i2]);
              if (isNaN(dashValue)) {
                return;
              }
              dashArray.push(dashValue);
            }
            layer.options._dashArray = dashArray;
          } else {
            layer.options._dashArray = layer.options.dashArray;
          }
        },
        _requestRedraw: function(layer) {
          if (!this._map) {
            return;
          }
          this._extendRedrawBounds(layer);
          this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
        },
        _extendRedrawBounds: function(layer) {
          if (layer._pxBounds) {
            var padding = (layer.options.weight || 0) + 1;
            this._redrawBounds = this._redrawBounds || new Bounds();
            this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
            this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
          }
        },
        _redraw: function() {
          this._redrawRequest = null;
          if (this._redrawBounds) {
            this._redrawBounds.min._floor();
            this._redrawBounds.max._ceil();
          }
          this._clear();
          this._draw();
          this._redrawBounds = null;
        },
        _clear: function() {
          var bounds = this._redrawBounds;
          if (bounds) {
            var size = bounds.getSize();
            this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
          } else {
            this._ctx.save();
            this._ctx.setTransform(1, 0, 0, 1, 0, 0);
            this._ctx.clearRect(0, 0, this._container.width, this._container.height);
            this._ctx.restore();
          }
        },
        _draw: function() {
          var layer, bounds = this._redrawBounds;
          this._ctx.save();
          if (bounds) {
            var size = bounds.getSize();
            this._ctx.beginPath();
            this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
            this._ctx.clip();
          }
          this._drawing = true;
          for (var order2 = this._drawFirst; order2; order2 = order2.next) {
            layer = order2.layer;
            if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
              layer._updatePath();
            }
          }
          this._drawing = false;
          this._ctx.restore();
        },
        _updatePoly: function(layer, closed) {
          if (!this._drawing) {
            return;
          }
          var i2, j2, len2, p2, parts = layer._parts, len = parts.length, ctx = this._ctx;
          if (!len) {
            return;
          }
          ctx.beginPath();
          for (i2 = 0; i2 < len; i2++) {
            for (j2 = 0, len2 = parts[i2].length; j2 < len2; j2++) {
              p2 = parts[i2][j2];
              ctx[j2 ? "lineTo" : "moveTo"](p2.x, p2.y);
            }
            if (closed) {
              ctx.closePath();
            }
          }
          this._fillStroke(ctx, layer);
        },
        _updateCircle: function(layer) {
          if (!this._drawing || layer._empty()) {
            return;
          }
          var p2 = layer._point, ctx = this._ctx, r2 = Math.max(Math.round(layer._radius), 1), s2 = (Math.max(Math.round(layer._radiusY), 1) || r2) / r2;
          if (s2 !== 1) {
            ctx.save();
            ctx.scale(1, s2);
          }
          ctx.beginPath();
          ctx.arc(p2.x, p2.y / s2, r2, 0, Math.PI * 2, false);
          if (s2 !== 1) {
            ctx.restore();
          }
          this._fillStroke(ctx, layer);
        },
        _fillStroke: function(ctx, layer) {
          var options = layer.options;
          if (options.fill) {
            ctx.globalAlpha = options.fillOpacity;
            ctx.fillStyle = options.fillColor || options.color;
            ctx.fill(options.fillRule || "evenodd");
          }
          if (options.stroke && options.weight !== 0) {
            if (ctx.setLineDash) {
              ctx.setLineDash(layer.options && layer.options._dashArray || []);
            }
            ctx.globalAlpha = options.opacity;
            ctx.lineWidth = options.weight;
            ctx.strokeStyle = options.color;
            ctx.lineCap = options.lineCap;
            ctx.lineJoin = options.lineJoin;
            ctx.stroke();
          }
        },
        // Canvas obviously doesn't have mouse events for individual drawn objects,
        // so we emulate that by calculating what's under the mouse on mousemove/click manually
        _onClick: function(e3) {
          var point2 = this._map.mouseEventToLayerPoint(e3), layer, clickedLayer;
          for (var order2 = this._drawFirst; order2; order2 = order2.next) {
            layer = order2.layer;
            if (layer.options.interactive && layer._containsPoint(point2)) {
              if (!(e3.type === "click" || e3.type === "preclick") || !this._map._draggableMoved(layer)) {
                clickedLayer = layer;
              }
            }
          }
          this._fireEvent(clickedLayer ? [clickedLayer] : false, e3);
        },
        _onMouseMove: function(e3) {
          if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
            return;
          }
          var point2 = this._map.mouseEventToLayerPoint(e3);
          this._handleMouseHover(e3, point2);
        },
        _handleMouseOut: function(e3) {
          var layer = this._hoveredLayer;
          if (layer) {
            removeClass(this._container, "leaflet-interactive");
            this._fireEvent([layer], e3, "mouseout");
            this._hoveredLayer = null;
            this._mouseHoverThrottled = false;
          }
        },
        _handleMouseHover: function(e3, point2) {
          if (this._mouseHoverThrottled) {
            return;
          }
          var layer, candidateHoveredLayer;
          for (var order2 = this._drawFirst; order2; order2 = order2.next) {
            layer = order2.layer;
            if (layer.options.interactive && layer._containsPoint(point2)) {
              candidateHoveredLayer = layer;
            }
          }
          if (candidateHoveredLayer !== this._hoveredLayer) {
            this._handleMouseOut(e3);
            if (candidateHoveredLayer) {
              addClass(this._container, "leaflet-interactive");
              this._fireEvent([candidateHoveredLayer], e3, "mouseover");
              this._hoveredLayer = candidateHoveredLayer;
            }
          }
          this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e3);
          this._mouseHoverThrottled = true;
          setTimeout(bind(function() {
            this._mouseHoverThrottled = false;
          }, this), 32);
        },
        _fireEvent: function(layers2, e3, type) {
          this._map._fireDOMEvent(e3, type || e3.type, layers2);
        },
        _bringToFront: function(layer) {
          var order2 = layer._order;
          if (!order2) {
            return;
          }
          var next = order2.next;
          var prev = order2.prev;
          if (next) {
            next.prev = prev;
          } else {
            return;
          }
          if (prev) {
            prev.next = next;
          } else if (next) {
            this._drawFirst = next;
          }
          order2.prev = this._drawLast;
          this._drawLast.next = order2;
          order2.next = null;
          this._drawLast = order2;
          this._requestRedraw(layer);
        },
        _bringToBack: function(layer) {
          var order2 = layer._order;
          if (!order2) {
            return;
          }
          var next = order2.next;
          var prev = order2.prev;
          if (prev) {
            prev.next = next;
          } else {
            return;
          }
          if (next) {
            next.prev = prev;
          } else if (prev) {
            this._drawLast = prev;
          }
          order2.prev = null;
          order2.next = this._drawFirst;
          this._drawFirst.prev = order2;
          this._drawFirst = order2;
          this._requestRedraw(layer);
        }
      });
      function canvas2(options) {
        return Browser2.canvas ? new Canvas(options) : null;
      }
      var vmlCreate = (function() {
        try {
          document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
          return function(name) {
            return document.createElement("<lvml:" + name + ' class="lvml">');
          };
        } catch (e3) {
        }
        return function(name) {
          return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      })();
      var vmlMixin = {
        _initContainer: function() {
          this._container = create$1("div", "leaflet-vml-container");
        },
        _update: function() {
          if (this._map._animatingZoom) {
            return;
          }
          Renderer.prototype._update.call(this);
          this.fire("update");
        },
        _initPath: function(layer) {
          var container = layer._container = vmlCreate("shape");
          addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
          container.coordsize = "1 1";
          layer._path = vmlCreate("path");
          container.appendChild(layer._path);
          this._updateStyle(layer);
          this._layers[stamp(layer)] = layer;
        },
        _addPath: function(layer) {
          var container = layer._container;
          this._container.appendChild(container);
          if (layer.options.interactive) {
            layer.addInteractiveTarget(container);
          }
        },
        _removePath: function(layer) {
          var container = layer._container;
          remove(container);
          layer.removeInteractiveTarget(container);
          delete this._layers[stamp(layer)];
        },
        _updateStyle: function(layer) {
          var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
          container.stroked = !!options.stroke;
          container.filled = !!options.fill;
          if (options.stroke) {
            if (!stroke) {
              stroke = layer._stroke = vmlCreate("stroke");
            }
            container.appendChild(stroke);
            stroke.weight = options.weight + "px";
            stroke.color = options.color;
            stroke.opacity = options.opacity;
            if (options.dashArray) {
              stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
            } else {
              stroke.dashStyle = "";
            }
            stroke.endcap = options.lineCap.replace("butt", "flat");
            stroke.joinstyle = options.lineJoin;
          } else if (stroke) {
            container.removeChild(stroke);
            layer._stroke = null;
          }
          if (options.fill) {
            if (!fill) {
              fill = layer._fill = vmlCreate("fill");
            }
            container.appendChild(fill);
            fill.color = options.fillColor || options.color;
            fill.opacity = options.fillOpacity;
          } else if (fill) {
            container.removeChild(fill);
            layer._fill = null;
          }
        },
        _updateCircle: function(layer) {
          var p2 = layer._point.round(), r2 = Math.round(layer._radius), r22 = Math.round(layer._radiusY || r2);
          this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p2.x + "," + p2.y + " " + r2 + "," + r22 + " 0," + 65535 * 360);
        },
        _setPath: function(layer, path2) {
          layer._path.v = path2;
        },
        _bringToFront: function(layer) {
          toFront(layer._container);
        },
        _bringToBack: function(layer) {
          toBack(layer._container);
        }
      };
      var create = Browser2.vml ? vmlCreate : svgCreate;
      var SVG = Renderer.extend({
        _initContainer: function() {
          this._container = create("svg");
          this._container.setAttribute("pointer-events", "none");
          this._rootGroup = create("g");
          this._container.appendChild(this._rootGroup);
        },
        _destroyContainer: function() {
          remove(this._container);
          off(this._container);
          delete this._container;
          delete this._rootGroup;
          delete this._svgSize;
        },
        _update: function() {
          if (this._map._animatingZoom && this._bounds) {
            return;
          }
          Renderer.prototype._update.call(this);
          var b2 = this._bounds, size = b2.getSize(), container = this._container;
          if (!this._svgSize || !this._svgSize.equals(size)) {
            this._svgSize = size;
            container.setAttribute("width", size.x);
            container.setAttribute("height", size.y);
          }
          setPosition(container, b2.min);
          container.setAttribute("viewBox", [b2.min.x, b2.min.y, size.x, size.y].join(" "));
          this.fire("update");
        },
        // methods below are called by vector layers implementations
        _initPath: function(layer) {
          var path2 = layer._path = create("path");
          if (layer.options.className) {
            addClass(path2, layer.options.className);
          }
          if (layer.options.interactive) {
            addClass(path2, "leaflet-interactive");
          }
          this._updateStyle(layer);
          this._layers[stamp(layer)] = layer;
        },
        _addPath: function(layer) {
          if (!this._rootGroup) {
            this._initContainer();
          }
          this._rootGroup.appendChild(layer._path);
          layer.addInteractiveTarget(layer._path);
        },
        _removePath: function(layer) {
          remove(layer._path);
          layer.removeInteractiveTarget(layer._path);
          delete this._layers[stamp(layer)];
        },
        _updatePath: function(layer) {
          layer._project();
          layer._update();
        },
        _updateStyle: function(layer) {
          var path2 = layer._path, options = layer.options;
          if (!path2) {
            return;
          }
          if (options.stroke) {
            path2.setAttribute("stroke", options.color);
            path2.setAttribute("stroke-opacity", options.opacity);
            path2.setAttribute("stroke-width", options.weight);
            path2.setAttribute("stroke-linecap", options.lineCap);
            path2.setAttribute("stroke-linejoin", options.lineJoin);
            if (options.dashArray) {
              path2.setAttribute("stroke-dasharray", options.dashArray);
            } else {
              path2.removeAttribute("stroke-dasharray");
            }
            if (options.dashOffset) {
              path2.setAttribute("stroke-dashoffset", options.dashOffset);
            } else {
              path2.removeAttribute("stroke-dashoffset");
            }
          } else {
            path2.setAttribute("stroke", "none");
          }
          if (options.fill) {
            path2.setAttribute("fill", options.fillColor || options.color);
            path2.setAttribute("fill-opacity", options.fillOpacity);
            path2.setAttribute("fill-rule", options.fillRule || "evenodd");
          } else {
            path2.setAttribute("fill", "none");
          }
        },
        _updatePoly: function(layer, closed) {
          this._setPath(layer, pointsToPath(layer._parts, closed));
        },
        _updateCircle: function(layer) {
          var p2 = layer._point, r2 = Math.max(Math.round(layer._radius), 1), r22 = Math.max(Math.round(layer._radiusY), 1) || r2, arc = "a" + r2 + "," + r22 + " 0 1,0 ";
          var d2 = layer._empty() ? "M0 0" : "M" + (p2.x - r2) + "," + p2.y + arc + r2 * 2 + ",0 " + arc + -r2 * 2 + ",0 ";
          this._setPath(layer, d2);
        },
        _setPath: function(layer, path2) {
          layer._path.setAttribute("d", path2);
        },
        // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
        _bringToFront: function(layer) {
          toFront(layer._path);
        },
        _bringToBack: function(layer) {
          toBack(layer._path);
        }
      });
      if (Browser2.vml) {
        SVG.include(vmlMixin);
      }
      function svg(options) {
        return Browser2.svg || Browser2.vml ? new SVG(options) : null;
      }
      Map2.include({
        // @namespace Map; @method getRenderer(layer: Path): Renderer
        // Returns the instance of `Renderer` that should be used to render the given
        // `Path`. It will ensure that the `renderer` options of the map and paths
        // are respected, and that the renderers do exist on the map.
        getRenderer: function(layer) {
          var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
          if (!renderer) {
            renderer = this._renderer = this._createRenderer();
          }
          if (!this.hasLayer(renderer)) {
            this.addLayer(renderer);
          }
          return renderer;
        },
        _getPaneRenderer: function(name) {
          if (name === "overlayPane" || name === void 0) {
            return false;
          }
          var renderer = this._paneRenderers[name];
          if (renderer === void 0) {
            renderer = this._createRenderer({ pane: name });
            this._paneRenderers[name] = renderer;
          }
          return renderer;
        },
        _createRenderer: function(options) {
          return this.options.preferCanvas && canvas2(options) || svg(options);
        }
      });
      var Rectangle2 = Polygon.extend({
        initialize: function(latLngBounds, options) {
          Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
        },
        // @method setBounds(latLngBounds: LatLngBounds): this
        // Redraws the rectangle with the passed bounds.
        setBounds: function(latLngBounds) {
          return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
        },
        _boundsToLatLngs: function(latLngBounds) {
          latLngBounds = toLatLngBounds(latLngBounds);
          return [
            latLngBounds.getSouthWest(),
            latLngBounds.getNorthWest(),
            latLngBounds.getNorthEast(),
            latLngBounds.getSouthEast()
          ];
        }
      });
      function rectangle(latLngBounds, options) {
        return new Rectangle2(latLngBounds, options);
      }
      SVG.create = create;
      SVG.pointsToPath = pointsToPath;
      GeoJSON.geometryToLayer = geometryToLayer;
      GeoJSON.coordsToLatLng = coordsToLatLng;
      GeoJSON.coordsToLatLngs = coordsToLatLngs;
      GeoJSON.latLngToCoords = latLngToCoords;
      GeoJSON.latLngsToCoords = latLngsToCoords;
      GeoJSON.getFeature = getFeature;
      GeoJSON.asFeature = asFeature;
      Map2.mergeOptions({
        // @option boxZoom: Boolean = true
        // Whether the map can be zoomed to a rectangular area specified by
        // dragging the mouse while pressing the shift key.
        boxZoom: true
      });
      var BoxZoom = Handler.extend({
        initialize: function(map2) {
          this._map = map2;
          this._container = map2._container;
          this._pane = map2._panes.overlayPane;
          this._resetStateTimeout = 0;
          map2.on("unload", this._destroy, this);
        },
        addHooks: function() {
          on(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function() {
          off(this._container, "mousedown", this._onMouseDown, this);
        },
        moved: function() {
          return this._moved;
        },
        _destroy: function() {
          remove(this._pane);
          delete this._pane;
        },
        _resetState: function() {
          this._resetStateTimeout = 0;
          this._moved = false;
        },
        _clearDeferredResetState: function() {
          if (this._resetStateTimeout !== 0) {
            clearTimeout(this._resetStateTimeout);
            this._resetStateTimeout = 0;
          }
        },
        _onMouseDown: function(e3) {
          if (!e3.shiftKey || e3.which !== 1 && e3.button !== 1) {
            return false;
          }
          this._clearDeferredResetState();
          this._resetState();
          disableTextSelection();
          disableImageDrag();
          this._startPoint = this._map.mouseEventToContainerPoint(e3);
          on(document, {
            contextmenu: stop,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseMove: function(e3) {
          if (!this._moved) {
            this._moved = true;
            this._box = create$1("div", "leaflet-zoom-box", this._container);
            addClass(this._container, "leaflet-crosshair");
            this._map.fire("boxzoomstart");
          }
          this._point = this._map.mouseEventToContainerPoint(e3);
          var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
          setPosition(this._box, bounds.min);
          this._box.style.width = size.x + "px";
          this._box.style.height = size.y + "px";
        },
        _finish: function() {
          if (this._moved) {
            remove(this._box);
            removeClass(this._container, "leaflet-crosshair");
          }
          enableTextSelection();
          enableImageDrag();
          off(document, {
            contextmenu: stop,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseUp: function(e3) {
          if (e3.which !== 1 && e3.button !== 1) {
            return;
          }
          this._finish();
          if (!this._moved) {
            return;
          }
          this._clearDeferredResetState();
          this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
          var bounds = new LatLngBounds(
            this._map.containerPointToLatLng(this._startPoint),
            this._map.containerPointToLatLng(this._point)
          );
          this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
        },
        _onKeyDown: function(e3) {
          if (e3.keyCode === 27) {
            this._finish();
            this._clearDeferredResetState();
            this._resetState();
          }
        }
      });
      Map2.addInitHook("addHandler", "boxZoom", BoxZoom);
      Map2.mergeOptions({
        // @option doubleClickZoom: Boolean|String = true
        // Whether the map can be zoomed in by double clicking on it and
        // zoomed out by double clicking while holding shift. If passed
        // `'center'`, double-click zoom will zoom to the center of the
        //  view regardless of where the mouse was.
        doubleClickZoom: true
      });
      var DoubleClickZoom = Handler.extend({
        addHooks: function() {
          this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function() {
          this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function(e3) {
          var map2 = this._map, oldZoom = map2.getZoom(), delta = map2.options.zoomDelta, zoom2 = e3.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
          if (map2.options.doubleClickZoom === "center") {
            map2.setZoom(zoom2);
          } else {
            map2.setZoomAround(e3.containerPoint, zoom2);
          }
        }
      });
      Map2.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
      Map2.mergeOptions({
        // @option dragging: Boolean = true
        // Whether the map is draggable with mouse/touch or not.
        dragging: true,
        // @section Panning Inertia Options
        // @option inertia: Boolean = *
        // If enabled, panning of the map will have an inertia effect where
        // the map builds momentum while dragging and continues moving in
        // the same direction for some time. Feels especially nice on touch
        // devices. Enabled by default.
        inertia: true,
        // @option inertiaDeceleration: Number = 3000
        // The rate with which the inertial movement slows down, in pixels/second.
        inertiaDeceleration: 3400,
        // px/s^2
        // @option inertiaMaxSpeed: Number = Infinity
        // Max speed of the inertial movement, in pixels/second.
        inertiaMaxSpeed: Infinity,
        // px/s
        // @option easeLinearity: Number = 0.2
        easeLinearity: 0.2,
        // TODO refactor, move to CRS
        // @option worldCopyJump: Boolean = false
        // With this option enabled, the map tracks when you pan to another "copy"
        // of the world and seamlessly jumps to the original one so that all overlays
        // like markers and vector layers are still visible.
        worldCopyJump: false,
        // @option maxBoundsViscosity: Number = 0.0
        // If `maxBounds` is set, this option will control how solid the bounds
        // are when dragging the map around. The default value of `0.0` allows the
        // user to drag outside the bounds at normal speed, higher values will
        // slow down map dragging outside bounds, and `1.0` makes the bounds fully
        // solid, preventing the user from dragging outside the bounds.
        maxBoundsViscosity: 0
      });
      var Drag = Handler.extend({
        addHooks: function() {
          if (!this._draggable) {
            var map2 = this._map;
            this._draggable = new Draggable(map2._mapPane, map2._container);
            this._draggable.on({
              dragstart: this._onDragStart,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this);
            this._draggable.on("predrag", this._onPreDragLimit, this);
            if (map2.options.worldCopyJump) {
              this._draggable.on("predrag", this._onPreDragWrap, this);
              map2.on("zoomend", this._onZoomEnd, this);
              map2.whenReady(this._onZoomEnd, this);
            }
          }
          addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
          this._draggable.enable();
          this._positions = [];
          this._times = [];
        },
        removeHooks: function() {
          removeClass(this._map._container, "leaflet-grab");
          removeClass(this._map._container, "leaflet-touch-drag");
          this._draggable.disable();
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        moving: function() {
          return this._draggable && this._draggable._moving;
        },
        _onDragStart: function() {
          var map2 = this._map;
          map2._stop();
          if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
            var bounds = toLatLngBounds(this._map.options.maxBounds);
            this._offsetLimit = toBounds(
              this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
              this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
            );
            this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
          } else {
            this._offsetLimit = null;
          }
          map2.fire("movestart").fire("dragstart");
          if (map2.options.inertia) {
            this._positions = [];
            this._times = [];
          }
        },
        _onDrag: function(e3) {
          if (this._map.options.inertia) {
            var time2 = this._lastTime = +/* @__PURE__ */ new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
            this._positions.push(pos);
            this._times.push(time2);
            this._prunePositions(time2);
          }
          this._map.fire("move", e3).fire("drag", e3);
        },
        _prunePositions: function(time2) {
          while (this._positions.length > 1 && time2 - this._times[0] > 50) {
            this._positions.shift();
            this._times.shift();
          }
        },
        _onZoomEnd: function() {
          var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
          this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
          this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
        },
        _viscousLimit: function(value, threshold2) {
          return value - (value - threshold2) * this._viscosity;
        },
        _onPreDragLimit: function() {
          if (!this._viscosity || !this._offsetLimit) {
            return;
          }
          var offset = this._draggable._newPos.subtract(this._draggable._startPos);
          var limit = this._offsetLimit;
          if (offset.x < limit.min.x) {
            offset.x = this._viscousLimit(offset.x, limit.min.x);
          }
          if (offset.y < limit.min.y) {
            offset.y = this._viscousLimit(offset.y, limit.min.y);
          }
          if (offset.x > limit.max.x) {
            offset.x = this._viscousLimit(offset.x, limit.max.x);
          }
          if (offset.y > limit.max.y) {
            offset.y = this._viscousLimit(offset.y, limit.max.y);
          }
          this._draggable._newPos = this._draggable._startPos.add(offset);
        },
        _onPreDragWrap: function() {
          var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x2 = this._draggable._newPos.x, newX1 = (x2 - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x2 + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
          this._draggable._absPos = this._draggable._newPos.clone();
          this._draggable._newPos.x = newX;
        },
        _onDragEnd: function(e3) {
          var map2 = this._map, options = map2.options, noInertia = !options.inertia || e3.noInertia || this._times.length < 2;
          map2.fire("dragend", e3);
          if (noInertia) {
            map2.fire("moveend");
          } else {
            this._prunePositions(+/* @__PURE__ */ new Date());
            var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
            if (!offset.x && !offset.y) {
              map2.fire("moveend");
            } else {
              offset = map2._limitOffset(offset, map2.options.maxBounds);
              requestAnimFrame(function() {
                map2.panBy(offset, {
                  duration: decelerationDuration,
                  easeLinearity: ease,
                  noMoveStart: true,
                  animate: true
                });
              });
            }
          }
        }
      });
      Map2.addInitHook("addHandler", "dragging", Drag);
      Map2.mergeOptions({
        // @option keyboard: Boolean = true
        // Makes the map focusable and allows users to navigate the map with keyboard
        // arrows and `+`/`-` keys.
        keyboard: true,
        // @option keyboardPanDelta: Number = 80
        // Amount of pixels to pan when pressing an arrow key.
        keyboardPanDelta: 80
      });
      var Keyboard = Handler.extend({
        keyCodes: {
          left: [37],
          right: [39],
          down: [40],
          up: [38],
          zoomIn: [187, 107, 61, 171],
          zoomOut: [189, 109, 54, 173]
        },
        initialize: function(map2) {
          this._map = map2;
          this._setPanDelta(map2.options.keyboardPanDelta);
          this._setZoomDelta(map2.options.zoomDelta);
        },
        addHooks: function() {
          var container = this._map._container;
          if (container.tabIndex <= 0) {
            container.tabIndex = "0";
          }
          on(container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this);
          this._map.on({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        removeHooks: function() {
          this._removeHooks();
          off(this._map._container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this);
          this._map.off({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        _onMouseDown: function() {
          if (this._focused) {
            return;
          }
          var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
          this._map._container.focus();
          window.scrollTo(left, top);
        },
        _onFocus: function() {
          this._focused = true;
          this._map.fire("focus");
        },
        _onBlur: function() {
          this._focused = false;
          this._map.fire("blur");
        },
        _setPanDelta: function(panDelta) {
          var keys = this._panKeys = {}, codes = this.keyCodes, i2, len;
          for (i2 = 0, len = codes.left.length; i2 < len; i2++) {
            keys[codes.left[i2]] = [-1 * panDelta, 0];
          }
          for (i2 = 0, len = codes.right.length; i2 < len; i2++) {
            keys[codes.right[i2]] = [panDelta, 0];
          }
          for (i2 = 0, len = codes.down.length; i2 < len; i2++) {
            keys[codes.down[i2]] = [0, panDelta];
          }
          for (i2 = 0, len = codes.up.length; i2 < len; i2++) {
            keys[codes.up[i2]] = [0, -1 * panDelta];
          }
        },
        _setZoomDelta: function(zoomDelta) {
          var keys = this._zoomKeys = {}, codes = this.keyCodes, i2, len;
          for (i2 = 0, len = codes.zoomIn.length; i2 < len; i2++) {
            keys[codes.zoomIn[i2]] = zoomDelta;
          }
          for (i2 = 0, len = codes.zoomOut.length; i2 < len; i2++) {
            keys[codes.zoomOut[i2]] = -zoomDelta;
          }
        },
        _addHooks: function() {
          on(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function() {
          off(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function(e3) {
          if (e3.altKey || e3.ctrlKey || e3.metaKey) {
            return;
          }
          var key = e3.keyCode, map2 = this._map, offset;
          if (key in this._panKeys) {
            if (!map2._panAnim || !map2._panAnim._inProgress) {
              offset = this._panKeys[key];
              if (e3.shiftKey) {
                offset = toPoint(offset).multiplyBy(3);
              }
              if (map2.options.maxBounds) {
                offset = map2._limitOffset(toPoint(offset), map2.options.maxBounds);
              }
              if (map2.options.worldCopyJump) {
                var newLatLng = map2.wrapLatLng(map2.unproject(map2.project(map2.getCenter()).add(offset)));
                map2.panTo(newLatLng);
              } else {
                map2.panBy(offset);
              }
            }
          } else if (key in this._zoomKeys) {
            map2.setZoom(map2.getZoom() + (e3.shiftKey ? 3 : 1) * this._zoomKeys[key]);
          } else if (key === 27 && map2._popup && map2._popup.options.closeOnEscapeKey) {
            map2.closePopup();
          } else {
            return;
          }
          stop(e3);
        }
      });
      Map2.addInitHook("addHandler", "keyboard", Keyboard);
      Map2.mergeOptions({
        // @section Mouse wheel options
        // @option scrollWheelZoom: Boolean|String = true
        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
        // it will zoom to the center of the view regardless of where the mouse was.
        scrollWheelZoom: true,
        // @option wheelDebounceTime: Number = 40
        // Limits the rate at which a wheel can fire (in milliseconds). By default
        // user can't zoom via wheel more often than once per 40 ms.
        wheelDebounceTime: 40,
        // @option wheelPxPerZoomLevel: Number = 60
        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
        // mean a change of one full zoom level. Smaller values will make wheel-zooming
        // faster (and vice versa).
        wheelPxPerZoomLevel: 60
      });
      var ScrollWheelZoom = Handler.extend({
        addHooks: function() {
          on(this._map._container, "wheel", this._onWheelScroll, this);
          this._delta = 0;
        },
        removeHooks: function() {
          off(this._map._container, "wheel", this._onWheelScroll, this);
        },
        _onWheelScroll: function(e3) {
          var delta = getWheelDelta(e3);
          var debounce2 = this._map.options.wheelDebounceTime;
          this._delta += delta;
          this._lastMousePos = this._map.mouseEventToContainerPoint(e3);
          if (!this._startTime) {
            this._startTime = +/* @__PURE__ */ new Date();
          }
          var left = Math.max(debounce2 - (+/* @__PURE__ */ new Date() - this._startTime), 0);
          clearTimeout(this._timer);
          this._timer = setTimeout(bind(this._performZoom, this), left);
          stop(e3);
        },
        _performZoom: function() {
          var map2 = this._map, zoom2 = map2.getZoom(), snap = this._map.options.zoomSnap || 0;
          map2._stop();
          var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map2._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
          this._delta = 0;
          this._startTime = null;
          if (!delta) {
            return;
          }
          if (map2.options.scrollWheelZoom === "center") {
            map2.setZoom(zoom2 + delta);
          } else {
            map2.setZoomAround(this._lastMousePos, zoom2 + delta);
          }
        }
      });
      Map2.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
      var tapHoldDelay = 600;
      Map2.mergeOptions({
        // @section Touch interaction options
        // @option tapHold: Boolean
        // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
        tapHold: Browser2.touchNative && Browser2.safari && Browser2.mobile,
        // @option tapTolerance: Number = 15
        // The max number of pixels a user can shift his finger during touch
        // for it to be considered a valid tap.
        tapTolerance: 15
      });
      var TapHold = Handler.extend({
        addHooks: function() {
          on(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function() {
          off(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function(e3) {
          clearTimeout(this._holdTimeout);
          if (e3.touches.length !== 1) {
            return;
          }
          var first = e3.touches[0];
          this._startPos = this._newPos = new Point(first.clientX, first.clientY);
          this._holdTimeout = setTimeout(bind(function() {
            this._cancel();
            if (!this._isTapValid()) {
              return;
            }
            on(document, "touchend", preventDefault);
            on(document, "touchend touchcancel", this._cancelClickPrevent);
            this._simulateEvent("contextmenu", first);
          }, this), tapHoldDelay);
          on(document, "touchend touchcancel contextmenu", this._cancel, this);
          on(document, "touchmove", this._onMove, this);
        },
        _cancelClickPrevent: function cancelClickPrevent() {
          off(document, "touchend", preventDefault);
          off(document, "touchend touchcancel", cancelClickPrevent);
        },
        _cancel: function() {
          clearTimeout(this._holdTimeout);
          off(document, "touchend touchcancel contextmenu", this._cancel, this);
          off(document, "touchmove", this._onMove, this);
        },
        _onMove: function(e3) {
          var first = e3.touches[0];
          this._newPos = new Point(first.clientX, first.clientY);
        },
        _isTapValid: function() {
          return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _simulateEvent: function(type, e3) {
          var simulatedEvent = new MouseEvent(type, {
            bubbles: true,
            cancelable: true,
            view: window,
            // detail: 1,
            screenX: e3.screenX,
            screenY: e3.screenY,
            clientX: e3.clientX,
            clientY: e3.clientY
            // button: 2,
            // buttons: 2
          });
          simulatedEvent._simulated = true;
          e3.target.dispatchEvent(simulatedEvent);
        }
      });
      Map2.addInitHook("addHandler", "tapHold", TapHold);
      Map2.mergeOptions({
        // @section Touch interaction options
        // @option touchZoom: Boolean|String = *
        // Whether the map can be zoomed by touch-dragging with two fingers. If
        // passed `'center'`, it will zoom to the center of the view regardless of
        // where the touch events (fingers) were. Enabled for touch-capable web
        // browsers.
        touchZoom: Browser2.touch,
        // @option bounceAtZoomLimits: Boolean = true
        // Set it to false if you don't want the map to zoom beyond min/max zoom
        // and then bounce back when pinch-zooming.
        bounceAtZoomLimits: true
      });
      var TouchZoom = Handler.extend({
        addHooks: function() {
          addClass(this._map._container, "leaflet-touch-zoom");
          on(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function() {
          removeClass(this._map._container, "leaflet-touch-zoom");
          off(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function(e3) {
          var map2 = this._map;
          if (!e3.touches || e3.touches.length !== 2 || map2._animatingZoom || this._zooming) {
            return;
          }
          var p1 = map2.mouseEventToContainerPoint(e3.touches[0]), p2 = map2.mouseEventToContainerPoint(e3.touches[1]);
          this._centerPoint = map2.getSize()._divideBy(2);
          this._startLatLng = map2.containerPointToLatLng(this._centerPoint);
          if (map2.options.touchZoom !== "center") {
            this._pinchStartLatLng = map2.containerPointToLatLng(p1.add(p2)._divideBy(2));
          }
          this._startDist = p1.distanceTo(p2);
          this._startZoom = map2.getZoom();
          this._moved = false;
          this._zooming = true;
          map2._stop();
          on(document, "touchmove", this._onTouchMove, this);
          on(document, "touchend touchcancel", this._onTouchEnd, this);
          preventDefault(e3);
        },
        _onTouchMove: function(e3) {
          if (!e3.touches || e3.touches.length !== 2 || !this._zooming) {
            return;
          }
          var map2 = this._map, p1 = map2.mouseEventToContainerPoint(e3.touches[0]), p2 = map2.mouseEventToContainerPoint(e3.touches[1]), scale2 = p1.distanceTo(p2) / this._startDist;
          this._zoom = map2.getScaleZoom(scale2, this._startZoom);
          if (!map2.options.bounceAtZoomLimits && (this._zoom < map2.getMinZoom() && scale2 < 1 || this._zoom > map2.getMaxZoom() && scale2 > 1)) {
            this._zoom = map2._limitZoom(this._zoom);
          }
          if (map2.options.touchZoom === "center") {
            this._center = this._startLatLng;
            if (scale2 === 1) {
              return;
            }
          } else {
            var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
            if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
              return;
            }
            this._center = map2.unproject(map2.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
          }
          if (!this._moved) {
            map2._moveStart(true, false);
            this._moved = true;
          }
          cancelAnimFrame(this._animRequest);
          var moveFn = bind(map2._move, map2, this._center, this._zoom, { pinch: true, round: false }, void 0);
          this._animRequest = requestAnimFrame(moveFn, this, true);
          preventDefault(e3);
        },
        _onTouchEnd: function() {
          if (!this._moved || !this._zooming) {
            this._zooming = false;
            return;
          }
          this._zooming = false;
          cancelAnimFrame(this._animRequest);
          off(document, "touchmove", this._onTouchMove, this);
          off(document, "touchend touchcancel", this._onTouchEnd, this);
          if (this._map.options.zoomAnimation) {
            this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
          } else {
            this._map._resetView(this._center, this._map._limitZoom(this._zoom));
          }
        }
      });
      Map2.addInitHook("addHandler", "touchZoom", TouchZoom);
      Map2.BoxZoom = BoxZoom;
      Map2.DoubleClickZoom = DoubleClickZoom;
      Map2.Drag = Drag;
      Map2.Keyboard = Keyboard;
      Map2.ScrollWheelZoom = ScrollWheelZoom;
      Map2.TapHold = TapHold;
      Map2.TouchZoom = TouchZoom;
      exports2.Bounds = Bounds;
      exports2.Browser = Browser2;
      exports2.CRS = CRS;
      exports2.Canvas = Canvas;
      exports2.Circle = Circle2;
      exports2.CircleMarker = CircleMarker;
      exports2.Class = Class;
      exports2.Control = Control;
      exports2.DivIcon = DivIcon;
      exports2.DivOverlay = DivOverlay;
      exports2.DomEvent = DomEvent;
      exports2.DomUtil = DomUtil;
      exports2.Draggable = Draggable;
      exports2.Evented = Evented;
      exports2.FeatureGroup = FeatureGroup;
      exports2.GeoJSON = GeoJSON;
      exports2.GridLayer = GridLayer;
      exports2.Handler = Handler;
      exports2.Icon = Icon;
      exports2.ImageOverlay = ImageOverlay;
      exports2.LatLng = LatLng;
      exports2.LatLngBounds = LatLngBounds;
      exports2.Layer = Layer2;
      exports2.LayerGroup = LayerGroup;
      exports2.LineUtil = LineUtil;
      exports2.Map = Map2;
      exports2.Marker = Marker2;
      exports2.Mixin = Mixin;
      exports2.Path = Path2;
      exports2.Point = Point;
      exports2.PolyUtil = PolyUtil;
      exports2.Polygon = Polygon;
      exports2.Polyline = Polyline;
      exports2.Popup = Popup2;
      exports2.PosAnimation = PosAnimation;
      exports2.Projection = index;
      exports2.Rectangle = Rectangle2;
      exports2.Renderer = Renderer;
      exports2.SVG = SVG;
      exports2.SVGOverlay = SVGOverlay;
      exports2.TileLayer = TileLayer2;
      exports2.Tooltip = Tooltip2;
      exports2.Transformation = Transformation;
      exports2.Util = Util;
      exports2.VideoOverlay = VideoOverlay;
      exports2.bind = bind;
      exports2.bounds = toBounds;
      exports2.canvas = canvas2;
      exports2.circle = circle;
      exports2.circleMarker = circleMarker;
      exports2.control = control;
      exports2.divIcon = divIcon;
      exports2.extend = extend2;
      exports2.featureGroup = featureGroup;
      exports2.geoJSON = geoJSON;
      exports2.geoJson = geoJson;
      exports2.gridLayer = gridLayer;
      exports2.icon = icon;
      exports2.imageOverlay = imageOverlay;
      exports2.latLng = toLatLng;
      exports2.latLngBounds = toLatLngBounds;
      exports2.layerGroup = layerGroup;
      exports2.map = createMap;
      exports2.marker = marker;
      exports2.point = toPoint;
      exports2.polygon = polygon;
      exports2.polyline = polyline;
      exports2.popup = popup2;
      exports2.rectangle = rectangle;
      exports2.setOptions = setOptions;
      exports2.stamp = stamp;
      exports2.svg = svg;
      exports2.svgOverlay = svgOverlay;
      exports2.tileLayer = tileLayer;
      exports2.tooltip = tooltip;
      exports2.transformation = toTransformation;
      exports2.version = version2;
      exports2.videoOverlay = videoOverlay;
      var oldL = window.L;
      exports2.noConflict = function() {
        window.L = oldL;
        return this;
      };
      window.L = exports2;
    }));
  })(leafletSrc$1, leafletSrc$1.exports);
  return leafletSrc$1.exports;
}
var leafletSrcExports = requireLeafletSrc();
const L$3 = /* @__PURE__ */ getDefaultExportFromCjs(leafletSrcExports);
function createElementObject(instance2, context, container) {
  return Object.freeze({
    instance: instance2,
    context,
    container
  });
}
function createElementHook(createElement, updateElement) {
  if (updateElement == null) {
    return function useImmutableLeafletElement(props, context) {
      const elementRef = reactExports.useRef(void 0);
      if (!elementRef.current) elementRef.current = createElement(props, context);
      return elementRef;
    };
  }
  return function useMutableLeafletElement(props, context) {
    const elementRef = reactExports.useRef(void 0);
    if (!elementRef.current) elementRef.current = createElement(props, context);
    const propsRef = reactExports.useRef(props);
    const { instance: instance2 } = elementRef.current;
    reactExports.useEffect(function updateElementProps() {
      if (propsRef.current !== props) {
        updateElement(instance2, props, propsRef.current);
        propsRef.current = props;
      }
    }, [
      instance2,
      props,
      updateElement
    ]);
    return elementRef;
  };
}
function useLayerLifecycle(element, context) {
  reactExports.useEffect(function addLayer() {
    const container = context.layerContainer ?? context.map;
    container.addLayer(element.instance);
    return function removeLayer() {
      context.layerContainer?.removeLayer(element.instance);
      context.map.removeLayer(element.instance);
    };
  }, [
    context,
    element
  ]);
}
function createLayerHook(useElement) {
  return function useLayer(props) {
    const context = useLeafletContext();
    const elementRef = useElement(withPane(props, context), context);
    useAttribution(context.map, props.attribution);
    useEventHandlers(elementRef.current, props.eventHandlers);
    useLayerLifecycle(elementRef.current, context);
    return elementRef;
  };
}
function usePathOptions(element, props) {
  const optionsRef = reactExports.useRef(void 0);
  reactExports.useEffect(function updatePathOptions() {
    if (props.pathOptions !== optionsRef.current) {
      const options = props.pathOptions ?? {};
      element.instance.setStyle(options);
      optionsRef.current = options;
    }
  }, [
    element,
    props
  ]);
}
function createPathHook(useElement) {
  return function usePath(props) {
    const context = useLeafletContext();
    const elementRef = useElement(withPane(props, context), context);
    useEventHandlers(elementRef.current, props.eventHandlers);
    useLayerLifecycle(elementRef.current, context);
    usePathOptions(elementRef.current, props);
    return elementRef;
  };
}
function createLayerComponent(createElement, updateElement) {
  const useElement = createElementHook(createElement, updateElement);
  const useLayer = createLayerHook(useElement);
  return createContainerComponent(useLayer);
}
function createOverlayComponent(createElement, useLifecycle) {
  const useElement = createElementHook(createElement);
  const useOverlay = createDivOverlayHook(useElement, useLifecycle);
  return createDivOverlayComponent(useOverlay);
}
function createPathComponent(createElement, updateElement) {
  const useElement = createElementHook(createElement, updateElement);
  const usePath = createPathHook(useElement);
  return createContainerComponent(usePath);
}
function createTileLayerComponent(createElement, updateElement) {
  const useElement = createElementHook(createElement, updateElement);
  const useLayer = createLayerHook(useElement);
  return createLeafComponent(useLayer);
}
function updateGridLayer(layer, props, prevProps) {
  const { opacity, zIndex } = props;
  if (opacity != null && opacity !== prevProps.opacity) {
    layer.setOpacity(opacity);
  }
  if (zIndex != null && zIndex !== prevProps.zIndex) {
    layer.setZIndex(zIndex);
  }
}
const Circle = createPathComponent(function createCircle({ center, children: _c, ...options }, ctx) {
  const circle = new leafletSrcExports.Circle(center, options);
  return createElementObject(circle, extendContext(ctx, {
    overlayContainer: circle
  }));
}, updateCircle);
function MapContainerComponent({ bounds, boundsOptions, center, children, className, id, placeholder, style, whenReady, zoom, ...options }, forwardedRef) {
  const [props] = reactExports.useState({
    className,
    id,
    style
  });
  const [context, setContext] = reactExports.useState(null);
  const mapInstanceRef = reactExports.useRef(void 0);
  reactExports.useImperativeHandle(forwardedRef, () => context?.map ?? null, [
    context
  ]);
  const mapRef = reactExports.useCallback((node) => {
    if (node !== null && !mapInstanceRef.current) {
      const map2 = new leafletSrcExports.Map(node, options);
      mapInstanceRef.current = map2;
      if (center != null && zoom != null) {
        map2.setView(center, zoom);
      } else if (bounds != null) {
        map2.fitBounds(bounds, boundsOptions);
      }
      if (whenReady != null) {
        map2.whenReady(whenReady);
      }
      setContext(createLeafletContext(map2));
    }
  }, []);
  reactExports.useEffect(() => {
    return () => {
      context?.map.remove();
    };
  }, [
    context
  ]);
  const contents = context ? /* @__PURE__ */ React.createElement(LeafletContext, {
    value: context
  }, children) : placeholder ?? null;
  return /* @__PURE__ */ React.createElement("div", {
    ...props,
    ref: mapRef
  }, contents);
}
const MapContainer = /* @__PURE__ */ reactExports.forwardRef(MapContainerComponent);
const Marker = createLayerComponent(function createMarker({ position, ...options }, ctx) {
  const marker = new leafletSrcExports.Marker(position, options);
  return createElementObject(marker, extendContext(ctx, {
    overlayContainer: marker
  }));
}, function updateMarker(marker, props, prevProps) {
  if (props.position !== prevProps.position) {
    marker.setLatLng(props.position);
  }
  if (props.icon != null && props.icon !== prevProps.icon) {
    marker.setIcon(props.icon);
  }
  if (props.zIndexOffset != null && props.zIndexOffset !== prevProps.zIndexOffset) {
    marker.setZIndexOffset(props.zIndexOffset);
  }
  if (props.opacity != null && props.opacity !== prevProps.opacity) {
    marker.setOpacity(props.opacity);
  }
  if (marker.dragging != null && props.draggable !== prevProps.draggable) {
    if (props.draggable === true) {
      marker.dragging.enable();
    } else {
      marker.dragging.disable();
    }
  }
});
const Popup = createOverlayComponent(function createPopup(props, context) {
  const popup2 = new leafletSrcExports.Popup(props, context.overlayContainer);
  return createElementObject(popup2, context);
}, function usePopupLifecycle(element, context, { position }, setOpen) {
  reactExports.useEffect(function addPopup() {
    const { instance: instance2 } = element;
    function onPopupOpen(event) {
      if (event.popup === instance2) {
        instance2.update();
        setOpen(true);
      }
    }
    function onPopupClose(event) {
      if (event.popup === instance2) {
        setOpen(false);
      }
    }
    context.map.on({
      popupopen: onPopupOpen,
      popupclose: onPopupClose
    });
    if (context.overlayContainer == null) {
      if (position != null) {
        instance2.setLatLng(position);
      }
      instance2.openOn(context.map);
    } else {
      context.overlayContainer.bindPopup(instance2);
    }
    return function removePopup() {
      context.map.off({
        popupopen: onPopupOpen,
        popupclose: onPopupClose
      });
      context.overlayContainer?.unbindPopup();
      context.map.removeLayer(instance2);
    };
  }, [
    element,
    context,
    setOpen,
    position
  ]);
});
const TileLayer = createTileLayerComponent(function createTileLayer({ url, ...options }, context) {
  const layer = new leafletSrcExports.TileLayer(url, withPane(options, context));
  return createElementObject(layer, context);
}, function updateTileLayer(layer, props, prevProps) {
  updateGridLayer(layer, props, prevProps);
  const { url } = props;
  if (url != null && url !== prevProps.url) {
    layer.setUrl(url);
  }
});
delete L$3.Icon.Default.prototype._getIconUrl;
L$3.Icon.Default.mergeOptions({
  iconRetinaUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png",
  iconUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png",
  shadowUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png"
});
const Map$1 = ({ darkMode }) => {
  const { t: t2 } = useTranslation();
  const [campaigns, setCampaigns] = reactExports.useState([]);
  const [disasterZones, setDisasterZones] = reactExports.useState([]);
  const [filteredCampaigns, setFilteredCampaigns] = reactExports.useState([]);
  const [filteredDisasterZones, setFilteredDisasterZones] = reactExports.useState([]);
  const [mapKey, setMapKey] = reactExports.useState(0);
  const [timeRange, setTimeRange] = reactExports.useState("all");
  const [showCampaigns, setShowCampaigns] = reactExports.useState(true);
  const [showDisasterZones, setShowDisasterZones] = reactExports.useState(true);
  const mapRef = reactExports.useRef();
  const sampleCampaigns = [
    {
      id: 1,
      title: "Kerala Flood Relief",
      description: "Providing emergency aid to flood-affected families in Kerala",
      location: [10.8505, 76.2711],
      fundsRaised: "25,00,000",
      goal: "50,00,000",
      status: "active",
      source: "NDRF Kerala Unit",
      createdAt: /* @__PURE__ */ new Date("2023-07-15"),
      endDate: null
    },
    {
      id: 2,
      title: "Rajasthan Drought Support",
      description: "Water conservation and distribution in drought-prone areas of Rajasthan",
      location: [27.0238, 74.2179],
      fundsRaised: "18,50,000",
      goal: "30,00,000",
      status: "active",
      source: "Government of Rajasthan",
      createdAt: /* @__PURE__ */ new Date("2023-05-20"),
      endDate: null
    },
    {
      id: 3,
      title: "Himalayan Earthquake Recovery",
      description: "Rebuilding homes and infrastructure after the earthquake in Uttarakhand",
      location: [30.0668, 79.0193],
      fundsRaised: "42,00,000",
      goal: "42,00,000",
      status: "completed",
      source: "Ministry of Home Affairs",
      createdAt: /* @__PURE__ */ new Date("2022-03-10"),
      endDate: /* @__PURE__ */ new Date("2023-09-30")
    },
    {
      id: 4,
      title: "Odisha Cyclone Aid",
      description: "Emergency relief and rehabilitation after cyclone damage",
      location: [20.9517, 85.0985],
      fundsRaised: "15,75,000",
      goal: "35,00,000",
      status: "active",
      source: "NDRF Odisha Unit",
      createdAt: /* @__PURE__ */ new Date("2023-10-05"),
      endDate: null
    },
    {
      id: 5,
      title: "Assam Flood Response",
      description: "Providing relief to flood-affected communities in Assam",
      location: [26.2006, 92.9376],
      fundsRaised: "8,25,000",
      goal: "20,00,000",
      status: "active",
      source: "Assam State Disaster Management Authority",
      createdAt: /* @__PURE__ */ new Date("2023-08-12"),
      endDate: null
    },
    {
      id: 6,
      title: "Maharashtra Flood Relief",
      description: "Emergency response for monsoon floods in Mumbai and surrounding areas",
      location: [19.7515, 75.7139],
      fundsRaised: "32,00,000",
      goal: "40,00,000",
      status: "active",
      source: "NDRF Maharashtra Unit",
      createdAt: /* @__PURE__ */ new Date("2023-07-25"),
      endDate: null
    }
  ];
  const sampleDisasterZones = [
    {
      id: 1,
      name: "Kerala Flood Zone",
      center: [10.8505, 76.2711],
      radius: 5e4,
      // 50km in meters
      riskLevel: "high",
      disasterType: "flood",
      lastUpdated: /* @__PURE__ */ new Date("2023-07-20")
    },
    {
      id: 2,
      name: "Gujarat Earthquake Zone",
      center: [22.2587, 71.1924],
      radius: 1e5,
      // 100km in meters
      riskLevel: "moderate",
      disasterType: "earthquake",
      lastUpdated: /* @__PURE__ */ new Date("2023-06-15")
    },
    {
      id: 3,
      name: "Odisha Cyclone Zone",
      center: [20.9517, 85.0985],
      radius: 75e3,
      // 75km in meters
      riskLevel: "high",
      disasterType: "cyclone",
      lastUpdated: /* @__PURE__ */ new Date("2023-10-10")
    },
    {
      id: 4,
      name: "Uttarakhand Landslide Zone",
      center: [30.0668, 79.0193],
      radius: 3e4,
      // 30km in meters
      riskLevel: "moderate",
      disasterType: "landslide",
      lastUpdated: /* @__PURE__ */ new Date("2023-08-05")
    }
  ];
  reactExports.useEffect(() => {
    setCampaigns(sampleCampaigns);
    setDisasterZones(sampleDisasterZones);
    setFilteredCampaigns(sampleCampaigns);
    setFilteredDisasterZones(sampleDisasterZones);
    setMapKey((prev) => prev + 1);
  }, [darkMode]);
  reactExports.useEffect(() => {
    let campaignFilter, zoneFilter;
    if (timeRange === "all") {
      campaignFilter = () => true;
      zoneFilter = () => true;
    } else if (timeRange === "month") {
      const oneMonthAgo = /* @__PURE__ */ new Date();
      oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
      campaignFilter = (campaign) => new Date(campaign.createdAt) >= oneMonthAgo;
      zoneFilter = (zone) => new Date(zone.lastUpdated) >= oneMonthAgo;
    } else if (timeRange === "quarter") {
      const threeMonthsAgo = /* @__PURE__ */ new Date();
      threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
      campaignFilter = (campaign) => new Date(campaign.createdAt) >= threeMonthsAgo;
      zoneFilter = (zone) => new Date(zone.lastUpdated) >= threeMonthsAgo;
    } else if (timeRange === "year") {
      const oneYearAgo = /* @__PURE__ */ new Date();
      oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
      campaignFilter = (campaign) => new Date(campaign.createdAt) >= oneYearAgo;
      zoneFilter = (zone) => new Date(zone.lastUpdated) >= oneYearAgo;
    }
    setFilteredCampaigns(showCampaigns ? campaigns.filter(campaignFilter) : []);
    setFilteredDisasterZones(showDisasterZones ? disasterZones.filter(zoneFilter) : []);
  }, [timeRange, campaigns, disasterZones, showCampaigns, showDisasterZones]);
  const center = [20.5937, 78.9629];
  const getMarkerIcon = (status) => {
    return new L$3.Icon({
      iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${status === "active" ? "blue" : "green"}.png`,
      shadowUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png",
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });
  };
  const getRiskColor = (riskLevel) => {
    switch (riskLevel) {
      case "high":
        return "#ef4444";
      case "moderate":
        return "#f59e0b";
      case "low":
        return "#10b981";
      default:
        return "#6b7280";
    }
  };
  const getFillOpacity = (riskLevel) => {
    switch (riskLevel) {
      case "high":
        return 0.3;
      case "moderate":
        return 0.2;
      case "low":
        return 0.1;
      default:
        return 0.1;
    }
  };
  const formatDate2 = (date2) => {
    return new Date(date2).toLocaleDateString(void 0, {
      year: "numeric",
      month: "short",
      day: "numeric"
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `rounded-2xl overflow-hidden ${darkMode ? "bg-gray-800" : "bg-white"} shadow-lg`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `p-4 ${darkMode ? "bg-gray-700" : "bg-gray-100"} rounded-t-2xl`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap items-center justify-between gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: `font-semibold ${darkMode ? "text-white" : "text-gray-800"}`, children: t2("map.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setTimeRange("all"),
              className: `px-3 py-1 text-sm rounded-full ${timeRange === "all" ? darkMode ? "bg-blue-600 text-white" : "bg-blue-500 text-white" : darkMode ? "bg-gray-600 text-gray-200" : "bg-gray-200 text-gray-700"}`,
              children: t2("map.allTime")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setTimeRange("month"),
              className: `px-3 py-1 text-sm rounded-full ${timeRange === "month" ? darkMode ? "bg-blue-600 text-white" : "bg-blue-500 text-white" : darkMode ? "bg-gray-600 text-gray-200" : "bg-gray-200 text-gray-700"}`,
              children: t2("map.lastMonth")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setTimeRange("quarter"),
              className: `px-3 py-1 text-sm rounded-full ${timeRange === "quarter" ? darkMode ? "bg-blue-600 text-white" : "bg-blue-500 text-white" : darkMode ? "bg-gray-600 text-gray-200" : "bg-gray-200 text-gray-700"}`,
              children: t2("map.lastQuarter")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setTimeRange("year"),
              className: `px-3 py-1 text-sm rounded-full ${timeRange === "year" ? darkMode ? "bg-blue-600 text-white" : "bg-blue-500 text-white" : darkMode ? "bg-gray-600 text-gray-200" : "bg-gray-200 text-gray-700"}`,
              children: t2("map.lastYear")
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-4 mt-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: `flex items-center ${darkMode ? "text-gray-200" : "text-gray-700"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: showCampaigns,
              onChange: () => setShowCampaigns(!showCampaigns),
              className: "mr-2 rounded"
            }
          ),
          t2("map.campaigns")
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: `flex items-center ${darkMode ? "text-gray-200" : "text-gray-700"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: showDisasterZones,
              onChange: () => setShowDisasterZones(!showDisasterZones),
              className: "mr-2 rounded"
            }
          ),
          t2("map.riskZones")
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      MapContainer,
      {
        center,
        zoom: 5,
        style: { height: "400px", width: "100%" },
        className: `${darkMode ? "dark-map" : ""} rounded-2xl`,
        ref: mapRef,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TileLayer,
            {
              url: darkMode ? "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png" : "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
              attribution: darkMode ? '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>' : '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }
          ),
          filteredCampaigns.map((campaign) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Marker,
            {
              position: campaign.location,
              icon: getMarkerIcon(campaign.status),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Popup, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `max-w-xs ${darkMode ? "dark-popup" : ""}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: `font-bold text-lg ${darkMode ? "text-white" : "text-gray-800"}`, children: [
                  t2("map.campaign"),
                  ": ",
                  campaign.title
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `text-sm mt-1 ${darkMode ? "text-gray-300" : "text-gray-600"}`, children: campaign.description }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-sm", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: darkMode ? "text-gray-300" : "text-gray-600", children: [
                      t2("map.fundsRaised"),
                      ":"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: campaign.fundsRaised })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-sm", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: darkMode ? "text-gray-300" : "text-gray-600", children: [
                      t2("map.goal"),
                      ":"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: campaign.goal })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 py-1 rounded-full text-xs font-semibold ${campaign.status === "active" ? "bg-blue-100 text-blue-800" : "bg-green-100 text-green-800"}`, children: campaign.status === "active" ? t2("map.active") : t2("map.completed") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 text-xs", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: darkMode ? "text-gray-400" : "text-gray-500", children: [
                    t2("map.source"),
                    ": ",
                    campaign.source
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: darkMode ? "text-gray-400" : "text-gray-500", children: [
                    t2("map.createdAt"),
                    ": ",
                    formatDate2(campaign.createdAt)
                  ] }),
                  campaign.endDate && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: darkMode ? "text-gray-400" : "text-gray-500", children: [
                    t2("map.endDate"),
                    ": ",
                    formatDate2(campaign.endDate)
                  ] })
                ] })
              ] }) })
            },
            campaign.id
          )),
          filteredDisasterZones.map((zone) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Circle,
            {
              center: zone.center,
              radius: zone.radius,
              color: getRiskColor(zone.riskLevel),
              fillColor: getRiskColor(zone.riskLevel),
              fillOpacity: getFillOpacity(zone.riskLevel),
              weight: 2,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Popup, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `max-w-xs ${darkMode ? "dark-popup" : ""}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: `font-bold text-lg ${darkMode ? "text-white" : "text-gray-800"}`, children: [
                  t2("map.disasterZone"),
                  ": ",
                  zone.name
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: `text-sm mt-1 ${darkMode ? "text-gray-300" : "text-gray-600"}`, children: [
                  t2("map.riskLevel"),
                  ": ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold capitalize", children: t2(`map.riskLevels.${zone.riskLevel}`) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: `text-sm ${darkMode ? "text-gray-300" : "text-gray-600"}`, children: [
                  t2("map.disasterType"),
                  ": ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold capitalize", children: t2(`disasterTypes.${zone.disasterType}`) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `text-xs mt-2 ${darkMode ? "text-gray-400" : "text-gray-500"}`, children: [
                  t2("map.lastUpdated"),
                  ": ",
                  formatDate2(zone.lastUpdated)
                ] })
              ] }) })
            },
            zone.id
          ))
        ]
      },
      mapKey
    )
  ] });
};
const DisasterInfo = () => {
  const { t: t2 } = useTranslation();
  const disasterInfo = [
    {
      type: t2("home.disaster_flood"),
      icon: "",
      description: t2("home.disaster_flood_desc"),
      regions: ["Kerala", "Assam", "Bihar", "Uttar Pradesh"],
      frequency: t2("home.disaster_high"),
      impact: t2("home.disaster_severe"),
      preparedness: [
        t2("home.disaster_flood_prep1"),
        t2("home.disaster_flood_prep2"),
        t2("home.disaster_flood_prep3")
      ]
    },
    {
      type: t2("home.disaster_earthquake"),
      icon: " earthqua ke",
      description: t2("home.disaster_earthquake_desc"),
      regions: ["Himalayan Region", "North-East", "Gujarat", "Bihar"],
      frequency: t2("home.disaster_medium"),
      impact: t2("home.disaster_severe"),
      preparedness: [
        t2("home.disaster_earthquake_prep1"),
        t2("home.disaster_earthquake_prep2"),
        t2("home.disaster_earthquake_prep3")
      ]
    },
    {
      type: t2("home.disaster_cyclone"),
      icon: "",
      description: t2("home.disaster_cyclone_desc"),
      regions: ["Odisha", "West Bengal", "Andhra Pradesh", "Tamil Nadu"],
      frequency: t2("home.disaster_high"),
      impact: t2("home.disaster_severe"),
      preparedness: [
        t2("home.disaster_cyclone_prep1"),
        t2("home.disaster_cyclone_prep2"),
        t2("home.disaster_cyclone_prep3")
      ]
    },
    {
      type: t2("home.disaster_drought"),
      icon: "",
      description: t2("home.disaster_drought_desc"),
      regions: ["Rajasthan", "Maharashtra", "Karnataka", "Andhra Pradesh"],
      frequency: t2("home.disaster_medium"),
      impact: t2("home.disaster_moderate"),
      preparedness: [
        t2("home.disaster_drought_prep1"),
        t2("home.disaster_drought_prep2"),
        t2("home.disaster_drought_prep3")
      ]
    },
    {
      type: t2("home.disaster_landslide"),
      icon: "",
      description: t2("home.disaster_landslide_desc"),
      regions: ["Himalayan Region", "Western Ghats", "North-East"],
      frequency: t2("home.disaster_low"),
      impact: t2("home.disaster_moderate"),
      preparedness: [
        t2("home.disaster_landslide_prep1"),
        t2("home.disaster_landslide_prep2"),
        t2("home.disaster_landslide_prep3")
      ]
    },
    {
      type: t2("home.disaster_fire"),
      icon: "",
      description: t2("home.disaster_fire_desc"),
      regions: ["Himachal Pradesh", "Uttarakhand", "Madhya Pradesh", "Odisha"],
      frequency: t2("home.disaster_medium"),
      impact: t2("home.disaster_moderate"),
      preparedness: [
        t2("home.disaster_fire_prep1"),
        t2("home.disaster_fire_prep2"),
        t2("home.disaster_fire_prep3")
      ]
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 mb-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white mb-6", children: t2("home.india_disaster_info") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6", children: disasterInfo.map((disaster, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-gray-200 dark:border-gray-700 rounded-xl p-4 hover:shadow-md transition-shadow", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center mb-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-3xl mr-3", children: disaster.icon }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 dark:text-white", children: disaster.type })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300 text-sm mb-3", children: disaster.description }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase mb-1", children: t2("home.disaster_affected_regions") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-1", children: disaster.regions.map((region, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 text-xs px-2 py-1 rounded", children: region }, idx)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-sm mb-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-500 dark:text-gray-400", children: [
            t2("home.disaster_frequency"),
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1 font-medium text-gray-800 dark:text-white", children: disaster.frequency })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-500 dark:text-gray-400", children: [
            t2("home.disaster_impact"),
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1 font-medium text-gray-800 dark:text-white", children: disaster.impact })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase mb-1", children: t2("home.disaster_preparedness") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "text-gray-600 dark:text-gray-300 text-xs list-disc pl-4 space-y-1", children: disaster.preparedness.map((prep, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: prep }, idx)) })
      ] })
    ] }, index)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6 p-4 bg-blue-50 dark:bg-blue-900 rounded-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-blue-800 dark:text-blue-200 mb-2", children: t2("home.disaster_preparedness_tip") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-blue-700 dark:text-blue-300 text-sm", children: t2("home.disaster_preparedness_desc") })
    ] })
  ] });
};
const RegionalStats = () => {
  const { t: t2 } = useTranslation();
  const regionalData = [
    {
      state: "Kerala",
      disasters: ["Floods", "Landslides"],
      affected: "5.4 million",
      funds: "1,200 Cr",
      color: "bg-blue-500"
    },
    {
      state: "Odisha",
      disasters: ["Cyclones", "Floods"],
      affected: "3.8 million",
      funds: "850 Cr",
      color: "bg-green-500"
    },
    {
      state: "Uttarakhand",
      disasters: ["Landslides", "Floods"],
      affected: "2.1 million",
      funds: "620 Cr",
      color: "bg-yellow-500"
    },
    {
      state: "Assam",
      disasters: ["Floods", "Erosion"],
      affected: "4.2 million",
      funds: "780 Cr",
      color: "bg-red-500"
    },
    {
      state: "Maharashtra",
      disasters: ["Droughts", "Floods"],
      affected: "3.5 million",
      funds: "950 Cr",
      color: "bg-purple-500"
    },
    {
      state: "Rajasthan",
      disasters: ["Droughts", "Heat Waves"],
      affected: "1.8 million",
      funds: "520 Cr",
      color: "bg-orange-500"
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 mb-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white mb-6", children: t2("home.regional_disaster_stats") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6", children: regionalData.map((region, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-gray-200 dark:border-gray-700 rounded-xl p-4 hover:shadow-md transition-shadow", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start mb-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 dark:text-white", children: region.state }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-4 h-4 rounded-full ${region.color}` })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase mb-1", children: t2("home.common_disasters") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-1", children: region.disasters.map((disaster, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 text-xs px-2 py-1 rounded", children: disaster }, idx)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-3 mt-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 dark:bg-blue-900 rounded-lg p-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-blue-600 dark:text-blue-300", children: t2("home.people_affected") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-semibold text-blue-800 dark:text-blue-200", children: region.affected })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-green-50 dark:bg-green-900 rounded-lg p-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-green-600 dark:text-green-300", children: t2("home.funds_allocated") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-semibold text-green-800 dark:text-green-200", children: region.funds })
        ] })
      ] })
    ] }, index)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-6 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-blue-600 dark:text-blue-400 hover:underline font-medium", children: t2("home.view_detailed_statistics") }) })
  ] });
};
function r$2(e3) {
  var t2, f2, n2 = "";
  if ("string" == typeof e3 || "number" == typeof e3) n2 += e3;
  else if ("object" == typeof e3) if (Array.isArray(e3)) {
    var o2 = e3.length;
    for (t2 = 0; t2 < o2; t2++) e3[t2] && (f2 = r$2(e3[t2])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e3) e3[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e3, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++) (e3 = arguments[f2]) && (t2 = r$2(e3)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
var EventKeys = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"];
function isEventKey(key) {
  if (typeof key !== "string") {
    return false;
  }
  var allowedEventKeys = EventKeys;
  return allowedEventKeys.includes(key);
}
var SVGElementPropKeys = [
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-modal",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  "className",
  "color",
  "height",
  "id",
  "lang",
  "max",
  "media",
  "method",
  "min",
  "name",
  "style",
  /*
   * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
   * that can use it, and it conflicts with the recharts prop 'type'
   * https://github.com/recharts/recharts/pull/3327
   * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
   */
  // 'type',
  "target",
  "width",
  "role",
  "tabIndex",
  "accentHeight",
  "accumulate",
  "additive",
  "alignmentBaseline",
  "allowReorder",
  "alphabetic",
  "amplitude",
  "arabicForm",
  "ascent",
  "attributeName",
  "attributeType",
  "autoReverse",
  "azimuth",
  "baseFrequency",
  "baselineShift",
  "baseProfile",
  "bbox",
  "begin",
  "bias",
  "by",
  "calcMode",
  "capHeight",
  "clip",
  "clipPath",
  "clipPathUnits",
  "clipRule",
  "colorInterpolation",
  "colorInterpolationFilters",
  "colorProfile",
  "colorRendering",
  "contentScriptType",
  "contentStyleType",
  "cursor",
  "cx",
  "cy",
  "d",
  "decelerate",
  "descent",
  "diffuseConstant",
  "direction",
  "display",
  "divisor",
  "dominantBaseline",
  "dur",
  "dx",
  "dy",
  "edgeMode",
  "elevation",
  "enableBackground",
  "end",
  "exponent",
  "externalResourcesRequired",
  "fill",
  "fillOpacity",
  "fillRule",
  "filter",
  "filterRes",
  "filterUnits",
  "floodColor",
  "floodOpacity",
  "focusable",
  "fontFamily",
  "fontSize",
  "fontSizeAdjust",
  "fontStretch",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "format",
  "from",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyphName",
  "glyphOrientationHorizontal",
  "glyphOrientationVertical",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "hanging",
  "horizAdvX",
  "horizOriginX",
  "href",
  "ideographic",
  "imageRendering",
  "in2",
  "in",
  "intercept",
  "k1",
  "k2",
  "k3",
  "k4",
  "k",
  "kernelMatrix",
  "kernelUnitLength",
  "kerning",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "letterSpacing",
  "lightingColor",
  "limitingConeAngle",
  "local",
  "markerEnd",
  "markerHeight",
  "markerMid",
  "markerStart",
  "markerUnits",
  "markerWidth",
  "mask",
  "maskContentUnits",
  "maskUnits",
  "mathematical",
  "mode",
  "numOctaves",
  "offset",
  "opacity",
  "operator",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "overlinePosition",
  "overlineThickness",
  "paintOrder",
  "panose1",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointerEvents",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "r",
  "radius",
  "refX",
  "refY",
  "renderingIntent",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "restart",
  "result",
  "rotate",
  "rx",
  "ry",
  "seed",
  "shapeRendering",
  "slope",
  "spacing",
  "specularConstant",
  "specularExponent",
  "speed",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stemh",
  "stemv",
  "stitchTiles",
  "stopColor",
  "stopOpacity",
  "strikethroughPosition",
  "strikethroughThickness",
  "string",
  "stroke",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textAnchor",
  "textDecoration",
  "textLength",
  "textRendering",
  "to",
  "transform",
  "u1",
  "u2",
  "underlinePosition",
  "underlineThickness",
  "unicode",
  "unicodeBidi",
  "unicodeRange",
  "unitsPerEm",
  "vAlphabetic",
  "values",
  "vectorEffect",
  "version",
  "vertAdvY",
  "vertOriginX",
  "vertOriginY",
  "vHanging",
  "vIdeographic",
  "viewTarget",
  "visibility",
  "vMathematical",
  "widths",
  "wordSpacing",
  "writingMode",
  "x1",
  "x2",
  "x",
  "xChannelSelector",
  "xHeight",
  "xlinkActuate",
  "xlinkArcrole",
  "xlinkHref",
  "xlinkRole",
  "xlinkShow",
  "xlinkTitle",
  "xlinkType",
  "xmlBase",
  "xmlLang",
  "xmlns",
  "xmlnsXlink",
  "xmlSpace",
  "y1",
  "y2",
  "y",
  "yChannelSelector",
  "z",
  "zoomAndPan",
  "ref",
  "key",
  "angle"
];
function isSvgElementPropKey(key) {
  if (typeof key !== "string") {
    return false;
  }
  var allowedSvgKeys = SVGElementPropKeys;
  return allowedSvgKeys.includes(key);
}
function isDataAttribute(key) {
  return typeof key === "string" && key.startsWith("data-");
}
function svgPropertiesNoEvents(obj) {
  var filteredEntries = Object.entries(obj).filter((_ref2) => {
    var [key] = _ref2;
    return isSvgElementPropKey(key) || isDataAttribute(key);
  });
  return Object.fromEntries(filteredEntries);
}
function svgPropertiesNoEventsFromUnknown(input) {
  if (input == null) {
    return null;
  }
  if (/* @__PURE__ */ reactExports.isValidElement(input) && typeof input.props === "object" && input.props !== null) {
    var p2 = input.props;
    return svgPropertiesNoEvents(p2);
  }
  if (typeof input === "object" && !Array.isArray(input)) {
    return svgPropertiesNoEvents(input);
  }
  return null;
}
function svgPropertiesAndEvents(obj) {
  var filteredEntries = Object.entries(obj).filter((_ref2) => {
    var [key] = _ref2;
    return isSvgElementPropKey(key) || isDataAttribute(key) || isEventKey(key);
  });
  return Object.fromEntries(filteredEntries);
}
function svgPropertiesAndEventsFromUnknown(input) {
  if (input == null) {
    return null;
  }
  if (/* @__PURE__ */ reactExports.isValidElement(input)) {
    return svgPropertiesAndEvents(input.props);
  }
  if (typeof input === "object" && !Array.isArray(input)) {
    return svgPropertiesAndEvents(input);
  }
  return null;
}
var _excluded$m = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"];
function _extends$s() {
  return _extends$s = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$s.apply(null, arguments);
}
function _objectWithoutProperties$m(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$m(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$m(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
var Surface = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  var {
    children,
    width,
    height,
    viewBox,
    className,
    style,
    title,
    desc
  } = props, others = _objectWithoutProperties$m(props, _excluded$m);
  var svgView = viewBox || {
    width,
    height,
    x: 0,
    y: 0
  };
  var layerClass = clsx("recharts-surface", className);
  return /* @__PURE__ */ reactExports.createElement("svg", _extends$s({}, svgPropertiesAndEvents(others), {
    className: layerClass,
    width,
    height,
    style,
    viewBox: "".concat(svgView.x, " ").concat(svgView.y, " ").concat(svgView.width, " ").concat(svgView.height),
    ref
  }), /* @__PURE__ */ reactExports.createElement("title", null, title), /* @__PURE__ */ reactExports.createElement("desc", null, desc), children);
});
var _excluded$l = ["children", "className"];
function _extends$r() {
  return _extends$r = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$r.apply(null, arguments);
}
function _objectWithoutProperties$l(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$l(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$l(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
var Layer = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  var {
    children,
    className
  } = props, others = _objectWithoutProperties$l(props, _excluded$l);
  var layerClass = clsx("recharts-layer", className);
  return /* @__PURE__ */ reactExports.createElement("g", _extends$r({
    className: layerClass
  }, svgPropertiesAndEvents(others), {
    ref
  }), children);
});
var LegendPortalContext = /* @__PURE__ */ reactExports.createContext(null);
var useLegendPortal = () => reactExports.useContext(LegendPortalContext);
function constant$1(x2) {
  return function constant2() {
    return x2;
  };
}
const cos = Math.cos;
const sin = Math.sin;
const sqrt$1 = Math.sqrt;
const pi$1 = Math.PI;
const tau$1 = 2 * pi$1;
const pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
function append(strings) {
  this._ += strings[0];
  for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2) {
    this._ += arguments[i2] + strings[i2];
  }
}
function appendRound(digits) {
  let d2 = Math.floor(digits);
  if (!(d2 >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d2 > 15) return append;
  const k2 = 10 ** d2;
  return function(strings) {
    this._ += strings[0];
    for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2) {
      this._ += Math.round(arguments[i2] * k2) / k2 + strings[i2];
    }
  };
}
class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r2) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r2 = +r2;
    if (r2 < 0) throw new Error(`negative radius: ${r2}`);
    let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    } else {
      let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x2, y2, r2, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r2 = +r2, ccw = !!ccw;
    if (r2 < 0) throw new Error(`negative radius: ${r2}`);
    let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._append`L${x0},${y0}`;
    }
    if (!r2) return;
    if (da < 0) da = da % tau + tau;
    if (da > tauEpsilon) {
      this._append`A${r2},${r2},0,1,${cw},${x2 - dx},${y2 - dy}A${r2},${r2},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    } else if (da > epsilon) {
      this._append`A${r2},${r2},0,${+(da >= pi)},${cw},${this._x1 = x2 + r2 * Math.cos(a1)},${this._y1 = y2 + r2 * Math.sin(a1)}`;
    }
  }
  rect(x2, y2, w2, h2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w2 = +w2}v${+h2}h${-w2}Z`;
  }
  toString() {
    return this._;
  }
}
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_2) {
    if (!arguments.length) return digits;
    if (_2 == null) {
      digits = null;
    } else {
      const d2 = Math.floor(_2);
      if (!(d2 >= 0)) throw new RangeError(`invalid digits: ${_2}`);
      digits = d2;
    }
    return shape;
  };
  return () => new Path(digits);
}
function array(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context) {
  return new Linear(context);
}
function x$2(p2) {
  return p2[0];
}
function y$2(p2) {
  return p2[1];
}
function shapeLine(x2, y2) {
  var defined2 = constant$1(true), context = null, curve = curveLinear, output = null, path2 = withPath(line);
  x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x$2 : constant$1(x2);
  y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y$2 : constant$1(y2);
  function line(data) {
    var i2, n2 = (data = array(data)).length, d2, defined0 = false, buffer2;
    if (context == null) output = curve(buffer2 = path2());
    for (i2 = 0; i2 <= n2; ++i2) {
      if (!(i2 < n2 && defined2(d2 = data[i2], i2, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x2(d2, i2, data), +y2(d2, i2, data));
    }
    if (buffer2) return output = null, buffer2 + "" || null;
  }
  line.x = function(_2) {
    return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$1(+_2), line) : x2;
  };
  line.y = function(_2) {
    return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant$1(+_2), line) : y2;
  };
  line.defined = function(_2) {
    return arguments.length ? (defined2 = typeof _2 === "function" ? _2 : constant$1(!!_2), line) : defined2;
  };
  line.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line) : context;
  };
  return line;
}
function shapeArea(x0, y0, y1) {
  var x1 = null, defined2 = constant$1(true), context = null, curve = curveLinear, output = null, path2 = withPath(area);
  x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x$2 : constant$1(+x0);
  y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant$1(0) : constant$1(+y0);
  y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y$2 : constant$1(+y1);
  function area(data) {
    var i2, j2, k2, n2 = (data = array(data)).length, d2, defined0 = false, buffer2, x0z = new Array(n2), y0z = new Array(n2);
    if (context == null) output = curve(buffer2 = path2());
    for (i2 = 0; i2 <= n2; ++i2) {
      if (!(i2 < n2 && defined2(d2 = data[i2], i2, data)) === defined0) {
        if (defined0 = !defined0) {
          j2 = i2;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i2 - 1; k2 >= j2; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i2] = +x0(d2, i2, data), y0z[i2] = +y0(d2, i2, data);
        output.point(x1 ? +x1(d2, i2, data) : x0z[i2], y1 ? +y1(d2, i2, data) : y0z[i2]);
      }
    }
    if (buffer2) return output = null, buffer2 + "" || null;
  }
  function arealine() {
    return shapeLine().defined(defined2).curve(curve).context(context);
  }
  area.x = function(_2) {
    return arguments.length ? (x0 = typeof _2 === "function" ? _2 : constant$1(+_2), x1 = null, area) : x0;
  };
  area.x0 = function(_2) {
    return arguments.length ? (x0 = typeof _2 === "function" ? _2 : constant$1(+_2), area) : x0;
  };
  area.x1 = function(_2) {
    return arguments.length ? (x1 = _2 == null ? null : typeof _2 === "function" ? _2 : constant$1(+_2), area) : x1;
  };
  area.y = function(_2) {
    return arguments.length ? (y0 = typeof _2 === "function" ? _2 : constant$1(+_2), y1 = null, area) : y0;
  };
  area.y0 = function(_2) {
    return arguments.length ? (y0 = typeof _2 === "function" ? _2 : constant$1(+_2), area) : y0;
  };
  area.y1 = function(_2) {
    return arguments.length ? (y1 = _2 == null ? null : typeof _2 === "function" ? _2 : constant$1(+_2), area) : y1;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };
  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };
  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };
  area.defined = function(_2) {
    return arguments.length ? (defined2 = typeof _2 === "function" ? _2 : constant$1(!!_2), area) : defined2;
  };
  area.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), area) : curve;
  };
  area.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), area) : context;
  };
  return area;
}
class Bump {
  constructor(context, x2) {
    this._context = context;
    this._x = x2;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line) this._context.lineTo(x2, y2);
        else this._context.moveTo(x2, y2);
        break;
      }
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2);
        else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
        break;
      }
    }
    this._x0 = x2, this._y0 = y2;
  }
}
function bumpX(context) {
  return new Bump(context, true);
}
function bumpY(context) {
  return new Bump(context, false);
}
const symbolCircle = {
  draw(context, size) {
    const r2 = sqrt$1(size / pi$1);
    context.moveTo(r2, 0);
    context.arc(0, 0, r2, 0, tau$1);
  }
};
const symbolCross = {
  draw(context, size) {
    const r2 = sqrt$1(size / 5) / 2;
    context.moveTo(-3 * r2, -r2);
    context.lineTo(-r2, -r2);
    context.lineTo(-r2, -3 * r2);
    context.lineTo(r2, -3 * r2);
    context.lineTo(r2, -r2);
    context.lineTo(3 * r2, -r2);
    context.lineTo(3 * r2, r2);
    context.lineTo(r2, r2);
    context.lineTo(r2, 3 * r2);
    context.lineTo(-r2, 3 * r2);
    context.lineTo(-r2, r2);
    context.lineTo(-3 * r2, r2);
    context.closePath();
  }
};
const tan30 = sqrt$1(1 / 3);
const tan30_2 = tan30 * 2;
const symbolDiamond = {
  draw(context, size) {
    const y2 = sqrt$1(size / tan30_2);
    const x2 = y2 * tan30;
    context.moveTo(0, -y2);
    context.lineTo(x2, 0);
    context.lineTo(0, y2);
    context.lineTo(-x2, 0);
    context.closePath();
  }
};
const symbolSquare = {
  draw(context, size) {
    const w2 = sqrt$1(size);
    const x2 = -w2 / 2;
    context.rect(x2, x2, w2, w2);
  }
};
const ka = 0.8908130915292852;
const kr = sin(pi$1 / 10) / sin(7 * pi$1 / 10);
const kx = sin(tau$1 / 10) * kr;
const ky = -cos(tau$1 / 10) * kr;
const symbolStar = {
  draw(context, size) {
    const r2 = sqrt$1(size * ka);
    const x2 = kx * r2;
    const y2 = ky * r2;
    context.moveTo(0, -r2);
    context.lineTo(x2, y2);
    for (let i2 = 1; i2 < 5; ++i2) {
      const a2 = tau$1 * i2 / 5;
      const c2 = cos(a2);
      const s2 = sin(a2);
      context.lineTo(s2 * r2, -c2 * r2);
      context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
    }
    context.closePath();
  }
};
const sqrt3 = sqrt$1(3);
const symbolTriangle = {
  draw(context, size) {
    const y2 = -sqrt$1(size / (sqrt3 * 3));
    context.moveTo(0, y2 * 2);
    context.lineTo(-sqrt3 * y2, -y2);
    context.lineTo(sqrt3 * y2, -y2);
    context.closePath();
  }
};
const c$2 = -0.5;
const s$2 = sqrt$1(3) / 2;
const k$2 = 1 / sqrt$1(12);
const a$2 = (k$2 / 2 + 1) * 3;
const symbolWye = {
  draw(context, size) {
    const r2 = sqrt$1(size / a$2);
    const x0 = r2 / 2, y0 = r2 * k$2;
    const x1 = x0, y1 = r2 * k$2 + r2;
    const x2 = -x1, y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c$2 * x0 - s$2 * y0, s$2 * x0 + c$2 * y0);
    context.lineTo(c$2 * x1 - s$2 * y1, s$2 * x1 + c$2 * y1);
    context.lineTo(c$2 * x2 - s$2 * y2, s$2 * x2 + c$2 * y2);
    context.lineTo(c$2 * x0 + s$2 * y0, c$2 * y0 - s$2 * x0);
    context.lineTo(c$2 * x1 + s$2 * y1, c$2 * y1 - s$2 * x1);
    context.lineTo(c$2 * x2 + s$2 * y2, c$2 * y2 - s$2 * x2);
    context.closePath();
  }
};
function Symbol$1(type, size) {
  let context = null, path2 = withPath(symbol);
  type = typeof type === "function" ? type : constant$1(type || symbolCircle);
  size = typeof size === "function" ? size : constant$1(size === void 0 ? 64 : +size);
  function symbol() {
    let buffer2;
    if (!context) context = buffer2 = path2();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer2) return context = null, buffer2 + "" || null;
  }
  symbol.type = function(_2) {
    return arguments.length ? (type = typeof _2 === "function" ? _2 : constant$1(_2), symbol) : type;
  };
  symbol.size = function(_2) {
    return arguments.length ? (size = typeof _2 === "function" ? _2 : constant$1(+_2), symbol) : size;
  };
  symbol.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, symbol) : context;
  };
  return symbol;
}
function noop$5() {
}
function point$2(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point$2(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasis(context) {
  return new Basis(context);
}
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop$5,
  areaEnd: noop$5,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisClosed(context) {
  return new BasisClosed(context);
}
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisOpen(context) {
  return new BasisOpen(context);
}
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop$5,
  areaEnd: noop$5,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) this._context.lineTo(x2, y2);
    else this._point = 1, this._context.moveTo(x2, y2);
  }
};
function curveLinearClosed(context) {
  return new LinearClosed(context);
}
function sign$1(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
}
function slope2(that, t2) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t2) / 2 : t2;
}
function point$1(that, t02, t12) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t02, x1 - dx, y1 - dx * t12, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point$1(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t12 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point$1(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
        break;
      default:
        point$1(this, this._t0, t12 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t12;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n2 = x2.length;
    if (n2) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n2 === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n2; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n2 === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i2, n2 = x2.length - 1, m2, a2 = new Array(n2), b2 = new Array(n2), r2 = new Array(n2);
  a2[0] = 0, b2[0] = 2, r2[0] = x2[0] + 2 * x2[1];
  for (i2 = 1; i2 < n2 - 1; ++i2) a2[i2] = 1, b2[i2] = 4, r2[i2] = 4 * x2[i2] + 2 * x2[i2 + 1];
  a2[n2 - 1] = 2, b2[n2 - 1] = 7, r2[n2 - 1] = 8 * x2[n2 - 1] + x2[n2];
  for (i2 = 1; i2 < n2; ++i2) m2 = a2[i2] / b2[i2 - 1], b2[i2] -= m2, r2[i2] -= m2 * r2[i2 - 1];
  a2[n2 - 1] = r2[n2 - 1] / b2[n2 - 1];
  for (i2 = n2 - 2; i2 >= 0; --i2) a2[i2] = (r2[i2] - a2[i2 + 1]) / b2[i2];
  b2[n2 - 1] = (x2[n2] + a2[n2 - 1]) / 2;
  for (i2 = 0; i2 < n2 - 1; ++i2) b2[i2] = 2 * x2[i2 + 1] - a2[i2 + 1];
  return [a2, b2];
}
function curveNatural(context) {
  return new Natural(context);
}
function Step(context, t2) {
  this._context = context;
  this._t = t2;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x1 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};
function curveStep(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}
function stackOffsetNone(series, order2) {
  if (!((n2 = series.length) > 1)) return;
  for (var i2 = 1, j2, s0, s1 = series[order2[0]], n2, m2 = s1.length; i2 < n2; ++i2) {
    s0 = s1, s1 = series[order2[i2]];
    for (j2 = 0; j2 < m2; ++j2) {
      s1[j2][1] += s1[j2][0] = isNaN(s0[j2][1]) ? s0[j2][0] : s0[j2][1];
    }
  }
}
function stackOrderNone(series) {
  var n2 = series.length, o2 = new Array(n2);
  while (--n2 >= 0) o2[n2] = n2;
  return o2;
}
function stackValue(d2, key) {
  return d2[key];
}
function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}
function shapeStack() {
  var keys = constant$1([]), order2 = stackOrderNone, offset = stackOffsetNone, value = stackValue;
  function stack(data) {
    var sz = Array.from(keys.apply(this, arguments), stackSeries), i2, n2 = sz.length, j2 = -1, oz;
    for (const d2 of data) {
      for (i2 = 0, ++j2; i2 < n2; ++i2) {
        (sz[i2][j2] = [0, +value(d2, sz[i2].key, j2, data)]).data = d2;
      }
    }
    for (i2 = 0, oz = array(order2(sz)); i2 < n2; ++i2) {
      sz[oz[i2]].index = i2;
    }
    offset(sz, oz);
    return sz;
  }
  stack.keys = function(_2) {
    return arguments.length ? (keys = typeof _2 === "function" ? _2 : constant$1(Array.from(_2)), stack) : keys;
  };
  stack.value = function(_2) {
    return arguments.length ? (value = typeof _2 === "function" ? _2 : constant$1(+_2), stack) : value;
  };
  stack.order = function(_2) {
    return arguments.length ? (order2 = _2 == null ? stackOrderNone : typeof _2 === "function" ? _2 : constant$1(Array.from(_2)), stack) : order2;
  };
  stack.offset = function(_2) {
    return arguments.length ? (offset = _2 == null ? stackOffsetNone : _2, stack) : offset;
  };
  return stack;
}
function stackOffsetExpand(series, order2) {
  if (!((n2 = series.length) > 0)) return;
  for (var i2, n2, j2 = 0, m2 = series[0].length, y2; j2 < m2; ++j2) {
    for (y2 = i2 = 0; i2 < n2; ++i2) y2 += series[i2][j2][1] || 0;
    if (y2) for (i2 = 0; i2 < n2; ++i2) series[i2][j2][1] /= y2;
  }
  stackOffsetNone(series, order2);
}
function stackOffsetSilhouette(series, order2) {
  if (!((n2 = series.length) > 0)) return;
  for (var j2 = 0, s0 = series[order2[0]], n2, m2 = s0.length; j2 < m2; ++j2) {
    for (var i2 = 0, y2 = 0; i2 < n2; ++i2) y2 += series[i2][j2][1] || 0;
    s0[j2][1] += s0[j2][0] = -y2 / 2;
  }
  stackOffsetNone(series, order2);
}
function stackOffsetWiggle(series, order2) {
  if (!((n2 = series.length) > 0) || !((m2 = (s0 = series[order2[0]]).length) > 0)) return;
  for (var y2 = 0, j2 = 1, s0, m2, n2; j2 < m2; ++j2) {
    for (var i2 = 0, s1 = 0, s2 = 0; i2 < n2; ++i2) {
      var si = series[order2[i2]], sij0 = si[j2][1] || 0, sij1 = si[j2 - 1][1] || 0, s3 = (sij0 - sij1) / 2;
      for (var k2 = 0; k2 < i2; ++k2) {
        var sk = series[order2[k2]], skj0 = sk[j2][1] || 0, skj1 = sk[j2 - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j2 - 1][1] += s0[j2 - 1][0] = y2;
    if (s1) y2 -= s2 / s1;
  }
  s0[j2 - 1][1] += s0[j2 - 1][0] = y2;
  stackOffsetNone(series, order2);
}
var get$2 = {};
var isUnsafeProperty = {};
var hasRequiredIsUnsafeProperty;
function requireIsUnsafeProperty() {
  if (hasRequiredIsUnsafeProperty) return isUnsafeProperty;
  hasRequiredIsUnsafeProperty = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isUnsafeProperty2(key) {
      return key === "__proto__";
    }
    exports.isUnsafeProperty = isUnsafeProperty2;
  })(isUnsafeProperty);
  return isUnsafeProperty;
}
var isDeepKey = {};
var hasRequiredIsDeepKey;
function requireIsDeepKey() {
  if (hasRequiredIsDeepKey) return isDeepKey;
  hasRequiredIsDeepKey = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isDeepKey2(key) {
      switch (typeof key) {
        case "number":
        case "symbol": {
          return false;
        }
        case "string": {
          return key.includes(".") || key.includes("[") || key.includes("]");
        }
      }
    }
    exports.isDeepKey = isDeepKey2;
  })(isDeepKey);
  return isDeepKey;
}
var toKey = {};
var hasRequiredToKey;
function requireToKey() {
  if (hasRequiredToKey) return toKey;
  hasRequiredToKey = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function toKey2(value) {
      if (typeof value === "string" || typeof value === "symbol") {
        return value;
      }
      if (Object.is(value?.valueOf?.(), -0)) {
        return "-0";
      }
      return String(value);
    }
    exports.toKey = toKey2;
  })(toKey);
  return toKey;
}
var toPath = {};
var toString$1 = {};
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString) return toString$1;
  hasRequiredToString = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function toString2(value) {
      if (value == null) {
        return "";
      }
      if (typeof value === "string") {
        return value;
      }
      if (Array.isArray(value)) {
        return value.map(toString2).join(",");
      }
      const result = String(value);
      if (result === "0" && Object.is(Number(value), -0)) {
        return "-0";
      }
      return result;
    }
    exports.toString = toString2;
  })(toString$1);
  return toString$1;
}
var hasRequiredToPath;
function requireToPath() {
  if (hasRequiredToPath) return toPath;
  hasRequiredToPath = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const toString2 = /* @__PURE__ */ requireToString();
    const toKey2 = /* @__PURE__ */ requireToKey();
    function toPath2(deepKey) {
      if (Array.isArray(deepKey)) {
        return deepKey.map(toKey2.toKey);
      }
      if (typeof deepKey === "symbol") {
        return [deepKey];
      }
      deepKey = toString2.toString(deepKey);
      const result = [];
      const length = deepKey.length;
      if (length === 0) {
        return result;
      }
      let index = 0;
      let key = "";
      let quoteChar = "";
      let bracket = false;
      if (deepKey.charCodeAt(0) === 46) {
        result.push("");
        index++;
      }
      while (index < length) {
        const char = deepKey[index];
        if (quoteChar) {
          if (char === "\\" && index + 1 < length) {
            index++;
            key += deepKey[index];
          } else if (char === quoteChar) {
            quoteChar = "";
          } else {
            key += char;
          }
        } else if (bracket) {
          if (char === '"' || char === "'") {
            quoteChar = char;
          } else if (char === "]") {
            bracket = false;
            result.push(key);
            key = "";
          } else {
            key += char;
          }
        } else {
          if (char === "[") {
            bracket = true;
            if (key) {
              result.push(key);
              key = "";
            }
          } else if (char === ".") {
            if (key) {
              result.push(key);
              key = "";
            }
          } else {
            key += char;
          }
        }
        index++;
      }
      if (key) {
        result.push(key);
      }
      return result;
    }
    exports.toPath = toPath2;
  })(toPath);
  return toPath;
}
var hasRequiredGet$1;
function requireGet$1() {
  if (hasRequiredGet$1) return get$2;
  hasRequiredGet$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isUnsafeProperty2 = /* @__PURE__ */ requireIsUnsafeProperty();
    const isDeepKey2 = /* @__PURE__ */ requireIsDeepKey();
    const toKey2 = /* @__PURE__ */ requireToKey();
    const toPath2 = /* @__PURE__ */ requireToPath();
    function get2(object2, path2, defaultValue) {
      if (object2 == null) {
        return defaultValue;
      }
      switch (typeof path2) {
        case "string": {
          if (isUnsafeProperty2.isUnsafeProperty(path2)) {
            return defaultValue;
          }
          const result = object2[path2];
          if (result === void 0) {
            if (isDeepKey2.isDeepKey(path2)) {
              return get2(object2, toPath2.toPath(path2), defaultValue);
            } else {
              return defaultValue;
            }
          }
          return result;
        }
        case "number":
        case "symbol": {
          if (typeof path2 === "number") {
            path2 = toKey2.toKey(path2);
          }
          const result = object2[path2];
          if (result === void 0) {
            return defaultValue;
          }
          return result;
        }
        default: {
          if (Array.isArray(path2)) {
            return getWithPath(object2, path2, defaultValue);
          }
          if (Object.is(path2?.valueOf(), -0)) {
            path2 = "-0";
          } else {
            path2 = String(path2);
          }
          if (isUnsafeProperty2.isUnsafeProperty(path2)) {
            return defaultValue;
          }
          const result = object2[path2];
          if (result === void 0) {
            return defaultValue;
          }
          return result;
        }
      }
    }
    function getWithPath(object2, path2, defaultValue) {
      if (path2.length === 0) {
        return defaultValue;
      }
      let current2 = object2;
      for (let index = 0; index < path2.length; index++) {
        if (current2 == null) {
          return defaultValue;
        }
        if (isUnsafeProperty2.isUnsafeProperty(path2[index])) {
          return defaultValue;
        }
        current2 = current2[path2[index]];
      }
      if (current2 === void 0) {
        return defaultValue;
      }
      return current2;
    }
    exports.get = get2;
  })(get$2);
  return get$2;
}
var get$1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get$1;
  hasRequiredGet = 1;
  get$1 = requireGet$1().get;
  return get$1;
}
var getExports = /* @__PURE__ */ requireGet();
const get = /* @__PURE__ */ getDefaultExportFromCjs(getExports);
var mathSign = (value) => {
  if (value === 0) {
    return 0;
  }
  if (value > 0) {
    return 1;
  }
  return -1;
};
var isNan = (value) => {
  return typeof value == "number" && value != +value;
};
var isPercent = (value) => typeof value === "string" && value.indexOf("%") === value.length - 1;
var isNumber = (value) => (typeof value === "number" || value instanceof Number) && !isNan(value);
var isNumOrStr = (value) => isNumber(value) || typeof value === "string";
var idCounter = 0;
var uniqueId = (prefix2) => {
  var id = ++idCounter;
  return "".concat(prefix2 || "").concat(id);
};
var getPercentValue = function getPercentValue2(percent, totalValue) {
  var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var validate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (!isNumber(percent) && typeof percent !== "string") {
    return defaultValue;
  }
  var value;
  if (isPercent(percent)) {
    if (totalValue == null) {
      return defaultValue;
    }
    var index = percent.indexOf("%");
    value = totalValue * parseFloat(percent.slice(0, index)) / 100;
  } else {
    value = +percent;
  }
  if (isNan(value)) {
    value = defaultValue;
  }
  if (validate && totalValue != null && value > totalValue) {
    value = totalValue;
  }
  return value;
};
var hasDuplicate = (ary) => {
  if (!Array.isArray(ary)) {
    return false;
  }
  var len = ary.length;
  var cache = {};
  for (var i2 = 0; i2 < len; i2++) {
    if (!cache[ary[i2]]) {
      cache[ary[i2]] = true;
    } else {
      return true;
    }
  }
  return false;
};
function interpolate$1(start, end, t2) {
  if (isNumber(start) && isNumber(end)) {
    return start + t2 * (end - start);
  }
  return end;
}
function findEntryInArray(ary, specifiedKey, specifiedValue) {
  if (!ary || !ary.length) {
    return void 0;
  }
  return ary.find((entry) => entry && (typeof specifiedKey === "function" ? specifiedKey(entry) : get(entry, specifiedKey)) === specifiedValue);
}
var isNullish = (value) => {
  return value === null || typeof value === "undefined";
};
var upperFirst = (value) => {
  if (isNullish(value)) {
    return value;
  }
  return "".concat(value.charAt(0).toUpperCase()).concat(value.slice(1));
};
var _excluded$k = ["type", "size", "sizeType"];
function _extends$q() {
  return _extends$q = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$q.apply(null, arguments);
}
function ownKeys$B(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$B(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$B(Object(t2), true).forEach(function(r3) {
      _defineProperty$D(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$B(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$D(e3, r2, t2) {
  return (r2 = _toPropertyKey$D(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$D(t2) {
  var i2 = _toPrimitive$D(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$D(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$k(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$k(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$k(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
var symbolFactories = {
  symbolCircle,
  symbolCross,
  symbolDiamond,
  symbolSquare,
  symbolStar,
  symbolTriangle,
  symbolWye
};
var RADIAN$1 = Math.PI / 180;
var getSymbolFactory = (type) => {
  var name = "symbol".concat(upperFirst(type));
  return symbolFactories[name] || symbolCircle;
};
var calculateAreaSize = (size, sizeType, type) => {
  if (sizeType === "area") {
    return size;
  }
  switch (type) {
    case "cross":
      return 5 * size * size / 9;
    case "diamond":
      return 0.5 * size * size / Math.sqrt(3);
    case "square":
      return size * size;
    case "star": {
      var angle = 18 * RADIAN$1;
      return 1.25 * size * size * (Math.tan(angle) - Math.tan(angle * 2) * Math.tan(angle) ** 2);
    }
    case "triangle":
      return Math.sqrt(3) * size * size / 4;
    case "wye":
      return (21 - 10 * Math.sqrt(3)) * size * size / 8;
    default:
      return Math.PI * size * size / 4;
  }
};
var registerSymbol = (key, factory) => {
  symbolFactories["symbol".concat(upperFirst(key))] = factory;
};
var Symbols = (_ref2) => {
  var {
    type = "circle",
    size = 64,
    sizeType = "area"
  } = _ref2, rest = _objectWithoutProperties$k(_ref2, _excluded$k);
  var props = _objectSpread$B(_objectSpread$B({}, rest), {}, {
    type,
    size,
    sizeType
  });
  var realType = "circle";
  if (typeof type === "string") {
    realType = type;
  }
  var getPath2 = () => {
    var symbolFactory = getSymbolFactory(realType);
    var symbol = Symbol$1().type(symbolFactory).size(calculateAreaSize(size, sizeType, realType));
    var s2 = symbol();
    if (s2 === null) {
      return void 0;
    }
    return s2;
  };
  var {
    className,
    cx,
    cy
  } = props;
  var filteredProps = svgPropertiesAndEvents(props);
  if (cx === +cx && cy === +cy && size === +size) {
    return /* @__PURE__ */ reactExports.createElement("path", _extends$q({}, filteredProps, {
      className: clsx("recharts-symbols", className),
      transform: "translate(".concat(cx, ", ").concat(cy, ")"),
      d: getPath2()
    }));
  }
  return null;
};
Symbols.registerSymbol = registerSymbol;
var adaptEventHandlers = (props, newHandler) => {
  if (!props || typeof props === "function" || typeof props === "boolean") {
    return null;
  }
  var inputProps = props;
  if (/* @__PURE__ */ reactExports.isValidElement(props)) {
    inputProps = props.props;
  }
  if (typeof inputProps !== "object" && typeof inputProps !== "function") {
    return null;
  }
  var out = {};
  Object.keys(inputProps).forEach((key) => {
    if (isEventKey(key)) {
      out[key] = ((e3) => inputProps[key](inputProps, e3));
    }
  });
  return out;
};
var getEventHandlerOfChild = (originalHandler, data, index) => (e3) => {
  originalHandler(data, index, e3);
  return null;
};
var adaptEventsOfChild = (props, data, index) => {
  if (props === null || typeof props !== "object" && typeof props !== "function") {
    return null;
  }
  var out = null;
  Object.keys(props).forEach((key) => {
    var item = props[key];
    if (isEventKey(key) && typeof item === "function") {
      if (!out) out = {};
      out[key] = getEventHandlerOfChild(item, data, index);
    }
  });
  return out;
};
function _extends$p() {
  return _extends$p = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$p.apply(null, arguments);
}
function ownKeys$A(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$A(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$A(Object(t2), true).forEach(function(r3) {
      _defineProperty$C(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$A(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$C(e3, r2, t2) {
  return (r2 = _toPropertyKey$C(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$C(t2) {
  var i2 = _toPrimitive$C(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$C(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var SIZE = 32;
class DefaultLegendContent extends reactExports.PureComponent {
  /**
   * Render the path of icon
   * @param data Data of each legend item
   * @param iconType if defined, it will always render this icon. If undefined then it uses icon from data.type
   * @return Path element
   */
  renderIcon(data, iconType) {
    var {
      inactiveColor
    } = this.props;
    var halfSize = SIZE / 2;
    var sixthSize = SIZE / 6;
    var thirdSize = SIZE / 3;
    var color2 = data.inactive ? inactiveColor : data.color;
    var preferredIcon = iconType !== null && iconType !== void 0 ? iconType : data.type;
    if (preferredIcon === "none") {
      return null;
    }
    if (preferredIcon === "plainline") {
      return /* @__PURE__ */ reactExports.createElement("line", {
        strokeWidth: 4,
        fill: "none",
        stroke: color2,
        strokeDasharray: data.payload.strokeDasharray,
        x1: 0,
        y1: halfSize,
        x2: SIZE,
        y2: halfSize,
        className: "recharts-legend-icon"
      });
    }
    if (preferredIcon === "line") {
      return /* @__PURE__ */ reactExports.createElement("path", {
        strokeWidth: 4,
        fill: "none",
        stroke: color2,
        d: "M0,".concat(halfSize, "h").concat(thirdSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(2 * thirdSize, ",").concat(halfSize, "\n            H").concat(SIZE, "M").concat(2 * thirdSize, ",").concat(halfSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(thirdSize, ",").concat(halfSize),
        className: "recharts-legend-icon"
      });
    }
    if (preferredIcon === "rect") {
      return /* @__PURE__ */ reactExports.createElement("path", {
        stroke: "none",
        fill: color2,
        d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat(SIZE * 3 / 4, "h").concat(-SIZE, "z"),
        className: "recharts-legend-icon"
      });
    }
    if (/* @__PURE__ */ reactExports.isValidElement(data.legendIcon)) {
      var iconProps = _objectSpread$A({}, data);
      delete iconProps.legendIcon;
      return /* @__PURE__ */ reactExports.cloneElement(data.legendIcon, iconProps);
    }
    return /* @__PURE__ */ reactExports.createElement(Symbols, {
      fill: color2,
      cx: halfSize,
      cy: halfSize,
      size: SIZE,
      sizeType: "diameter",
      type: preferredIcon
    });
  }
  /**
   * Draw items of legend
   * @return Items
   */
  renderItems() {
    var {
      payload,
      iconSize,
      layout,
      formatter,
      inactiveColor,
      iconType
    } = this.props;
    var viewBox = {
      x: 0,
      y: 0,
      width: SIZE,
      height: SIZE
    };
    var itemStyle = {
      display: layout === "horizontal" ? "inline-block" : "block",
      marginRight: 10
    };
    var svgStyle = {
      display: "inline-block",
      verticalAlign: "middle",
      marginRight: 4
    };
    return payload.map((entry, i2) => {
      var finalFormatter = entry.formatter || formatter;
      var className = clsx({
        "recharts-legend-item": true,
        ["legend-item-".concat(i2)]: true,
        inactive: entry.inactive
      });
      if (entry.type === "none") {
        return null;
      }
      var color2 = entry.inactive ? inactiveColor : entry.color;
      var finalValue = finalFormatter ? finalFormatter(entry.value, entry, i2) : entry.value;
      return /* @__PURE__ */ reactExports.createElement("li", _extends$p({
        className,
        style: itemStyle,
        key: "legend-item-".concat(i2)
      }, adaptEventsOfChild(this.props, entry, i2)), /* @__PURE__ */ reactExports.createElement(Surface, {
        width: iconSize,
        height: iconSize,
        viewBox,
        style: svgStyle,
        "aria-label": "".concat(finalValue, " legend icon")
      }, this.renderIcon(entry, iconType)), /* @__PURE__ */ reactExports.createElement("span", {
        className: "recharts-legend-item-text",
        style: {
          color: color2
        }
      }, finalValue));
    });
  }
  render() {
    var {
      payload,
      layout,
      align
    } = this.props;
    if (!payload || !payload.length) {
      return null;
    }
    var finalStyle = {
      padding: 0,
      margin: 0,
      textAlign: layout === "horizontal" ? align : "left"
    };
    return /* @__PURE__ */ reactExports.createElement("ul", {
      className: "recharts-default-legend",
      style: finalStyle
    }, this.renderItems());
  }
}
_defineProperty$C(DefaultLegendContent, "displayName", "Legend");
_defineProperty$C(DefaultLegendContent, "defaultProps", {
  align: "center",
  iconSize: 14,
  inactiveColor: "#ccc",
  layout: "horizontal",
  verticalAlign: "middle"
});
var uniqBy$3 = {};
var uniqBy$2 = {};
var hasRequiredUniqBy$2;
function requireUniqBy$2() {
  if (hasRequiredUniqBy$2) return uniqBy$2;
  hasRequiredUniqBy$2 = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function uniqBy2(arr, mapper) {
      const map2 = /* @__PURE__ */ new Map();
      for (let i2 = 0; i2 < arr.length; i2++) {
        const item = arr[i2];
        const key = mapper(item);
        if (!map2.has(key)) {
          map2.set(key, item);
        }
      }
      return Array.from(map2.values());
    }
    exports.uniqBy = uniqBy2;
  })(uniqBy$2);
  return uniqBy$2;
}
var identity$4 = {};
var hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity) return identity$4;
  hasRequiredIdentity = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function identity2(x2) {
      return x2;
    }
    exports.identity = identity2;
  })(identity$4);
  return identity$4;
}
var isArrayLikeObject = {};
var isArrayLike = {};
var isLength = {};
var hasRequiredIsLength;
function requireIsLength() {
  if (hasRequiredIsLength) return isLength;
  hasRequiredIsLength = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isLength2(value) {
      return Number.isSafeInteger(value) && value >= 0;
    }
    exports.isLength = isLength2;
  })(isLength);
  return isLength;
}
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike) return isArrayLike;
  hasRequiredIsArrayLike = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isLength2 = /* @__PURE__ */ requireIsLength();
    function isArrayLike2(value) {
      return value != null && typeof value !== "function" && isLength2.isLength(value.length);
    }
    exports.isArrayLike = isArrayLike2;
  })(isArrayLike);
  return isArrayLike;
}
var isObjectLike = {};
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike) return isObjectLike;
  hasRequiredIsObjectLike = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isObjectLike2(value) {
      return typeof value === "object" && value !== null;
    }
    exports.isObjectLike = isObjectLike2;
  })(isObjectLike);
  return isObjectLike;
}
var hasRequiredIsArrayLikeObject;
function requireIsArrayLikeObject() {
  if (hasRequiredIsArrayLikeObject) return isArrayLikeObject;
  hasRequiredIsArrayLikeObject = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isArrayLike2 = /* @__PURE__ */ requireIsArrayLike();
    const isObjectLike2 = /* @__PURE__ */ requireIsObjectLike();
    function isArrayLikeObject2(value) {
      return isObjectLike2.isObjectLike(value) && isArrayLike2.isArrayLike(value);
    }
    exports.isArrayLikeObject = isArrayLikeObject2;
  })(isArrayLikeObject);
  return isArrayLikeObject;
}
var iteratee = {};
var property = {};
var hasRequiredProperty;
function requireProperty() {
  if (hasRequiredProperty) return property;
  hasRequiredProperty = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const get2 = /* @__PURE__ */ requireGet$1();
    function property2(path2) {
      return function(object2) {
        return get2.get(object2, path2);
      };
    }
    exports.property = property2;
  })(property);
  return property;
}
var matches = {};
var isMatch = {};
var isMatchWith = {};
var isObject = {};
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject;
  hasRequiredIsObject = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isObject2(value) {
      return value !== null && (typeof value === "object" || typeof value === "function");
    }
    exports.isObject = isObject2;
  })(isObject);
  return isObject;
}
var isPrimitive = {};
var hasRequiredIsPrimitive;
function requireIsPrimitive() {
  if (hasRequiredIsPrimitive) return isPrimitive;
  hasRequiredIsPrimitive = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isPrimitive2(value) {
      return value == null || typeof value !== "object" && typeof value !== "function";
    }
    exports.isPrimitive = isPrimitive2;
  })(isPrimitive);
  return isPrimitive;
}
var eq = {};
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq;
  hasRequiredEq = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function eq2(value, other) {
      return value === other || Number.isNaN(value) && Number.isNaN(other);
    }
    exports.eq = eq2;
  })(eq);
  return eq;
}
var hasRequiredIsMatchWith;
function requireIsMatchWith() {
  if (hasRequiredIsMatchWith) return isMatchWith;
  hasRequiredIsMatchWith = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isObject2 = /* @__PURE__ */ requireIsObject();
    const isPrimitive2 = /* @__PURE__ */ requireIsPrimitive();
    const eq2 = /* @__PURE__ */ requireEq();
    function isMatchWith2(target, source, compare) {
      if (typeof compare !== "function") {
        return isMatchWith2(target, source, () => void 0);
      }
      return isMatchWithInternal(target, source, function doesMatch(objValue, srcValue, key, object2, source2, stack) {
        const isEqual = compare(objValue, srcValue, key, object2, source2, stack);
        if (isEqual !== void 0) {
          return Boolean(isEqual);
        }
        return isMatchWithInternal(objValue, srcValue, doesMatch, stack);
      }, /* @__PURE__ */ new Map());
    }
    function isMatchWithInternal(target, source, compare, stack) {
      if (source === target) {
        return true;
      }
      switch (typeof source) {
        case "object": {
          return isObjectMatch(target, source, compare, stack);
        }
        case "function": {
          const sourceKeys = Object.keys(source);
          if (sourceKeys.length > 0) {
            return isMatchWithInternal(target, { ...source }, compare, stack);
          }
          return eq2.eq(target, source);
        }
        default: {
          if (!isObject2.isObject(target)) {
            return eq2.eq(target, source);
          }
          if (typeof source === "string") {
            return source === "";
          }
          return true;
        }
      }
    }
    function isObjectMatch(target, source, compare, stack) {
      if (source == null) {
        return true;
      }
      if (Array.isArray(source)) {
        return isArrayMatch(target, source, compare, stack);
      }
      if (source instanceof Map) {
        return isMapMatch(target, source, compare, stack);
      }
      if (source instanceof Set) {
        return isSetMatch(target, source, compare, stack);
      }
      const keys = Object.keys(source);
      if (target == null) {
        return keys.length === 0;
      }
      if (keys.length === 0) {
        return true;
      }
      if (stack?.has(source)) {
        return stack.get(source) === target;
      }
      stack?.set(source, target);
      try {
        for (let i2 = 0; i2 < keys.length; i2++) {
          const key = keys[i2];
          if (!isPrimitive2.isPrimitive(target) && !(key in target)) {
            return false;
          }
          if (source[key] === void 0 && target[key] !== void 0) {
            return false;
          }
          if (source[key] === null && target[key] !== null) {
            return false;
          }
          const isEqual = compare(target[key], source[key], key, target, source, stack);
          if (!isEqual) {
            return false;
          }
        }
        return true;
      } finally {
        stack?.delete(source);
      }
    }
    function isMapMatch(target, source, compare, stack) {
      if (source.size === 0) {
        return true;
      }
      if (!(target instanceof Map)) {
        return false;
      }
      for (const [key, sourceValue] of source.entries()) {
        const targetValue = target.get(key);
        const isEqual = compare(targetValue, sourceValue, key, target, source, stack);
        if (isEqual === false) {
          return false;
        }
      }
      return true;
    }
    function isArrayMatch(target, source, compare, stack) {
      if (source.length === 0) {
        return true;
      }
      if (!Array.isArray(target)) {
        return false;
      }
      const countedIndex = /* @__PURE__ */ new Set();
      for (let i2 = 0; i2 < source.length; i2++) {
        const sourceItem = source[i2];
        let found = false;
        for (let j2 = 0; j2 < target.length; j2++) {
          if (countedIndex.has(j2)) {
            continue;
          }
          const targetItem = target[j2];
          let matches2 = false;
          const isEqual = compare(targetItem, sourceItem, i2, target, source, stack);
          if (isEqual) {
            matches2 = true;
          }
          if (matches2) {
            countedIndex.add(j2);
            found = true;
            break;
          }
        }
        if (!found) {
          return false;
        }
      }
      return true;
    }
    function isSetMatch(target, source, compare, stack) {
      if (source.size === 0) {
        return true;
      }
      if (!(target instanceof Set)) {
        return false;
      }
      return isArrayMatch([...target], [...source], compare, stack);
    }
    exports.isMatchWith = isMatchWith2;
    exports.isSetMatch = isSetMatch;
  })(isMatchWith);
  return isMatchWith;
}
var hasRequiredIsMatch;
function requireIsMatch() {
  if (hasRequiredIsMatch) return isMatch;
  hasRequiredIsMatch = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isMatchWith2 = /* @__PURE__ */ requireIsMatchWith();
    function isMatch2(target, source) {
      return isMatchWith2.isMatchWith(target, source, () => void 0);
    }
    exports.isMatch = isMatch2;
  })(isMatch);
  return isMatch;
}
var cloneDeep$1 = {};
var cloneDeepWith$1 = {};
var getSymbols = {};
var hasRequiredGetSymbols;
function requireGetSymbols() {
  if (hasRequiredGetSymbols) return getSymbols;
  hasRequiredGetSymbols = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function getSymbols2(object2) {
      return Object.getOwnPropertySymbols(object2).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object2, symbol));
    }
    exports.getSymbols = getSymbols2;
  })(getSymbols);
  return getSymbols;
}
var getTag = {};
var hasRequiredGetTag;
function requireGetTag() {
  if (hasRequiredGetTag) return getTag;
  hasRequiredGetTag = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function getTag2(value) {
      if (value == null) {
        return value === void 0 ? "[object Undefined]" : "[object Null]";
      }
      return Object.prototype.toString.call(value);
    }
    exports.getTag = getTag2;
  })(getTag);
  return getTag;
}
var tags = {};
var hasRequiredTags;
function requireTags() {
  if (hasRequiredTags) return tags;
  hasRequiredTags = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const regexpTag = "[object RegExp]";
    const stringTag = "[object String]";
    const numberTag = "[object Number]";
    const booleanTag = "[object Boolean]";
    const argumentsTag = "[object Arguments]";
    const symbolTag = "[object Symbol]";
    const dateTag = "[object Date]";
    const mapTag = "[object Map]";
    const setTag = "[object Set]";
    const arrayTag = "[object Array]";
    const functionTag = "[object Function]";
    const arrayBufferTag = "[object ArrayBuffer]";
    const objectTag = "[object Object]";
    const errorTag = "[object Error]";
    const dataViewTag = "[object DataView]";
    const uint8ArrayTag = "[object Uint8Array]";
    const uint8ClampedArrayTag = "[object Uint8ClampedArray]";
    const uint16ArrayTag = "[object Uint16Array]";
    const uint32ArrayTag = "[object Uint32Array]";
    const bigUint64ArrayTag = "[object BigUint64Array]";
    const int8ArrayTag = "[object Int8Array]";
    const int16ArrayTag = "[object Int16Array]";
    const int32ArrayTag = "[object Int32Array]";
    const bigInt64ArrayTag = "[object BigInt64Array]";
    const float32ArrayTag = "[object Float32Array]";
    const float64ArrayTag = "[object Float64Array]";
    exports.argumentsTag = argumentsTag;
    exports.arrayBufferTag = arrayBufferTag;
    exports.arrayTag = arrayTag;
    exports.bigInt64ArrayTag = bigInt64ArrayTag;
    exports.bigUint64ArrayTag = bigUint64ArrayTag;
    exports.booleanTag = booleanTag;
    exports.dataViewTag = dataViewTag;
    exports.dateTag = dateTag;
    exports.errorTag = errorTag;
    exports.float32ArrayTag = float32ArrayTag;
    exports.float64ArrayTag = float64ArrayTag;
    exports.functionTag = functionTag;
    exports.int16ArrayTag = int16ArrayTag;
    exports.int32ArrayTag = int32ArrayTag;
    exports.int8ArrayTag = int8ArrayTag;
    exports.mapTag = mapTag;
    exports.numberTag = numberTag;
    exports.objectTag = objectTag;
    exports.regexpTag = regexpTag;
    exports.setTag = setTag;
    exports.stringTag = stringTag;
    exports.symbolTag = symbolTag;
    exports.uint16ArrayTag = uint16ArrayTag;
    exports.uint32ArrayTag = uint32ArrayTag;
    exports.uint8ArrayTag = uint8ArrayTag;
    exports.uint8ClampedArrayTag = uint8ClampedArrayTag;
  })(tags);
  return tags;
}
var isTypedArray = {};
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isTypedArray2(x2) {
      return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
    }
    exports.isTypedArray = isTypedArray2;
  })(isTypedArray);
  return isTypedArray;
}
var hasRequiredCloneDeepWith$1;
function requireCloneDeepWith$1() {
  if (hasRequiredCloneDeepWith$1) return cloneDeepWith$1;
  hasRequiredCloneDeepWith$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const getSymbols2 = /* @__PURE__ */ requireGetSymbols();
    const getTag2 = /* @__PURE__ */ requireGetTag();
    const tags2 = /* @__PURE__ */ requireTags();
    const isPrimitive2 = /* @__PURE__ */ requireIsPrimitive();
    const isTypedArray2 = /* @__PURE__ */ requireIsTypedArray();
    function cloneDeepWith2(obj, cloneValue) {
      return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), cloneValue);
    }
    function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
      const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);
      if (cloned !== void 0) {
        return cloned;
      }
      if (isPrimitive2.isPrimitive(valueToClone)) {
        return valueToClone;
      }
      if (stack.has(valueToClone)) {
        return stack.get(valueToClone);
      }
      if (Array.isArray(valueToClone)) {
        const result = new Array(valueToClone.length);
        stack.set(valueToClone, result);
        for (let i2 = 0; i2 < valueToClone.length; i2++) {
          result[i2] = cloneDeepWithImpl(valueToClone[i2], i2, objectToClone, stack, cloneValue);
        }
        if (Object.hasOwn(valueToClone, "index")) {
          result.index = valueToClone.index;
        }
        if (Object.hasOwn(valueToClone, "input")) {
          result.input = valueToClone.input;
        }
        return result;
      }
      if (valueToClone instanceof Date) {
        return new Date(valueToClone.getTime());
      }
      if (valueToClone instanceof RegExp) {
        const result = new RegExp(valueToClone.source, valueToClone.flags);
        result.lastIndex = valueToClone.lastIndex;
        return result;
      }
      if (valueToClone instanceof Map) {
        const result = /* @__PURE__ */ new Map();
        stack.set(valueToClone, result);
        for (const [key, value] of valueToClone) {
          result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));
        }
        return result;
      }
      if (valueToClone instanceof Set) {
        const result = /* @__PURE__ */ new Set();
        stack.set(valueToClone, result);
        for (const value of valueToClone) {
          result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack, cloneValue));
        }
        return result;
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
        return valueToClone.subarray();
      }
      if (isTypedArray2.isTypedArray(valueToClone)) {
        const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
        stack.set(valueToClone, result);
        for (let i2 = 0; i2 < valueToClone.length; i2++) {
          result[i2] = cloneDeepWithImpl(valueToClone[i2], i2, objectToClone, stack, cloneValue);
        }
        return result;
      }
      if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
        return valueToClone.slice(0);
      }
      if (valueToClone instanceof DataView) {
        const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
        stack.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (typeof File !== "undefined" && valueToClone instanceof File) {
        const result = new File([valueToClone], valueToClone.name, {
          type: valueToClone.type
        });
        stack.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (typeof Blob !== "undefined" && valueToClone instanceof Blob) {
        const result = new Blob([valueToClone], { type: valueToClone.type });
        stack.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (valueToClone instanceof Error) {
        const result = new valueToClone.constructor();
        stack.set(valueToClone, result);
        result.message = valueToClone.message;
        result.name = valueToClone.name;
        result.stack = valueToClone.stack;
        result.cause = valueToClone.cause;
        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (valueToClone instanceof Boolean) {
        const result = new Boolean(valueToClone.valueOf());
        stack.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (valueToClone instanceof Number) {
        const result = new Number(valueToClone.valueOf());
        stack.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (valueToClone instanceof String) {
        const result = new String(valueToClone.valueOf());
        stack.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
        const result = Object.create(Object.getPrototypeOf(valueToClone));
        stack.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      return valueToClone;
    }
    function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
      const keys = [...Object.keys(source), ...getSymbols2.getSymbols(source)];
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        const descriptor = Object.getOwnPropertyDescriptor(target, key);
        if (descriptor == null || descriptor.writable) {
          target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);
        }
      }
    }
    function isCloneableObject(object2) {
      switch (getTag2.getTag(object2)) {
        case tags2.argumentsTag:
        case tags2.arrayTag:
        case tags2.arrayBufferTag:
        case tags2.dataViewTag:
        case tags2.booleanTag:
        case tags2.dateTag:
        case tags2.float32ArrayTag:
        case tags2.float64ArrayTag:
        case tags2.int8ArrayTag:
        case tags2.int16ArrayTag:
        case tags2.int32ArrayTag:
        case tags2.mapTag:
        case tags2.numberTag:
        case tags2.objectTag:
        case tags2.regexpTag:
        case tags2.setTag:
        case tags2.stringTag:
        case tags2.symbolTag:
        case tags2.uint8ArrayTag:
        case tags2.uint8ClampedArrayTag:
        case tags2.uint16ArrayTag:
        case tags2.uint32ArrayTag: {
          return true;
        }
        default: {
          return false;
        }
      }
    }
    exports.cloneDeepWith = cloneDeepWith2;
    exports.cloneDeepWithImpl = cloneDeepWithImpl;
    exports.copyProperties = copyProperties;
  })(cloneDeepWith$1);
  return cloneDeepWith$1;
}
var hasRequiredCloneDeep$1;
function requireCloneDeep$1() {
  if (hasRequiredCloneDeep$1) return cloneDeep$1;
  hasRequiredCloneDeep$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const cloneDeepWith2 = /* @__PURE__ */ requireCloneDeepWith$1();
    function cloneDeep2(obj) {
      return cloneDeepWith2.cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
    }
    exports.cloneDeep = cloneDeep2;
  })(cloneDeep$1);
  return cloneDeep$1;
}
var hasRequiredMatches;
function requireMatches() {
  if (hasRequiredMatches) return matches;
  hasRequiredMatches = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isMatch2 = /* @__PURE__ */ requireIsMatch();
    const cloneDeep2 = /* @__PURE__ */ requireCloneDeep$1();
    function matches2(source) {
      source = cloneDeep2.cloneDeep(source);
      return (target) => {
        return isMatch2.isMatch(target, source);
      };
    }
    exports.matches = matches2;
  })(matches);
  return matches;
}
var matchesProperty = {};
var cloneDeep = {};
var cloneDeepWith = {};
var hasRequiredCloneDeepWith;
function requireCloneDeepWith() {
  if (hasRequiredCloneDeepWith) return cloneDeepWith;
  hasRequiredCloneDeepWith = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const cloneDeepWith$12 = /* @__PURE__ */ requireCloneDeepWith$1();
    const tags2 = /* @__PURE__ */ requireTags();
    function cloneDeepWith2(obj, customizer) {
      return cloneDeepWith$12.cloneDeepWith(obj, (value, key, object2, stack) => {
        const cloned = customizer?.(value, key, object2, stack);
        if (cloned !== void 0) {
          return cloned;
        }
        if (typeof obj !== "object") {
          return void 0;
        }
        switch (Object.prototype.toString.call(obj)) {
          case tags2.numberTag:
          case tags2.stringTag:
          case tags2.booleanTag: {
            const result = new obj.constructor(obj?.valueOf());
            cloneDeepWith$12.copyProperties(result, obj);
            return result;
          }
          case tags2.argumentsTag: {
            const result = {};
            cloneDeepWith$12.copyProperties(result, obj);
            result.length = obj.length;
            result[Symbol.iterator] = obj[Symbol.iterator];
            return result;
          }
          default: {
            return void 0;
          }
        }
      });
    }
    exports.cloneDeepWith = cloneDeepWith2;
  })(cloneDeepWith);
  return cloneDeepWith;
}
var hasRequiredCloneDeep;
function requireCloneDeep() {
  if (hasRequiredCloneDeep) return cloneDeep;
  hasRequiredCloneDeep = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const cloneDeepWith2 = /* @__PURE__ */ requireCloneDeepWith();
    function cloneDeep2(obj) {
      return cloneDeepWith2.cloneDeepWith(obj);
    }
    exports.cloneDeep = cloneDeep2;
  })(cloneDeep);
  return cloneDeep;
}
var has$1 = {};
var isIndex = {};
var hasRequiredIsIndex;
function requireIsIndex() {
  if (hasRequiredIsIndex) return isIndex;
  hasRequiredIsIndex = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
    function isIndex2(value, length = Number.MAX_SAFE_INTEGER) {
      switch (typeof value) {
        case "number": {
          return Number.isInteger(value) && value >= 0 && value < length;
        }
        case "symbol": {
          return false;
        }
        case "string": {
          return IS_UNSIGNED_INTEGER.test(value);
        }
      }
    }
    exports.isIndex = isIndex2;
  })(isIndex);
  return isIndex;
}
var isArguments = {};
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const getTag2 = /* @__PURE__ */ requireGetTag();
    function isArguments2(value) {
      return value !== null && typeof value === "object" && getTag2.getTag(value) === "[object Arguments]";
    }
    exports.isArguments = isArguments2;
  })(isArguments);
  return isArguments;
}
var hasRequiredHas;
function requireHas() {
  if (hasRequiredHas) return has$1;
  hasRequiredHas = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isDeepKey2 = /* @__PURE__ */ requireIsDeepKey();
    const isIndex2 = /* @__PURE__ */ requireIsIndex();
    const isArguments2 = /* @__PURE__ */ requireIsArguments();
    const toPath2 = /* @__PURE__ */ requireToPath();
    function has2(object2, path2) {
      let resolvedPath;
      if (Array.isArray(path2)) {
        resolvedPath = path2;
      } else if (typeof path2 === "string" && isDeepKey2.isDeepKey(path2) && object2?.[path2] == null) {
        resolvedPath = toPath2.toPath(path2);
      } else {
        resolvedPath = [path2];
      }
      if (resolvedPath.length === 0) {
        return false;
      }
      let current2 = object2;
      for (let i2 = 0; i2 < resolvedPath.length; i2++) {
        const key = resolvedPath[i2];
        if (current2 == null || !Object.hasOwn(current2, key)) {
          const isSparseIndex = (Array.isArray(current2) || isArguments2.isArguments(current2)) && isIndex2.isIndex(key) && key < current2.length;
          if (!isSparseIndex) {
            return false;
          }
        }
        current2 = current2[key];
      }
      return true;
    }
    exports.has = has2;
  })(has$1);
  return has$1;
}
var hasRequiredMatchesProperty;
function requireMatchesProperty() {
  if (hasRequiredMatchesProperty) return matchesProperty;
  hasRequiredMatchesProperty = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isMatch2 = /* @__PURE__ */ requireIsMatch();
    const toKey2 = /* @__PURE__ */ requireToKey();
    const cloneDeep2 = /* @__PURE__ */ requireCloneDeep();
    const get2 = /* @__PURE__ */ requireGet$1();
    const has2 = /* @__PURE__ */ requireHas();
    function matchesProperty2(property2, source) {
      switch (typeof property2) {
        case "object": {
          if (Object.is(property2?.valueOf(), -0)) {
            property2 = "-0";
          }
          break;
        }
        case "number": {
          property2 = toKey2.toKey(property2);
          break;
        }
      }
      source = cloneDeep2.cloneDeep(source);
      return function(target) {
        const result = get2.get(target, property2);
        if (result === void 0) {
          return has2.has(target, property2);
        }
        if (source === void 0) {
          return result === void 0;
        }
        return isMatch2.isMatch(result, source);
      };
    }
    exports.matchesProperty = matchesProperty2;
  })(matchesProperty);
  return matchesProperty;
}
var hasRequiredIteratee;
function requireIteratee() {
  if (hasRequiredIteratee) return iteratee;
  hasRequiredIteratee = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const identity2 = /* @__PURE__ */ requireIdentity();
    const property2 = /* @__PURE__ */ requireProperty();
    const matches2 = /* @__PURE__ */ requireMatches();
    const matchesProperty2 = /* @__PURE__ */ requireMatchesProperty();
    function iteratee2(value) {
      if (value == null) {
        return identity2.identity;
      }
      switch (typeof value) {
        case "function": {
          return value;
        }
        case "object": {
          if (Array.isArray(value) && value.length === 2) {
            return matchesProperty2.matchesProperty(value[0], value[1]);
          }
          return matches2.matches(value);
        }
        case "string":
        case "symbol":
        case "number": {
          return property2.property(value);
        }
      }
    }
    exports.iteratee = iteratee2;
  })(iteratee);
  return iteratee;
}
var hasRequiredUniqBy$1;
function requireUniqBy$1() {
  if (hasRequiredUniqBy$1) return uniqBy$3;
  hasRequiredUniqBy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const uniqBy$12 = /* @__PURE__ */ requireUniqBy$2();
    const identity2 = /* @__PURE__ */ requireIdentity();
    const isArrayLikeObject2 = /* @__PURE__ */ requireIsArrayLikeObject();
    const iteratee2 = /* @__PURE__ */ requireIteratee();
    function uniqBy2(array2, iteratee$1 = identity2.identity) {
      if (!isArrayLikeObject2.isArrayLikeObject(array2)) {
        return [];
      }
      return uniqBy$12.uniqBy(Array.from(array2), iteratee2.iteratee(iteratee$1));
    }
    exports.uniqBy = uniqBy2;
  })(uniqBy$3);
  return uniqBy$3;
}
var uniqBy$1;
var hasRequiredUniqBy;
function requireUniqBy() {
  if (hasRequiredUniqBy) return uniqBy$1;
  hasRequiredUniqBy = 1;
  uniqBy$1 = requireUniqBy$1().uniqBy;
  return uniqBy$1;
}
var uniqByExports = /* @__PURE__ */ requireUniqBy();
const uniqBy = /* @__PURE__ */ getDefaultExportFromCjs(uniqByExports);
function getUniqPayload(payload, option, defaultUniqBy2) {
  if (option === true) {
    return uniqBy(payload, defaultUniqBy2);
  }
  if (typeof option === "function") {
    return uniqBy(payload, option);
  }
  return payload;
}
var withSelector$1 = { exports: {} };
var withSelector_production = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_production;
function requireWithSelector_production() {
  if (hasRequiredWithSelector_production) return withSelector_production;
  hasRequiredWithSelector_production = 1;
  var React2 = requireReact(), shim2 = requireShim();
  function is2(x2, y2) {
    return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore = shim2.useSyncExternalStore, useRef = React2.useRef, useEffect = React2.useEffect, useMemo = React2.useMemo, useDebugValue = React2.useDebugValue;
  withSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef(null);
    if (null === instRef.current) {
      var inst = { hasValue: false, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            hasMemo = true;
            memoizedSnapshot = nextSnapshot;
            nextSnapshot = selector(nextSnapshot);
            if (void 0 !== isEqual && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          currentSelection = memoizedSelection;
          if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
            return memoizedSnapshot = nextSnapshot, currentSelection;
          memoizedSnapshot = nextSnapshot;
          return memoizedSelection = nextSelection;
        }
        var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          null === maybeGetServerSnapshot ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector, isEqual]
    );
    var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    useEffect(
      function() {
        inst.hasValue = true;
        inst.value = value;
      },
      [value]
    );
    useDebugValue(value);
    return value;
  };
  return withSelector_production;
}
var hasRequiredWithSelector$1;
function requireWithSelector$1() {
  if (hasRequiredWithSelector$1) return withSelector$1.exports;
  hasRequiredWithSelector$1 = 1;
  {
    withSelector$1.exports = requireWithSelector_production();
  }
  return withSelector$1.exports;
}
var withSelectorExports = requireWithSelector$1();
var RechartsReduxContext = /* @__PURE__ */ reactExports.createContext(null);
var noopDispatch = (a2) => a2;
var useAppDispatch = () => {
  var context = reactExports.useContext(RechartsReduxContext);
  if (context) {
    return context.store.dispatch;
  }
  return noopDispatch;
};
var noop$4 = () => {
};
var addNestedSubNoop = () => noop$4;
var refEquality = (a2, b2) => a2 === b2;
function useAppSelector(selector) {
  var context = reactExports.useContext(RechartsReduxContext);
  return withSelectorExports.useSyncExternalStoreWithSelector(context ? context.subscription.addNestedSub : addNestedSubNoop, context ? context.store.getState : noop$4, context ? context.store.getState : noop$4, context ? selector : noop$4, refEquality);
}
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
function assertIsObject(object2, errorMessage = `expected an object, instead received ${typeof object2}`) {
  if (typeof object2 !== "object") {
    throw new TypeError(errorMessage);
  }
}
function assertIsArrayOfFunctions(array2, errorMessage = `expected all items to be functions, instead received the following types: `) {
  if (!array2.every((item) => typeof item === "function")) {
    const itemTypes = array2.map(
      (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
    ).join(", ");
    throw new TypeError(`${errorMessage}[${itemTypes}]`);
  }
}
var ensureIsArray = (item) => {
  return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  assertIsArrayOfFunctions(
    dependencies,
    `createSelector expects all input-selectors to be functions, but received the following types: `
  );
  return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const { length } = dependencies;
  for (let i2 = 0; i2 < length; i2++) {
    inputSelectorResults.push(dependencies[i2].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
var StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
function weakMapMemoize(func, options = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options;
  let lastResult2;
  let resultsCount = 0;
  function memoized() {
    let cacheNode = fnNode;
    const { length } = arguments;
    for (let i2 = 0, l2 = length; i2 < l2; i2++) {
      const arg = arguments[i2];
      if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
        }
        const objectNode = objectCache.get(arg);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
        }
        const primitiveNode = primitiveCache.get(arg);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED) {
      result = cacheNode.v;
    } else {
      result = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const lastResultValue = lastResult2?.deref?.() ?? lastResult2;
        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
          result = lastResultValue;
          resultsCount !== 0 && resultsCount--;
        }
        const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
        lastResult2 = needsWeakRef ? new Ref(result) : result;
      }
    }
    terminatedNode.s = TERMINATED;
    terminatedNode.v = result;
    return result;
  }
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions;
  const createSelector2 = (...createSelectorArgs) => {
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult2;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(
      resultFunc,
      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    };
    const {
      memoize: memoize2,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = []
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize2(function recomputationWrapper() {
      recomputations++;
      return resultFunc.apply(
        null,
        arguments
      );
    }, ...finalMemoizeOptions);
    const selector = argsMemoize(function dependenciesChecker() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(
        dependencies,
        arguments
      );
      lastResult2 = memoizedResultFunc.apply(null, inputSelectorResults);
      return lastResult2;
    }, ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult2,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize: memoize2,
      argsMemoize
    });
  };
  Object.assign(createSelector2, {
    withTypes: () => createSelector2
  });
  return createSelector2;
}
var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector) => {
    assertIsObject(
      inputSelectorsObject,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map(
      (key) => inputSelectorsObject[key]
    );
    const structuredSelector = selectorCreator(
      dependencies,
      (...inputSelectorResults) => {
        return inputSelectorResults.reduce((composition, value, index) => {
          composition[inputSelectorKeys[index]] = value;
          return composition;
        }, {});
      }
    );
    return structuredSelector;
  },
  { withTypes: () => createStructuredSelector }
);
var sortBy$2 = {};
var orderBy = {};
var compareValues = {};
var hasRequiredCompareValues;
function requireCompareValues() {
  if (hasRequiredCompareValues) return compareValues;
  hasRequiredCompareValues = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function getPriority(a2) {
      if (typeof a2 === "symbol") {
        return 1;
      }
      if (a2 === null) {
        return 2;
      }
      if (a2 === void 0) {
        return 3;
      }
      if (a2 !== a2) {
        return 4;
      }
      return 0;
    }
    const compareValues2 = (a2, b2, order2) => {
      if (a2 !== b2) {
        const aPriority = getPriority(a2);
        const bPriority = getPriority(b2);
        if (aPriority === bPriority && aPriority === 0) {
          if (a2 < b2) {
            return order2 === "desc" ? 1 : -1;
          }
          if (a2 > b2) {
            return order2 === "desc" ? -1 : 1;
          }
        }
        return order2 === "desc" ? bPriority - aPriority : aPriority - bPriority;
      }
      return 0;
    };
    exports.compareValues = compareValues2;
  })(compareValues);
  return compareValues;
}
var isKey = {};
var isSymbol = {};
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol;
  hasRequiredIsSymbol = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isSymbol2(value) {
      return typeof value === "symbol" || value instanceof Symbol;
    }
    exports.isSymbol = isSymbol2;
  })(isSymbol);
  return isSymbol;
}
var hasRequiredIsKey;
function requireIsKey() {
  if (hasRequiredIsKey) return isKey;
  hasRequiredIsKey = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isSymbol2 = /* @__PURE__ */ requireIsSymbol();
    const regexIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    const regexIsPlainProp = /^\w*$/;
    function isKey2(value, object2) {
      if (Array.isArray(value)) {
        return false;
      }
      if (typeof value === "number" || typeof value === "boolean" || value == null || isSymbol2.isSymbol(value)) {
        return true;
      }
      return typeof value === "string" && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value)) || object2 != null && Object.hasOwn(object2, value);
    }
    exports.isKey = isKey2;
  })(isKey);
  return isKey;
}
var hasRequiredOrderBy;
function requireOrderBy() {
  if (hasRequiredOrderBy) return orderBy;
  hasRequiredOrderBy = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const compareValues2 = /* @__PURE__ */ requireCompareValues();
    const isKey2 = /* @__PURE__ */ requireIsKey();
    const toPath2 = /* @__PURE__ */ requireToPath();
    function orderBy2(collection, criteria, orders, guard) {
      if (collection == null) {
        return [];
      }
      orders = guard ? void 0 : orders;
      if (!Array.isArray(collection)) {
        collection = Object.values(collection);
      }
      if (!Array.isArray(criteria)) {
        criteria = criteria == null ? [null] : [criteria];
      }
      if (criteria.length === 0) {
        criteria = [null];
      }
      if (!Array.isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      orders = orders.map((order2) => String(order2));
      const getValueByNestedPath = (object2, path2) => {
        let target = object2;
        for (let i2 = 0; i2 < path2.length && target != null; ++i2) {
          target = target[path2[i2]];
        }
        return target;
      };
      const getValueByCriterion = (criterion, object2) => {
        if (object2 == null || criterion == null) {
          return object2;
        }
        if (typeof criterion === "object" && "key" in criterion) {
          if (Object.hasOwn(object2, criterion.key)) {
            return object2[criterion.key];
          }
          return getValueByNestedPath(object2, criterion.path);
        }
        if (typeof criterion === "function") {
          return criterion(object2);
        }
        if (Array.isArray(criterion)) {
          return getValueByNestedPath(object2, criterion);
        }
        if (typeof object2 === "object") {
          return object2[criterion];
        }
        return object2;
      };
      const preparedCriteria = criteria.map((criterion) => {
        if (Array.isArray(criterion) && criterion.length === 1) {
          criterion = criterion[0];
        }
        if (criterion == null || typeof criterion === "function" || Array.isArray(criterion) || isKey2.isKey(criterion)) {
          return criterion;
        }
        return { key: criterion, path: toPath2.toPath(criterion) };
      });
      const preparedCollection = collection.map((item) => ({
        original: item,
        criteria: preparedCriteria.map((criterion) => getValueByCriterion(criterion, item))
      }));
      return preparedCollection.slice().sort((a2, b2) => {
        for (let i2 = 0; i2 < preparedCriteria.length; i2++) {
          const comparedResult = compareValues2.compareValues(a2.criteria[i2], b2.criteria[i2], orders[i2]);
          if (comparedResult !== 0) {
            return comparedResult;
          }
        }
        return 0;
      }).map((item) => item.original);
    }
    exports.orderBy = orderBy2;
  })(orderBy);
  return orderBy;
}
var flatten = {};
var hasRequiredFlatten;
function requireFlatten() {
  if (hasRequiredFlatten) return flatten;
  hasRequiredFlatten = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function flatten2(arr, depth = 1) {
      const result = [];
      const flooredDepth = Math.floor(depth);
      const recursive = (arr2, currentDepth) => {
        for (let i2 = 0; i2 < arr2.length; i2++) {
          const item = arr2[i2];
          if (Array.isArray(item) && currentDepth < flooredDepth) {
            recursive(item, currentDepth + 1);
          } else {
            result.push(item);
          }
        }
      };
      recursive(arr, 0);
      return result;
    }
    exports.flatten = flatten2;
  })(flatten);
  return flatten;
}
var isIterateeCall = {};
var hasRequiredIsIterateeCall;
function requireIsIterateeCall() {
  if (hasRequiredIsIterateeCall) return isIterateeCall;
  hasRequiredIsIterateeCall = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isIndex2 = /* @__PURE__ */ requireIsIndex();
    const isArrayLike2 = /* @__PURE__ */ requireIsArrayLike();
    const isObject2 = /* @__PURE__ */ requireIsObject();
    const eq2 = /* @__PURE__ */ requireEq();
    function isIterateeCall2(value, index, object2) {
      if (!isObject2.isObject(object2)) {
        return false;
      }
      if (typeof index === "number" && isArrayLike2.isArrayLike(object2) && isIndex2.isIndex(index) && index < object2.length || typeof index === "string" && index in object2) {
        return eq2.eq(object2[index], value);
      }
      return false;
    }
    exports.isIterateeCall = isIterateeCall2;
  })(isIterateeCall);
  return isIterateeCall;
}
var hasRequiredSortBy$1;
function requireSortBy$1() {
  if (hasRequiredSortBy$1) return sortBy$2;
  hasRequiredSortBy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const orderBy2 = /* @__PURE__ */ requireOrderBy();
    const flatten2 = /* @__PURE__ */ requireFlatten();
    const isIterateeCall2 = /* @__PURE__ */ requireIsIterateeCall();
    function sortBy2(collection, ...criteria) {
      const length = criteria.length;
      if (length > 1 && isIterateeCall2.isIterateeCall(collection, criteria[0], criteria[1])) {
        criteria = [];
      } else if (length > 2 && isIterateeCall2.isIterateeCall(criteria[0], criteria[1], criteria[2])) {
        criteria = [criteria[0]];
      }
      return orderBy2.orderBy(collection, flatten2.flatten(criteria), ["asc"]);
    }
    exports.sortBy = sortBy2;
  })(sortBy$2);
  return sortBy$2;
}
var sortBy$1;
var hasRequiredSortBy;
function requireSortBy() {
  if (hasRequiredSortBy) return sortBy$1;
  hasRequiredSortBy = 1;
  sortBy$1 = requireSortBy$1().sortBy;
  return sortBy$1;
}
var sortByExports = /* @__PURE__ */ requireSortBy();
const sortBy = /* @__PURE__ */ getDefaultExportFromCjs(sortByExports);
var selectLegendSettings = (state) => state.legend.settings;
var selectLegendSize = (state) => state.legend.size;
var selectAllLegendPayload2DArray = (state) => state.legend.payload;
var selectLegendPayload = createSelector([selectAllLegendPayload2DArray, selectLegendSettings], (payloads, _ref2) => {
  var {
    itemSorter
  } = _ref2;
  var flat = payloads.flat(1);
  return itemSorter ? sortBy(flat, itemSorter) : flat;
});
function useLegendPayload() {
  return useAppSelector(selectLegendPayload);
}
var EPS$1 = 1;
function useElementOffset() {
  var extraDependencies = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var [lastBoundingBox, setLastBoundingBox] = reactExports.useState({
    height: 0,
    left: 0,
    top: 0,
    width: 0
  });
  var updateBoundingBox = reactExports.useCallback(
    (node) => {
      if (node != null) {
        var rect = node.getBoundingClientRect();
        var box = {
          height: rect.height,
          left: rect.left,
          top: rect.top,
          width: rect.width
        };
        if (Math.abs(box.height - lastBoundingBox.height) > EPS$1 || Math.abs(box.left - lastBoundingBox.left) > EPS$1 || Math.abs(box.top - lastBoundingBox.top) > EPS$1 || Math.abs(box.width - lastBoundingBox.width) > EPS$1) {
          setLastBoundingBox({
            height: box.height,
            left: box.left,
            top: box.top,
            width: box.width
          });
        }
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [lastBoundingBox.width, lastBoundingBox.height, lastBoundingBox.top, lastBoundingBox.left, ...extraDependencies]
  );
  return [lastBoundingBox, updateBoundingBox];
}
function formatProdErrorMessage$1(code) {
  return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}
var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
var actionTypes_default = ActionTypes;
function isPlainObject$4(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}
function createStore(reducer, preloadedState, enhancer) {
  if (typeof reducer !== "function") {
    throw new Error(formatProdErrorMessage$1(2));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage$1(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage$1(1));
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  let currentReducer = reducer;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener2, key) => {
        nextListeners.set(key, listener2);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage$1(3));
    }
    return currentState;
  }
  function subscribe(listener2) {
    if (typeof listener2 !== "function") {
      throw new Error(formatProdErrorMessage$1(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage$1(5));
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener2);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage$1(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject$4(action)) {
      throw new Error(formatProdErrorMessage$1(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage$1(8));
    }
    if (typeof action.type !== "string") {
      throw new Error(formatProdErrorMessage$1(17));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage$1(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners = currentListeners = nextListeners;
    listeners.forEach((listener2) => {
      listener2();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage$1(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage$1(11));
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store = {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store;
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach((key) => {
    const reducer = reducers[key];
    const initialState2 = reducer(void 0, {
      type: actionTypes_default.INIT
    });
    if (typeof initialState2 === "undefined") {
      throw new Error(formatProdErrorMessage$1(12));
    }
    if (typeof reducer(void 0, {
      type: actionTypes_default.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(formatProdErrorMessage$1(13));
    }
  });
}
function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers);
  const finalReducers = {};
  for (let i2 = 0; i2 < reducerKeys.length; i2++) {
    const key = reducerKeys[i2];
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  const finalReducerKeys = Object.keys(finalReducers);
  let shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e3) {
    shapeAssertionError = e3;
  }
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    let hasChanged = false;
    const nextState = {};
    for (let i2 = 0; i2 < finalReducerKeys.length; i2++) {
      const key = finalReducerKeys[i2];
      const reducer = finalReducers[key];
      const previousStateForKey = state[key];
      const nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        action && action.type;
        throw new Error(formatProdErrorMessage$1(14));
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose$1(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
}
function applyMiddleware(...middlewares) {
  return (createStore2) => (reducer, preloadedState) => {
    const store = createStore2(reducer, preloadedState);
    let dispatch = () => {
      throw new Error(formatProdErrorMessage$1(15));
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    };
    const chain = middlewares.map((middleware) => middleware(middlewareAPI));
    dispatch = compose$1(...chain)(store.dispatch);
    return {
      ...store,
      dispatch
    };
  };
}
function isAction(action) {
  return isPlainObject$4(action) && "type" in action && typeof action.type === "string";
}
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
function die(error, ...args) {
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  if (!value)
    return false;
  return isPlainObject$3(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
var cachedCtorStrings = /* @__PURE__ */ new WeakMap();
function isPlainObject$3(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null || proto === Object.prototype)
    return true;
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  if (typeof Ctor !== "function")
    return false;
  let ctorString = cachedCtorStrings.get(Ctor);
  if (ctorString === void 0) {
    ctorString = Function.toString.call(Ctor);
    cachedCtorStrings.set(Ctor, ctorString);
  }
  return ctorString === objectCtorString;
}
function each(obj, iter, strict = true) {
  if (getArchtype(obj) === 0) {
    const keys = strict ? Reflect.ownKeys(obj) : Object.keys(obj);
    keys.forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set(thing, propOrOldValue, value) {
  const t2 = getArchtype(thing);
  if (t2 === 2)
    thing.set(propOrOldValue, value);
  else if (t2 === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain = isPlainObject$3(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys = Reflect.ownKeys(descriptors);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return { ...base };
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    Object.defineProperties(obj, {
      set: dontMutateMethodOverride,
      add: dontMutateMethodOverride,
      clear: dontMutateMethodOverride,
      delete: dontMutateMethodOverride
    });
  }
  Object.freeze(obj);
  if (deep)
    Object.values(obj).forEach((value) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
var dontMutateMethodOverride = {
  value: dontMutateFrozenCollections
};
function isFrozen(obj) {
  if (obj === null || typeof obj !== "object")
    return true;
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path2) {
  if (isFrozen(value))
    return value;
  const useStrictIteration = rootScope.immer_.shouldUseStrictIteration();
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path2),
      useStrictIteration
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(
        rootScope,
        state,
        result,
        key,
        childValue,
        path2,
        isSet2
      ),
      useStrictIteration
    );
    maybeFreeze(rootScope, result, false);
    if (path2 && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path2,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (childValue == null) {
    return;
  }
  if (typeof childValue !== "object" && !targetIsSet) {
    return;
  }
  const childIsFrozen = isFrozen(childValue);
  if (childIsFrozen && !targetIsSet) {
    return;
  }
  if (isDraft(childValue)) {
    const path2 = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path2);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !childIsFrozen) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    if (parentState && parentState.base_ && parentState.base_[prop] === childValue && childIsFrozen) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && (isMap(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop)))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function createProxyProxy(base, parent) {
  const isArray = Array.isArray(base);
  const state = {
    type_: isArray ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc?.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2?.[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
var Immer2 = class {
  constructor(config2) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.useStrictIteration_ = true;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self2 = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p2 = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p2, ip);
          patchListener(p2, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p2, ip) => {
        patches = p2;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof config2?.autoFreeze === "boolean")
      this.setAutoFreeze(config2.autoFreeze);
    if (typeof config2?.useStrictShallowCopy === "boolean")
      this.setUseStrictShallowCopy(config2.useStrictShallowCopy);
    if (typeof config2?.useStrictIteration === "boolean")
      this.setUseStrictIteration(config2.useStrictIteration);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  /**
   * Pass false to use faster iteration that skips non-enumerable properties
   * but still handles symbols for compatibility.
   *
   * By default, strict iteration is enabled (includes all own properties).
   */
  setUseStrictIteration(value) {
    this.useStrictIteration_ = value;
  }
  shouldUseStrictIteration() {
    return this.useStrictIteration_;
  }
  applyPatches(base, patches) {
    let i2;
    for (i2 = patches.length - 1; i2 >= 0; i2--) {
      const patch = patches[i2];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i2 > -1) {
      patches = patches.slice(i2 + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy2;
  let strict = true;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy2 = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
    strict = state.scope_.immer_.shouldUseStrictIteration();
  } else {
    copy2 = shallowCopy(value, true);
  }
  each(
    copy2,
    (key, childValue) => {
      set(copy2, key, currentImpl(childValue));
    },
    strict
  );
  if (state) {
    state.finalized_ = false;
  }
  return copy2;
}
var immer = new Immer2();
var produce = immer.produce;
function castDraft(value) {
  return value;
}
function createThunkMiddleware(extraArgument) {
  const middleware = ({ dispatch, getState }) => (next) => (action) => {
    if (typeof action === "function") {
      return action(dispatch, getState, extraArgument);
    }
    return next(action);
  };
  return middleware;
}
var thunk = createThunkMiddleware();
var withExtraArgument = createThunkMiddleware;
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0) return void 0;
  if (typeof arguments[0] === "object") return compose$1;
  return compose$1.apply(null, arguments);
};
function createAction(type, prepareAction) {
  function actionCreator(...args) {
    if (prepareAction) {
      let prepared = prepareAction(...args);
      if (!prepared) {
        throw new Error(formatProdErrorMessage(0));
      }
      return {
        type,
        payload: prepared.payload,
        ..."meta" in prepared && {
          meta: prepared.meta
        },
        ..."error" in prepared && {
          error: prepared.error
        }
      };
    }
    return {
      type,
      payload: args[0]
    };
  }
  actionCreator.toString = () => `${type}`;
  actionCreator.type = type;
  actionCreator.match = (action) => isAction(action) && action.type === type;
  return actionCreator;
}
var Tuple = class _Tuple extends Array {
  constructor(...items) {
    super(...items);
    Object.setPrototypeOf(this, _Tuple.prototype);
  }
  static get [Symbol.species]() {
    return _Tuple;
  }
  concat(...arr) {
    return super.concat.apply(this, arr);
  }
  prepend(...arr) {
    if (arr.length === 1 && Array.isArray(arr[0])) {
      return new _Tuple(...arr[0].concat(this));
    }
    return new _Tuple(...arr.concat(this));
  }
};
function freezeDraftable(val) {
  return isDraftable(val) ? produce(val, () => {
  }) : val;
}
function getOrInsertComputed(map2, key, compute) {
  if (map2.has(key)) return map2.get(key);
  return map2.set(key, compute(key)).get(key);
}
function isBoolean(x2) {
  return typeof x2 === "boolean";
}
var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {
  const {
    thunk: thunk$1 = true,
    immutableCheck = true,
    serializableCheck = true,
    actionCreatorCheck = true
  } = options ?? {};
  let middlewareArray = new Tuple();
  if (thunk$1) {
    if (isBoolean(thunk$1)) {
      middlewareArray.push(thunk);
    } else {
      middlewareArray.push(withExtraArgument(thunk$1.extraArgument));
    }
  }
  return middlewareArray;
};
var SHOULD_AUTOBATCH = "RTK_autoBatch";
var prepareAutoBatched = () => (payload) => ({
  payload,
  meta: {
    [SHOULD_AUTOBATCH]: true
  }
});
var createQueueWithTimer = (timeout) => {
  return (notify) => {
    setTimeout(notify, timeout);
  };
};
var autoBatchEnhancer = (options = {
  type: "raf"
}) => (next) => (...args) => {
  const store = next(...args);
  let notifying = true;
  let shouldNotifyAtEndOfTick = false;
  let notificationQueued = false;
  const listeners = /* @__PURE__ */ new Set();
  const queueCallback = options.type === "tick" ? queueMicrotask : options.type === "raf" ? (
    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
    typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
  ) : options.type === "callback" ? options.queueNotification : createQueueWithTimer(options.timeout);
  const notifyListeners = () => {
    notificationQueued = false;
    if (shouldNotifyAtEndOfTick) {
      shouldNotifyAtEndOfTick = false;
      listeners.forEach((l2) => l2());
    }
  };
  return Object.assign({}, store, {
    // Override the base `store.subscribe` method to keep original listeners
    // from running if we're delaying notifications
    subscribe(listener2) {
      const wrappedListener = () => notifying && listener2();
      const unsubscribe = store.subscribe(wrappedListener);
      listeners.add(listener2);
      return () => {
        unsubscribe();
        listeners.delete(listener2);
      };
    },
    // Override the base `store.dispatch` method so that we can check actions
    // for the `shouldAutoBatch` flag and determine if batching is active
    dispatch(action) {
      try {
        notifying = !action?.meta?.[SHOULD_AUTOBATCH];
        shouldNotifyAtEndOfTick = !notifying;
        if (shouldNotifyAtEndOfTick) {
          if (!notificationQueued) {
            notificationQueued = true;
            queueCallback(notifyListeners);
          }
        }
        return store.dispatch(action);
      } finally {
        notifying = true;
      }
    }
  });
};
var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {
  const {
    autoBatch = true
  } = options ?? {};
  let enhancerArray = new Tuple(middlewareEnhancer);
  if (autoBatch) {
    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
  }
  return enhancerArray;
};
function configureStore(options) {
  const getDefaultMiddleware = buildGetDefaultMiddleware();
  const {
    reducer = void 0,
    middleware,
    devTools = true,
    preloadedState = void 0,
    enhancers = void 0
  } = options || {};
  let rootReducer2;
  if (typeof reducer === "function") {
    rootReducer2 = reducer;
  } else if (isPlainObject$4(reducer)) {
    rootReducer2 = combineReducers(reducer);
  } else {
    throw new Error(formatProdErrorMessage(1));
  }
  let finalMiddleware;
  if (typeof middleware === "function") {
    finalMiddleware = middleware(getDefaultMiddleware);
  } else {
    finalMiddleware = getDefaultMiddleware();
  }
  let finalCompose = compose$1;
  if (devTools) {
    finalCompose = composeWithDevTools({
      // Enable capture of stack traces for dispatched Redux actions
      trace: false,
      ...typeof devTools === "object" && devTools
    });
  }
  const middlewareEnhancer = applyMiddleware(...finalMiddleware);
  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
  let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
  const composedEnhancer = finalCompose(...storeEnhancers);
  return createStore(rootReducer2, preloadedState, composedEnhancer);
}
function executeReducerBuilderCallback(builderCallback) {
  const actionsMap = {};
  const actionMatchers = [];
  let defaultCaseReducer;
  const builder = {
    addCase(typeOrActionCreator, reducer) {
      const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (!type) {
        throw new Error(formatProdErrorMessage(28));
      }
      if (type in actionsMap) {
        throw new Error(formatProdErrorMessage(29));
      }
      actionsMap[type] = reducer;
      return builder;
    },
    addAsyncThunk(asyncThunk, reducers) {
      if (reducers.pending) actionsMap[asyncThunk.pending.type] = reducers.pending;
      if (reducers.rejected) actionsMap[asyncThunk.rejected.type] = reducers.rejected;
      if (reducers.fulfilled) actionsMap[asyncThunk.fulfilled.type] = reducers.fulfilled;
      if (reducers.settled) actionMatchers.push({
        matcher: asyncThunk.settled,
        reducer: reducers.settled
      });
      return builder;
    },
    addMatcher(matcher, reducer) {
      actionMatchers.push({
        matcher,
        reducer
      });
      return builder;
    },
    addDefaultCase(reducer) {
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x2) {
  return typeof x2 === "function";
}
function createReducer(initialState2, mapOrBuilderCallback) {
  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
  let getInitialState;
  if (isStateFunction(initialState2)) {
    getInitialState = () => freezeDraftable(initialState2());
  } else {
    const frozenInitialState = freezeDraftable(initialState2);
    getInitialState = () => frozenInitialState;
  }
  function reducer(state = getInitialState(), action) {
    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
      matcher
    }) => matcher(action)).map(({
      reducer: reducer2
    }) => reducer2)];
    if (caseReducers.filter((cr) => !!cr).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce((previousState, caseReducer) => {
      if (caseReducer) {
        if (isDraft(previousState)) {
          const draft = previousState;
          const result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!isDraftable(previousState)) {
          const result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return produce(previousState, (draft) => {
            return caseReducer(draft, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = (size = 21) => {
  let id = "";
  let i2 = size;
  while (i2--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
var asyncThunkSymbol = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
function getType(slice2, actionKey) {
  return `${slice2}/${actionKey}`;
}
function buildCreateSlice({
  creators
} = {}) {
  const cAT = creators?.asyncThunk?.[asyncThunkSymbol];
  return function createSlice2(options) {
    const {
      name,
      reducerPath = name
    } = options;
    if (!name) {
      throw new Error(formatProdErrorMessage(11));
    }
    const reducers = (typeof options.reducers === "function" ? options.reducers(buildReducerCreators()) : options.reducers) || {};
    const reducerNames = Object.keys(reducers);
    const context = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    };
    const contextMethods = {
      addCase(typeOrActionCreator, reducer2) {
        const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
        if (!type) {
          throw new Error(formatProdErrorMessage(12));
        }
        if (type in context.sliceCaseReducersByType) {
          throw new Error(formatProdErrorMessage(13));
        }
        context.sliceCaseReducersByType[type] = reducer2;
        return contextMethods;
      },
      addMatcher(matcher, reducer2) {
        context.sliceMatchers.push({
          matcher,
          reducer: reducer2
        });
        return contextMethods;
      },
      exposeAction(name2, actionCreator) {
        context.actionCreators[name2] = actionCreator;
        return contextMethods;
      },
      exposeCaseReducer(name2, reducer2) {
        context.sliceCaseReducersByName[name2] = reducer2;
        return contextMethods;
      }
    };
    reducerNames.forEach((reducerName) => {
      const reducerDefinition = reducers[reducerName];
      const reducerDetails = {
        reducerName,
        type: getType(name, reducerName),
        createNotation: typeof options.reducers === "function"
      };
      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
      } else {
        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
      }
    });
    function buildReducer() {
      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];
      const finalCaseReducers = {
        ...extraReducers,
        ...context.sliceCaseReducersByType
      };
      return createReducer(options.initialState, (builder) => {
        for (let key in finalCaseReducers) {
          builder.addCase(key, finalCaseReducers[key]);
        }
        for (let sM of context.sliceMatchers) {
          builder.addMatcher(sM.matcher, sM.reducer);
        }
        for (let m2 of actionMatchers) {
          builder.addMatcher(m2.matcher, m2.reducer);
        }
        if (defaultCaseReducer) {
          builder.addDefaultCase(defaultCaseReducer);
        }
      });
    }
    const selectSelf = (state) => state;
    const injectedSelectorCache = /* @__PURE__ */ new Map();
    const injectedStateCache = /* @__PURE__ */ new WeakMap();
    let _reducer;
    function reducer(state, action) {
      if (!_reducer) _reducer = buildReducer();
      return _reducer(state, action);
    }
    function getInitialState() {
      if (!_reducer) _reducer = buildReducer();
      return _reducer.getInitialState();
    }
    function makeSelectorProps(reducerPath2, injected = false) {
      function selectSlice(state) {
        let sliceState = state[reducerPath2];
        if (typeof sliceState === "undefined") {
          if (injected) {
            sliceState = getOrInsertComputed(injectedStateCache, selectSlice, getInitialState);
          }
        }
        return sliceState;
      }
      function getSelectors(selectState = selectSelf) {
        const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());
        return getOrInsertComputed(selectorCache, selectState, () => {
          const map2 = {};
          for (const [name2, selector] of Object.entries(options.selectors ?? {})) {
            map2[name2] = wrapSelector(selector, selectState, () => getOrInsertComputed(injectedStateCache, selectState, getInitialState), injected);
          }
          return map2;
        });
      }
      return {
        reducerPath: reducerPath2,
        getSelectors,
        get selectors() {
          return getSelectors(selectSlice);
        },
        selectSlice
      };
    }
    const slice2 = {
      name,
      reducer,
      actions: context.actionCreators,
      caseReducers: context.sliceCaseReducersByName,
      getInitialState,
      ...makeSelectorProps(reducerPath),
      injectInto(injectable, {
        reducerPath: pathOpt,
        ...config2
      } = {}) {
        const newReducerPath = pathOpt ?? reducerPath;
        injectable.inject({
          reducerPath: newReducerPath,
          reducer
        }, config2);
        return {
          ...slice2,
          ...makeSelectorProps(newReducerPath, true)
        };
      }
    };
    return slice2;
  };
}
function wrapSelector(selector, selectState, getInitialState, injected) {
  function wrapper(rootState, ...args) {
    let sliceState = selectState(rootState);
    if (typeof sliceState === "undefined") {
      if (injected) {
        sliceState = getInitialState();
      }
    }
    return selector(sliceState, ...args);
  }
  wrapper.unwrapped = selector;
  return wrapper;
}
var createSlice = /* @__PURE__ */ buildCreateSlice();
function buildReducerCreators() {
  function asyncThunk(payloadCreator, config2) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator,
      ...config2
    };
  }
  asyncThunk.withTypes = () => asyncThunk;
  return {
    reducer(caseReducer) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [caseReducer.name](...args) {
          return caseReducer(...args);
        }
      }[caseReducer.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(prepare, reducer) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare,
        reducer
      };
    },
    asyncThunk
  };
}
function handleNormalReducerDefinition({
  type,
  reducerName,
  createNotation
}, maybeReducerWithPrepare, context) {
  let caseReducer;
  let prepareCallback;
  if ("reducer" in maybeReducerWithPrepare) {
    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
      throw new Error(formatProdErrorMessage(17));
    }
    caseReducer = maybeReducerWithPrepare.reducer;
    prepareCallback = maybeReducerWithPrepare.prepare;
  } else {
    caseReducer = maybeReducerWithPrepare;
  }
  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
}
function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "asyncThunk";
}
function isCaseReducerWithPrepareDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
}
function handleThunkCaseReducerDefinition({
  type,
  reducerName
}, reducerDefinition, context, cAT) {
  if (!cAT) {
    throw new Error(formatProdErrorMessage(18));
  }
  const {
    payloadCreator,
    fulfilled,
    pending,
    rejected,
    settled,
    options
  } = reducerDefinition;
  const thunk2 = cAT(type, payloadCreator, options);
  context.exposeAction(reducerName, thunk2);
  if (fulfilled) {
    context.addCase(thunk2.fulfilled, fulfilled);
  }
  if (pending) {
    context.addCase(thunk2.pending, pending);
  }
  if (rejected) {
    context.addCase(thunk2.rejected, rejected);
  }
  if (settled) {
    context.addMatcher(thunk2.settled, settled);
  }
  context.exposeCaseReducer(reducerName, {
    fulfilled: fulfilled || noop$3,
    pending: pending || noop$3,
    rejected: rejected || noop$3,
    settled: settled || noop$3
  });
}
function noop$3() {
}
var task = "task";
var listener = "listener";
var completed = "completed";
var cancelled = "cancelled";
var taskCancelled = `task-${cancelled}`;
var taskCompleted = `task-${completed}`;
var listenerCancelled = `${listener}-${cancelled}`;
var listenerCompleted = `${listener}-${completed}`;
var TaskAbortError = class {
  constructor(code) {
    this.code = code;
    this.message = `${task} ${cancelled} (reason: ${code})`;
  }
  name = "TaskAbortError";
  message;
};
var assertFunction = (func, expected) => {
  if (typeof func !== "function") {
    throw new TypeError(formatProdErrorMessage(32));
  }
};
var noop2 = () => {
};
var catchRejection = (promise, onError = noop2) => {
  promise.catch(onError);
  return promise;
};
var addAbortSignalListener = (abortSignal, callback) => {
  abortSignal.addEventListener("abort", callback, {
    once: true
  });
  return () => abortSignal.removeEventListener("abort", callback);
};
var abortControllerWithReason = (abortController, reason) => {
  const signal = abortController.signal;
  if (signal.aborted) {
    return;
  }
  if (!("reason" in signal)) {
    Object.defineProperty(signal, "reason", {
      enumerable: true,
      value: reason,
      configurable: true,
      writable: true
    });
  }
  abortController.abort(reason);
};
var validateActive = (signal) => {
  if (signal.aborted) {
    const {
      reason
    } = signal;
    throw new TaskAbortError(reason);
  }
};
function raceWithSignal(signal, promise) {
  let cleanup = noop2;
  return new Promise((resolve, reject) => {
    const notifyRejection = () => reject(new TaskAbortError(signal.reason));
    if (signal.aborted) {
      notifyRejection();
      return;
    }
    cleanup = addAbortSignalListener(signal, notifyRejection);
    promise.finally(() => cleanup()).then(resolve, reject);
  }).finally(() => {
    cleanup = noop2;
  });
}
var runTask = async (task2, cleanUp) => {
  try {
    await Promise.resolve();
    const value = await task2();
    return {
      status: "ok",
      value
    };
  } catch (error) {
    return {
      status: error instanceof TaskAbortError ? "cancelled" : "rejected",
      error
    };
  } finally {
    cleanUp?.();
  }
};
var createPause = (signal) => {
  return (promise) => {
    return catchRejection(raceWithSignal(signal, promise).then((output) => {
      validateActive(signal);
      return output;
    }));
  };
};
var createDelay = (signal) => {
  const pause = createPause(signal);
  return (timeoutMs) => {
    return pause(new Promise((resolve) => setTimeout(resolve, timeoutMs)));
  };
};
var {
  assign
} = Object;
var INTERNAL_NIL_TOKEN = {};
var alm = "listenerMiddleware";
var createFork = (parentAbortSignal, parentBlockingPromises) => {
  const linkControllers = (controller) => addAbortSignalListener(parentAbortSignal, () => abortControllerWithReason(controller, parentAbortSignal.reason));
  return (taskExecutor, opts) => {
    assertFunction(taskExecutor);
    const childAbortController = new AbortController();
    linkControllers(childAbortController);
    const result = runTask(async () => {
      validateActive(parentAbortSignal);
      validateActive(childAbortController.signal);
      const result2 = await taskExecutor({
        pause: createPause(childAbortController.signal),
        delay: createDelay(childAbortController.signal),
        signal: childAbortController.signal
      });
      validateActive(childAbortController.signal);
      return result2;
    }, () => abortControllerWithReason(childAbortController, taskCompleted));
    if (opts?.autoJoin) {
      parentBlockingPromises.push(result.catch(noop2));
    }
    return {
      result: createPause(parentAbortSignal)(result),
      cancel() {
        abortControllerWithReason(childAbortController, taskCancelled);
      }
    };
  };
};
var createTakePattern = (startListening, signal) => {
  const take = async (predicate, timeout) => {
    validateActive(signal);
    let unsubscribe = () => {
    };
    const tuplePromise = new Promise((resolve, reject) => {
      let stopListening = startListening({
        predicate,
        effect: (action, listenerApi) => {
          listenerApi.unsubscribe();
          resolve([action, listenerApi.getState(), listenerApi.getOriginalState()]);
        }
      });
      unsubscribe = () => {
        stopListening();
        reject();
      };
    });
    const promises = [tuplePromise];
    if (timeout != null) {
      promises.push(new Promise((resolve) => setTimeout(resolve, timeout, null)));
    }
    try {
      const output = await raceWithSignal(signal, Promise.race(promises));
      validateActive(signal);
      return output;
    } finally {
      unsubscribe();
    }
  };
  return (predicate, timeout) => catchRejection(take(predicate, timeout));
};
var getListenerEntryPropsFrom = (options) => {
  let {
    type,
    actionCreator,
    matcher,
    predicate,
    effect
  } = options;
  if (type) {
    predicate = createAction(type).match;
  } else if (actionCreator) {
    type = actionCreator.type;
    predicate = actionCreator.match;
  } else if (matcher) {
    predicate = matcher;
  } else if (predicate) ;
  else {
    throw new Error(formatProdErrorMessage(21));
  }
  assertFunction(effect);
  return {
    predicate,
    type,
    effect
  };
};
var createListenerEntry = /* @__PURE__ */ assign((options) => {
  const {
    type,
    predicate,
    effect
  } = getListenerEntryPropsFrom(options);
  const entry = {
    id: nanoid(),
    effect,
    type,
    predicate,
    pending: /* @__PURE__ */ new Set(),
    unsubscribe: () => {
      throw new Error(formatProdErrorMessage(22));
    }
  };
  return entry;
}, {
  withTypes: () => createListenerEntry
});
var findListenerEntry = (listenerMap, options) => {
  const {
    type,
    effect,
    predicate
  } = getListenerEntryPropsFrom(options);
  return Array.from(listenerMap.values()).find((entry) => {
    const matchPredicateOrType = typeof type === "string" ? entry.type === type : entry.predicate === predicate;
    return matchPredicateOrType && entry.effect === effect;
  });
};
var cancelActiveListeners = (entry) => {
  entry.pending.forEach((controller) => {
    abortControllerWithReason(controller, listenerCancelled);
  });
};
var createClearListenerMiddleware = (listenerMap, executingListeners) => {
  return () => {
    for (const listener2 of executingListeners.keys()) {
      cancelActiveListeners(listener2);
    }
    listenerMap.clear();
  };
};
var safelyNotifyError = (errorHandler, errorToNotify, errorInfo) => {
  try {
    errorHandler(errorToNotify, errorInfo);
  } catch (errorHandlerError) {
    setTimeout(() => {
      throw errorHandlerError;
    }, 0);
  }
};
var addListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/add`), {
  withTypes: () => addListener
});
var clearAllListeners = /* @__PURE__ */ createAction(`${alm}/removeAll`);
var removeListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/remove`), {
  withTypes: () => removeListener
});
var defaultErrorHandler = (...args) => {
  console.error(`${alm}/error`, ...args);
};
var createListenerMiddleware = (middlewareOptions = {}) => {
  const listenerMap = /* @__PURE__ */ new Map();
  const executingListeners = /* @__PURE__ */ new Map();
  const trackExecutingListener = (entry) => {
    const count = executingListeners.get(entry) ?? 0;
    executingListeners.set(entry, count + 1);
  };
  const untrackExecutingListener = (entry) => {
    const count = executingListeners.get(entry) ?? 1;
    if (count === 1) {
      executingListeners.delete(entry);
    } else {
      executingListeners.set(entry, count - 1);
    }
  };
  const {
    extra,
    onError = defaultErrorHandler
  } = middlewareOptions;
  assertFunction(onError);
  const insertEntry = (entry) => {
    entry.unsubscribe = () => listenerMap.delete(entry.id);
    listenerMap.set(entry.id, entry);
    return (cancelOptions) => {
      entry.unsubscribe();
      if (cancelOptions?.cancelActive) {
        cancelActiveListeners(entry);
      }
    };
  };
  const startListening = (options) => {
    const entry = findListenerEntry(listenerMap, options) ?? createListenerEntry(options);
    return insertEntry(entry);
  };
  assign(startListening, {
    withTypes: () => startListening
  });
  const stopListening = (options) => {
    const entry = findListenerEntry(listenerMap, options);
    if (entry) {
      entry.unsubscribe();
      if (options.cancelActive) {
        cancelActiveListeners(entry);
      }
    }
    return !!entry;
  };
  assign(stopListening, {
    withTypes: () => stopListening
  });
  const notifyListener = async (entry, action, api, getOriginalState) => {
    const internalTaskController = new AbortController();
    const take = createTakePattern(startListening, internalTaskController.signal);
    const autoJoinPromises = [];
    try {
      entry.pending.add(internalTaskController);
      trackExecutingListener(entry);
      await Promise.resolve(entry.effect(
        action,
        // Use assign() rather than ... to avoid extra helper functions added to bundle
        assign({}, api, {
          getOriginalState,
          condition: (predicate, timeout) => take(predicate, timeout).then(Boolean),
          take,
          delay: createDelay(internalTaskController.signal),
          pause: createPause(internalTaskController.signal),
          extra,
          signal: internalTaskController.signal,
          fork: createFork(internalTaskController.signal, autoJoinPromises),
          unsubscribe: entry.unsubscribe,
          subscribe: () => {
            listenerMap.set(entry.id, entry);
          },
          cancelActiveListeners: () => {
            entry.pending.forEach((controller, _2, set2) => {
              if (controller !== internalTaskController) {
                abortControllerWithReason(controller, listenerCancelled);
                set2.delete(controller);
              }
            });
          },
          cancel: () => {
            abortControllerWithReason(internalTaskController, listenerCancelled);
            entry.pending.delete(internalTaskController);
          },
          throwIfCancelled: () => {
            validateActive(internalTaskController.signal);
          }
        })
      ));
    } catch (listenerError) {
      if (!(listenerError instanceof TaskAbortError)) {
        safelyNotifyError(onError, listenerError, {
          raisedBy: "effect"
        });
      }
    } finally {
      await Promise.all(autoJoinPromises);
      abortControllerWithReason(internalTaskController, listenerCompleted);
      untrackExecutingListener(entry);
      entry.pending.delete(internalTaskController);
    }
  };
  const clearListenerMiddleware = createClearListenerMiddleware(listenerMap, executingListeners);
  const middleware = (api) => (next) => (action) => {
    if (!isAction(action)) {
      return next(action);
    }
    if (addListener.match(action)) {
      return startListening(action.payload);
    }
    if (clearAllListeners.match(action)) {
      clearListenerMiddleware();
      return;
    }
    if (removeListener.match(action)) {
      return stopListening(action.payload);
    }
    let originalState = api.getState();
    const getOriginalState = () => {
      if (originalState === INTERNAL_NIL_TOKEN) {
        throw new Error(formatProdErrorMessage(23));
      }
      return originalState;
    };
    let result;
    try {
      result = next(action);
      if (listenerMap.size > 0) {
        const currentState = api.getState();
        const listenerEntries = Array.from(listenerMap.values());
        for (const entry of listenerEntries) {
          let runListener = false;
          try {
            runListener = entry.predicate(action, currentState, originalState);
          } catch (predicateError) {
            runListener = false;
            safelyNotifyError(onError, predicateError, {
              raisedBy: "predicate"
            });
          }
          if (!runListener) {
            continue;
          }
          notifyListener(entry, action, api, getOriginalState);
        }
      }
    } finally {
      originalState = INTERNAL_NIL_TOKEN;
    }
    return result;
  };
  return {
    middleware,
    startListening,
    stopListening,
    clearListeners: clearListenerMiddleware
  };
};
function formatProdErrorMessage(code) {
  return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}
var initialState$a = {
  layoutType: "horizontal",
  width: 0,
  height: 0,
  margin: {
    top: 5,
    right: 5,
    bottom: 5,
    left: 5
  },
  scale: 1
};
var chartLayoutSlice = createSlice({
  name: "chartLayout",
  initialState: initialState$a,
  reducers: {
    setLayout(state, action) {
      state.layoutType = action.payload;
    },
    setChartSize(state, action) {
      state.width = action.payload.width;
      state.height = action.payload.height;
    },
    setMargin(state, action) {
      var _action$payload$top, _action$payload$right, _action$payload$botto, _action$payload$left;
      state.margin.top = (_action$payload$top = action.payload.top) !== null && _action$payload$top !== void 0 ? _action$payload$top : 0;
      state.margin.right = (_action$payload$right = action.payload.right) !== null && _action$payload$right !== void 0 ? _action$payload$right : 0;
      state.margin.bottom = (_action$payload$botto = action.payload.bottom) !== null && _action$payload$botto !== void 0 ? _action$payload$botto : 0;
      state.margin.left = (_action$payload$left = action.payload.left) !== null && _action$payload$left !== void 0 ? _action$payload$left : 0;
    },
    setScale(state, action) {
      state.scale = action.payload;
    }
  }
});
var {
  setMargin,
  setLayout,
  setChartSize,
  setScale
} = chartLayoutSlice.actions;
var chartLayoutReducer = chartLayoutSlice.reducer;
function ownKeys$z(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$z(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$z(Object(t2), true).forEach(function(r3) {
      _defineProperty$B(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$z(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$B(e3, r2, t2) {
  return (r2 = _toPropertyKey$B(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$B(t2) {
  var i2 = _toPrimitive$B(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$B(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var RADIAN = Math.PI / 180;
var radianToDegree = (angleInRadian) => angleInRadian * 180 / Math.PI;
var polarToCartesian = (cx, cy, radius, angle) => ({
  x: cx + Math.cos(-RADIAN * angle) * radius,
  y: cy + Math.sin(-RADIAN * angle) * radius
});
var getMaxRadius = function getMaxRadius2(width, height) {
  var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  return Math.min(Math.abs(width - (offset.left || 0) - (offset.right || 0)), Math.abs(height - (offset.top || 0) - (offset.bottom || 0))) / 2;
};
var distanceBetweenPoints = (point2, anotherPoint) => {
  var {
    x: x1,
    y: y1
  } = point2;
  var {
    x: x2,
    y: y2
  } = anotherPoint;
  return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
};
var getAngleOfPoint = (_ref2, _ref22) => {
  var {
    x: x2,
    y: y2
  } = _ref2;
  var {
    cx,
    cy
  } = _ref22;
  var radius = distanceBetweenPoints({
    x: x2,
    y: y2
  }, {
    x: cx,
    y: cy
  });
  if (radius <= 0) {
    return {
      radius,
      angle: 0
    };
  }
  var cos2 = (x2 - cx) / radius;
  var angleInRadian = Math.acos(cos2);
  if (y2 > cy) {
    angleInRadian = 2 * Math.PI - angleInRadian;
  }
  return {
    radius,
    angle: radianToDegree(angleInRadian),
    angleInRadian
  };
};
var formatAngleOfSector = (_ref3) => {
  var {
    startAngle,
    endAngle
  } = _ref3;
  var startCnt = Math.floor(startAngle / 360);
  var endCnt = Math.floor(endAngle / 360);
  var min2 = Math.min(startCnt, endCnt);
  return {
    startAngle: startAngle - min2 * 360,
    endAngle: endAngle - min2 * 360
  };
};
var reverseFormatAngleOfSector = (angle, _ref4) => {
  var {
    startAngle,
    endAngle
  } = _ref4;
  var startCnt = Math.floor(startAngle / 360);
  var endCnt = Math.floor(endAngle / 360);
  var min2 = Math.min(startCnt, endCnt);
  return angle + min2 * 360;
};
var inRangeOfSector = (_ref5, viewBox) => {
  var {
    x: x2,
    y: y2
  } = _ref5;
  var {
    radius,
    angle
  } = getAngleOfPoint({
    x: x2,
    y: y2
  }, viewBox);
  var {
    innerRadius,
    outerRadius
  } = viewBox;
  if (radius < innerRadius || radius > outerRadius) {
    return null;
  }
  if (radius === 0) {
    return null;
  }
  var {
    startAngle,
    endAngle
  } = formatAngleOfSector(viewBox);
  var formatAngle = angle;
  var inRange2;
  if (startAngle <= endAngle) {
    while (formatAngle > endAngle) {
      formatAngle -= 360;
    }
    while (formatAngle < startAngle) {
      formatAngle += 360;
    }
    inRange2 = formatAngle >= startAngle && formatAngle <= endAngle;
  } else {
    while (formatAngle > startAngle) {
      formatAngle -= 360;
    }
    while (formatAngle < endAngle) {
      formatAngle += 360;
    }
    inRange2 = formatAngle >= endAngle && formatAngle <= startAngle;
  }
  if (inRange2) {
    return _objectSpread$z(_objectSpread$z({}, viewBox), {}, {
      radius,
      angle: reverseFormatAngleOfSector(formatAngle, viewBox)
    });
  }
  return null;
};
function getSliced(arr, startIndex, endIndex) {
  if (!Array.isArray(arr)) {
    return arr;
  }
  if (arr && startIndex + endIndex !== 0) {
    return arr.slice(startIndex, endIndex + 1);
  }
  return arr;
}
function ownKeys$y(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$y(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$y(Object(t2), true).forEach(function(r3) {
      _defineProperty$A(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$y(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$A(e3, r2, t2) {
  return (r2 = _toPropertyKey$A(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$A(t2) {
  var i2 = _toPrimitive$A(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$A(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function getValueByDataKey(obj, dataKey, defaultValue) {
  if (isNullish(obj) || isNullish(dataKey)) {
    return defaultValue;
  }
  if (isNumOrStr(dataKey)) {
    return get(obj, dataKey, defaultValue);
  }
  if (typeof dataKey === "function") {
    return dataKey(obj);
  }
  return defaultValue;
}
var calculateActiveTickIndex = (coordinate, ticks2, unsortedTicks, axisType, range2) => {
  var _ticks$length;
  var index = -1;
  var len = (_ticks$length = ticks2 === null || ticks2 === void 0 ? void 0 : ticks2.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;
  if (len <= 1 || coordinate == null) {
    return 0;
  }
  if (axisType === "angleAxis" && range2 != null && Math.abs(Math.abs(range2[1] - range2[0]) - 360) <= 1e-6) {
    for (var i2 = 0; i2 < len; i2++) {
      var before = i2 > 0 ? unsortedTicks[i2 - 1].coordinate : unsortedTicks[len - 1].coordinate;
      var cur = unsortedTicks[i2].coordinate;
      var after = i2 >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i2 + 1].coordinate;
      var sameDirectionCoord = void 0;
      if (mathSign(cur - before) !== mathSign(after - cur)) {
        var diffInterval = [];
        if (mathSign(after - cur) === mathSign(range2[1] - range2[0])) {
          sameDirectionCoord = after;
          var curInRange = cur + range2[1] - range2[0];
          diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);
          diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);
        } else {
          sameDirectionCoord = before;
          var afterInRange = after + range2[1] - range2[0];
          diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);
          diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);
        }
        var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];
        if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {
          ({
            index
          } = unsortedTicks[i2]);
          break;
        }
      } else {
        var minValue = Math.min(before, after);
        var maxValue = Math.max(before, after);
        if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {
          ({
            index
          } = unsortedTicks[i2]);
          break;
        }
      }
    }
  } else if (ticks2) {
    for (var _i = 0; _i < len; _i++) {
      if (_i === 0 && coordinate <= (ticks2[_i].coordinate + ticks2[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks2[_i].coordinate + ticks2[_i - 1].coordinate) / 2 && coordinate <= (ticks2[_i].coordinate + ticks2[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks2[_i].coordinate + ticks2[_i - 1].coordinate) / 2) {
        ({
          index
        } = ticks2[_i]);
        break;
      }
    }
  }
  return index;
};
var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {
  if (legendSettings && legendSize) {
    var {
      width: boxWidth,
      height: boxHeight
    } = legendSize;
    var {
      align,
      verticalAlign,
      layout
    } = legendSettings;
    if ((layout === "vertical" || layout === "horizontal" && verticalAlign === "middle") && align !== "center" && isNumber(offset[align])) {
      return _objectSpread$y(_objectSpread$y({}, offset), {}, {
        [align]: offset[align] + (boxWidth || 0)
      });
    }
    if ((layout === "horizontal" || layout === "vertical" && align === "center") && verticalAlign !== "middle" && isNumber(offset[verticalAlign])) {
      return _objectSpread$y(_objectSpread$y({}, offset), {}, {
        [verticalAlign]: offset[verticalAlign] + (boxHeight || 0)
      });
    }
  }
  return offset;
};
var isCategoricalAxis = (layout, axisType) => layout === "horizontal" && axisType === "xAxis" || layout === "vertical" && axisType === "yAxis" || layout === "centric" && axisType === "angleAxis" || layout === "radial" && axisType === "radiusAxis";
var getCoordinatesOfGrid = (ticks2, minValue, maxValue, syncWithTicks) => {
  if (syncWithTicks) {
    return ticks2.map((entry) => entry.coordinate);
  }
  var hasMin, hasMax;
  var values = ticks2.map((entry) => {
    if (entry.coordinate === minValue) {
      hasMin = true;
    }
    if (entry.coordinate === maxValue) {
      hasMax = true;
    }
    return entry.coordinate;
  });
  if (!hasMin) {
    values.push(minValue);
  }
  if (!hasMax) {
    values.push(maxValue);
  }
  return values;
};
var getTicksOfAxis = (axis, isGrid, isAll) => {
  if (!axis) {
    return null;
  }
  var {
    duplicateDomain,
    type,
    range: range2,
    scale,
    realScaleType,
    isCategorical,
    categoricalDomain,
    tickCount,
    ticks: ticks2,
    niceTicks,
    axisType
  } = axis;
  if (!scale) {
    return null;
  }
  var offsetForBand = realScaleType === "scaleBand" && scale.bandwidth ? scale.bandwidth() / 2 : 2;
  var offset = type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
  offset = axisType === "angleAxis" && range2 && range2.length >= 2 ? mathSign(range2[0] - range2[1]) * 2 * offset : offset;
  if (ticks2 || niceTicks) {
    var result = (ticks2 || niceTicks || []).map((entry, index) => {
      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
      return {
        // If the scaleContent is not a number, the coordinate will be NaN.
        // That could be the case for example with a PointScale and a string as domain.
        coordinate: scale(scaleContent) + offset,
        value: entry,
        offset,
        index
      };
    });
    return result.filter((row) => !isNan(row.coordinate));
  }
  if (isCategorical && categoricalDomain) {
    return categoricalDomain.map((entry, index) => ({
      coordinate: scale(entry) + offset,
      value: entry,
      index,
      offset
    }));
  }
  if (scale.ticks && true && tickCount != null) {
    return scale.ticks(tickCount).map((entry, index) => ({
      coordinate: scale(entry) + offset,
      value: entry,
      offset,
      index
    }));
  }
  return scale.domain().map((entry, index) => ({
    coordinate: scale(entry) + offset,
    value: duplicateDomain ? duplicateDomain[entry] : entry,
    index,
    offset
  }));
};
var EPS = 1e-4;
var checkDomainOfScale = (scale) => {
  var domain2 = scale.domain();
  if (!domain2 || domain2.length <= 2) {
    return;
  }
  var len = domain2.length;
  var range2 = scale.range();
  var minValue = Math.min(range2[0], range2[1]) - EPS;
  var maxValue = Math.max(range2[0], range2[1]) + EPS;
  var first = scale(domain2[0]);
  var last2 = scale(domain2[len - 1]);
  if (first < minValue || first > maxValue || last2 < minValue || last2 > maxValue) {
    scale.domain([domain2[0], domain2[len - 1]]);
  }
};
var truncateByDomain = (value, domain2) => {
  if (!domain2 || domain2.length !== 2 || !isNumber(domain2[0]) || !isNumber(domain2[1])) {
    return value;
  }
  var minValue = Math.min(domain2[0], domain2[1]);
  var maxValue = Math.max(domain2[0], domain2[1]);
  var result = [value[0], value[1]];
  if (!isNumber(value[0]) || value[0] < minValue) {
    result[0] = minValue;
  }
  if (!isNumber(value[1]) || value[1] > maxValue) {
    result[1] = maxValue;
  }
  if (result[0] > maxValue) {
    result[0] = maxValue;
  }
  if (result[1] < minValue) {
    result[1] = minValue;
  }
  return result;
};
var offsetSign = (series) => {
  var n2 = series.length;
  if (n2 <= 0) {
    return;
  }
  for (var j2 = 0, m2 = series[0].length; j2 < m2; ++j2) {
    var positive = 0;
    var negative = 0;
    for (var i2 = 0; i2 < n2; ++i2) {
      var value = isNan(series[i2][j2][1]) ? series[i2][j2][0] : series[i2][j2][1];
      if (value >= 0) {
        series[i2][j2][0] = positive;
        series[i2][j2][1] = positive + value;
        positive = series[i2][j2][1];
      } else {
        series[i2][j2][0] = negative;
        series[i2][j2][1] = negative + value;
        negative = series[i2][j2][1];
      }
    }
  }
};
var offsetPositive = (series) => {
  var n2 = series.length;
  if (n2 <= 0) {
    return;
  }
  for (var j2 = 0, m2 = series[0].length; j2 < m2; ++j2) {
    var positive = 0;
    for (var i2 = 0; i2 < n2; ++i2) {
      var value = isNan(series[i2][j2][1]) ? series[i2][j2][0] : series[i2][j2][1];
      if (value >= 0) {
        series[i2][j2][0] = positive;
        series[i2][j2][1] = positive + value;
        positive = series[i2][j2][1];
      } else {
        series[i2][j2][0] = 0;
        series[i2][j2][1] = 0;
      }
    }
  }
};
var STACK_OFFSET_MAP = {
  sign: offsetSign,
  // @ts-expect-error definitelytyped types are incorrect
  expand: stackOffsetExpand,
  // @ts-expect-error definitelytyped types are incorrect
  none: stackOffsetNone,
  // @ts-expect-error definitelytyped types are incorrect
  silhouette: stackOffsetSilhouette,
  // @ts-expect-error definitelytyped types are incorrect
  wiggle: stackOffsetWiggle,
  positive: offsetPositive
};
var getStackedData = (data, dataKeys, offsetType) => {
  var offsetAccessor = STACK_OFFSET_MAP[offsetType];
  var stack = shapeStack().keys(dataKeys).value((d2, key) => +getValueByDataKey(d2, key, 0)).order(stackOrderNone).offset(offsetAccessor);
  return stack(data);
};
function getNormalizedStackId(publicStackId) {
  return publicStackId == null ? void 0 : String(publicStackId);
}
function getCateCoordinateOfLine(_ref2) {
  var {
    axis,
    ticks: ticks2,
    bandSize,
    entry,
    index,
    dataKey
  } = _ref2;
  if (axis.type === "category") {
    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {
      var matchedTick = findEntryInArray(ticks2, "value", entry[axis.dataKey]);
      if (matchedTick) {
        return matchedTick.coordinate + bandSize / 2;
      }
    }
    return ticks2[index] ? ticks2[index].coordinate + bandSize / 2 : null;
  }
  var value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey);
  return !isNullish(value) ? axis.scale(value) : null;
}
var getCateCoordinateOfBar = (_ref2) => {
  var {
    axis,
    ticks: ticks2,
    offset,
    bandSize,
    entry,
    index
  } = _ref2;
  if (axis.type === "category") {
    return ticks2[index] ? ticks2[index].coordinate + offset : null;
  }
  var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index]);
  return !isNullish(value) ? axis.scale(value) - bandSize / 2 + offset : null;
};
var getBaseValueOfBar = (_ref3) => {
  var {
    numericAxis
  } = _ref3;
  var domain2 = numericAxis.scale.domain();
  if (numericAxis.type === "number") {
    var minValue = Math.min(domain2[0], domain2[1]);
    var maxValue = Math.max(domain2[0], domain2[1]);
    if (minValue <= 0 && maxValue >= 0) {
      return 0;
    }
    if (maxValue < 0) {
      return maxValue;
    }
    return minValue;
  }
  return domain2[0];
};
var getDomainOfSingle = (data) => {
  var flat = data.flat(2).filter(isNumber);
  return [Math.min(...flat), Math.max(...flat)];
};
var makeDomainFinite = (domain2) => {
  return [domain2[0] === Infinity ? 0 : domain2[0], domain2[1] === -Infinity ? 0 : domain2[1]];
};
var getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {
  if (stackGroups == null) {
    return void 0;
  }
  return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {
    var group = stackGroups[stackId];
    var {
      stackedData
    } = group;
    var domain2 = stackedData.reduce((res, entry) => {
      var sliced = getSliced(entry, startIndex, endIndex);
      var s2 = getDomainOfSingle(sliced);
      return [Math.min(res[0], s2[0]), Math.max(res[1], s2[1])];
    }, [Infinity, -Infinity]);
    return [Math.min(domain2[0], result[0]), Math.max(domain2[1], result[1])];
  }, [Infinity, -Infinity]));
};
var MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
var MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
var getBandSizeOfAxis = (axis, ticks2, isBar) => {
  if (axis && axis.scale && axis.scale.bandwidth) {
    var bandWidth = axis.scale.bandwidth();
    if (!isBar || bandWidth > 0) {
      return bandWidth;
    }
  }
  if (axis && ticks2 && ticks2.length >= 2) {
    var orderedTicks = sortBy(ticks2, (o2) => o2.coordinate);
    var bandSize = Infinity;
    for (var i2 = 1, len = orderedTicks.length; i2 < len; i2++) {
      var cur = orderedTicks[i2];
      var prev = orderedTicks[i2 - 1];
      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);
    }
    return bandSize === Infinity ? 0 : bandSize;
  }
  return isBar ? void 0 : 0;
};
function getTooltipEntry(_ref4) {
  var {
    tooltipEntrySettings,
    dataKey,
    payload,
    value,
    name
  } = _ref4;
  return _objectSpread$y(_objectSpread$y({}, tooltipEntrySettings), {}, {
    dataKey,
    payload,
    value,
    name
  });
}
function getTooltipNameProp(nameFromItem, dataKey) {
  if (nameFromItem) {
    return String(nameFromItem);
  }
  if (typeof dataKey === "string") {
    return dataKey;
  }
  return void 0;
}
function inRange(x2, y2, layout, polarViewBox, offset) {
  if (layout === "horizontal" || layout === "vertical") {
    var isInRange = x2 >= offset.left && x2 <= offset.left + offset.width && y2 >= offset.top && y2 <= offset.top + offset.height;
    return isInRange ? {
      x: x2,
      y: y2
    } : null;
  }
  if (polarViewBox) {
    return inRangeOfSector({
      x: x2,
      y: y2
    }, polarViewBox);
  }
  return null;
}
var getActiveCoordinate = (layout, tooltipTicks, activeIndex, rangeObj) => {
  var entry = tooltipTicks.find((tick) => tick && tick.index === activeIndex);
  if (entry) {
    if (layout === "horizontal") {
      return {
        x: entry.coordinate,
        y: rangeObj.y
      };
    }
    if (layout === "vertical") {
      return {
        x: rangeObj.x,
        y: entry.coordinate
      };
    }
    if (layout === "centric") {
      var _angle = entry.coordinate;
      var {
        radius: _radius
      } = rangeObj;
      return _objectSpread$y(_objectSpread$y(_objectSpread$y({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {
        angle: _angle,
        radius: _radius
      });
    }
    var radius = entry.coordinate;
    var {
      angle
    } = rangeObj;
    return _objectSpread$y(_objectSpread$y(_objectSpread$y({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {
      angle,
      radius
    });
  }
  return {
    x: 0,
    y: 0
  };
};
var calculateTooltipPos = (rangeObj, layout) => {
  if (layout === "horizontal") {
    return rangeObj.x;
  }
  if (layout === "vertical") {
    return rangeObj.y;
  }
  if (layout === "centric") {
    return rangeObj.angle;
  }
  return rangeObj.radius;
};
var selectChartWidth = (state) => state.layout.width;
var selectChartHeight = (state) => state.layout.height;
var selectContainerScale = (state) => state.layout.scale;
var selectMargin = (state) => state.layout.margin;
var selectAllXAxes = createSelector((state) => state.cartesianAxis.xAxis, (xAxisMap) => {
  return Object.values(xAxisMap);
});
var selectAllYAxes = createSelector((state) => state.cartesianAxis.yAxis, (yAxisMap) => {
  return Object.values(yAxisMap);
});
var DATA_ITEM_INDEX_ATTRIBUTE_NAME = "data-recharts-item-index";
var DATA_ITEM_DATAKEY_ATTRIBUTE_NAME = "data-recharts-item-data-key";
var DEFAULT_Y_AXIS_WIDTH = 60;
function ownKeys$x(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$x(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$x(Object(t2), true).forEach(function(r3) {
      _defineProperty$z(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$x(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$z(e3, r2, t2) {
  return (r2 = _toPropertyKey$z(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$z(t2) {
  var i2 = _toPrimitive$z(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$z(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var selectBrushHeight = (state) => state.brush.height;
function selectLeftAxesOffset(state) {
  var yAxes = selectAllYAxes(state);
  return yAxes.reduce((result, entry) => {
    if (entry.orientation === "left" && !entry.mirror && !entry.hide) {
      var width = typeof entry.width === "number" ? entry.width : DEFAULT_Y_AXIS_WIDTH;
      return result + width;
    }
    return result;
  }, 0);
}
function selectRightAxesOffset(state) {
  var yAxes = selectAllYAxes(state);
  return yAxes.reduce((result, entry) => {
    if (entry.orientation === "right" && !entry.mirror && !entry.hide) {
      var width = typeof entry.width === "number" ? entry.width : DEFAULT_Y_AXIS_WIDTH;
      return result + width;
    }
    return result;
  }, 0);
}
function selectTopAxesOffset(state) {
  var xAxes = selectAllXAxes(state);
  return xAxes.reduce((result, entry) => {
    if (entry.orientation === "top" && !entry.mirror && !entry.hide) {
      return result + entry.height;
    }
    return result;
  }, 0);
}
function selectBottomAxesOffset(state) {
  var xAxes = selectAllXAxes(state);
  return xAxes.reduce((result, entry) => {
    if (entry.orientation === "bottom" && !entry.mirror && !entry.hide) {
      return result + entry.height;
    }
    return result;
  }, 0);
}
var selectChartOffsetInternal = createSelector([selectChartWidth, selectChartHeight, selectMargin, selectBrushHeight, selectLeftAxesOffset, selectRightAxesOffset, selectTopAxesOffset, selectBottomAxesOffset, selectLegendSettings, selectLegendSize], (chartWidth, chartHeight, margin, brushHeight, leftAxesOffset, rightAxesOffset, topAxesOffset, bottomAxesOffset, legendSettings, legendSize) => {
  var offsetH = {
    left: (margin.left || 0) + leftAxesOffset,
    right: (margin.right || 0) + rightAxesOffset
  };
  var offsetV = {
    top: (margin.top || 0) + topAxesOffset,
    bottom: (margin.bottom || 0) + bottomAxesOffset
  };
  var offset = _objectSpread$x(_objectSpread$x({}, offsetV), offsetH);
  var brushBottom = offset.bottom;
  offset.bottom += brushHeight;
  offset = appendOffsetOfLegend(offset, legendSettings, legendSize);
  var offsetWidth = chartWidth - offset.left - offset.right;
  var offsetHeight = chartHeight - offset.top - offset.bottom;
  return _objectSpread$x(_objectSpread$x({
    brushBottom
  }, offset), {}, {
    // never return negative values for height and width
    width: Math.max(offsetWidth, 0),
    height: Math.max(offsetHeight, 0)
  });
});
var selectChartViewBox = createSelector(selectChartOffsetInternal, (offset) => ({
  x: offset.left,
  y: offset.top,
  width: offset.width,
  height: offset.height
}));
var selectAxisViewBox = createSelector(selectChartWidth, selectChartHeight, (width, height) => ({
  x: 0,
  y: 0,
  width,
  height
}));
var PanoramaContext = /* @__PURE__ */ reactExports.createContext(null);
var useIsPanorama = () => reactExports.useContext(PanoramaContext) != null;
var selectBrushSettings = (state) => state.brush;
var selectBrushDimensions = createSelector([selectBrushSettings, selectChartOffsetInternal, selectMargin], (brushSettings, offset, margin) => ({
  height: brushSettings.height,
  x: isNumber(brushSettings.x) ? brushSettings.x : offset.left,
  y: isNumber(brushSettings.y) ? brushSettings.y : offset.top + offset.height + offset.brushBottom - ((margin === null || margin === void 0 ? void 0 : margin.bottom) || 0),
  width: isNumber(brushSettings.width) ? brushSettings.width : offset.width
}));
var throttle$2 = {};
var debounce$1 = {};
var debounce = {};
var hasRequiredDebounce$1;
function requireDebounce$1() {
  if (hasRequiredDebounce$1) return debounce;
  hasRequiredDebounce$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function debounce2(func, debounceMs, { signal, edges } = {}) {
      let pendingThis = void 0;
      let pendingArgs = null;
      const leading = edges != null && edges.includes("leading");
      const trailing = edges == null || edges.includes("trailing");
      const invoke = () => {
        if (pendingArgs !== null) {
          func.apply(pendingThis, pendingArgs);
          pendingThis = void 0;
          pendingArgs = null;
        }
      };
      const onTimerEnd = () => {
        if (trailing) {
          invoke();
        }
        cancel();
      };
      let timeoutId = null;
      const schedule = () => {
        if (timeoutId != null) {
          clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
          timeoutId = null;
          onTimerEnd();
        }, debounceMs);
      };
      const cancelTimer = () => {
        if (timeoutId !== null) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      };
      const cancel = () => {
        cancelTimer();
        pendingThis = void 0;
        pendingArgs = null;
      };
      const flush = () => {
        invoke();
      };
      const debounced = function(...args) {
        if (signal?.aborted) {
          return;
        }
        pendingThis = this;
        pendingArgs = args;
        const isFirstCall = timeoutId == null;
        schedule();
        if (leading && isFirstCall) {
          invoke();
        }
      };
      debounced.schedule = schedule;
      debounced.cancel = cancel;
      debounced.flush = flush;
      signal?.addEventListener("abort", cancel, { once: true });
      return debounced;
    }
    exports.debounce = debounce2;
  })(debounce);
  return debounce;
}
var hasRequiredDebounce;
function requireDebounce() {
  if (hasRequiredDebounce) return debounce$1;
  hasRequiredDebounce = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const debounce$12 = /* @__PURE__ */ requireDebounce$1();
    function debounce2(func, debounceMs = 0, options = {}) {
      if (typeof options !== "object") {
        options = {};
      }
      const { leading = false, trailing = true, maxWait } = options;
      const edges = Array(2);
      if (leading) {
        edges[0] = "leading";
      }
      if (trailing) {
        edges[1] = "trailing";
      }
      let result = void 0;
      let pendingAt = null;
      const _debounced = debounce$12.debounce(function(...args) {
        result = func.apply(this, args);
        pendingAt = null;
      }, debounceMs, { edges });
      const debounced = function(...args) {
        if (maxWait != null) {
          if (pendingAt === null) {
            pendingAt = Date.now();
          }
          if (Date.now() - pendingAt >= maxWait) {
            result = func.apply(this, args);
            pendingAt = Date.now();
            _debounced.cancel();
            _debounced.schedule();
            return result;
          }
        }
        _debounced.apply(this, args);
        return result;
      };
      const flush = () => {
        _debounced.flush();
        return result;
      };
      debounced.cancel = _debounced.cancel;
      debounced.flush = flush;
      return debounced;
    }
    exports.debounce = debounce2;
  })(debounce$1);
  return debounce$1;
}
var hasRequiredThrottle$1;
function requireThrottle$1() {
  if (hasRequiredThrottle$1) return throttle$2;
  hasRequiredThrottle$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const debounce2 = /* @__PURE__ */ requireDebounce();
    function throttle2(func, throttleMs = 0, options = {}) {
      const { leading = true, trailing = true } = options;
      return debounce2.debounce(func, throttleMs, {
        leading,
        maxWait: throttleMs,
        trailing
      });
    }
    exports.throttle = throttle2;
  })(throttle$2);
  return throttle$2;
}
var throttle$1;
var hasRequiredThrottle;
function requireThrottle() {
  if (hasRequiredThrottle) return throttle$1;
  hasRequiredThrottle = 1;
  throttle$1 = requireThrottle$1().throttle;
  return throttle$1;
}
var throttleExports = /* @__PURE__ */ requireThrottle();
const throttle = /* @__PURE__ */ getDefaultExportFromCjs(throttleExports);
var warn = function warn2(condition, format2) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
};
var calculateChartDimensions = (containerWidth, containerHeight, props) => {
  var {
    width = "100%",
    height = "100%",
    aspect,
    maxHeight
  } = props;
  var calculatedWidth = isPercent(width) ? containerWidth : Number(width);
  var calculatedHeight = isPercent(height) ? containerHeight : Number(height);
  if (aspect && aspect > 0) {
    if (calculatedWidth) {
      calculatedHeight = calculatedWidth / aspect;
    } else if (calculatedHeight) {
      calculatedWidth = calculatedHeight * aspect;
    }
    if (maxHeight && calculatedHeight > maxHeight) {
      calculatedHeight = maxHeight;
    }
  }
  return {
    calculatedWidth,
    calculatedHeight
  };
};
var bothOverflow = {
  width: 0,
  height: 0,
  overflow: "visible"
};
var overflowX = {
  width: 0,
  overflowX: "visible"
};
var overflowY = {
  height: 0,
  overflowY: "visible"
};
var noStyle = {};
var getInnerDivStyle = (props) => {
  var {
    width,
    height
  } = props;
  var isWidthPercent = isPercent(width);
  var isHeightPercent = isPercent(height);
  if (isWidthPercent && isHeightPercent) {
    return bothOverflow;
  }
  if (isWidthPercent) {
    return overflowX;
  }
  if (isHeightPercent) {
    return overflowY;
  }
  return noStyle;
};
function getDefaultWidthAndHeight(_ref2) {
  var {
    width,
    height,
    aspect
  } = _ref2;
  var calculatedWidth = width;
  var calculatedHeight = height;
  if (calculatedWidth === void 0 && calculatedHeight === void 0) {
    calculatedWidth = "100%";
    calculatedHeight = "100%";
  } else if (calculatedWidth === void 0) {
    calculatedWidth = aspect && aspect > 0 ? void 0 : "100%";
  } else if (calculatedHeight === void 0) {
    calculatedHeight = aspect && aspect > 0 ? void 0 : "100%";
  }
  return {
    width: calculatedWidth,
    height: calculatedHeight
  };
}
function isWellBehavedNumber(n2) {
  return Number.isFinite(n2);
}
function isPositiveNumber(n2) {
  return typeof n2 === "number" && n2 > 0 && Number.isFinite(n2);
}
function _extends$o() {
  return _extends$o = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$o.apply(null, arguments);
}
function ownKeys$w(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$w(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$w(Object(t2), true).forEach(function(r3) {
      _defineProperty$y(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$w(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$y(e3, r2, t2) {
  return (r2 = _toPropertyKey$y(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$y(t2) {
  var i2 = _toPrimitive$y(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$y(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var ResponsiveContainerContext = /* @__PURE__ */ reactExports.createContext({
  width: -1,
  height: -1
});
function ResponsiveContainerContextProvider(_ref2) {
  var {
    children,
    width,
    height
  } = _ref2;
  var size = reactExports.useMemo(() => ({
    width,
    height
  }), [width, height]);
  if (width <= 0 || height <= 0) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(ResponsiveContainerContext.Provider, {
    value: size
  }, children);
}
var useResponsiveContainerContext = () => reactExports.useContext(ResponsiveContainerContext);
var SizeDetectorContainer = /* @__PURE__ */ reactExports.forwardRef((_ref2, ref) => {
  var {
    aspect,
    initialDimension = {
      width: -1,
      height: -1
    },
    width,
    height,
    /*
     * default min-width to 0 if not specified - 'auto' causes issues with flexbox
     * https://github.com/recharts/recharts/issues/172
     */
    minWidth = 0,
    minHeight,
    maxHeight,
    children,
    debounce: debounce2 = 0,
    id,
    className,
    onResize,
    style = {}
  } = _ref2;
  var containerRef = reactExports.useRef(null);
  var onResizeRef = reactExports.useRef();
  onResizeRef.current = onResize;
  reactExports.useImperativeHandle(ref, () => containerRef.current);
  var [sizes, setSizes] = reactExports.useState({
    containerWidth: initialDimension.width,
    containerHeight: initialDimension.height
  });
  var setContainerSize = reactExports.useCallback((newWidth, newHeight) => {
    setSizes((prevState) => {
      var roundedWidth = Math.round(newWidth);
      var roundedHeight = Math.round(newHeight);
      if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) {
        return prevState;
      }
      return {
        containerWidth: roundedWidth,
        containerHeight: roundedHeight
      };
    });
  }, []);
  reactExports.useEffect(() => {
    var callback = (entries) => {
      var _onResizeRef$current;
      var {
        width: containerWidth3,
        height: containerHeight3
      } = entries[0].contentRect;
      setContainerSize(containerWidth3, containerHeight3);
      (_onResizeRef$current = onResizeRef.current) === null || _onResizeRef$current === void 0 || _onResizeRef$current.call(onResizeRef, containerWidth3, containerHeight3);
    };
    if (debounce2 > 0) {
      callback = throttle(callback, debounce2, {
        trailing: true,
        leading: false
      });
    }
    var observer = new ResizeObserver(callback);
    var {
      width: containerWidth2,
      height: containerHeight2
    } = containerRef.current.getBoundingClientRect();
    setContainerSize(containerWidth2, containerHeight2);
    observer.observe(containerRef.current);
    return () => {
      observer.disconnect();
    };
  }, [setContainerSize, debounce2]);
  var {
    containerWidth,
    containerHeight
  } = sizes;
  warn(!aspect || aspect > 0, "The aspect(%s) must be greater than zero.", aspect);
  var {
    calculatedWidth,
    calculatedHeight
  } = calculateChartDimensions(containerWidth, containerHeight, {
    width,
    height,
    aspect,
    maxHeight
  });
  warn(calculatedWidth > 0 || calculatedHeight > 0, "The width(%s) and height(%s) of chart should be greater than 0,\n       please check the style of container, or the props width(%s) and height(%s),\n       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the\n       height and width.", calculatedWidth, calculatedHeight, width, height, minWidth, minHeight, aspect);
  return /* @__PURE__ */ reactExports.createElement("div", {
    id: id ? "".concat(id) : void 0,
    className: clsx("recharts-responsive-container", className),
    style: _objectSpread$w(_objectSpread$w({}, style), {}, {
      width,
      height,
      minWidth,
      minHeight,
      maxHeight
    }),
    ref: containerRef
  }, /* @__PURE__ */ reactExports.createElement("div", {
    style: getInnerDivStyle({
      width,
      height
    })
  }, /* @__PURE__ */ reactExports.createElement(ResponsiveContainerContextProvider, {
    width: calculatedWidth,
    height: calculatedHeight
  }, children)));
});
var ResponsiveContainer = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  var responsiveContainerContext = useResponsiveContainerContext();
  if (isPositiveNumber(responsiveContainerContext.width) && isPositiveNumber(responsiveContainerContext.height)) {
    return props.children;
  }
  var {
    width,
    height
  } = getDefaultWidthAndHeight({
    width: props.width,
    height: props.height,
    aspect: props.aspect
  });
  var {
    calculatedWidth,
    calculatedHeight
  } = calculateChartDimensions(void 0, void 0, {
    width,
    height,
    aspect: props.aspect,
    maxHeight: props.maxHeight
  });
  if (isNumber(calculatedWidth) && isNumber(calculatedHeight)) {
    return /* @__PURE__ */ reactExports.createElement(ResponsiveContainerContextProvider, {
      width: calculatedWidth,
      height: calculatedHeight
    }, props.children);
  }
  return /* @__PURE__ */ reactExports.createElement(SizeDetectorContainer, _extends$o({}, props, {
    width,
    height,
    ref
  }));
});
var useViewBox = () => {
  var _useAppSelector;
  var panorama = useIsPanorama();
  var rootViewBox = useAppSelector(selectChartViewBox);
  var brushDimensions = useAppSelector(selectBrushDimensions);
  var brushPadding = (_useAppSelector = useAppSelector(selectBrushSettings)) === null || _useAppSelector === void 0 ? void 0 : _useAppSelector.padding;
  if (!panorama || !brushDimensions || !brushPadding) {
    return rootViewBox;
  }
  return {
    width: brushDimensions.width - brushPadding.left - brushPadding.right,
    height: brushDimensions.height - brushPadding.top - brushPadding.bottom,
    x: brushPadding.left,
    y: brushPadding.top
  };
};
var manyComponentsThrowErrorsIfOffsetIsUndefined = {
  top: 0,
  bottom: 0,
  left: 0,
  right: 0,
  width: 0,
  height: 0,
  brushBottom: 0
};
var useOffsetInternal = () => {
  var _useAppSelector2;
  return (_useAppSelector2 = useAppSelector(selectChartOffsetInternal)) !== null && _useAppSelector2 !== void 0 ? _useAppSelector2 : manyComponentsThrowErrorsIfOffsetIsUndefined;
};
var useChartWidth = () => {
  return useAppSelector(selectChartWidth);
};
var useChartHeight = () => {
  return useAppSelector(selectChartHeight);
};
var useMargin = () => {
  return useAppSelector((state) => state.layout.margin);
};
var selectChartLayout = (state) => state.layout.layoutType;
var useChartLayout = () => useAppSelector(selectChartLayout);
var ReportChartSize = (props) => {
  var dispatch = useAppDispatch();
  var isPanorama = useIsPanorama();
  var {
    width: widthFromProps,
    height: heightFromProps
  } = props;
  var responsiveContainerCalculations = useResponsiveContainerContext();
  var width = widthFromProps;
  var height = heightFromProps;
  if (responsiveContainerCalculations) {
    width = responsiveContainerCalculations.width > 0 ? responsiveContainerCalculations.width : widthFromProps;
    height = responsiveContainerCalculations.height > 0 ? responsiveContainerCalculations.height : heightFromProps;
  }
  reactExports.useEffect(() => {
    if (!isPanorama && isPositiveNumber(width) && isPositiveNumber(height)) {
      dispatch(setChartSize({
        width,
        height
      }));
    }
  }, [dispatch, isPanorama, width, height]);
  return null;
};
var initialState$9 = {
  settings: {
    layout: "horizontal",
    align: "center",
    verticalAlign: "middle",
    itemSorter: "value"
  },
  size: {
    width: 0,
    height: 0
  },
  payload: []
};
var legendSlice = createSlice({
  name: "legend",
  initialState: initialState$9,
  reducers: {
    setLegendSize(state, action) {
      state.size.width = action.payload.width;
      state.size.height = action.payload.height;
    },
    setLegendSettings(state, action) {
      state.settings.align = action.payload.align;
      state.settings.layout = action.payload.layout;
      state.settings.verticalAlign = action.payload.verticalAlign;
      state.settings.itemSorter = action.payload.itemSorter;
    },
    addLegendPayload: {
      reducer(state, action) {
        state.payload.push(castDraft(action.payload));
      },
      prepare: prepareAutoBatched()
    },
    removeLegendPayload: {
      reducer(state, action) {
        var index = current(state).payload.indexOf(castDraft(action.payload));
        if (index > -1) {
          state.payload.splice(index, 1);
        }
      },
      prepare: prepareAutoBatched()
    }
  }
});
var {
  setLegendSize,
  setLegendSettings,
  addLegendPayload,
  removeLegendPayload
} = legendSlice.actions;
var legendReducer = legendSlice.reducer;
var _excluded$j = ["contextPayload"];
function _extends$n() {
  return _extends$n = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$n.apply(null, arguments);
}
function ownKeys$v(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$v(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$v(Object(t2), true).forEach(function(r3) {
      _defineProperty$x(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$v(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$x(e3, r2, t2) {
  return (r2 = _toPropertyKey$x(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$x(t2) {
  var i2 = _toPrimitive$x(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$x(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$j(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$j(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$j(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function defaultUniqBy$1(entry) {
  return entry.value;
}
function LegendContent(props) {
  var {
    contextPayload
  } = props, otherProps = _objectWithoutProperties$j(props, _excluded$j);
  var finalPayload = getUniqPayload(contextPayload, props.payloadUniqBy, defaultUniqBy$1);
  var contentProps = _objectSpread$v(_objectSpread$v({}, otherProps), {}, {
    payload: finalPayload
  });
  if (/* @__PURE__ */ reactExports.isValidElement(props.content)) {
    return /* @__PURE__ */ reactExports.cloneElement(props.content, contentProps);
  }
  if (typeof props.content === "function") {
    return /* @__PURE__ */ reactExports.createElement(props.content, contentProps);
  }
  return /* @__PURE__ */ reactExports.createElement(DefaultLegendContent, contentProps);
}
function getDefaultPosition(style, props, margin, chartWidth, chartHeight, box) {
  var {
    layout,
    align,
    verticalAlign
  } = props;
  var hPos, vPos;
  if (!style || (style.left === void 0 || style.left === null) && (style.right === void 0 || style.right === null)) {
    if (align === "center" && layout === "vertical") {
      hPos = {
        left: ((chartWidth || 0) - box.width) / 2
      };
    } else {
      hPos = align === "right" ? {
        right: margin && margin.right || 0
      } : {
        left: margin && margin.left || 0
      };
    }
  }
  if (!style || (style.top === void 0 || style.top === null) && (style.bottom === void 0 || style.bottom === null)) {
    if (verticalAlign === "middle") {
      vPos = {
        top: ((chartHeight || 0) - box.height) / 2
      };
    } else {
      vPos = verticalAlign === "bottom" ? {
        bottom: margin && margin.bottom || 0
      } : {
        top: margin && margin.top || 0
      };
    }
  }
  return _objectSpread$v(_objectSpread$v({}, hPos), vPos);
}
function LegendSettingsDispatcher(props) {
  var dispatch = useAppDispatch();
  reactExports.useEffect(() => {
    dispatch(setLegendSettings(props));
  }, [dispatch, props]);
  return null;
}
function LegendSizeDispatcher(props) {
  var dispatch = useAppDispatch();
  reactExports.useEffect(() => {
    dispatch(setLegendSize(props));
    return () => {
      dispatch(setLegendSize({
        width: 0,
        height: 0
      }));
    };
  }, [dispatch, props]);
  return null;
}
function LegendWrapper(props) {
  var contextPayload = useLegendPayload();
  var legendPortalFromContext = useLegendPortal();
  var margin = useMargin();
  var {
    width: widthFromProps,
    height: heightFromProps,
    wrapperStyle,
    portal: portalFromProps
  } = props;
  var [lastBoundingBox, updateBoundingBox] = useElementOffset([contextPayload]);
  var chartWidth = useChartWidth();
  var chartHeight = useChartHeight();
  if (chartWidth == null || chartHeight == null) {
    return null;
  }
  var maxWidth = chartWidth - (margin.left || 0) - (margin.right || 0);
  var widthOrHeight = Legend.getWidthOrHeight(props.layout, heightFromProps, widthFromProps, maxWidth);
  var outerStyle = portalFromProps ? wrapperStyle : _objectSpread$v(_objectSpread$v({
    position: "absolute",
    width: (widthOrHeight === null || widthOrHeight === void 0 ? void 0 : widthOrHeight.width) || widthFromProps || "auto",
    height: (widthOrHeight === null || widthOrHeight === void 0 ? void 0 : widthOrHeight.height) || heightFromProps || "auto"
  }, getDefaultPosition(wrapperStyle, props, margin, chartWidth, chartHeight, lastBoundingBox)), wrapperStyle);
  var legendPortal = portalFromProps !== null && portalFromProps !== void 0 ? portalFromProps : legendPortalFromContext;
  if (legendPortal == null) {
    return null;
  }
  var legendElement = /* @__PURE__ */ reactExports.createElement("div", {
    className: "recharts-legend-wrapper",
    style: outerStyle,
    ref: updateBoundingBox
  }, /* @__PURE__ */ reactExports.createElement(LegendSettingsDispatcher, {
    layout: props.layout,
    align: props.align,
    verticalAlign: props.verticalAlign,
    itemSorter: props.itemSorter
  }), /* @__PURE__ */ reactExports.createElement(LegendSizeDispatcher, {
    width: lastBoundingBox.width,
    height: lastBoundingBox.height
  }), /* @__PURE__ */ reactExports.createElement(LegendContent, _extends$n({}, props, widthOrHeight, {
    margin,
    chartWidth,
    chartHeight,
    contextPayload
  })));
  return /* @__PURE__ */ reactDomExports.createPortal(legendElement, legendPortal);
}
class Legend extends reactExports.PureComponent {
  static getWidthOrHeight(layout, height, width, maxWidth) {
    if (layout === "vertical" && isNumber(height)) {
      return {
        height
      };
    }
    if (layout === "horizontal") {
      return {
        width: width || maxWidth
      };
    }
    return null;
  }
  render() {
    return /* @__PURE__ */ reactExports.createElement(LegendWrapper, this.props);
  }
}
_defineProperty$x(Legend, "displayName", "Legend");
_defineProperty$x(Legend, "defaultProps", {
  align: "center",
  iconSize: 14,
  itemSorter: "value",
  layout: "horizontal",
  verticalAlign: "bottom"
});
function _extends$m() {
  return _extends$m = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$m.apply(null, arguments);
}
function ownKeys$u(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$u(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$u(Object(t2), true).forEach(function(r3) {
      _defineProperty$w(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$u(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$w(e3, r2, t2) {
  return (r2 = _toPropertyKey$w(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$w(t2) {
  var i2 = _toPrimitive$w(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$w(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function defaultFormatter(value) {
  return Array.isArray(value) && isNumOrStr(value[0]) && isNumOrStr(value[1]) ? value.join(" ~ ") : value;
}
var DefaultTooltipContent = (props) => {
  var {
    separator = " : ",
    contentStyle = {},
    itemStyle = {},
    labelStyle = {},
    payload,
    formatter,
    itemSorter,
    wrapperClassName,
    labelClassName,
    label,
    labelFormatter,
    accessibilityLayer = false
  } = props;
  var renderContent2 = () => {
    if (payload && payload.length) {
      var listStyle = {
        padding: 0,
        margin: 0
      };
      var items = (itemSorter ? sortBy(payload, itemSorter) : payload).map((entry, i2) => {
        if (entry.type === "none") {
          return null;
        }
        var finalFormatter = entry.formatter || formatter || defaultFormatter;
        var {
          value,
          name
        } = entry;
        var finalValue = value;
        var finalName = name;
        if (finalFormatter) {
          var formatted = finalFormatter(value, name, entry, i2, payload);
          if (Array.isArray(formatted)) {
            [finalValue, finalName] = formatted;
          } else if (formatted != null) {
            finalValue = formatted;
          } else {
            return null;
          }
        }
        var finalItemStyle = _objectSpread$u({
          display: "block",
          paddingTop: 4,
          paddingBottom: 4,
          color: entry.color || "#000"
        }, itemStyle);
        return (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ reactExports.createElement("li", {
            className: "recharts-tooltip-item",
            key: "tooltip-item-".concat(i2),
            style: finalItemStyle
          }, isNumOrStr(finalName) ? /* @__PURE__ */ reactExports.createElement("span", {
            className: "recharts-tooltip-item-name"
          }, finalName) : null, isNumOrStr(finalName) ? /* @__PURE__ */ reactExports.createElement("span", {
            className: "recharts-tooltip-item-separator"
          }, separator) : null, /* @__PURE__ */ reactExports.createElement("span", {
            className: "recharts-tooltip-item-value"
          }, finalValue), /* @__PURE__ */ reactExports.createElement("span", {
            className: "recharts-tooltip-item-unit"
          }, entry.unit || ""))
        );
      });
      return /* @__PURE__ */ reactExports.createElement("ul", {
        className: "recharts-tooltip-item-list",
        style: listStyle
      }, items);
    }
    return null;
  };
  var finalStyle = _objectSpread$u({
    margin: 0,
    padding: 10,
    backgroundColor: "#fff",
    border: "1px solid #ccc",
    whiteSpace: "nowrap"
  }, contentStyle);
  var finalLabelStyle = _objectSpread$u({
    margin: 0
  }, labelStyle);
  var hasLabel = !isNullish(label);
  var finalLabel = hasLabel ? label : "";
  var wrapperCN = clsx("recharts-default-tooltip", wrapperClassName);
  var labelCN = clsx("recharts-tooltip-label", labelClassName);
  if (hasLabel && labelFormatter && payload !== void 0 && payload !== null) {
    finalLabel = labelFormatter(label, payload);
  }
  var accessibilityAttributes = accessibilityLayer ? {
    role: "status",
    "aria-live": "assertive"
  } : {};
  return /* @__PURE__ */ reactExports.createElement("div", _extends$m({
    className: wrapperCN,
    style: finalStyle
  }, accessibilityAttributes), /* @__PURE__ */ reactExports.createElement("p", {
    className: labelCN,
    style: finalLabelStyle
  }, /* @__PURE__ */ reactExports.isValidElement(finalLabel) ? finalLabel : "".concat(finalLabel)), renderContent2());
};
var CSS_CLASS_PREFIX = "recharts-tooltip-wrapper";
var TOOLTIP_HIDDEN = {
  visibility: "hidden"
};
function getTooltipCSSClassName(_ref2) {
  var {
    coordinate,
    translateX,
    translateY
  } = _ref2;
  return clsx(CSS_CLASS_PREFIX, {
    ["".concat(CSS_CLASS_PREFIX, "-right")]: isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX >= coordinate.x,
    ["".concat(CSS_CLASS_PREFIX, "-left")]: isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX < coordinate.x,
    ["".concat(CSS_CLASS_PREFIX, "-bottom")]: isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY >= coordinate.y,
    ["".concat(CSS_CLASS_PREFIX, "-top")]: isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY < coordinate.y
  });
}
function getTooltipTranslateXY(_ref2) {
  var {
    allowEscapeViewBox,
    coordinate,
    key,
    offsetTopLeft,
    position,
    reverseDirection,
    tooltipDimension,
    viewBox,
    viewBoxDimension
  } = _ref2;
  if (position && isNumber(position[key])) {
    return position[key];
  }
  var negative = coordinate[key] - tooltipDimension - (offsetTopLeft > 0 ? offsetTopLeft : 0);
  var positive = coordinate[key] + offsetTopLeft;
  if (allowEscapeViewBox[key]) {
    return reverseDirection[key] ? negative : positive;
  }
  var viewBoxKey = viewBox[key];
  if (viewBoxKey == null) {
    return 0;
  }
  if (reverseDirection[key]) {
    var _tooltipBoundary = negative;
    var _viewBoxBoundary = viewBoxKey;
    if (_tooltipBoundary < _viewBoxBoundary) {
      return Math.max(positive, viewBoxKey);
    }
    return Math.max(negative, viewBoxKey);
  }
  if (viewBoxDimension == null) {
    return 0;
  }
  var tooltipBoundary = positive + tooltipDimension;
  var viewBoxBoundary = viewBoxKey + viewBoxDimension;
  if (tooltipBoundary > viewBoxBoundary) {
    return Math.max(negative, viewBoxKey);
  }
  return Math.max(positive, viewBoxKey);
}
function getTransformStyle(_ref3) {
  var {
    translateX,
    translateY,
    useTranslate3d
  } = _ref3;
  return {
    transform: useTranslate3d ? "translate3d(".concat(translateX, "px, ").concat(translateY, "px, 0)") : "translate(".concat(translateX, "px, ").concat(translateY, "px)")
  };
}
function getTooltipTranslate(_ref4) {
  var {
    allowEscapeViewBox,
    coordinate,
    offsetTopLeft,
    position,
    reverseDirection,
    tooltipBox,
    useTranslate3d,
    viewBox
  } = _ref4;
  var cssProperties, translateX, translateY;
  if (tooltipBox.height > 0 && tooltipBox.width > 0 && coordinate) {
    translateX = getTooltipTranslateXY({
      allowEscapeViewBox,
      coordinate,
      key: "x",
      offsetTopLeft,
      position,
      reverseDirection,
      tooltipDimension: tooltipBox.width,
      viewBox,
      viewBoxDimension: viewBox.width
    });
    translateY = getTooltipTranslateXY({
      allowEscapeViewBox,
      coordinate,
      key: "y",
      offsetTopLeft,
      position,
      reverseDirection,
      tooltipDimension: tooltipBox.height,
      viewBox,
      viewBoxDimension: viewBox.height
    });
    cssProperties = getTransformStyle({
      translateX,
      translateY,
      useTranslate3d
    });
  } else {
    cssProperties = TOOLTIP_HIDDEN;
  }
  return {
    cssProperties,
    cssClasses: getTooltipCSSClassName({
      translateX,
      translateY,
      coordinate
    })
  };
}
function ownKeys$t(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$t(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$t(Object(t2), true).forEach(function(r3) {
      _defineProperty$v(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$t(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$v(e3, r2, t2) {
  return (r2 = _toPropertyKey$v(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$v(t2) {
  var i2 = _toPrimitive$v(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$v(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
class TooltipBoundingBox extends reactExports.PureComponent {
  constructor() {
    super(...arguments);
    _defineProperty$v(this, "state", {
      dismissed: false,
      dismissedAtCoordinate: {
        x: 0,
        y: 0
      }
    });
    _defineProperty$v(this, "handleKeyDown", (event) => {
      if (event.key === "Escape") {
        var _this$props$coordinat, _this$props$coordinat2, _this$props$coordinat3, _this$props$coordinat4;
        this.setState({
          dismissed: true,
          dismissedAtCoordinate: {
            x: (_this$props$coordinat = (_this$props$coordinat2 = this.props.coordinate) === null || _this$props$coordinat2 === void 0 ? void 0 : _this$props$coordinat2.x) !== null && _this$props$coordinat !== void 0 ? _this$props$coordinat : 0,
            y: (_this$props$coordinat3 = (_this$props$coordinat4 = this.props.coordinate) === null || _this$props$coordinat4 === void 0 ? void 0 : _this$props$coordinat4.y) !== null && _this$props$coordinat3 !== void 0 ? _this$props$coordinat3 : 0
          }
        });
      }
    });
  }
  componentDidMount() {
    document.addEventListener("keydown", this.handleKeyDown);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown);
  }
  componentDidUpdate() {
    var _this$props$coordinat5, _this$props$coordinat6;
    if (!this.state.dismissed) {
      return;
    }
    if (((_this$props$coordinat5 = this.props.coordinate) === null || _this$props$coordinat5 === void 0 ? void 0 : _this$props$coordinat5.x) !== this.state.dismissedAtCoordinate.x || ((_this$props$coordinat6 = this.props.coordinate) === null || _this$props$coordinat6 === void 0 ? void 0 : _this$props$coordinat6.y) !== this.state.dismissedAtCoordinate.y) {
      this.state.dismissed = false;
    }
  }
  render() {
    var {
      active,
      allowEscapeViewBox,
      animationDuration,
      animationEasing,
      children,
      coordinate,
      hasPayload,
      isAnimationActive,
      offset,
      position,
      reverseDirection,
      useTranslate3d,
      viewBox,
      wrapperStyle,
      lastBoundingBox,
      innerRef,
      hasPortalFromProps
    } = this.props;
    var {
      cssClasses,
      cssProperties
    } = getTooltipTranslate({
      allowEscapeViewBox,
      coordinate,
      offsetTopLeft: offset,
      position,
      reverseDirection,
      tooltipBox: {
        height: lastBoundingBox.height,
        width: lastBoundingBox.width
      },
      useTranslate3d,
      viewBox
    });
    var positionStyles = hasPortalFromProps ? {} : _objectSpread$t(_objectSpread$t({
      transition: isAnimationActive && active ? "transform ".concat(animationDuration, "ms ").concat(animationEasing) : void 0
    }, cssProperties), {}, {
      pointerEvents: "none",
      visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden",
      position: "absolute",
      top: 0,
      left: 0
    });
    var outerStyle = _objectSpread$t(_objectSpread$t({}, positionStyles), {}, {
      visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden"
    }, wrapperStyle);
    return (
      // This element allow listening to the `Escape` key. See https://github.com/recharts/recharts/pull/2925
      /* @__PURE__ */ reactExports.createElement("div", {
        // @ts-expect-error typescript library does not recognize xmlns attribute, but it's required for an HTML chunk inside SVG.
        xmlns: "http://www.w3.org/1999/xhtml",
        tabIndex: -1,
        className: cssClasses,
        style: outerStyle,
        ref: innerRef
      }, children)
    );
  }
}
var parseIsSsrByDefault = () => !(typeof window !== "undefined" && window.document && Boolean(window.document.createElement) && window.setTimeout);
var Global = {
  devToolsEnabled: false,
  isSsr: parseIsSsrByDefault()
};
var useAccessibilityLayer = () => useAppSelector((state) => state.rootProps.accessibilityLayer);
function _extends$l() {
  return _extends$l = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$l.apply(null, arguments);
}
function ownKeys$s(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$s(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$s(Object(t2), true).forEach(function(r3) {
      _defineProperty$u(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$s(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$u(e3, r2, t2) {
  return (r2 = _toPropertyKey$u(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$u(t2) {
  var i2 = _toPrimitive$u(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$u(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var CURVE_FACTORIES = {
  curveBasisClosed,
  curveBasisOpen,
  curveBasis,
  curveBumpX: bumpX,
  curveBumpY: bumpY,
  curveLinearClosed,
  curveLinear,
  curveMonotoneX: monotoneX,
  curveMonotoneY: monotoneY,
  curveNatural,
  curveStep,
  curveStepAfter: stepAfter,
  curveStepBefore: stepBefore
};
var defined = (p2) => isWellBehavedNumber(p2.x) && isWellBehavedNumber(p2.y);
var getX = (p2) => p2.x;
var getY = (p2) => p2.y;
var getCurveFactory = (type, layout) => {
  if (typeof type === "function") {
    return type;
  }
  var name = "curve".concat(upperFirst(type));
  if ((name === "curveMonotone" || name === "curveBump") && layout) {
    return CURVE_FACTORIES["".concat(name).concat(layout === "vertical" ? "Y" : "X")];
  }
  return CURVE_FACTORIES[name] || curveLinear;
};
var getPath$1 = (_ref2) => {
  var {
    type = "linear",
    points = [],
    baseLine,
    layout,
    connectNulls = false
  } = _ref2;
  var curveFactory = getCurveFactory(type, layout);
  var formatPoints = connectNulls ? points.filter(defined) : points;
  var lineFunction;
  if (Array.isArray(baseLine)) {
    var formatBaseLine = connectNulls ? baseLine.filter((base) => defined(base)) : baseLine;
    var areaPoints = formatPoints.map((entry, index) => _objectSpread$s(_objectSpread$s({}, entry), {}, {
      base: formatBaseLine[index]
    }));
    if (layout === "vertical") {
      lineFunction = shapeArea().y(getY).x1(getX).x0((d2) => d2.base.x);
    } else {
      lineFunction = shapeArea().x(getX).y1(getY).y0((d2) => d2.base.y);
    }
    lineFunction.defined(defined).curve(curveFactory);
    return lineFunction(areaPoints);
  }
  if (layout === "vertical" && isNumber(baseLine)) {
    lineFunction = shapeArea().y(getY).x1(getX).x0(baseLine);
  } else if (isNumber(baseLine)) {
    lineFunction = shapeArea().x(getX).y1(getY).y0(baseLine);
  } else {
    lineFunction = shapeLine().x(getX).y(getY);
  }
  lineFunction.defined(defined).curve(curveFactory);
  return lineFunction(formatPoints);
};
var Curve = (props) => {
  var {
    className,
    points,
    path: path2,
    pathRef
  } = props;
  if ((!points || !points.length) && !path2) {
    return null;
  }
  var realPath = points && points.length ? getPath$1(props) : path2;
  return /* @__PURE__ */ reactExports.createElement("path", _extends$l({}, svgPropertiesNoEvents(props), adaptEventHandlers(props), {
    className: clsx("recharts-curve", className),
    d: realPath === null ? void 0 : realPath,
    ref: pathRef
  }));
};
var _excluded$i = ["x", "y", "top", "left", "width", "height", "className"];
function _extends$k() {
  return _extends$k = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$k.apply(null, arguments);
}
function ownKeys$r(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$r(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$r(Object(t2), true).forEach(function(r3) {
      _defineProperty$t(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$r(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$t(e3, r2, t2) {
  return (r2 = _toPropertyKey$t(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$t(t2) {
  var i2 = _toPrimitive$t(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$t(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$i(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$i(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$i(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
var getPath = (x2, y2, width, height, top, left) => {
  return "M".concat(x2, ",").concat(top, "v").concat(height, "M").concat(left, ",").concat(y2, "h").concat(width);
};
var Cross = (_ref2) => {
  var {
    x: x2 = 0,
    y: y2 = 0,
    top = 0,
    left = 0,
    width = 0,
    height = 0,
    className
  } = _ref2, rest = _objectWithoutProperties$i(_ref2, _excluded$i);
  var props = _objectSpread$r({
    x: x2,
    y: y2,
    top,
    left,
    width,
    height
  }, rest);
  if (!isNumber(x2) || !isNumber(y2) || !isNumber(width) || !isNumber(height) || !isNumber(top) || !isNumber(left)) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement("path", _extends$k({}, svgPropertiesAndEvents(props), {
    className: clsx("recharts-cross", className),
    d: getPath(x2, y2, width, height, top, left)
  }));
};
function getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize) {
  var halfSize = tooltipAxisBandSize / 2;
  return {
    stroke: "none",
    fill: "#ccc",
    x: layout === "horizontal" ? activeCoordinate.x - halfSize : offset.left + 0.5,
    y: layout === "horizontal" ? offset.top + 0.5 : activeCoordinate.y - halfSize,
    width: layout === "horizontal" ? tooltipAxisBandSize : offset.width - 1,
    height: layout === "horizontal" ? offset.height - 1 : tooltipAxisBandSize
  };
}
function ownKeys$q(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$q(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$q(Object(t2), true).forEach(function(r3) {
      _defineProperty$s(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$q(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$s(e3, r2, t2) {
  return (r2 = _toPropertyKey$s(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$s(t2) {
  var i2 = _toPrimitive$s(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$s(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function resolveDefaultProps(realProps, defaultProps2) {
  var resolvedProps = _objectSpread$q({}, realProps);
  var dp = defaultProps2;
  var keys = Object.keys(defaultProps2);
  var withDefaults = keys.reduce((acc, key) => {
    if (acc[key] === void 0 && dp[key] !== void 0) {
      acc[key] = dp[key];
    }
    return acc;
  }, resolvedProps);
  return withDefaults;
}
function noop$2() {
}
function isNotNil(x2) {
  return x2 != null;
}
function ownKeys$p(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$p(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$p(Object(t2), true).forEach(function(r3) {
      _defineProperty$r(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$p(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$r(e3, r2, t2) {
  return (r2 = _toPropertyKey$r(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$r(t2) {
  var i2 = _toPrimitive$r(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$r(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var getDashCase = (name) => name.replace(/([A-Z])/g, (v2) => "-".concat(v2.toLowerCase()));
var getTransitionVal = (props, duration, easing) => props.map((prop) => "".concat(getDashCase(prop), " ").concat(duration, "ms ").concat(easing)).join(",");
var getIntersectionKeys = (preObj, nextObj) => [Object.keys(preObj), Object.keys(nextObj)].reduce((a2, b2) => a2.filter((c2) => b2.includes(c2)));
var mapObject = (fn, obj) => Object.keys(obj).reduce((res, key) => _objectSpread$p(_objectSpread$p({}, res), {}, {
  [key]: fn(key, obj[key])
}), {});
function ownKeys$o(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$o(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$o(Object(t2), true).forEach(function(r3) {
      _defineProperty$q(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$o(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$q(e3, r2, t2) {
  return (r2 = _toPropertyKey$q(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$q(t2) {
  var i2 = _toPrimitive$q(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$q(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var alpha = (begin, end, k2) => begin + (end - begin) * k2;
var needContinue = (_ref2) => {
  var {
    from: from2,
    to: to2
  } = _ref2;
  return from2 !== to2;
};
var calStepperVals = (easing, preVals, steps) => {
  var nextStepVals = mapObject((key, val) => {
    if (needContinue(val)) {
      var [newX, newV] = easing(val.from, val.to, val.velocity);
      return _objectSpread$o(_objectSpread$o({}, val), {}, {
        from: newX,
        velocity: newV
      });
    }
    return val;
  }, preVals);
  if (steps < 1) {
    return mapObject((key, val) => {
      if (needContinue(val)) {
        return _objectSpread$o(_objectSpread$o({}, val), {}, {
          velocity: alpha(val.velocity, nextStepVals[key].velocity, steps),
          from: alpha(val.from, nextStepVals[key].from, steps)
        });
      }
      return val;
    }, preVals);
  }
  return calStepperVals(easing, nextStepVals, steps - 1);
};
function createStepperUpdate(from2, to2, easing, interKeys, render, timeoutController) {
  var preTime;
  var stepperStyle = interKeys.reduce((res, key) => _objectSpread$o(_objectSpread$o({}, res), {}, {
    [key]: {
      from: from2[key],
      velocity: 0,
      to: to2[key]
    }
  }), {});
  var getCurrStyle = () => mapObject((key, val) => val.from, stepperStyle);
  var shouldStopAnimation = () => !Object.values(stepperStyle).filter(needContinue).length;
  var stopAnimation = null;
  var stepperUpdate = (now) => {
    if (!preTime) {
      preTime = now;
    }
    var deltaTime = now - preTime;
    var steps = deltaTime / easing.dt;
    stepperStyle = calStepperVals(easing, stepperStyle, steps);
    render(_objectSpread$o(_objectSpread$o(_objectSpread$o({}, from2), to2), getCurrStyle()));
    preTime = now;
    if (!shouldStopAnimation()) {
      stopAnimation = timeoutController.setTimeout(stepperUpdate);
    }
  };
  return () => {
    stopAnimation = timeoutController.setTimeout(stepperUpdate);
    return () => {
      stopAnimation();
    };
  };
}
function createTimingUpdate(from2, to2, easing, duration, interKeys, render, timeoutController) {
  var stopAnimation = null;
  var timingStyle = interKeys.reduce((res, key) => _objectSpread$o(_objectSpread$o({}, res), {}, {
    [key]: [from2[key], to2[key]]
  }), {});
  var beginTime;
  var timingUpdate = (now) => {
    if (!beginTime) {
      beginTime = now;
    }
    var t2 = (now - beginTime) / duration;
    var currStyle = mapObject((key, val) => alpha(...val, easing(t2)), timingStyle);
    render(_objectSpread$o(_objectSpread$o(_objectSpread$o({}, from2), to2), currStyle));
    if (t2 < 1) {
      stopAnimation = timeoutController.setTimeout(timingUpdate);
    } else {
      var finalStyle = mapObject((key, val) => alpha(...val, easing(1)), timingStyle);
      render(_objectSpread$o(_objectSpread$o(_objectSpread$o({}, from2), to2), finalStyle));
    }
  };
  return () => {
    stopAnimation = timeoutController.setTimeout(timingUpdate);
    return () => {
      stopAnimation();
    };
  };
}
const configUpdate = (from2, to2, easing, duration, render, timeoutController) => {
  var interKeys = getIntersectionKeys(from2, to2);
  return easing.isStepper === true ? createStepperUpdate(from2, to2, easing, interKeys, render, timeoutController) : createTimingUpdate(from2, to2, easing, duration, interKeys, render, timeoutController);
};
var ACCURACY = 1e-4;
var cubicBezierFactor = (c1, c2) => [0, 3 * c1, 3 * c2 - 6 * c1, 3 * c1 - 3 * c2 + 1];
var evaluatePolynomial = (params, t2) => params.map((param, i2) => param * t2 ** i2).reduce((pre, curr) => pre + curr);
var cubicBezier = (c1, c2) => (t2) => {
  var params = cubicBezierFactor(c1, c2);
  return evaluatePolynomial(params, t2);
};
var derivativeCubicBezier = (c1, c2) => (t2) => {
  var params = cubicBezierFactor(c1, c2);
  var newParams = [...params.map((param, i2) => param * i2).slice(1), 0];
  return evaluatePolynomial(newParams, t2);
};
var configBezier = function configBezier2() {
  var x1, x2, y1, y2;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (args.length === 1) {
    switch (args[0]) {
      case "linear":
        [x1, y1, x2, y2] = [0, 0, 1, 1];
        break;
      case "ease":
        [x1, y1, x2, y2] = [0.25, 0.1, 0.25, 1];
        break;
      case "ease-in":
        [x1, y1, x2, y2] = [0.42, 0, 1, 1];
        break;
      case "ease-out":
        [x1, y1, x2, y2] = [0.42, 0, 0.58, 1];
        break;
      case "ease-in-out":
        [x1, y1, x2, y2] = [0, 0, 0.58, 1];
        break;
      default: {
        var easing = args[0].split("(");
        if (easing[0] === "cubic-bezier" && easing[1].split(")")[0].split(",").length === 4) {
          [x1, y1, x2, y2] = easing[1].split(")")[0].split(",").map((x3) => parseFloat(x3));
        }
      }
    }
  } else if (args.length === 4) {
    [x1, y1, x2, y2] = args;
  }
  var curveX = cubicBezier(x1, x2);
  var curveY = cubicBezier(y1, y2);
  var derCurveX = derivativeCubicBezier(x1, x2);
  var rangeValue = (value) => {
    if (value > 1) {
      return 1;
    }
    if (value < 0) {
      return 0;
    }
    return value;
  };
  var bezier = (_t) => {
    var t2 = _t > 1 ? 1 : _t;
    var x3 = t2;
    for (var i2 = 0; i2 < 8; ++i2) {
      var evalT = curveX(x3) - t2;
      var derVal = derCurveX(x3);
      if (Math.abs(evalT - t2) < ACCURACY || derVal < ACCURACY) {
        return curveY(x3);
      }
      x3 = rangeValue(x3 - evalT / derVal);
    }
    return curveY(x3);
  };
  bezier.isStepper = false;
  return bezier;
};
var configSpring = function configSpring2() {
  var config2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var {
    stiff = 100,
    damping = 8,
    dt = 17
  } = config2;
  var stepper = (currX, destX, currV) => {
    var FSpring = -(currX - destX) * stiff;
    var FDamping = currV * damping;
    var newV = currV + (FSpring - FDamping) * dt / 1e3;
    var newX = currV * dt / 1e3 + currX;
    if (Math.abs(newX - destX) < ACCURACY && Math.abs(newV) < ACCURACY) {
      return [destX, 0];
    }
    return [newX, newV];
  };
  stepper.isStepper = true;
  stepper.dt = dt;
  return stepper;
};
var configEasing = (easing) => {
  if (typeof easing === "string") {
    switch (easing) {
      case "ease":
      case "ease-in-out":
      case "ease-out":
      case "ease-in":
      case "linear":
        return configBezier(easing);
      case "spring":
        return configSpring();
      default:
        if (easing.split("(")[0] === "cubic-bezier") {
          return configBezier(easing);
        }
    }
  }
  if (typeof easing === "function") {
    return easing;
  }
  return null;
};
function createAnimateManager(timeoutController) {
  var currStyle;
  var handleChange = () => null;
  var shouldStop = false;
  var cancelTimeout = null;
  var setStyle = (_style) => {
    if (shouldStop) {
      return;
    }
    if (Array.isArray(_style)) {
      if (!_style.length) {
        return;
      }
      var styles = _style;
      var [curr, ...restStyles] = styles;
      if (typeof curr === "number") {
        cancelTimeout = timeoutController.setTimeout(setStyle.bind(null, restStyles), curr);
        return;
      }
      setStyle(curr);
      cancelTimeout = timeoutController.setTimeout(setStyle.bind(null, restStyles));
      return;
    }
    if (typeof _style === "string") {
      currStyle = _style;
      handleChange(currStyle);
    }
    if (typeof _style === "object") {
      currStyle = _style;
      handleChange(currStyle);
    }
    if (typeof _style === "function") {
      _style();
    }
  };
  return {
    stop: () => {
      shouldStop = true;
    },
    start: (style) => {
      shouldStop = false;
      if (cancelTimeout) {
        cancelTimeout();
        cancelTimeout = null;
      }
      setStyle(style);
    },
    subscribe: (_handleChange) => {
      handleChange = _handleChange;
      return () => {
        handleChange = () => null;
      };
    },
    getTimeoutController: () => timeoutController
  };
}
class RequestAnimationFrameTimeoutController {
  setTimeout(callback) {
    var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var startTime = performance.now();
    var requestId = null;
    var executeCallback = (now) => {
      if (now - startTime >= delay) {
        callback(now);
      } else if (typeof requestAnimationFrame === "function") {
        requestId = requestAnimationFrame(executeCallback);
      }
    };
    requestId = requestAnimationFrame(executeCallback);
    return () => {
      cancelAnimationFrame(requestId);
    };
  }
}
function createDefaultAnimationManager() {
  return createAnimateManager(new RequestAnimationFrameTimeoutController());
}
var AnimationManagerContext = /* @__PURE__ */ reactExports.createContext(createDefaultAnimationManager);
function useAnimationManager(animationId, animationManagerFromProps) {
  var contextAnimationManager = reactExports.useContext(AnimationManagerContext);
  return reactExports.useMemo(() => animationManagerFromProps !== null && animationManagerFromProps !== void 0 ? animationManagerFromProps : contextAnimationManager(animationId), [animationId, animationManagerFromProps, contextAnimationManager]);
}
var defaultJavascriptAnimateProps = {
  begin: 0,
  duration: 1e3,
  easing: "ease",
  isActive: true,
  canBegin: true,
  onAnimationEnd: () => {
  },
  onAnimationStart: () => {
  }
};
var from = {
  t: 0
};
var to = {
  t: 1
};
function JavascriptAnimate(outsideProps) {
  var props = resolveDefaultProps(outsideProps, defaultJavascriptAnimateProps);
  var {
    isActive,
    canBegin,
    duration,
    easing,
    begin,
    onAnimationEnd,
    onAnimationStart,
    children
  } = props;
  var animationManager = useAnimationManager(props.animationId, props.animationManager);
  var [style, setStyle] = reactExports.useState(isActive ? from : to);
  var stopJSAnimation = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!isActive) {
      setStyle(to);
    }
  }, [isActive]);
  reactExports.useEffect(() => {
    if (!isActive || !canBegin) {
      return noop$2;
    }
    var startAnimation = configUpdate(from, to, configEasing(easing), duration, setStyle, animationManager.getTimeoutController());
    var onAnimationActive = () => {
      stopJSAnimation.current = startAnimation();
    };
    animationManager.start([onAnimationStart, begin, onAnimationActive, duration, onAnimationEnd]);
    return () => {
      animationManager.stop();
      if (stopJSAnimation.current) {
        stopJSAnimation.current();
      }
      onAnimationEnd();
    };
  }, [isActive, canBegin, duration, easing, begin, onAnimationStart, onAnimationEnd, animationManager]);
  return children(style.t);
}
function useAnimationId(input) {
  var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "animation-";
  var animationId = reactExports.useRef(uniqueId(prefix2));
  var prevProps = reactExports.useRef(input);
  if (prevProps.current !== input) {
    animationId.current = uniqueId(prefix2);
    prevProps.current = input;
  }
  return animationId.current;
}
var _excluded$h = ["radius"], _excluded2$9 = ["radius"];
function ownKeys$n(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$n(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$n(Object(t2), true).forEach(function(r3) {
      _defineProperty$p(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$n(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$p(e3, r2, t2) {
  return (r2 = _toPropertyKey$p(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$p(t2) {
  var i2 = _toPrimitive$p(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$p(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _extends$j() {
  return _extends$j = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$j.apply(null, arguments);
}
function _objectWithoutProperties$h(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$h(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$h(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
var getRectanglePath = (x2, y2, width, height, radius) => {
  var maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2);
  var ySign = height >= 0 ? 1 : -1;
  var xSign = width >= 0 ? 1 : -1;
  var clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0;
  var path2;
  if (maxRadius > 0 && radius instanceof Array) {
    var newRadius = [0, 0, 0, 0];
    for (var i2 = 0, len = 4; i2 < len; i2++) {
      newRadius[i2] = radius[i2] > maxRadius ? maxRadius : radius[i2];
    }
    path2 = "M".concat(x2, ",").concat(y2 + ySign * newRadius[0]);
    if (newRadius[0] > 0) {
      path2 += "A ".concat(newRadius[0], ",").concat(newRadius[0], ",0,0,").concat(clockWise, ",").concat(x2 + xSign * newRadius[0], ",").concat(y2);
    }
    path2 += "L ".concat(x2 + width - xSign * newRadius[1], ",").concat(y2);
    if (newRadius[1] > 0) {
      path2 += "A ".concat(newRadius[1], ",").concat(newRadius[1], ",0,0,").concat(clockWise, ",\n        ").concat(x2 + width, ",").concat(y2 + ySign * newRadius[1]);
    }
    path2 += "L ".concat(x2 + width, ",").concat(y2 + height - ySign * newRadius[2]);
    if (newRadius[2] > 0) {
      path2 += "A ".concat(newRadius[2], ",").concat(newRadius[2], ",0,0,").concat(clockWise, ",\n        ").concat(x2 + width - xSign * newRadius[2], ",").concat(y2 + height);
    }
    path2 += "L ".concat(x2 + xSign * newRadius[3], ",").concat(y2 + height);
    if (newRadius[3] > 0) {
      path2 += "A ".concat(newRadius[3], ",").concat(newRadius[3], ",0,0,").concat(clockWise, ",\n        ").concat(x2, ",").concat(y2 + height - ySign * newRadius[3]);
    }
    path2 += "Z";
  } else if (maxRadius > 0 && radius === +radius && radius > 0) {
    var _newRadius = Math.min(maxRadius, radius);
    path2 = "M ".concat(x2, ",").concat(y2 + ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + xSign * _newRadius, ",").concat(y2, "\n            L ").concat(x2 + width - xSign * _newRadius, ",").concat(y2, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + width, ",").concat(y2 + ySign * _newRadius, "\n            L ").concat(x2 + width, ",").concat(y2 + height - ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + width - xSign * _newRadius, ",").concat(y2 + height, "\n            L ").concat(x2 + xSign * _newRadius, ",").concat(y2 + height, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2, ",").concat(y2 + height - ySign * _newRadius, " Z");
  } else {
    path2 = "M ".concat(x2, ",").concat(y2, " h ").concat(width, " v ").concat(height, " h ").concat(-width, " Z");
  }
  return path2;
};
var defaultProps$6 = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  // The radius of border
  // The radius of four corners when radius is a number
  // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
  radius: 0,
  isAnimationActive: false,
  isUpdateAnimationActive: false,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
};
var Rectangle = (rectangleProps) => {
  var props = resolveDefaultProps(rectangleProps, defaultProps$6);
  var pathRef = reactExports.useRef(null);
  var [totalLength, setTotalLength] = reactExports.useState(-1);
  reactExports.useEffect(() => {
    if (pathRef.current && pathRef.current.getTotalLength) {
      try {
        var pathTotalLength = pathRef.current.getTotalLength();
        if (pathTotalLength) {
          setTotalLength(pathTotalLength);
        }
      } catch (_unused) {
      }
    }
  }, []);
  var {
    x: x2,
    y: y2,
    width,
    height,
    radius,
    className
  } = props;
  var {
    animationEasing,
    animationDuration,
    animationBegin,
    isAnimationActive,
    isUpdateAnimationActive
  } = props;
  var prevWidthRef = reactExports.useRef(width);
  var prevHeightRef = reactExports.useRef(height);
  var prevXRef = reactExports.useRef(x2);
  var prevYRef = reactExports.useRef(y2);
  var animationIdInput = reactExports.useMemo(() => ({
    x: x2,
    y: y2,
    width,
    height,
    radius
  }), [x2, y2, width, height, radius]);
  var animationId = useAnimationId(animationIdInput, "rectangle-");
  if (x2 !== +x2 || y2 !== +y2 || width !== +width || height !== +height || width === 0 || height === 0) {
    return null;
  }
  var layerClass = clsx("recharts-rectangle", className);
  if (!isUpdateAnimationActive) {
    var _svgPropertiesAndEven = svgPropertiesAndEvents(props), {
      radius: _2
    } = _svgPropertiesAndEven, otherPathProps = _objectWithoutProperties$h(_svgPropertiesAndEven, _excluded$h);
    return /* @__PURE__ */ reactExports.createElement("path", _extends$j({}, otherPathProps, {
      radius: typeof radius === "number" ? radius : void 0,
      className: layerClass,
      d: getRectanglePath(x2, y2, width, height, radius)
    }));
  }
  var prevWidth = prevWidthRef.current;
  var prevHeight = prevHeightRef.current;
  var prevX = prevXRef.current;
  var prevY = prevYRef.current;
  var from2 = "0px ".concat(totalLength === -1 ? 1 : totalLength, "px");
  var to2 = "".concat(totalLength, "px 0px");
  var transition = getTransitionVal(["strokeDasharray"], animationDuration, typeof animationEasing === "string" ? animationEasing : void 0);
  return /* @__PURE__ */ reactExports.createElement(JavascriptAnimate, {
    animationId,
    key: animationId,
    canBegin: totalLength > 0,
    duration: animationDuration,
    easing: animationEasing,
    isActive: isUpdateAnimationActive,
    begin: animationBegin
  }, (t2) => {
    var currWidth = interpolate$1(prevWidth, width, t2);
    var currHeight = interpolate$1(prevHeight, height, t2);
    var currX = interpolate$1(prevX, x2, t2);
    var currY = interpolate$1(prevY, y2, t2);
    if (pathRef.current) {
      prevWidthRef.current = currWidth;
      prevHeightRef.current = currHeight;
      prevXRef.current = currX;
      prevYRef.current = currY;
    }
    var animationStyle;
    if (!isAnimationActive) {
      animationStyle = {
        strokeDasharray: to2
      };
    } else if (t2 > 0) {
      animationStyle = {
        transition,
        strokeDasharray: to2
      };
    } else {
      animationStyle = {
        strokeDasharray: from2
      };
    }
    var _svgPropertiesAndEven2 = svgPropertiesAndEvents(props), {
      radius: _3
    } = _svgPropertiesAndEven2, otherPathProps2 = _objectWithoutProperties$h(_svgPropertiesAndEven2, _excluded2$9);
    return /* @__PURE__ */ reactExports.createElement("path", _extends$j({}, otherPathProps2, {
      radius: typeof radius === "number" ? radius : void 0,
      className: layerClass,
      d: getRectanglePath(currX, currY, currWidth, currHeight, radius),
      ref: pathRef,
      style: _objectSpread$n(_objectSpread$n({}, animationStyle), props.style)
    }));
  });
};
function getRadialCursorPoints(activeCoordinate) {
  var {
    cx,
    cy,
    radius,
    startAngle,
    endAngle
  } = activeCoordinate;
  var startPoint = polarToCartesian(cx, cy, radius, startAngle);
  var endPoint = polarToCartesian(cx, cy, radius, endAngle);
  return {
    points: [startPoint, endPoint],
    cx,
    cy,
    radius,
    startAngle,
    endAngle
  };
}
function _extends$i() {
  return _extends$i = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$i.apply(null, arguments);
}
var getDeltaAngle$1 = (startAngle, endAngle) => {
  var sign2 = mathSign(endAngle - startAngle);
  var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);
  return sign2 * deltaAngle;
};
var getTangentCircle = (_ref2) => {
  var {
    cx,
    cy,
    radius,
    angle,
    sign: sign2,
    isExternal,
    cornerRadius,
    cornerIsExternal
  } = _ref2;
  var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;
  var theta = Math.asin(cornerRadius / centerRadius) / RADIAN;
  var centerAngle = cornerIsExternal ? angle : angle + sign2 * theta;
  var center = polarToCartesian(cx, cy, centerRadius, centerAngle);
  var circleTangency = polarToCartesian(cx, cy, radius, centerAngle);
  var lineTangencyAngle = cornerIsExternal ? angle - sign2 * theta : angle;
  var lineTangency = polarToCartesian(cx, cy, centerRadius * Math.cos(theta * RADIAN), lineTangencyAngle);
  return {
    center,
    circleTangency,
    lineTangency,
    theta
  };
};
var getSectorPath = (_ref2) => {
  var {
    cx,
    cy,
    innerRadius,
    outerRadius,
    startAngle,
    endAngle
  } = _ref2;
  var angle = getDeltaAngle$1(startAngle, endAngle);
  var tempEndAngle = startAngle + angle;
  var outerStartPoint = polarToCartesian(cx, cy, outerRadius, startAngle);
  var outerEndPoint = polarToCartesian(cx, cy, outerRadius, tempEndAngle);
  var path2 = "M ".concat(outerStartPoint.x, ",").concat(outerStartPoint.y, "\n    A ").concat(outerRadius, ",").concat(outerRadius, ",0,\n    ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle > tempEndAngle), ",\n    ").concat(outerEndPoint.x, ",").concat(outerEndPoint.y, "\n  ");
  if (innerRadius > 0) {
    var innerStartPoint = polarToCartesian(cx, cy, innerRadius, startAngle);
    var innerEndPoint = polarToCartesian(cx, cy, innerRadius, tempEndAngle);
    path2 += "L ".concat(innerEndPoint.x, ",").concat(innerEndPoint.y, "\n            A ").concat(innerRadius, ",").concat(innerRadius, ",0,\n            ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle <= tempEndAngle), ",\n            ").concat(innerStartPoint.x, ",").concat(innerStartPoint.y, " Z");
  } else {
    path2 += "L ".concat(cx, ",").concat(cy, " Z");
  }
  return path2;
};
var getSectorWithCorner = (_ref3) => {
  var {
    cx,
    cy,
    innerRadius,
    outerRadius,
    cornerRadius,
    forceCornerRadius,
    cornerIsExternal,
    startAngle,
    endAngle
  } = _ref3;
  var sign2 = mathSign(endAngle - startAngle);
  var {
    circleTangency: soct,
    lineTangency: solt,
    theta: sot
  } = getTangentCircle({
    cx,
    cy,
    radius: outerRadius,
    angle: startAngle,
    sign: sign2,
    cornerRadius,
    cornerIsExternal
  });
  var {
    circleTangency: eoct,
    lineTangency: eolt,
    theta: eot
  } = getTangentCircle({
    cx,
    cy,
    radius: outerRadius,
    angle: endAngle,
    sign: -sign2,
    cornerRadius,
    cornerIsExternal
  });
  var outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;
  if (outerArcAngle < 0) {
    if (forceCornerRadius) {
      return "M ".concat(solt.x, ",").concat(solt.y, "\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(cornerRadius * 2, ",0\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(-cornerRadius * 2, ",0\n      ");
    }
    return getSectorPath({
      cx,
      cy,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    });
  }
  var path2 = "M ".concat(solt.x, ",").concat(solt.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(soct.x, ",").concat(soct.y, "\n    A").concat(outerRadius, ",").concat(outerRadius, ",0,").concat(+(outerArcAngle > 180), ",").concat(+(sign2 < 0), ",").concat(eoct.x, ",").concat(eoct.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(eolt.x, ",").concat(eolt.y, "\n  ");
  if (innerRadius > 0) {
    var {
      circleTangency: sict,
      lineTangency: silt,
      theta: sit
    } = getTangentCircle({
      cx,
      cy,
      radius: innerRadius,
      angle: startAngle,
      sign: sign2,
      isExternal: true,
      cornerRadius,
      cornerIsExternal
    });
    var {
      circleTangency: eict,
      lineTangency: eilt,
      theta: eit
    } = getTangentCircle({
      cx,
      cy,
      radius: innerRadius,
      angle: endAngle,
      sign: -sign2,
      isExternal: true,
      cornerRadius,
      cornerIsExternal
    });
    var innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;
    if (innerArcAngle < 0 && cornerRadius === 0) {
      return "".concat(path2, "L").concat(cx, ",").concat(cy, "Z");
    }
    path2 += "L".concat(eilt.x, ",").concat(eilt.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(eict.x, ",").concat(eict.y, "\n      A").concat(innerRadius, ",").concat(innerRadius, ",0,").concat(+(innerArcAngle > 180), ",").concat(+(sign2 > 0), ",").concat(sict.x, ",").concat(sict.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(silt.x, ",").concat(silt.y, "Z");
  } else {
    path2 += "L".concat(cx, ",").concat(cy, "Z");
  }
  return path2;
};
var defaultProps$5 = {
  cx: 0,
  cy: 0,
  innerRadius: 0,
  outerRadius: 0,
  startAngle: 0,
  endAngle: 0,
  cornerRadius: 0,
  forceCornerRadius: false,
  cornerIsExternal: false
};
var Sector = (sectorProps) => {
  var props = resolveDefaultProps(sectorProps, defaultProps$5);
  var {
    cx,
    cy,
    innerRadius,
    outerRadius,
    cornerRadius,
    forceCornerRadius,
    cornerIsExternal,
    startAngle,
    endAngle,
    className
  } = props;
  if (outerRadius < innerRadius || startAngle === endAngle) {
    return null;
  }
  var layerClass = clsx("recharts-sector", className);
  var deltaRadius = outerRadius - innerRadius;
  var cr = getPercentValue(cornerRadius, deltaRadius, 0, true);
  var path2;
  if (cr > 0 && Math.abs(startAngle - endAngle) < 360) {
    path2 = getSectorWithCorner({
      cx,
      cy,
      innerRadius,
      outerRadius,
      cornerRadius: Math.min(cr, deltaRadius / 2),
      forceCornerRadius,
      cornerIsExternal,
      startAngle,
      endAngle
    });
  } else {
    path2 = getSectorPath({
      cx,
      cy,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    });
  }
  return /* @__PURE__ */ reactExports.createElement("path", _extends$i({}, svgPropertiesAndEvents(props), {
    className: layerClass,
    d: path2
  }));
};
function getCursorPoints(layout, activeCoordinate, offset) {
  var x1, y1, x2, y2;
  if (layout === "horizontal") {
    x1 = activeCoordinate.x;
    x2 = x1;
    y1 = offset.top;
    y2 = offset.top + offset.height;
  } else if (layout === "vertical") {
    y1 = activeCoordinate.y;
    y2 = y1;
    x1 = offset.left;
    x2 = offset.left + offset.width;
  } else if (activeCoordinate.cx != null && activeCoordinate.cy != null) {
    if (layout === "centric") {
      var {
        cx,
        cy,
        innerRadius,
        outerRadius,
        angle
      } = activeCoordinate;
      var innerPoint = polarToCartesian(cx, cy, innerRadius, angle);
      var outerPoint = polarToCartesian(cx, cy, outerRadius, angle);
      x1 = innerPoint.x;
      y1 = innerPoint.y;
      x2 = outerPoint.x;
      y2 = outerPoint.y;
    } else {
      return getRadialCursorPoints(activeCoordinate);
    }
  }
  return [{
    x: x1,
    y: y1
  }, {
    x: x2,
    y: y2
  }];
}
var range$4 = {};
var toFinite = {};
var toNumber = {};
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber) return toNumber;
  hasRequiredToNumber = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isSymbol2 = /* @__PURE__ */ requireIsSymbol();
    function toNumber2(value) {
      if (isSymbol2.isSymbol(value)) {
        return NaN;
      }
      return Number(value);
    }
    exports.toNumber = toNumber2;
  })(toNumber);
  return toNumber;
}
var hasRequiredToFinite;
function requireToFinite() {
  if (hasRequiredToFinite) return toFinite;
  hasRequiredToFinite = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const toNumber2 = /* @__PURE__ */ requireToNumber();
    function toFinite2(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber2.toNumber(value);
      if (value === Infinity || value === -Infinity) {
        const sign2 = value < 0 ? -1 : 1;
        return sign2 * Number.MAX_VALUE;
      }
      return value === value ? value : 0;
    }
    exports.toFinite = toFinite2;
  })(toFinite);
  return toFinite;
}
var hasRequiredRange$1;
function requireRange$1() {
  if (hasRequiredRange$1) return range$4;
  hasRequiredRange$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isIterateeCall2 = /* @__PURE__ */ requireIsIterateeCall();
    const toFinite2 = /* @__PURE__ */ requireToFinite();
    function range2(start, end, step) {
      if (step && typeof step !== "number" && isIterateeCall2.isIterateeCall(start, end, step)) {
        end = step = void 0;
      }
      start = toFinite2.toFinite(start);
      if (end === void 0) {
        end = start;
        start = 0;
      } else {
        end = toFinite2.toFinite(end);
      }
      step = step === void 0 ? start < end ? 1 : -1 : toFinite2.toFinite(step);
      const length = Math.max(Math.ceil((end - start) / (step || 1)), 0);
      const result = new Array(length);
      for (let index = 0; index < length; index++) {
        result[index] = start;
        start += step;
      }
      return result;
    }
    exports.range = range2;
  })(range$4);
  return range$4;
}
var range$3;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range$3;
  hasRequiredRange = 1;
  range$3 = requireRange$1().range;
  return range$3;
}
var rangeExports = /* @__PURE__ */ requireRange();
const range$2 = /* @__PURE__ */ getDefaultExportFromCjs(rangeExports);
function ascending(a2, b2) {
  return a2 == null || b2 == null ? NaN : a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}
function descending(a2, b2) {
  return a2 == null || b2 == null ? NaN : b2 < a2 ? -1 : b2 > a2 ? 1 : b2 >= a2 ? 0 : NaN;
}
function bisector(f2) {
  let compare1, compare2, delta;
  if (f2.length !== 2) {
    compare1 = ascending;
    compare2 = (d2, x2) => ascending(f2(d2), x2);
    delta = (d2, x2) => f2(d2) - x2;
  } else {
    compare1 = f2 === ascending || f2 === descending ? f2 : zero$1;
    compare2 = f2;
    delta = f2;
  }
  function left(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a2, x2, lo = 0, hi = a2.length) {
    const i2 = left(a2, x2, lo, hi - 1);
    return i2 > lo && delta(a2[i2 - 1], x2) > -delta(a2[i2], x2) ? i2 - 1 : i2;
  }
  return { left, center, right };
}
function zero$1() {
  return 0;
}
function number$2(x2) {
  return x2 === null ? NaN : +x2;
}
function* numbers(values, valueof) {
  {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}
const ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
bisector(number$2).center;
class InternMap extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
}
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
function compareDefined(compare = ascending) {
  if (compare === ascending) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a2, b2) => {
    const x2 = compare(a2, b2);
    if (x2 || x2 === 0) return x2;
    return (compare(b2, b2) === 0) - (compare(a2, a2) === 0);
  };
}
function ascendingDefined(a2, b2) {
  return (a2 == null || !(a2 >= a2)) - (b2 == null || !(b2 >= b2)) || (a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
}
const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function tickSpec(start, stop, count) {
  const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  if (!(count > 0)) return [];
  if (start === stop) return [start];
  const reverse2 = stop < start, [i1, i2, inc] = reverse2 ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
  if (!(i2 >= i1)) return [];
  const n2 = i2 - i1 + 1, ticks2 = new Array(n2);
  if (reverse2) {
    if (inc < 0) for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i2 - i3) / -inc;
    else for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i2 - i3) * inc;
  } else {
    if (inc < 0) for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i1 + i3) / -inc;
    else for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i1 + i3) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  return tickSpec(start, stop, count)[2];
}
function tickStep(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  const reverse2 = stop < start, inc = reverse2 ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
  return (reverse2 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
function max(values, valueof) {
  let max2;
  {
    for (const value of values) {
      if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  }
  return max2;
}
function min(values, valueof) {
  let min2;
  {
    for (const value of values) {
      if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  }
  return min2;
}
function quickselect(array2, k2, left = 0, right = Infinity, compare) {
  k2 = Math.floor(k2);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array2.length - 1, right));
  if (!(left <= k2 && k2 <= right)) return array2;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right > left) {
    if (right - left > 600) {
      const n2 = right - left + 1;
      const m2 = k2 - left + 1;
      const z2 = Math.log(n2);
      const s2 = 0.5 * Math.exp(2 * z2 / 3);
      const sd = 0.5 * Math.sqrt(z2 * s2 * (n2 - s2) / n2) * (m2 - n2 / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k2 - m2 * s2 / n2 + sd));
      const newRight = Math.min(right, Math.floor(k2 + (n2 - m2) * s2 / n2 + sd));
      quickselect(array2, k2, newLeft, newRight, compare);
    }
    const t2 = array2[k2];
    let i2 = left;
    let j2 = right;
    swap(array2, left, k2);
    if (compare(array2[right], t2) > 0) swap(array2, left, right);
    while (i2 < j2) {
      swap(array2, i2, j2), ++i2, --j2;
      while (compare(array2[i2], t2) < 0) ++i2;
      while (compare(array2[j2], t2) > 0) --j2;
    }
    if (compare(array2[left], t2) === 0) swap(array2, left, j2);
    else ++j2, swap(array2, j2, right);
    if (j2 <= k2) left = j2 + 1;
    if (k2 <= j2) right = j2 - 1;
  }
  return array2;
}
function swap(array2, i2, j2) {
  const t2 = array2[i2];
  array2[i2] = array2[j2];
  array2[j2] = t2;
}
function quantile$1(values, p2, valueof) {
  values = Float64Array.from(numbers(values));
  if (!(n2 = values.length) || isNaN(p2 = +p2)) return;
  if (p2 <= 0 || n2 < 2) return min(values);
  if (p2 >= 1) return max(values);
  var n2, i2 = (n2 - 1) * p2, i0 = Math.floor(i2), value0 = max(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i2 - i0);
}
function quantileSorted(values, p2, valueof = number$2) {
  if (!(n2 = values.length) || isNaN(p2 = +p2)) return;
  if (p2 <= 0 || n2 < 2) return +valueof(values[0], 0, values);
  if (p2 >= 1) return +valueof(values[n2 - 1], n2 - 1, values);
  var n2, i2 = (n2 - 1) * p2, i0 = Math.floor(i2), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i2 - i0);
}
function range$1(start, stop, step) {
  start = +start, stop = +stop, step = (n2 = arguments.length) < 2 ? (stop = start, start = 0, 1) : n2 < 3 ? 1 : +step;
  var i2 = -1, n2 = Math.max(0, Math.ceil((stop - start) / step)) | 0, range2 = new Array(n2);
  while (++i2 < n2) {
    range2[i2] = start + i2 * step;
  }
  return range2;
}
function initRange(domain2, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain2);
      break;
    default:
      this.range(range2).domain(domain2);
      break;
  }
  return this;
}
function initInterpolator(domain2, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain2 === "function") this.interpolator(domain2);
      else this.range(domain2);
      break;
    }
    default: {
      this.domain(domain2);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}
const implicit = Symbol("implicit");
function ordinal() {
  var index = new InternMap(), domain2 = [], range2 = [], unknown = implicit;
  function scale(d2) {
    let i2 = index.get(d2);
    if (i2 === void 0) {
      if (unknown !== implicit) return unknown;
      index.set(d2, i2 = domain2.push(d2) - 1);
    }
    return range2[i2 % range2.length];
  }
  scale.domain = function(_2) {
    if (!arguments.length) return domain2.slice();
    domain2 = [], index = new InternMap();
    for (const value of _2) {
      if (index.has(value)) continue;
      index.set(value, domain2.push(value) - 1);
    }
    return scale;
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = Array.from(_2), scale) : range2.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain2, range2).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}
function band() {
  var scale = ordinal().unknown(void 0), domain2 = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n2 = domain2().length, reverse2 = r1 < r0, start = reverse2 ? r1 : r0, stop = reverse2 ? r0 : r1;
    step = (stop - start) / Math.max(1, n2 - paddingInner + paddingOuter * 2);
    if (round2) step = Math.floor(step);
    start += (stop - start - step * (n2 - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round2) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = range$1(n2).map(function(i2) {
      return start + step * i2;
    });
    return ordinalRange(reverse2 ? values.reverse() : values);
  }
  scale.domain = function(_2) {
    return arguments.length ? (domain2(_2), rescale()) : domain2();
  };
  scale.range = function(_2) {
    return arguments.length ? ([r0, r1] = _2, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_2) {
    return [r0, r1] = _2, r0 = +r0, r1 = +r1, round2 = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_2) {
    return arguments.length ? (round2 = !!_2, rescale()) : round2;
  };
  scale.padding = function(_2) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_2), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_2) {
    return arguments.length ? (paddingInner = Math.min(1, _2), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_2) {
    return arguments.length ? (paddingOuter = +_2, rescale()) : paddingOuter;
  };
  scale.align = function(_2) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _2)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain2(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
  var copy2 = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;
  scale.copy = function() {
    return pointish(copy2());
  };
  return scale;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m2, l2;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format2)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r2, g2, b2, a2) {
  if (a2 <= 0) r2 = g2 = b2 = NaN;
  return new Rgb(r2, g2, b2, a2);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb$1(r2, g2, b2, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b2, opacity == null ? 1 : opacity);
}
function Rgb(r2, g2, b2, opacity) {
  this.r = +r2;
  this.g = +g2;
  this.b = +b2;
  this.opacity = +opacity;
}
define(Rgb, rgb$1, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s2, l2, a2) {
  if (a2 <= 0) h2 = s2 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1) h2 = s2 = NaN;
  else if (s2 <= 0) h2 = NaN;
  return new Hsl(h2, s2, l2, a2);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Hsl();
  if (o2 instanceof Hsl) return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g2 = o2.g / 255, b2 = o2.b / 255, min2 = Math.min(r2, g2, b2), max2 = Math.max(r2, g2, b2), h2 = NaN, s2 = max2 - min2, l2 = (max2 + min2) / 2;
  if (s2) {
    if (r2 === max2) h2 = (g2 - b2) / s2 + (g2 < b2) * 6;
    else if (g2 === max2) h2 = (b2 - r2) / s2 + 2;
    else h2 = (r2 - g2) / s2 + 4;
    s2 /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s2 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l2, o2.opacity);
}
function hsl(h2, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Hsl(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
const constant = (x2) => () => x2;
function linear$1(a2, d2) {
  return function(t2) {
    return a2 + t2 * d2;
  };
}
function exponential(a2, b2, y2) {
  return a2 = Math.pow(a2, y2), b2 = Math.pow(b2, y2) - a2, y2 = 1 / y2, function(t2) {
    return Math.pow(a2 + t2 * b2, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b2) {
    return b2 - a2 ? exponential(a2, b2, y2) : constant(isNaN(a2) ? b2 : a2);
  };
}
function nogamma(a2, b2) {
  var d2 = b2 - a2;
  return d2 ? linear$1(a2, d2) : constant(isNaN(a2) ? b2 : a2);
}
const rgb = (function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb2(start, end) {
    var r2 = color2((start = rgb$1(start)).r, (end = rgb$1(end)).r), g2 = color2(start.g, end.g), b2 = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t2) {
      start.r = r2(t2);
      start.g = g2(t2);
      start.b = b2(t2);
      start.opacity = opacity(t2);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
})(1);
function numberArray(a2, b2) {
  if (!b2) b2 = [];
  var n2 = a2 ? Math.min(b2.length, a2.length) : 0, c2 = b2.slice(), i2;
  return function(t2) {
    for (i2 = 0; i2 < n2; ++i2) c2[i2] = a2[i2] * (1 - t2) + b2[i2] * t2;
    return c2;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function genericArray(a2, b2) {
  var nb = b2 ? b2.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i2;
  for (i2 = 0; i2 < na; ++i2) x2[i2] = interpolate(a2[i2], b2[i2]);
  for (; i2 < nb; ++i2) c2[i2] = b2[i2];
  return function(t2) {
    for (i2 = 0; i2 < na; ++i2) c2[i2] = x2[i2](t2);
    return c2;
  };
}
function date$1(a2, b2) {
  var d2 = /* @__PURE__ */ new Date();
  return a2 = +a2, b2 = +b2, function(t2) {
    return d2.setTime(a2 * (1 - t2) + b2 * t2), d2;
  };
}
function interpolateNumber(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t2) {
    return a2 * (1 - t2) + b2 * t2;
  };
}
function object(a2, b2) {
  var i2 = {}, c2 = {}, k2;
  if (a2 === null || typeof a2 !== "object") a2 = {};
  if (b2 === null || typeof b2 !== "object") b2 = {};
  for (k2 in b2) {
    if (k2 in a2) {
      i2[k2] = interpolate(a2[k2], b2[k2]);
    } else {
      c2[k2] = b2[k2];
    }
  }
  return function(t2) {
    for (k2 in i2) c2[k2] = i2[k2](t2);
    return c2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t2) {
    return b2(t2) + "";
  };
}
function string(a2, b2) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s2 = [], q2 = [];
  a2 = a2 + "", b2 = b2 + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b2))) {
    if ((bs = bm.index) > bi) {
      bs = b2.slice(bi, bs);
      if (s2[i2]) s2[i2] += bs;
      else s2[++i2] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i2]) s2[i2] += bm;
      else s2[++i2] = bm;
    } else {
      s2[++i2] = null;
      q2.push({ i: i2, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b2.length) {
    bs = b2.slice(bi);
    if (s2[i2]) s2[i2] += bs;
    else s2[++i2] = bs;
  }
  return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero(b2) : (b2 = q2.length, function(t2) {
    for (var i3 = 0, o2; i3 < b2; ++i3) s2[(o2 = q2[i3]).i] = o2.x(t2);
    return s2.join("");
  });
}
function interpolate(a2, b2) {
  var t2 = typeof b2, c2;
  return b2 == null || t2 === "boolean" ? constant(b2) : (t2 === "number" ? interpolateNumber : t2 === "string" ? (c2 = color(b2)) ? (b2 = c2, rgb) : string : b2 instanceof color ? rgb : b2 instanceof Date ? date$1 : isNumberArray(b2) ? numberArray : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object : interpolateNumber)(a2, b2);
}
function interpolateRound(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t2) {
    return Math.round(a2 * (1 - t2) + b2 * t2);
  };
}
function piecewise(interpolate$12, values) {
  if (values === void 0) values = interpolate$12, interpolate$12 = interpolate;
  var i2 = 0, n2 = values.length - 1, v2 = values[0], I2 = new Array(n2 < 0 ? 0 : n2);
  while (i2 < n2) I2[i2] = interpolate$12(v2, v2 = values[++i2]);
  return function(t2) {
    var i3 = Math.max(0, Math.min(n2 - 1, Math.floor(t2 *= n2)));
    return I2[i3](t2 - i3);
  };
}
function constants(x2) {
  return function() {
    return x2;
  };
}
function number$1(x2) {
  return +x2;
}
var unit = [0, 1];
function identity$3(x2) {
  return x2;
}
function normalize(a2, b2) {
  return (b2 -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b2;
  } : constants(isNaN(b2) ? NaN : 0.5);
}
function clamper(a2, b2) {
  var t2;
  if (a2 > b2) t2 = a2, a2 = b2, b2 = t2;
  return function(x2) {
    return Math.max(a2, Math.min(b2, x2));
  };
}
function bimap(domain2, range2, interpolate2) {
  var d0 = domain2[0], d1 = domain2[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain2, range2, interpolate2) {
  var j2 = Math.min(domain2.length, range2.length) - 1, d2 = new Array(j2), r2 = new Array(j2), i2 = -1;
  if (domain2[j2] < domain2[0]) {
    domain2 = domain2.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i2 < j2) {
    d2[i2] = normalize(domain2[i2], domain2[i2 + 1]);
    r2[i2] = interpolate2(range2[i2], range2[i2 + 1]);
  }
  return function(x2) {
    var i3 = bisectRight(domain2, x2, 1, j2) - 1;
    return r2[i3](d2[i3](x2));
  };
}
function copy$1(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$2() {
  var domain2 = unit, range2 = unit, interpolate$12 = interpolate, transform, untransform, unknown, clamp = identity$3, piecewise2, output, input;
  function rescale() {
    var n2 = Math.min(domain2.length, range2.length);
    if (clamp !== identity$3) clamp = clamper(domain2[0], domain2[n2 - 1]);
    piecewise2 = n2 > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain2.map(transform), range2, interpolate$12)))(transform(clamp(x2)));
  }
  scale.invert = function(y2) {
    return clamp(untransform((input || (input = piecewise2(range2, domain2.map(transform), interpolateNumber)))(y2)));
  };
  scale.domain = function(_2) {
    return arguments.length ? (domain2 = Array.from(_2, number$1), rescale()) : domain2.slice();
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = Array.from(_2), rescale()) : range2.slice();
  };
  scale.rangeRound = function(_2) {
    return range2 = Array.from(_2), interpolate$12 = interpolateRound, rescale();
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = _2 ? true : identity$3, rescale()) : clamp !== identity$3;
  };
  scale.interpolate = function(_2) {
    return arguments.length ? (interpolate$12 = _2, rescale()) : interpolate$12;
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t2, u2) {
    transform = t2, untransform = u2;
    return rescale();
  };
}
function continuous() {
  return transformer$2()(identity$3, identity$3);
}
function formatDecimal(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p2) {
  if ((i2 = (x2 = p2 ? x2.toExponential(p2 - 1) : x2.toExponential()).indexOf("e")) < 0) return null;
  var i2, coefficient = x2.slice(0, i2);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i2 + 1)
  ];
}
function exponent(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i2 = value.length, t2 = [], j2 = 0, g2 = grouping[0], length = 0;
    while (i2 > 0 && g2 > 0) {
      if (length + g2 + 1 > width) g2 = Math.max(1, width - length);
      t2.push(value.substring(i2 -= g2, i2 + g2));
      if ((length += g2 + 1) > width) break;
      g2 = grouping[j2 = (j2 + 1) % grouping.length];
    }
    return t2.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i2) {
      return numerals[+i2];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s2) {
  out: for (var n2 = s2.length, i2 = 1, i0 = -1, i1; i2 < n2; ++i2) {
    switch (s2[i2]) {
      case ".":
        i0 = i1 = i2;
        break;
      case "0":
        if (i0 === 0) i0 = i2;
        i1 = i2;
        break;
      default:
        if (!+s2[i2]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}
var prefixExponent;
function formatPrefixAuto(x2, p2) {
  var d2 = formatDecimalParts(x2, p2);
  if (!d2) return x2 + "";
  var coefficient = d2[0], exponent2 = d2[1], i2 = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n2 = coefficient.length;
  return i2 === n2 ? coefficient : i2 > n2 ? coefficient + new Array(i2 - n2 + 1).join("0") : i2 > 0 ? coefficient.slice(0, i2) + "." + coefficient.slice(i2) : "0." + new Array(1 - i2).join("0") + formatDecimalParts(x2, Math.max(0, p2 + i2 - 1))[0];
}
function formatRounded(x2, p2) {
  var d2 = formatDecimalParts(x2, p2);
  if (!d2) return x2 + "";
  var coefficient = d2[0], exponent2 = d2[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes = {
  "%": (x2, p2) => (x2 * 100).toFixed(p2),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal,
  "e": (x2, p2) => x2.toExponential(p2),
  "f": (x2, p2) => x2.toFixed(p2),
  "g": (x2, p2) => x2.toPrecision(p2),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p2) => formatRounded(x2 * 100, p2),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};
function identity$2(x2) {
  return x2;
}
var map$3 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale$1(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$2 : formatGroup(map$3.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$2 : formatNumerals(map$3.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero2 || fill === "0" && align === "=") zero2 = true, fill = "0", align = "=";
    var prefix2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix2, valueSuffix = suffix, i2, n2, c2;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim) value = formatTrim(value);
        if (valueNegative && +value === 0 && sign2 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i2 = -1, n2 = value.length;
          while (++i2 < n2) {
            if (c2 = value.charCodeAt(i2), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value.slice(i2 + 1) : value.slice(i2)) + valueSuffix;
              value = value.slice(0, i2);
              break;
            }
          }
        }
      }
      if (comma && !zero2) value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k2 = Math.pow(10, -e3), prefix2 = prefixes[8 + e3 / 3];
    return function(value2) {
      return f2(k2 * value2) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale$1;
var format;
var formatPrefix;
defaultLocale$1({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  format = locale$1.format;
  formatPrefix = locale$1.formatPrefix;
  return locale$1;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent(max2) - exponent(step)) + 1;
}
function tickFormat(start, stop, count, specifier) {
  var step = tickStep(start, stop, count), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}
function linearish(scale) {
  var domain2 = scale.domain;
  scale.ticks = function(count) {
    var d2 = domain2();
    return ticks(d2[0], d2[d2.length - 1], count == null ? 10 : count);
  };
  scale.tickFormat = function(count, specifier) {
    var d2 = domain2();
    return tickFormat(d2[0], d2[d2.length - 1], count == null ? 10 : count, specifier);
  };
  scale.nice = function(count) {
    if (count == null) count = 10;
    var d2 = domain2();
    var i0 = 0;
    var i1 = d2.length - 1;
    var start = d2[i0];
    var stop = d2[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count);
      if (step === prestep) {
        d2[i0] = start;
        d2[i1] = stop;
        return domain2(d2);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = continuous();
  scale.copy = function() {
    return copy$1(scale, linear());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
function identity$1(domain2) {
  var unknown;
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : x2;
  }
  scale.invert = scale;
  scale.domain = scale.range = function(_2) {
    return arguments.length ? (domain2 = Array.from(_2, number$1), scale) : domain2.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return identity$1(domain2).unknown(unknown);
  };
  domain2 = arguments.length ? Array.from(domain2, number$1) : [0, 1];
  return linearish(scale);
}
function nice(domain2, interval) {
  domain2 = domain2.slice();
  var i0 = 0, i1 = domain2.length - 1, x0 = domain2[i0], x1 = domain2[i1], t2;
  if (x1 < x0) {
    t2 = i0, i0 = i1, i1 = t2;
    t2 = x0, x0 = x1, x1 = t2;
  }
  domain2[i0] = interval.floor(x0);
  domain2[i1] = interval.ceil(x1);
  return domain2;
}
function transformLog(x2) {
  return Math.log(x2);
}
function transformExp(x2) {
  return Math.exp(x2);
}
function transformLogn(x2) {
  return -Math.log(-x2);
}
function transformExpn(x2) {
  return -Math.exp(-x2);
}
function pow10(x2) {
  return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x2) => Math.pow(base, x2);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x2) => Math.log(x2) / base);
}
function reflect(f2) {
  return (x2, k2) => -f2(-x2, k2);
}
function loggish(transform) {
  const scale = transform(transformLog, transformExp);
  const domain2 = scale.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain2()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function(_2) {
    return arguments.length ? (base = +_2, rescale()) : base;
  };
  scale.domain = function(_2) {
    return arguments.length ? (domain2(_2), rescale()) : domain2();
  };
  scale.ticks = (count) => {
    const d2 = domain2();
    let u2 = d2[0];
    let v2 = d2[d2.length - 1];
    const r2 = v2 < u2;
    if (r2) [u2, v2] = [v2, u2];
    let i2 = logs(u2);
    let j2 = logs(v2);
    let k2;
    let t2;
    const n2 = count == null ? 10 : +count;
    let z2 = [];
    if (!(base % 1) && j2 - i2 < n2) {
      i2 = Math.floor(i2), j2 = Math.ceil(j2);
      if (u2 > 0) for (; i2 <= j2; ++i2) {
        for (k2 = 1; k2 < base; ++k2) {
          t2 = i2 < 0 ? k2 / pows(-i2) : k2 * pows(i2);
          if (t2 < u2) continue;
          if (t2 > v2) break;
          z2.push(t2);
        }
      }
      else for (; i2 <= j2; ++i2) {
        for (k2 = base - 1; k2 >= 1; --k2) {
          t2 = i2 > 0 ? k2 / pows(-i2) : k2 * pows(i2);
          if (t2 < u2) continue;
          if (t2 > v2) break;
          z2.push(t2);
        }
      }
      if (z2.length * 2 < n2) z2 = ticks(u2, v2, n2);
    } else {
      z2 = ticks(i2, j2, Math.min(j2 - i2, n2)).map(pows);
    }
    return r2 ? z2.reverse() : z2;
  };
  scale.tickFormat = (count, specifier) => {
    if (count == null) count = 10;
    if (specifier == null) specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
      specifier = format(specifier);
    }
    if (count === Infinity) return specifier;
    const k2 = Math.max(1, base * count / scale.ticks().length);
    return (d2) => {
      let i2 = d2 / pows(Math.round(logs(d2)));
      if (i2 * base < base - 0.5) i2 *= base;
      return i2 <= k2 ? specifier(d2) : "";
    };
  };
  scale.nice = () => {
    return domain2(nice(domain2(), {
      floor: (x2) => pows(Math.floor(logs(x2))),
      ceil: (x2) => pows(Math.ceil(logs(x2)))
    }));
  };
  return scale;
}
function log() {
  const scale = loggish(transformer$2()).domain([1, 10]);
  scale.copy = () => copy$1(scale, log()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}
function transformSymlog(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
  };
}
function transformSymexp(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
  };
}
function symlogish(transform) {
  var c2 = 1, scale = transform(transformSymlog(c2), transformSymexp(c2));
  scale.constant = function(_2) {
    return arguments.length ? transform(transformSymlog(c2 = +_2), transformSymexp(c2)) : c2;
  };
  return linearish(scale);
}
function symlog() {
  var scale = symlogish(transformer$2());
  scale.copy = function() {
    return copy$1(scale, symlog()).constant(scale.constant());
  };
  return initRange.apply(scale, arguments);
}
function transformPow(exponent2) {
  return function(x2) {
    return x2 < 0 ? -Math.pow(-x2, exponent2) : Math.pow(x2, exponent2);
  };
}
function transformSqrt(x2) {
  return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
}
function transformSquare(x2) {
  return x2 < 0 ? -x2 * x2 : x2 * x2;
}
function powish(transform) {
  var scale = transform(identity$3, identity$3), exponent2 = 1;
  function rescale() {
    return exponent2 === 1 ? transform(identity$3, identity$3) : exponent2 === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent2), transformPow(1 / exponent2));
  }
  scale.exponent = function(_2) {
    return arguments.length ? (exponent2 = +_2, rescale()) : exponent2;
  };
  return linearish(scale);
}
function pow() {
  var scale = powish(transformer$2());
  scale.copy = function() {
    return copy$1(scale, pow()).exponent(scale.exponent());
  };
  initRange.apply(scale, arguments);
  return scale;
}
function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}
function square(x2) {
  return Math.sign(x2) * x2 * x2;
}
function unsquare(x2) {
  return Math.sign(x2) * Math.sqrt(Math.abs(x2));
}
function radial() {
  var squared = continuous(), range2 = [0, 1], round2 = false, unknown;
  function scale(x2) {
    var y2 = unsquare(squared(x2));
    return isNaN(y2) ? unknown : round2 ? Math.round(y2) : y2;
  }
  scale.invert = function(y2) {
    return squared.invert(square(y2));
  };
  scale.domain = function(_2) {
    return arguments.length ? (squared.domain(_2), scale) : squared.domain();
  };
  scale.range = function(_2) {
    return arguments.length ? (squared.range((range2 = Array.from(_2, number$1)).map(square)), scale) : range2.slice();
  };
  scale.rangeRound = function(_2) {
    return scale.range(_2).round(true);
  };
  scale.round = function(_2) {
    return arguments.length ? (round2 = !!_2, scale) : round2;
  };
  scale.clamp = function(_2) {
    return arguments.length ? (squared.clamp(_2), scale) : squared.clamp();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return radial(squared.domain(), range2).round(round2).clamp(squared.clamp()).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
function quantile() {
  var domain2 = [], range2 = [], thresholds = [], unknown;
  function rescale() {
    var i2 = 0, n2 = Math.max(1, range2.length);
    thresholds = new Array(n2 - 1);
    while (++i2 < n2) thresholds[i2 - 1] = quantileSorted(domain2, i2 / n2);
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : range2[bisectRight(thresholds, x2)];
  }
  scale.invertExtent = function(y2) {
    var i2 = range2.indexOf(y2);
    return i2 < 0 ? [NaN, NaN] : [
      i2 > 0 ? thresholds[i2 - 1] : domain2[0],
      i2 < thresholds.length ? thresholds[i2] : domain2[domain2.length - 1]
    ];
  };
  scale.domain = function(_2) {
    if (!arguments.length) return domain2.slice();
    domain2 = [];
    for (let d2 of _2) if (d2 != null && !isNaN(d2 = +d2)) domain2.push(d2);
    domain2.sort(ascending);
    return rescale();
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = Array.from(_2), rescale()) : range2.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.quantiles = function() {
    return thresholds.slice();
  };
  scale.copy = function() {
    return quantile().domain(domain2).range(range2).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}
function quantize() {
  var x0 = 0, x1 = 1, n2 = 1, domain2 = [0.5], range2 = [0, 1], unknown;
  function scale(x2) {
    return x2 != null && x2 <= x2 ? range2[bisectRight(domain2, x2, 0, n2)] : unknown;
  }
  function rescale() {
    var i2 = -1;
    domain2 = new Array(n2);
    while (++i2 < n2) domain2[i2] = ((i2 + 1) * x1 - (i2 - n2) * x0) / (n2 + 1);
    return scale;
  }
  scale.domain = function(_2) {
    return arguments.length ? ([x0, x1] = _2, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };
  scale.range = function(_2) {
    return arguments.length ? (n2 = (range2 = Array.from(_2)).length - 1, rescale()) : range2.slice();
  };
  scale.invertExtent = function(y2) {
    var i2 = range2.indexOf(y2);
    return i2 < 0 ? [NaN, NaN] : i2 < 1 ? [x0, domain2[0]] : i2 >= n2 ? [domain2[n2 - 1], x1] : [domain2[i2 - 1], domain2[i2]];
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : scale;
  };
  scale.thresholds = function() {
    return domain2.slice();
  };
  scale.copy = function() {
    return quantize().domain([x0, x1]).range(range2).unknown(unknown);
  };
  return initRange.apply(linearish(scale), arguments);
}
function threshold() {
  var domain2 = [0.5], range2 = [0, 1], unknown, n2 = 1;
  function scale(x2) {
    return x2 != null && x2 <= x2 ? range2[bisectRight(domain2, x2, 0, n2)] : unknown;
  }
  scale.domain = function(_2) {
    return arguments.length ? (domain2 = Array.from(_2), n2 = Math.min(domain2.length, range2.length - 1), scale) : domain2.slice();
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = Array.from(_2), n2 = Math.min(domain2.length, range2.length - 1), scale) : range2.slice();
  };
  scale.invertExtent = function(y2) {
    var i2 = range2.indexOf(y2);
    return [domain2[i2 - 1], domain2[i2]];
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return threshold().domain(domain2).range(range2).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}
const t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count, field) {
  function interval(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval.round = (date2) => {
    const d0 = interval(date2), d1 = interval.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval.range = (start, stop, step) => {
    const range2 = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range2;
    let previous;
    do
      range2.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range2;
  };
  interval.filter = (test) => {
    return timeInterval((date2) => {
      if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date2, -1), !test(date2)) {
          }
        }
        else while (--step >= 0) {
          while (offseti(date2, 1), !test(date2)) {
          }
        }
      }
    });
  };
  if (count) {
    interval.count = (start, end) => {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };
    interval.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d2) => field(d2) % step === 0 : (d2) => interval.count(0, d2) % step === 0);
    };
  }
  return interval;
}
const millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start, end) => {
  return end - start;
});
millisecond.every = (k2) => {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0)) return null;
  if (!(k2 > 1)) return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k2) * k2);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k2);
  }, (start, end) => {
    return (end - start) / k2;
  });
};
millisecond.range;
const durationSecond = 1e3;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;
const second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
second.range;
const timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
timeMinute.range;
const utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
utcMinute.range;
const timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getHours();
});
timeHour.range;
const utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
utcHour.range;
const timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
timeDay.range;
const utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
utcDay.range;
const unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
unixDay.range;
function timeWeekday(i2) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i2) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
const timeSunday = timeWeekday(0);
const timeMonday = timeWeekday(1);
const timeTuesday = timeWeekday(2);
const timeWednesday = timeWeekday(3);
const timeThursday = timeWeekday(4);
const timeFriday = timeWeekday(5);
const timeSaturday = timeWeekday(6);
timeSunday.range;
timeMonday.range;
timeTuesday.range;
timeWednesday.range;
timeThursday.range;
timeFriday.range;
timeSaturday.range;
function utcWeekday(i2) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i2) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}
const utcSunday = utcWeekday(0);
const utcMonday = utcWeekday(1);
const utcTuesday = utcWeekday(2);
const utcWednesday = utcWeekday(3);
const utcThursday = utcWeekday(4);
const utcFriday = utcWeekday(5);
const utcSaturday = utcWeekday(6);
utcSunday.range;
utcMonday.range;
utcTuesday.range;
utcWednesday.range;
utcThursday.range;
utcFriday.range;
utcSaturday.range;
const timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
timeMonth.range;
const utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
utcMonth.range;
const timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k2);
  });
};
timeYear.range;
const utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
  });
};
utcYear.range;
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start, stop, count) {
    const reverse2 = stop < start;
    if (reverse2) [start, stop] = [stop, start];
    const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
    const ticks3 = interval ? interval.range(start, +stop + 1) : [];
    return reverse2 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start, stop, count) {
    const target = Math.abs(stop - start) / count;
    const i2 = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i2 === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
    if (i2 === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
    const [t2, step] = tickIntervals[target / tickIntervals[i2 - 1][2] < tickIntervals[i2][2] / target ? i2 - 1 : i2];
    return t2.every(step);
  }
  return [ticks2, tickInterval];
}
const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
function localDate(d2) {
  if (0 <= d2.y && d2.y < 100) {
    var date2 = new Date(-1, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L);
    date2.setFullYear(d2.y);
    return date2;
  }
  return new Date(d2.y, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L);
}
function utcDate(d2) {
  if (0 <= d2.y && d2.y < 100) {
    var date2 = new Date(Date.UTC(-1, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L));
    date2.setUTCFullYear(d2.y);
    return date2;
  }
  return new Date(Date.UTC(d2.y, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L));
}
function newDate(y2, m2, d2) {
  return { y: y2, m: m2, d: d2, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale2) {
  var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string2 = [], i2 = -1, j2 = 0, n2 = specifier.length, c2, pad2, format2;
      if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
      while (++i2 < n2) {
        if (specifier.charCodeAt(i2) === 37) {
          string2.push(specifier.slice(j2, i2));
          if ((pad2 = pads[c2 = specifier.charAt(++i2)]) != null) c2 = specifier.charAt(++i2);
          else pad2 = c2 === "e" ? " " : "0";
          if (format2 = formats2[c2]) c2 = format2(date2, pad2);
          string2.push(c2);
          j2 = i2 + 1;
        }
      }
      string2.push(specifier.slice(j2, i2));
      return string2.join("");
    };
  }
  function newParse(specifier, Z2) {
    return function(string2) {
      var d2 = newDate(1900, void 0, 1), i2 = parseSpecifier(d2, specifier, string2 += "", 0), week, day;
      if (i2 != string2.length) return null;
      if ("Q" in d2) return new Date(d2.Q);
      if ("s" in d2) return new Date(d2.s * 1e3 + ("L" in d2 ? d2.L : 0));
      if (Z2 && !("Z" in d2)) d2.Z = 0;
      if ("p" in d2) d2.H = d2.H % 12 + d2.p * 12;
      if (d2.m === void 0) d2.m = "q" in d2 ? d2.q : 0;
      if ("V" in d2) {
        if (d2.V < 1 || d2.V > 53) return null;
        if (!("w" in d2)) d2.w = 1;
        if ("Z" in d2) {
          week = utcDate(newDate(d2.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d2.V - 1) * 7);
          d2.y = week.getUTCFullYear();
          d2.m = week.getUTCMonth();
          d2.d = week.getUTCDate() + (d2.w + 6) % 7;
        } else {
          week = localDate(newDate(d2.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d2.V - 1) * 7);
          d2.y = week.getFullYear();
          d2.m = week.getMonth();
          d2.d = week.getDate() + (d2.w + 6) % 7;
        }
      } else if ("W" in d2 || "U" in d2) {
        if (!("w" in d2)) d2.w = "u" in d2 ? d2.u % 7 : "W" in d2 ? 1 : 0;
        day = "Z" in d2 ? utcDate(newDate(d2.y, 0, 1)).getUTCDay() : localDate(newDate(d2.y, 0, 1)).getDay();
        d2.m = 0;
        d2.d = "W" in d2 ? (d2.w + 6) % 7 + d2.W * 7 - (day + 5) % 7 : d2.w + d2.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d2) {
        d2.H += d2.Z / 100 | 0;
        d2.M += d2.Z % 100;
        return utcDate(d2);
      }
      return localDate(d2);
    };
  }
  function parseSpecifier(d2, specifier, string2, j2) {
    var i2 = 0, n2 = specifier.length, m2 = string2.length, c2, parse2;
    while (i2 < n2) {
      if (j2 >= m2) return -1;
      c2 = specifier.charCodeAt(i2++);
      if (c2 === 37) {
        c2 = specifier.charAt(i2++);
        parse2 = parses[c2 in pads ? specifier.charAt(i2++) : c2];
        if (!parse2 || (j2 = parse2(d2, string2, j2)) < 0) return -1;
      } else if (c2 != string2.charCodeAt(j2++)) {
        return -1;
      }
    }
    return j2;
  }
  function parsePeriod(d2, string2, i2) {
    var n2 = periodRe.exec(string2.slice(i2));
    return n2 ? (d2.p = periodLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseShortWeekday(d2, string2, i2) {
    var n2 = shortWeekdayRe.exec(string2.slice(i2));
    return n2 ? (d2.w = shortWeekdayLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseWeekday(d2, string2, i2) {
    var n2 = weekdayRe.exec(string2.slice(i2));
    return n2 ? (d2.w = weekdayLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseShortMonth(d2, string2, i2) {
    var n2 = shortMonthRe.exec(string2.slice(i2));
    return n2 ? (d2.m = shortMonthLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseMonth(d2, string2, i2) {
    var n2 = monthRe.exec(string2.slice(i2));
    return n2 ? (d2.m = monthLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseLocaleDateTime(d2, string2, i2) {
    return parseSpecifier(d2, locale_dateTime, string2, i2);
  }
  function parseLocaleDate(d2, string2, i2) {
    return parseSpecifier(d2, locale_date, string2, i2);
  }
  function parseLocaleTime(d2, string2, i2) {
    return parseSpecifier(d2, locale_time, string2, i2);
  }
  function formatShortWeekday(d2) {
    return locale_shortWeekdays[d2.getDay()];
  }
  function formatWeekday(d2) {
    return locale_weekdays[d2.getDay()];
  }
  function formatShortMonth(d2) {
    return locale_shortMonths[d2.getMonth()];
  }
  function formatMonth(d2) {
    return locale_months[d2.getMonth()];
  }
  function formatPeriod(d2) {
    return locale_periods[+(d2.getHours() >= 12)];
  }
  function formatQuarter(d2) {
    return 1 + ~~(d2.getMonth() / 3);
  }
  function formatUTCShortWeekday(d2) {
    return locale_shortWeekdays[d2.getUTCDay()];
  }
  function formatUTCWeekday(d2) {
    return locale_weekdays[d2.getUTCDay()];
  }
  function formatUTCShortMonth(d2) {
    return locale_shortMonths[d2.getUTCMonth()];
  }
  function formatUTCMonth(d2) {
    return locale_months[d2.getUTCMonth()];
  }
  function formatUTCPeriod(d2) {
    return locale_periods[+(d2.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d2) {
    return 1 + ~~(d2.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f2 = newFormat(specifier += "", formats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    parse: function(specifier) {
      var p2 = newParse(specifier += "", false);
      p2.toString = function() {
        return specifier;
      };
      return p2;
    },
    utcFormat: function(specifier) {
      var f2 = newFormat(specifier += "", utcFormats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    utcParse: function(specifier) {
      var p2 = newParse(specifier += "", true);
      p2.toString = function() {
        return specifier;
      };
      return p2;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
  var sign2 = value < 0 ? "-" : "", string2 = (sign2 ? -value : value) + "", length = string2.length;
  return sign2 + (length < width ? new Array(width - length + 1).join(fill) + string2 : string2);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i2) => [name.toLowerCase(), i2]));
}
function parseWeekdayNumberSunday(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 1));
  return n2 ? (d2.w = +n2[0], i2 + n2[0].length) : -1;
}
function parseWeekdayNumberMonday(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 1));
  return n2 ? (d2.u = +n2[0], i2 + n2[0].length) : -1;
}
function parseWeekNumberSunday(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d2.U = +n2[0], i2 + n2[0].length) : -1;
}
function parseWeekNumberISO(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d2.V = +n2[0], i2 + n2[0].length) : -1;
}
function parseWeekNumberMonday(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d2.W = +n2[0], i2 + n2[0].length) : -1;
}
function parseFullYear(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 4));
  return n2 ? (d2.y = +n2[0], i2 + n2[0].length) : -1;
}
function parseYear(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d2.y = +n2[0] + (+n2[0] > 68 ? 1900 : 2e3), i2 + n2[0].length) : -1;
}
function parseZone(d2, string2, i2) {
  var n2 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i2, i2 + 6));
  return n2 ? (d2.Z = n2[1] ? 0 : -(n2[2] + (n2[3] || "00")), i2 + n2[0].length) : -1;
}
function parseQuarter(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 1));
  return n2 ? (d2.q = n2[0] * 3 - 3, i2 + n2[0].length) : -1;
}
function parseMonthNumber(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d2.m = n2[0] - 1, i2 + n2[0].length) : -1;
}
function parseDayOfMonth(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d2.d = +n2[0], i2 + n2[0].length) : -1;
}
function parseDayOfYear(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 3));
  return n2 ? (d2.m = 0, d2.d = +n2[0], i2 + n2[0].length) : -1;
}
function parseHour24(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d2.H = +n2[0], i2 + n2[0].length) : -1;
}
function parseMinutes(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d2.M = +n2[0], i2 + n2[0].length) : -1;
}
function parseSeconds(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 2));
  return n2 ? (d2.S = +n2[0], i2 + n2[0].length) : -1;
}
function parseMilliseconds(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 3));
  return n2 ? (d2.L = +n2[0], i2 + n2[0].length) : -1;
}
function parseMicroseconds(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2, i2 + 6));
  return n2 ? (d2.L = Math.floor(n2[0] / 1e3), i2 + n2[0].length) : -1;
}
function parseLiteralPercent(d2, string2, i2) {
  var n2 = percentRe.exec(string2.slice(i2, i2 + 1));
  return n2 ? i2 + n2[0].length : -1;
}
function parseUnixTimestamp(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2));
  return n2 ? (d2.Q = +n2[0], i2 + n2[0].length) : -1;
}
function parseUnixTimestampSeconds(d2, string2, i2) {
  var n2 = numberRe.exec(string2.slice(i2));
  return n2 ? (d2.s = +n2[0], i2 + n2[0].length) : -1;
}
function formatDayOfMonth(d2, p2) {
  return pad(d2.getDate(), p2, 2);
}
function formatHour24(d2, p2) {
  return pad(d2.getHours(), p2, 2);
}
function formatHour12(d2, p2) {
  return pad(d2.getHours() % 12 || 12, p2, 2);
}
function formatDayOfYear(d2, p2) {
  return pad(1 + timeDay.count(timeYear(d2), d2), p2, 3);
}
function formatMilliseconds(d2, p2) {
  return pad(d2.getMilliseconds(), p2, 3);
}
function formatMicroseconds(d2, p2) {
  return formatMilliseconds(d2, p2) + "000";
}
function formatMonthNumber(d2, p2) {
  return pad(d2.getMonth() + 1, p2, 2);
}
function formatMinutes(d2, p2) {
  return pad(d2.getMinutes(), p2, 2);
}
function formatSeconds(d2, p2) {
  return pad(d2.getSeconds(), p2, 2);
}
function formatWeekdayNumberMonday(d2) {
  var day = d2.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d2, p2) {
  return pad(timeSunday.count(timeYear(d2) - 1, d2), p2, 2);
}
function dISO(d2) {
  var day = d2.getDay();
  return day >= 4 || day === 0 ? timeThursday(d2) : timeThursday.ceil(d2);
}
function formatWeekNumberISO(d2, p2) {
  d2 = dISO(d2);
  return pad(timeThursday.count(timeYear(d2), d2) + (timeYear(d2).getDay() === 4), p2, 2);
}
function formatWeekdayNumberSunday(d2) {
  return d2.getDay();
}
function formatWeekNumberMonday(d2, p2) {
  return pad(timeMonday.count(timeYear(d2) - 1, d2), p2, 2);
}
function formatYear(d2, p2) {
  return pad(d2.getFullYear() % 100, p2, 2);
}
function formatYearISO(d2, p2) {
  d2 = dISO(d2);
  return pad(d2.getFullYear() % 100, p2, 2);
}
function formatFullYear(d2, p2) {
  return pad(d2.getFullYear() % 1e4, p2, 4);
}
function formatFullYearISO(d2, p2) {
  var day = d2.getDay();
  d2 = day >= 4 || day === 0 ? timeThursday(d2) : timeThursday.ceil(d2);
  return pad(d2.getFullYear() % 1e4, p2, 4);
}
function formatZone(d2) {
  var z2 = d2.getTimezoneOffset();
  return (z2 > 0 ? "-" : (z2 *= -1, "+")) + pad(z2 / 60 | 0, "0", 2) + pad(z2 % 60, "0", 2);
}
function formatUTCDayOfMonth(d2, p2) {
  return pad(d2.getUTCDate(), p2, 2);
}
function formatUTCHour24(d2, p2) {
  return pad(d2.getUTCHours(), p2, 2);
}
function formatUTCHour12(d2, p2) {
  return pad(d2.getUTCHours() % 12 || 12, p2, 2);
}
function formatUTCDayOfYear(d2, p2) {
  return pad(1 + utcDay.count(utcYear(d2), d2), p2, 3);
}
function formatUTCMilliseconds(d2, p2) {
  return pad(d2.getUTCMilliseconds(), p2, 3);
}
function formatUTCMicroseconds(d2, p2) {
  return formatUTCMilliseconds(d2, p2) + "000";
}
function formatUTCMonthNumber(d2, p2) {
  return pad(d2.getUTCMonth() + 1, p2, 2);
}
function formatUTCMinutes(d2, p2) {
  return pad(d2.getUTCMinutes(), p2, 2);
}
function formatUTCSeconds(d2, p2) {
  return pad(d2.getUTCSeconds(), p2, 2);
}
function formatUTCWeekdayNumberMonday(d2) {
  var dow = d2.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d2, p2) {
  return pad(utcSunday.count(utcYear(d2) - 1, d2), p2, 2);
}
function UTCdISO(d2) {
  var day = d2.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d2) : utcThursday.ceil(d2);
}
function formatUTCWeekNumberISO(d2, p2) {
  d2 = UTCdISO(d2);
  return pad(utcThursday.count(utcYear(d2), d2) + (utcYear(d2).getUTCDay() === 4), p2, 2);
}
function formatUTCWeekdayNumberSunday(d2) {
  return d2.getUTCDay();
}
function formatUTCWeekNumberMonday(d2, p2) {
  return pad(utcMonday.count(utcYear(d2) - 1, d2), p2, 2);
}
function formatUTCYear(d2, p2) {
  return pad(d2.getUTCFullYear() % 100, p2, 2);
}
function formatUTCYearISO(d2, p2) {
  d2 = UTCdISO(d2);
  return pad(d2.getUTCFullYear() % 100, p2, 2);
}
function formatUTCFullYear(d2, p2) {
  return pad(d2.getUTCFullYear() % 1e4, p2, 4);
}
function formatUTCFullYearISO(d2, p2) {
  var day = d2.getUTCDay();
  d2 = day >= 4 || day === 0 ? utcThursday(d2) : utcThursday.ceil(d2);
  return pad(d2.getUTCFullYear() % 1e4, p2, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d2) {
  return +d2;
}
function formatUnixTimestampSeconds(d2) {
  return Math.floor(+d2 / 1e3);
}
var locale;
var timeFormat;
var utcFormat;
defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  timeFormat = locale.format;
  locale.parse;
  utcFormat = locale.utcFormat;
  locale.utcParse;
  return locale;
}
function date(t2) {
  return new Date(t2);
}
function number(t2) {
  return t2 instanceof Date ? +t2 : +/* @__PURE__ */ new Date(+t2);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
  var scale = continuous(), invert = scale.invert, domain2 = scale.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale.invert = function(y2) {
    return new Date(invert(y2));
  };
  scale.domain = function(_2) {
    return arguments.length ? domain2(Array.from(_2, number)) : domain2().map(date);
  };
  scale.ticks = function(interval) {
    var d2 = domain2();
    return ticks2(d2[0], d2[d2.length - 1], interval == null ? 10 : interval);
  };
  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale.nice = function(interval) {
    var d2 = domain2();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d2[0], d2[d2.length - 1], interval == null ? 10 : interval);
    return interval ? domain2(nice(d2, interval)) : scale;
  };
  scale.copy = function() {
    return copy$1(scale, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
  };
  return scale;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function transformer$1() {
  var x0 = 0, x1 = 1, t02, t12, k10, transform, interpolator = identity$3, clamp = false, unknown;
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform(x2) - t02) * k10, clamp ? Math.max(0, Math.min(1, x2)) : x2));
  }
  scale.domain = function(_2) {
    return arguments.length ? ([x0, x1] = _2, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale) : [x0, x1];
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = !!_2, scale) : clamp;
  };
  scale.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale) : interpolator;
  };
  function range2(interpolate2) {
    return function(_2) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _2, interpolator = interpolate2(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }
  scale.range = range2(interpolate);
  scale.rangeRound = range2(interpolateRound);
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t2) {
    transform = t2, t02 = t2(x0), t12 = t2(x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
    return scale;
  };
}
function copy(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale = linearish(transformer$1()(identity$3));
  scale.copy = function() {
    return copy(scale, sequential());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialLog() {
  var scale = loggish(transformer$1()).domain([1, 10]);
  scale.copy = function() {
    return copy(scale, sequentialLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSymlog() {
  var scale = symlogish(transformer$1());
  scale.copy = function() {
    return copy(scale, sequentialSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialPow() {
  var scale = powish(transformer$1());
  scale.copy = function() {
    return copy(scale, sequentialPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}
function sequentialQuantile() {
  var domain2 = [], interpolator = identity$3;
  function scale(x2) {
    if (x2 != null && !isNaN(x2 = +x2)) return interpolator((bisectRight(domain2, x2, 1) - 1) / (domain2.length - 1));
  }
  scale.domain = function(_2) {
    if (!arguments.length) return domain2.slice();
    domain2 = [];
    for (let d2 of _2) if (d2 != null && !isNaN(d2 = +d2)) domain2.push(d2);
    domain2.sort(ascending);
    return scale;
  };
  scale.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale) : interpolator;
  };
  scale.range = function() {
    return domain2.map((d2, i2) => interpolator(i2 / (domain2.length - 1)));
  };
  scale.quantiles = function(n2) {
    return Array.from({ length: n2 + 1 }, (_2, i2) => quantile$1(domain2, i2 / n2));
  };
  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain2);
  };
  return initInterpolator.apply(scale, arguments);
}
function transformer() {
  var x0 = 0, x1 = 0.5, x2 = 1, s2 = 1, t02, t12, t2, k10, k21, interpolator = identity$3, transform, clamp = false, unknown;
  function scale(x3) {
    return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform(x3)) - t12) * (s2 * x3 < s2 * t12 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x3)) : x3));
  }
  scale.domain = function(_2) {
    return arguments.length ? ([x0, x1, x2] = _2, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t2 ? 0 : 0.5 / (t2 - t12), s2 = t12 < t02 ? -1 : 1, scale) : [x0, x1, x2];
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = !!_2, scale) : clamp;
  };
  scale.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale) : interpolator;
  };
  function range2(interpolate2) {
    return function(_2) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _2, interpolator = piecewise(interpolate2, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale.range = range2(interpolate);
  scale.rangeRound = range2(interpolateRound);
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t3) {
    transform = t3, t02 = t3(x0), t12 = t3(x1), t2 = t3(x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t2 ? 0 : 0.5 / (t2 - t12), s2 = t12 < t02 ? -1 : 1;
    return scale;
  };
}
function diverging() {
  var scale = linearish(transformer()(identity$3));
  scale.copy = function() {
    return copy(scale, diverging());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingLog() {
  var scale = loggish(transformer()).domain([0.1, 1, 10]);
  scale.copy = function() {
    return copy(scale, divergingLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
  var scale = symlogish(transformer());
  scale.copy = function() {
    return copy(scale, divergingSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingPow() {
  var scale = powish(transformer());
  scale.copy = function() {
    return copy(scale, divergingPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}
const d3Scales = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  scaleBand: band,
  scaleDiverging: diverging,
  scaleDivergingLog: divergingLog,
  scaleDivergingPow: divergingPow,
  scaleDivergingSqrt: divergingSqrt,
  scaleDivergingSymlog: divergingSymlog,
  scaleIdentity: identity$1,
  scaleImplicit: implicit,
  scaleLinear: linear,
  scaleLog: log,
  scaleOrdinal: ordinal,
  scalePoint: point,
  scalePow: pow,
  scaleQuantile: quantile,
  scaleQuantize: quantize,
  scaleRadial: radial,
  scaleSequential: sequential,
  scaleSequentialLog: sequentialLog,
  scaleSequentialPow: sequentialPow,
  scaleSequentialQuantile: sequentialQuantile,
  scaleSequentialSqrt: sequentialSqrt,
  scaleSequentialSymlog: sequentialSymlog,
  scaleSqrt: sqrt,
  scaleSymlog: symlog,
  scaleThreshold: threshold,
  scaleTime: time,
  scaleUtc: utcTime,
  tickFormat
}, Symbol.toStringTag, { value: "Module" }));
var selectChartDataWithIndexes = (state) => state.chartData;
var selectChartDataAndAlwaysIgnoreIndexes = createSelector([selectChartDataWithIndexes], (dataState) => {
  var dataEndIndex = dataState.chartData != null ? dataState.chartData.length - 1 : 0;
  return {
    chartData: dataState.chartData,
    computedData: dataState.computedData,
    dataEndIndex,
    dataStartIndex: 0
  };
});
var selectChartDataWithIndexesIfNotInPanorama = (state, _unused1, _unused2, isPanorama) => {
  if (isPanorama) {
    return selectChartDataAndAlwaysIgnoreIndexes(state);
  }
  return selectChartDataWithIndexes(state);
};
function isWellFormedNumberDomain(v2) {
  if (Array.isArray(v2) && v2.length === 2) {
    var [min2, max2] = v2;
    if (isWellBehavedNumber(min2) && isWellBehavedNumber(max2)) {
      return true;
    }
  }
  return false;
}
function extendDomain(providedDomain, boundaryDomain, allowDataOverflow) {
  if (allowDataOverflow) {
    return providedDomain;
  }
  return [Math.min(providedDomain[0], boundaryDomain[0]), Math.max(providedDomain[1], boundaryDomain[1])];
}
function numericalDomainSpecifiedWithoutRequiringData(userDomain, allowDataOverflow) {
  if (!allowDataOverflow) {
    return void 0;
  }
  if (typeof userDomain === "function") {
    return void 0;
  }
  if (Array.isArray(userDomain) && userDomain.length === 2) {
    var [providedMin, providedMax] = userDomain;
    var finalMin, finalMax;
    if (isWellBehavedNumber(providedMin)) {
      finalMin = providedMin;
    } else if (typeof providedMin === "function") {
      return void 0;
    }
    if (isWellBehavedNumber(providedMax)) {
      finalMax = providedMax;
    } else if (typeof providedMax === "function") {
      return void 0;
    }
    var candidate = [finalMin, finalMax];
    if (isWellFormedNumberDomain(candidate)) {
      return candidate;
    }
  }
  return void 0;
}
function parseNumericalUserDomain(userDomain, dataDomain, allowDataOverflow) {
  if (!allowDataOverflow && dataDomain == null) {
    return void 0;
  }
  if (typeof userDomain === "function" && dataDomain != null) {
    try {
      var result = userDomain(dataDomain, allowDataOverflow);
      if (isWellFormedNumberDomain(result)) {
        return extendDomain(result, dataDomain, allowDataOverflow);
      }
    } catch (_unused) {
    }
  }
  if (Array.isArray(userDomain) && userDomain.length === 2) {
    var [providedMin, providedMax] = userDomain;
    var finalMin, finalMax;
    if (providedMin === "auto") {
      if (dataDomain != null) {
        finalMin = Math.min(...dataDomain);
      }
    } else if (isNumber(providedMin)) {
      finalMin = providedMin;
    } else if (typeof providedMin === "function") {
      try {
        if (dataDomain != null) {
          finalMin = providedMin(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0]);
        }
      } catch (_unused2) {
      }
    } else if (typeof providedMin === "string" && MIN_VALUE_REG.test(providedMin)) {
      var match = MIN_VALUE_REG.exec(providedMin);
      if (match == null || dataDomain == null) {
        finalMin = void 0;
      } else {
        var value = +match[1];
        finalMin = dataDomain[0] - value;
      }
    } else {
      finalMin = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0];
    }
    if (providedMax === "auto") {
      if (dataDomain != null) {
        finalMax = Math.max(...dataDomain);
      }
    } else if (isNumber(providedMax)) {
      finalMax = providedMax;
    } else if (typeof providedMax === "function") {
      try {
        if (dataDomain != null) {
          finalMax = providedMax(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1]);
        }
      } catch (_unused3) {
      }
    } else if (typeof providedMax === "string" && MAX_VALUE_REG.test(providedMax)) {
      var _match = MAX_VALUE_REG.exec(providedMax);
      if (_match == null || dataDomain == null) {
        finalMax = void 0;
      } else {
        var _value = +_match[1];
        finalMax = dataDomain[1] + _value;
      }
    } else {
      finalMax = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1];
    }
    var candidate = [finalMin, finalMax];
    if (isWellFormedNumberDomain(candidate)) {
      if (dataDomain == null) {
        return candidate;
      }
      return extendDomain(candidate, dataDomain, allowDataOverflow);
    }
  }
  return void 0;
}
var MAX_DIGITS = 1e9, defaults$1 = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed during run-time using `Decimal.config`.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
  // `toFixed`, `toPrecision` and `toSignificantDigits`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -MAX_E
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to MAX_E
  // The natural logarithm of 10.
  // 115 digits
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
}, Decimal, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE), P$2 = {};
P$2.absoluteValue = P$2.abs = function() {
  var x2 = new this.constructor(this);
  if (x2.s) x2.s = 1;
  return x2;
};
P$2.comparedTo = P$2.cmp = function(y2) {
  var i2, j2, xdL, ydL, x2 = this;
  y2 = new x2.constructor(y2);
  if (x2.s !== y2.s) return x2.s || -y2.s;
  if (x2.e !== y2.e) return x2.e > y2.e ^ x2.s < 0 ? 1 : -1;
  xdL = x2.d.length;
  ydL = y2.d.length;
  for (i2 = 0, j2 = xdL < ydL ? xdL : ydL; i2 < j2; ++i2) {
    if (x2.d[i2] !== y2.d[i2]) return x2.d[i2] > y2.d[i2] ^ x2.s < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ x2.s < 0 ? 1 : -1;
};
P$2.decimalPlaces = P$2.dp = function() {
  var x2 = this, w2 = x2.d.length - 1, dp = (w2 - x2.e) * LOG_BASE;
  w2 = x2.d[w2];
  if (w2) for (; w2 % 10 == 0; w2 /= 10) dp--;
  return dp < 0 ? 0 : dp;
};
P$2.dividedBy = P$2.div = function(y2) {
  return divide(this, new this.constructor(y2));
};
P$2.dividedToIntegerBy = P$2.idiv = function(y2) {
  var x2 = this, Ctor = x2.constructor;
  return round(divide(x2, new Ctor(y2), 0, 1), Ctor.precision);
};
P$2.equals = P$2.eq = function(y2) {
  return !this.cmp(y2);
};
P$2.exponent = function() {
  return getBase10Exponent(this);
};
P$2.greaterThan = P$2.gt = function(y2) {
  return this.cmp(y2) > 0;
};
P$2.greaterThanOrEqualTo = P$2.gte = function(y2) {
  return this.cmp(y2) >= 0;
};
P$2.isInteger = P$2.isint = function() {
  return this.e > this.d.length - 2;
};
P$2.isNegative = P$2.isneg = function() {
  return this.s < 0;
};
P$2.isPositive = P$2.ispos = function() {
  return this.s > 0;
};
P$2.isZero = function() {
  return this.s === 0;
};
P$2.lessThan = P$2.lt = function(y2) {
  return this.cmp(y2) < 0;
};
P$2.lessThanOrEqualTo = P$2.lte = function(y2) {
  return this.cmp(y2) < 1;
};
P$2.logarithm = P$2.log = function(base) {
  var r2, x2 = this, Ctor = x2.constructor, pr = Ctor.precision, wpr = pr + 5;
  if (base === void 0) {
    base = new Ctor(10);
  } else {
    base = new Ctor(base);
    if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + "NaN");
  }
  if (x2.s < 1) throw Error(decimalError + (x2.s ? "NaN" : "-Infinity"));
  if (x2.eq(ONE)) return new Ctor(0);
  external = false;
  r2 = divide(ln(x2, wpr), ln(base, wpr), wpr);
  external = true;
  return round(r2, pr);
};
P$2.minus = P$2.sub = function(y2) {
  var x2 = this;
  y2 = new x2.constructor(y2);
  return x2.s == y2.s ? subtract(x2, y2) : add(x2, (y2.s = -y2.s, y2));
};
P$2.modulo = P$2.mod = function(y2) {
  var q2, x2 = this, Ctor = x2.constructor, pr = Ctor.precision;
  y2 = new Ctor(y2);
  if (!y2.s) throw Error(decimalError + "NaN");
  if (!x2.s) return round(new Ctor(x2), pr);
  external = false;
  q2 = divide(x2, y2, 0, 1).times(y2);
  external = true;
  return x2.minus(q2);
};
P$2.naturalExponential = P$2.exp = function() {
  return exp(this);
};
P$2.naturalLogarithm = P$2.ln = function() {
  return ln(this);
};
P$2.negated = P$2.neg = function() {
  var x2 = new this.constructor(this);
  x2.s = -x2.s || 0;
  return x2;
};
P$2.plus = P$2.add = function(y2) {
  var x2 = this;
  y2 = new x2.constructor(y2);
  return x2.s == y2.s ? add(x2, y2) : subtract(x2, (y2.s = -y2.s, y2));
};
P$2.precision = P$2.sd = function(z2) {
  var e3, sd, w2, x2 = this;
  if (z2 !== void 0 && z2 !== !!z2 && z2 !== 1 && z2 !== 0) throw Error(invalidArgument + z2);
  e3 = getBase10Exponent(x2) + 1;
  w2 = x2.d.length - 1;
  sd = w2 * LOG_BASE + 1;
  w2 = x2.d[w2];
  if (w2) {
    for (; w2 % 10 == 0; w2 /= 10) sd--;
    for (w2 = x2.d[0]; w2 >= 10; w2 /= 10) sd++;
  }
  return z2 && e3 > sd ? e3 : sd;
};
P$2.squareRoot = P$2.sqrt = function() {
  var e3, n2, pr, r2, s2, t2, wpr, x2 = this, Ctor = x2.constructor;
  if (x2.s < 1) {
    if (!x2.s) return new Ctor(0);
    throw Error(decimalError + "NaN");
  }
  e3 = getBase10Exponent(x2);
  external = false;
  s2 = Math.sqrt(+x2);
  if (s2 == 0 || s2 == 1 / 0) {
    n2 = digitsToString(x2.d);
    if ((n2.length + e3) % 2 == 0) n2 += "0";
    s2 = Math.sqrt(n2);
    e3 = mathfloor((e3 + 1) / 2) - (e3 < 0 || e3 % 2);
    if (s2 == 1 / 0) {
      n2 = "5e" + e3;
    } else {
      n2 = s2.toExponential();
      n2 = n2.slice(0, n2.indexOf("e") + 1) + e3;
    }
    r2 = new Ctor(n2);
  } else {
    r2 = new Ctor(s2.toString());
  }
  pr = Ctor.precision;
  s2 = wpr = pr + 3;
  for (; ; ) {
    t2 = r2;
    r2 = t2.plus(divide(x2, t2, wpr + 2)).times(0.5);
    if (digitsToString(t2.d).slice(0, wpr) === (n2 = digitsToString(r2.d)).slice(0, wpr)) {
      n2 = n2.slice(wpr - 3, wpr + 1);
      if (s2 == wpr && n2 == "4999") {
        round(t2, pr + 1, 0);
        if (t2.times(t2).eq(x2)) {
          r2 = t2;
          break;
        }
      } else if (n2 != "9999") {
        break;
      }
      wpr += 4;
    }
  }
  external = true;
  return round(r2, pr);
};
P$2.times = P$2.mul = function(y2) {
  var carry, e3, i2, k2, r2, rL, t2, xdL, ydL, x2 = this, Ctor = x2.constructor, xd = x2.d, yd = (y2 = new Ctor(y2)).d;
  if (!x2.s || !y2.s) return new Ctor(0);
  y2.s *= x2.s;
  e3 = x2.e + y2.e;
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r2 = xd;
    xd = yd;
    yd = r2;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r2 = [];
  rL = xdL + ydL;
  for (i2 = rL; i2--; ) r2.push(0);
  for (i2 = ydL; --i2 >= 0; ) {
    carry = 0;
    for (k2 = xdL + i2; k2 > i2; ) {
      t2 = r2[k2] + yd[i2] * xd[k2 - i2 - 1] + carry;
      r2[k2--] = t2 % BASE | 0;
      carry = t2 / BASE | 0;
    }
    r2[k2] = (r2[k2] + carry) % BASE | 0;
  }
  for (; !r2[--rL]; ) r2.pop();
  if (carry) ++e3;
  else r2.shift();
  y2.d = r2;
  y2.e = e3;
  return external ? round(y2, Ctor.precision) : y2;
};
P$2.toDecimalPlaces = P$2.todp = function(dp, rm) {
  var x2 = this, Ctor = x2.constructor;
  x2 = new Ctor(x2);
  if (dp === void 0) return x2;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);
  return round(x2, dp + getBase10Exponent(x2) + 1, rm);
};
P$2.toExponential = function(dp, rm) {
  var str, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) {
    str = toString(x2, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x2 = round(new Ctor(x2), dp + 1, rm);
    str = toString(x2, true, dp + 1);
  }
  return str;
};
P$2.toFixed = function(dp, rm) {
  var str, y2, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) return toString(x2);
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);
  y2 = round(new Ctor(x2), dp + getBase10Exponent(x2) + 1, rm);
  str = toString(y2.abs(), false, dp + getBase10Exponent(y2) + 1);
  return x2.isneg() && !x2.isZero() ? "-" + str : str;
};
P$2.toInteger = P$2.toint = function() {
  var x2 = this, Ctor = x2.constructor;
  return round(new Ctor(x2), getBase10Exponent(x2) + 1, Ctor.rounding);
};
P$2.toNumber = function() {
  return +this;
};
P$2.toPower = P$2.pow = function(y2) {
  var e3, k2, pr, r2, sign2, yIsInt, x2 = this, Ctor = x2.constructor, guard = 12, yn = +(y2 = new Ctor(y2));
  if (!y2.s) return new Ctor(ONE);
  x2 = new Ctor(x2);
  if (!x2.s) {
    if (y2.s < 1) throw Error(decimalError + "Infinity");
    return x2;
  }
  if (x2.eq(ONE)) return x2;
  pr = Ctor.precision;
  if (y2.eq(ONE)) return round(x2, pr);
  e3 = y2.e;
  k2 = y2.d.length - 1;
  yIsInt = e3 >= k2;
  sign2 = x2.s;
  if (!yIsInt) {
    if (sign2 < 0) throw Error(decimalError + "NaN");
  } else if ((k2 = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r2 = new Ctor(ONE);
    e3 = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (k2 % 2) {
        r2 = r2.times(x2);
        truncate(r2.d, e3);
      }
      k2 = mathfloor(k2 / 2);
      if (k2 === 0) break;
      x2 = x2.times(x2);
      truncate(x2.d, e3);
    }
    external = true;
    return y2.s < 0 ? new Ctor(ONE).div(r2) : round(r2, pr);
  }
  sign2 = sign2 < 0 && y2.d[Math.max(e3, k2)] & 1 ? -1 : 1;
  x2.s = 1;
  external = false;
  r2 = y2.times(ln(x2, pr + guard));
  external = true;
  r2 = exp(r2);
  r2.s = sign2;
  return r2;
};
P$2.toPrecision = function(sd, rm) {
  var e3, str, x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    e3 = getBase10Exponent(x2);
    str = toString(x2, e3 <= Ctor.toExpNeg || e3 >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x2 = round(new Ctor(x2), sd, rm);
    e3 = getBase10Exponent(x2);
    str = toString(x2, sd <= e3 || e3 <= Ctor.toExpNeg, sd);
  }
  return str;
};
P$2.toSignificantDigits = P$2.tosd = function(sd, rm) {
  var x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }
  return round(new Ctor(x2), sd, rm);
};
P$2.toString = P$2.valueOf = P$2.val = P$2.toJSON = P$2[Symbol.for("nodejs.util.inspect.custom")] = function() {
  var x2 = this, e3 = getBase10Exponent(x2), Ctor = x2.constructor;
  return toString(x2, e3 <= Ctor.toExpNeg || e3 >= Ctor.toExpPos);
};
function add(x2, y2) {
  var carry, d2, e3, i2, k2, len, xd, yd, Ctor = x2.constructor, pr = Ctor.precision;
  if (!x2.s || !y2.s) {
    if (!y2.s) y2 = new Ctor(x2);
    return external ? round(y2, pr) : y2;
  }
  xd = x2.d;
  yd = y2.d;
  k2 = x2.e;
  e3 = y2.e;
  xd = xd.slice();
  i2 = k2 - e3;
  if (i2) {
    if (i2 < 0) {
      d2 = xd;
      i2 = -i2;
      len = yd.length;
    } else {
      d2 = yd;
      e3 = k2;
      len = xd.length;
    }
    k2 = Math.ceil(pr / LOG_BASE);
    len = k2 > len ? k2 + 1 : len + 1;
    if (i2 > len) {
      i2 = len;
      d2.length = 1;
    }
    d2.reverse();
    for (; i2--; ) d2.push(0);
    d2.reverse();
  }
  len = xd.length;
  i2 = yd.length;
  if (len - i2 < 0) {
    i2 = len;
    d2 = yd;
    yd = xd;
    xd = d2;
  }
  for (carry = 0; i2; ) {
    carry = (xd[--i2] = xd[i2] + yd[i2] + carry) / BASE | 0;
    xd[i2] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e3;
  }
  for (len = xd.length; xd[--len] == 0; ) xd.pop();
  y2.d = xd;
  y2.e = e3;
  return external ? round(y2, pr) : y2;
}
function checkInt32(i2, min2, max2) {
  if (i2 !== ~~i2 || i2 < min2 || i2 > max2) {
    throw Error(invalidArgument + i2);
  }
}
function digitsToString(d2) {
  var i2, k2, ws, indexOfLastWord = d2.length - 1, str = "", w2 = d2[0];
  if (indexOfLastWord > 0) {
    str += w2;
    for (i2 = 1; i2 < indexOfLastWord; i2++) {
      ws = d2[i2] + "";
      k2 = LOG_BASE - ws.length;
      if (k2) str += getZeroString(k2);
      str += ws;
    }
    w2 = d2[i2];
    ws = w2 + "";
    k2 = LOG_BASE - ws.length;
    if (k2) str += getZeroString(k2);
  } else if (w2 === 0) {
    return "0";
  }
  for (; w2 % 10 === 0; ) w2 /= 10;
  return str + w2;
}
var divide = /* @__PURE__ */ (function() {
  function multiplyInteger(x2, k2) {
    var temp, carry = 0, i2 = x2.length;
    for (x2 = x2.slice(); i2--; ) {
      temp = x2[i2] * k2 + carry;
      x2[i2] = temp % BASE | 0;
      carry = temp / BASE | 0;
    }
    if (carry) x2.unshift(carry);
    return x2;
  }
  function compare(a2, b2, aL, bL) {
    var i2, r2;
    if (aL != bL) {
      r2 = aL > bL ? 1 : -1;
    } else {
      for (i2 = r2 = 0; i2 < aL; i2++) {
        if (a2[i2] != b2[i2]) {
          r2 = a2[i2] > b2[i2] ? 1 : -1;
          break;
        }
      }
    }
    return r2;
  }
  function subtract2(a2, b2, aL) {
    var i2 = 0;
    for (; aL--; ) {
      a2[aL] -= i2;
      i2 = a2[aL] < b2[aL] ? 1 : 0;
      a2[aL] = i2 * BASE + a2[aL] - b2[aL];
    }
    for (; !a2[0] && a2.length > 1; ) a2.shift();
  }
  return function(x2, y2, pr, dp) {
    var cmp, e3, i2, k2, prod, prodL, q2, qd, rem, remL, rem0, sd, t2, xi, xL, yd0, yL, yz, Ctor = x2.constructor, sign2 = x2.s == y2.s ? 1 : -1, xd = x2.d, yd = y2.d;
    if (!x2.s) return new Ctor(x2);
    if (!y2.s) throw Error(decimalError + "Division by zero");
    e3 = x2.e - y2.e;
    yL = yd.length;
    xL = xd.length;
    q2 = new Ctor(sign2);
    qd = q2.d = [];
    for (i2 = 0; yd[i2] == (xd[i2] || 0); ) ++i2;
    if (yd[i2] > (xd[i2] || 0)) --e3;
    if (pr == null) {
      sd = pr = Ctor.precision;
    } else if (dp) {
      sd = pr + (getBase10Exponent(x2) - getBase10Exponent(y2)) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) return new Ctor(0);
    sd = sd / LOG_BASE + 2 | 0;
    i2 = 0;
    if (yL == 1) {
      k2 = 0;
      yd = yd[0];
      sd++;
      for (; (i2 < xL || k2) && sd--; i2++) {
        t2 = k2 * BASE + (xd[i2] || 0);
        qd[i2] = t2 / yd | 0;
        k2 = t2 % yd | 0;
      }
    } else {
      k2 = BASE / (yd[0] + 1) | 0;
      if (k2 > 1) {
        yd = multiplyInteger(yd, k2);
        xd = multiplyInteger(xd, k2);
        yL = yd.length;
        xL = xd.length;
      }
      xi = yL;
      rem = xd.slice(0, yL);
      remL = rem.length;
      for (; remL < yL; ) rem[remL++] = 0;
      yz = yd.slice();
      yz.unshift(0);
      yd0 = yd[0];
      if (yd[1] >= BASE / 2) ++yd0;
      do {
        k2 = 0;
        cmp = compare(yd, rem, yL, remL);
        if (cmp < 0) {
          rem0 = rem[0];
          if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);
          k2 = rem0 / yd0 | 0;
          if (k2 > 1) {
            if (k2 >= BASE) k2 = BASE - 1;
            prod = multiplyInteger(yd, k2);
            prodL = prod.length;
            remL = rem.length;
            cmp = compare(prod, rem, prodL, remL);
            if (cmp == 1) {
              k2--;
              subtract2(prod, yL < prodL ? yz : yd, prodL);
            }
          } else {
            if (k2 == 0) cmp = k2 = 1;
            prod = yd.slice();
          }
          prodL = prod.length;
          if (prodL < remL) prod.unshift(0);
          subtract2(rem, prod, remL);
          if (cmp == -1) {
            remL = rem.length;
            cmp = compare(yd, rem, yL, remL);
            if (cmp < 1) {
              k2++;
              subtract2(rem, yL < remL ? yz : yd, remL);
            }
          }
          remL = rem.length;
        } else if (cmp === 0) {
          k2++;
          rem = [0];
        }
        qd[i2++] = k2;
        if (cmp && rem[0]) {
          rem[remL++] = xd[xi] || 0;
        } else {
          rem = [xd[xi]];
          remL = 1;
        }
      } while ((xi++ < xL || rem[0] !== void 0) && sd--);
    }
    if (!qd[0]) qd.shift();
    q2.e = e3;
    return round(q2, dp ? pr + getBase10Exponent(q2) + 1 : pr);
  };
})();
function exp(x2, sd) {
  var denominator, guard, pow2, sum, t2, wpr, i2 = 0, k2 = 0, Ctor = x2.constructor, pr = Ctor.precision;
  if (getBase10Exponent(x2) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x2));
  if (!x2.s) return new Ctor(ONE);
  {
    external = false;
    wpr = pr;
  }
  t2 = new Ctor(0.03125);
  while (x2.abs().gte(0.1)) {
    x2 = x2.times(t2);
    k2 += 5;
  }
  guard = Math.log(mathpow(2, k2)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum = new Ctor(ONE);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = round(pow2.times(x2), wpr);
    denominator = denominator.times(++i2);
    t2 = sum.plus(divide(pow2, denominator, wpr));
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      while (k2--) sum = round(sum.times(sum), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round(sum, pr)) : sum;
    }
    sum = t2;
  }
}
function getBase10Exponent(x2) {
  var e3 = x2.e * LOG_BASE, w2 = x2.d[0];
  for (; w2 >= 10; w2 /= 10) e3++;
  return e3;
}
function getLn10(Ctor, sd, pr) {
  if (sd > Ctor.LN10.sd()) {
    external = true;
    if (pr) Ctor.precision = pr;
    throw Error(decimalError + "LN10 precision limit exceeded");
  }
  return round(new Ctor(Ctor.LN10), sd);
}
function getZeroString(k2) {
  var zs = "";
  for (; k2--; ) zs += "0";
  return zs;
}
function ln(y2, sd) {
  var c2, c0, denominator, e3, numerator, sum, t2, wpr, x2, n2 = 1, guard = 10, x3 = y2, xd = x3.d, Ctor = x3.constructor, pr = Ctor.precision;
  if (x3.s < 1) throw Error(decimalError + (x3.s ? "NaN" : "-Infinity"));
  if (x3.eq(ONE)) return new Ctor(0);
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  if (x3.eq(10)) {
    if (sd == null) external = true;
    return getLn10(Ctor, wpr);
  }
  wpr += guard;
  Ctor.precision = wpr;
  c2 = digitsToString(xd);
  c0 = c2.charAt(0);
  e3 = getBase10Exponent(x3);
  if (Math.abs(e3) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c2.charAt(1) > 3) {
      x3 = x3.times(y2);
      c2 = digitsToString(x3.d);
      c0 = c2.charAt(0);
      n2++;
    }
    e3 = getBase10Exponent(x3);
    if (c0 > 1) {
      x3 = new Ctor("0." + c2);
      e3++;
    } else {
      x3 = new Ctor(c0 + "." + c2.slice(1));
    }
  } else {
    t2 = getLn10(Ctor, wpr + 2, pr).times(e3 + "");
    x3 = ln(new Ctor(c0 + "." + c2.slice(1)), wpr - guard).plus(t2);
    Ctor.precision = pr;
    return sd == null ? (external = true, round(x3, pr)) : x3;
  }
  sum = numerator = x3 = divide(x3.minus(ONE), x3.plus(ONE), wpr);
  x2 = round(x3.times(x3), wpr);
  denominator = 3;
  for (; ; ) {
    numerator = round(numerator.times(x2), wpr);
    t2 = sum.plus(divide(numerator, new Ctor(denominator), wpr));
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      sum = sum.times(2);
      if (e3 !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e3 + ""));
      sum = divide(sum, new Ctor(n2), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round(sum, pr)) : sum;
    }
    sum = t2;
    denominator += 2;
  }
}
function parseDecimal(x2, str) {
  var e3, i2, len;
  if ((e3 = str.indexOf(".")) > -1) str = str.replace(".", "");
  if ((i2 = str.search(/e/i)) > 0) {
    if (e3 < 0) e3 = i2;
    e3 += +str.slice(i2 + 1);
    str = str.substring(0, i2);
  } else if (e3 < 0) {
    e3 = str.length;
  }
  for (i2 = 0; str.charCodeAt(i2) === 48; ) ++i2;
  for (len = str.length; str.charCodeAt(len - 1) === 48; ) --len;
  str = str.slice(i2, len);
  if (str) {
    len -= i2;
    e3 = e3 - i2 - 1;
    x2.e = mathfloor(e3 / LOG_BASE);
    x2.d = [];
    i2 = (e3 + 1) % LOG_BASE;
    if (e3 < 0) i2 += LOG_BASE;
    if (i2 < len) {
      if (i2) x2.d.push(+str.slice(0, i2));
      for (len -= LOG_BASE; i2 < len; ) x2.d.push(+str.slice(i2, i2 += LOG_BASE));
      str = str.slice(i2);
      i2 = LOG_BASE - str.length;
    } else {
      i2 -= len;
    }
    for (; i2--; ) str += "0";
    x2.d.push(+str);
    if (external && (x2.e > MAX_E || x2.e < -MAX_E)) throw Error(exponentOutOfRange + e3);
  } else {
    x2.s = 0;
    x2.e = 0;
    x2.d = [0];
  }
  return x2;
}
function round(x2, sd, rm) {
  var i2, j2, k2, n2, rd, doRound, w2, xdi, xd = x2.d;
  for (n2 = 1, k2 = xd[0]; k2 >= 10; k2 /= 10) n2++;
  i2 = sd - n2;
  if (i2 < 0) {
    i2 += LOG_BASE;
    j2 = sd;
    w2 = xd[xdi = 0];
  } else {
    xdi = Math.ceil((i2 + 1) / LOG_BASE);
    k2 = xd.length;
    if (xdi >= k2) return x2;
    w2 = k2 = xd[xdi];
    for (n2 = 1; k2 >= 10; k2 /= 10) n2++;
    i2 %= LOG_BASE;
    j2 = i2 - LOG_BASE + n2;
  }
  if (rm !== void 0) {
    k2 = mathpow(10, n2 - j2 - 1);
    rd = w2 / k2 % 10 | 0;
    doRound = sd < 0 || xd[xdi + 1] !== void 0 || w2 % k2;
    doRound = rm < 4 ? (rd || doRound) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i2 > 0 ? j2 > 0 ? w2 / mathpow(10, n2 - j2) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
  }
  if (sd < 1 || !xd[0]) {
    if (doRound) {
      k2 = getBase10Exponent(x2);
      xd.length = 1;
      sd = sd - k2 - 1;
      xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
      x2.e = mathfloor(-sd / LOG_BASE) || 0;
    } else {
      xd.length = 1;
      xd[0] = x2.e = x2.s = 0;
    }
    return x2;
  }
  if (i2 == 0) {
    xd.length = xdi;
    k2 = 1;
    xdi--;
  } else {
    xd.length = xdi + 1;
    k2 = mathpow(10, LOG_BASE - i2);
    xd[xdi] = j2 > 0 ? (w2 / mathpow(10, n2 - j2) % mathpow(10, j2) | 0) * k2 : 0;
  }
  if (doRound) {
    for (; ; ) {
      if (xdi == 0) {
        if ((xd[0] += k2) == BASE) {
          xd[0] = 1;
          ++x2.e;
        }
        break;
      } else {
        xd[xdi] += k2;
        if (xd[xdi] != BASE) break;
        xd[xdi--] = 0;
        k2 = 1;
      }
    }
  }
  for (i2 = xd.length; xd[--i2] === 0; ) xd.pop();
  if (external && (x2.e > MAX_E || x2.e < -MAX_E)) {
    throw Error(exponentOutOfRange + getBase10Exponent(x2));
  }
  return x2;
}
function subtract(x2, y2) {
  var d2, e3, i2, j2, k2, len, xd, xe, xLTy, yd, Ctor = x2.constructor, pr = Ctor.precision;
  if (!x2.s || !y2.s) {
    if (y2.s) y2.s = -y2.s;
    else y2 = new Ctor(x2);
    return external ? round(y2, pr) : y2;
  }
  xd = x2.d;
  yd = y2.d;
  e3 = y2.e;
  xe = x2.e;
  xd = xd.slice();
  k2 = xe - e3;
  if (k2) {
    xLTy = k2 < 0;
    if (xLTy) {
      d2 = xd;
      k2 = -k2;
      len = yd.length;
    } else {
      d2 = yd;
      e3 = xe;
      len = xd.length;
    }
    i2 = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k2 > i2) {
      k2 = i2;
      d2.length = 1;
    }
    d2.reverse();
    for (i2 = k2; i2--; ) d2.push(0);
    d2.reverse();
  } else {
    i2 = xd.length;
    len = yd.length;
    xLTy = i2 < len;
    if (xLTy) len = i2;
    for (i2 = 0; i2 < len; i2++) {
      if (xd[i2] != yd[i2]) {
        xLTy = xd[i2] < yd[i2];
        break;
      }
    }
    k2 = 0;
  }
  if (xLTy) {
    d2 = xd;
    xd = yd;
    yd = d2;
    y2.s = -y2.s;
  }
  len = xd.length;
  for (i2 = yd.length - len; i2 > 0; --i2) xd[len++] = 0;
  for (i2 = yd.length; i2 > k2; ) {
    if (xd[--i2] < yd[i2]) {
      for (j2 = i2; j2 && xd[--j2] === 0; ) xd[j2] = BASE - 1;
      --xd[j2];
      xd[i2] += BASE;
    }
    xd[i2] -= yd[i2];
  }
  for (; xd[--len] === 0; ) xd.pop();
  for (; xd[0] === 0; xd.shift()) --e3;
  if (!xd[0]) return new Ctor(0);
  y2.d = xd;
  y2.e = e3;
  return external ? round(y2, pr) : y2;
}
function toString(x2, isExp, sd) {
  var k2, e3 = getBase10Exponent(x2), str = digitsToString(x2.d), len = str.length;
  if (isExp) {
    if (sd && (k2 = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k2);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (e3 < 0 ? "e" : "e+") + e3;
  } else if (e3 < 0) {
    str = "0." + getZeroString(-e3 - 1) + str;
    if (sd && (k2 = sd - len) > 0) str += getZeroString(k2);
  } else if (e3 >= len) {
    str += getZeroString(e3 + 1 - len);
    if (sd && (k2 = sd - e3 - 1) > 0) str = str + "." + getZeroString(k2);
  } else {
    if ((k2 = e3 + 1) < len) str = str.slice(0, k2) + "." + str.slice(k2);
    if (sd && (k2 = sd - len) > 0) {
      if (e3 + 1 === len) str += ".";
      str += getZeroString(k2);
    }
  }
  return x2.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function clone(obj) {
  var i2, p2, ps;
  function Decimal2(value) {
    var x2 = this;
    if (!(x2 instanceof Decimal2)) return new Decimal2(value);
    x2.constructor = Decimal2;
    if (value instanceof Decimal2) {
      x2.s = value.s;
      x2.e = value.e;
      x2.d = (value = value.d) ? value.slice() : value;
      return;
    }
    if (typeof value === "number") {
      if (value * 0 !== 0) {
        throw Error(invalidArgument + value);
      }
      if (value > 0) {
        x2.s = 1;
      } else if (value < 0) {
        value = -value;
        x2.s = -1;
      } else {
        x2.s = 0;
        x2.e = 0;
        x2.d = [0];
        return;
      }
      if (value === ~~value && value < 1e7) {
        x2.e = 0;
        x2.d = [value];
        return;
      }
      return parseDecimal(x2, value.toString());
    } else if (typeof value !== "string") {
      throw Error(invalidArgument + value);
    }
    if (value.charCodeAt(0) === 45) {
      value = value.slice(1);
      x2.s = -1;
    } else {
      x2.s = 1;
    }
    if (isDecimal.test(value)) parseDecimal(x2, value);
    else throw Error(invalidArgument + value);
  }
  Decimal2.prototype = P$2;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.clone = clone;
  Decimal2.config = Decimal2.set = config;
  if (obj === void 0) obj = {};
  if (obj) {
    ps = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
    for (i2 = 0; i2 < ps.length; ) if (!obj.hasOwnProperty(p2 = ps[i2++])) obj[p2] = this[p2];
  }
  Decimal2.config(obj);
  return Decimal2;
}
function config(obj) {
  if (!obj || typeof obj !== "object") {
    throw Error(decimalError + "Object expected");
  }
  var i2, p2, v2, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (i2 = 0; i2 < ps.length; i2 += 3) {
    if ((v2 = obj[p2 = ps[i2]]) !== void 0) {
      if (mathfloor(v2) === v2 && v2 >= ps[i2 + 1] && v2 <= ps[i2 + 2]) this[p2] = v2;
      else throw Error(invalidArgument + p2 + ": " + v2);
    }
  }
  if ((v2 = obj[p2 = "LN10"]) !== void 0) {
    if (v2 == Math.LN10) this[p2] = new this(v2);
    else throw Error(invalidArgument + p2 + ": " + v2);
  }
  return this;
}
var Decimal = clone(defaults$1);
ONE = new Decimal(1);
const Decimal$1 = Decimal;
var identity = (i2) => i2;
var PLACE_HOLDER = {};
var isPlaceHolder = (val) => val === PLACE_HOLDER;
var curry0 = (fn) => function _curried() {
  if (arguments.length === 0 || arguments.length === 1 && isPlaceHolder(arguments.length <= 0 ? void 0 : arguments[0])) {
    return _curried;
  }
  return fn(...arguments);
};
var curryN = (n2, fn) => {
  if (n2 === 1) {
    return fn;
  }
  return curry0(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var argsLength = args.filter((arg) => arg !== PLACE_HOLDER).length;
    if (argsLength >= n2) {
      return fn(...args);
    }
    return curryN(n2 - argsLength, curry0(function() {
      for (var _len2 = arguments.length, restArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        restArgs[_key2] = arguments[_key2];
      }
      var newArgs = args.map((arg) => isPlaceHolder(arg) ? restArgs.shift() : arg);
      return fn(...newArgs, ...restArgs);
    }));
  });
};
var curry = (fn) => curryN(fn.length, fn);
var range = (begin, end) => {
  var arr = [];
  for (var i2 = begin; i2 < end; ++i2) {
    arr[i2 - begin] = i2;
  }
  return arr;
};
var map$2 = curry((fn, arr) => {
  if (Array.isArray(arr)) {
    return arr.map(fn);
  }
  return Object.keys(arr).map((key) => arr[key]).map(fn);
});
var compose = function compose2() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }
  if (!args.length) {
    return identity;
  }
  var fns = args.reverse();
  var firstFn = fns[0];
  var tailsFn = fns.slice(1);
  return function() {
    return tailsFn.reduce((res, fn) => fn(res), firstFn(...arguments));
  };
};
var reverse = (arr) => {
  if (Array.isArray(arr)) {
    return arr.reverse();
  }
  return arr.split("").reverse().join("");
};
var memoize = (fn) => {
  var lastArgs = null;
  var lastResult2 = null;
  return function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    if (lastArgs && args.every((val, i2) => {
      var _lastArgs;
      return val === ((_lastArgs = lastArgs) === null || _lastArgs === void 0 ? void 0 : _lastArgs[i2]);
    })) {
      return lastResult2;
    }
    lastArgs = args;
    lastResult2 = fn(...args);
    return lastResult2;
  };
};
function getDigitCount(value) {
  var result;
  if (value === 0) {
    result = 1;
  } else {
    result = Math.floor(new Decimal$1(value).abs().log(10).toNumber()) + 1;
  }
  return result;
}
function rangeStep(start, end, step) {
  var num = new Decimal$1(start);
  var i2 = 0;
  var result = [];
  while (num.lt(end) && i2 < 1e5) {
    result.push(num.toNumber());
    num = num.add(step);
    i2++;
  }
  return result;
}
curry((a2, b2, t2) => {
  var newA = +a2;
  var newB = +b2;
  return newA + t2 * (newB - newA);
});
curry((a2, b2, x2) => {
  var diff = b2 - +a2;
  diff = diff || Infinity;
  return (x2 - a2) / diff;
});
curry((a2, b2, x2) => {
  var diff = b2 - +a2;
  diff = diff || Infinity;
  return Math.max(0, Math.min(1, (x2 - a2) / diff));
});
var getValidInterval = (_ref2) => {
  var [min2, max2] = _ref2;
  var [validMin, validMax] = [min2, max2];
  if (min2 > max2) {
    [validMin, validMax] = [max2, min2];
  }
  return [validMin, validMax];
};
var getFormatStep = (roughStep, allowDecimals, correctionFactor) => {
  if (roughStep.lte(0)) {
    return new Decimal$1(0);
  }
  var digitCount = getDigitCount(roughStep.toNumber());
  var digitCountValue = new Decimal$1(10).pow(digitCount);
  var stepRatio = roughStep.div(digitCountValue);
  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;
  var amendStepRatio = new Decimal$1(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);
  var formatStep = amendStepRatio.mul(digitCountValue);
  return allowDecimals ? new Decimal$1(formatStep.toNumber()) : new Decimal$1(Math.ceil(formatStep.toNumber()));
};
var getTickOfSingleValue = (value, tickCount, allowDecimals) => {
  var step = new Decimal$1(1);
  var middle = new Decimal$1(value);
  if (!middle.isint() && allowDecimals) {
    var absVal = Math.abs(value);
    if (absVal < 1) {
      step = new Decimal$1(10).pow(getDigitCount(value) - 1);
      middle = new Decimal$1(Math.floor(middle.div(step).toNumber())).mul(step);
    } else if (absVal > 1) {
      middle = new Decimal$1(Math.floor(value));
    }
  } else if (value === 0) {
    middle = new Decimal$1(Math.floor((tickCount - 1) / 2));
  } else if (!allowDecimals) {
    middle = new Decimal$1(Math.floor(value));
  }
  var middleIndex = Math.floor((tickCount - 1) / 2);
  var fn = compose(map$2((n2) => middle.add(new Decimal$1(n2 - middleIndex).mul(step)).toNumber()), range);
  return fn(0, tickCount);
};
var _calculateStep = function calculateStep(min2, max2, tickCount, allowDecimals) {
  var correctionFactor = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  if (!Number.isFinite((max2 - min2) / (tickCount - 1))) {
    return {
      step: new Decimal$1(0),
      tickMin: new Decimal$1(0),
      tickMax: new Decimal$1(0)
    };
  }
  var step = getFormatStep(new Decimal$1(max2).sub(min2).div(tickCount - 1), allowDecimals, correctionFactor);
  var middle;
  if (min2 <= 0 && max2 >= 0) {
    middle = new Decimal$1(0);
  } else {
    middle = new Decimal$1(min2).add(max2).div(2);
    middle = middle.sub(new Decimal$1(middle).mod(step));
  }
  var belowCount = Math.ceil(middle.sub(min2).div(step).toNumber());
  var upCount = Math.ceil(new Decimal$1(max2).sub(middle).div(step).toNumber());
  var scaleCount = belowCount + upCount + 1;
  if (scaleCount > tickCount) {
    return _calculateStep(min2, max2, tickCount, allowDecimals, correctionFactor + 1);
  }
  if (scaleCount < tickCount) {
    upCount = max2 > 0 ? upCount + (tickCount - scaleCount) : upCount;
    belowCount = max2 > 0 ? belowCount : belowCount + (tickCount - scaleCount);
  }
  return {
    step,
    tickMin: middle.sub(new Decimal$1(belowCount).mul(step)),
    tickMax: middle.add(new Decimal$1(upCount).mul(step))
  };
};
function getNiceTickValuesFn(_ref2) {
  var [min2, max2] = _ref2;
  var tickCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;
  var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var count = Math.max(tickCount, 2);
  var [cormin, cormax] = getValidInterval([min2, max2]);
  if (cormin === -Infinity || cormax === Infinity) {
    var _values = cormax === Infinity ? [cormin, ...range(0, tickCount - 1).map(() => Infinity)] : [...range(0, tickCount - 1).map(() => -Infinity), cormax];
    return min2 > max2 ? reverse(_values) : _values;
  }
  if (cormin === cormax) {
    return getTickOfSingleValue(cormin, tickCount, allowDecimals);
  }
  var {
    step,
    tickMin,
    tickMax
  } = _calculateStep(cormin, cormax, count, allowDecimals, 0);
  var values = rangeStep(tickMin, tickMax.add(new Decimal$1(0.1).mul(step)), step);
  return min2 > max2 ? reverse(values) : values;
}
function getTickValuesFixedDomainFn(_ref3, tickCount) {
  var [min2, max2] = _ref3;
  var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var [cormin, cormax] = getValidInterval([min2, max2]);
  if (cormin === -Infinity || cormax === Infinity) {
    return [min2, max2];
  }
  if (cormin === cormax) {
    return [cormin];
  }
  var count = Math.max(tickCount, 2);
  var step = getFormatStep(new Decimal$1(cormax).sub(cormin).div(count - 1), allowDecimals, 0);
  var values = [...rangeStep(new Decimal$1(cormin), new Decimal$1(cormax), step), cormax];
  if (allowDecimals === false) {
    values = values.map((value) => Math.round(value));
  }
  return min2 > max2 ? reverse(values) : values;
}
var getNiceTickValues = memoize(getNiceTickValuesFn);
var getTickValuesFixedDomain = memoize(getTickValuesFixedDomainFn);
var selectRootMaxBarSize = (state) => state.rootProps.maxBarSize;
var selectBarGap = (state) => state.rootProps.barGap;
var selectBarCategoryGap = (state) => state.rootProps.barCategoryGap;
var selectRootBarSize = (state) => state.rootProps.barSize;
var selectStackOffsetType = (state) => state.rootProps.stackOffset;
var selectChartName = (state) => state.options.chartName;
var selectSyncId = (state) => state.rootProps.syncId;
var selectSyncMethod = (state) => state.rootProps.syncMethod;
var selectEventEmitter = (state) => state.options.eventEmitter;
var defaultPolarAngleAxisProps = {
  allowDuplicatedCategory: true,
  // if I set this to false then Tooltip synchronisation stops working in Radar, wtf
  angleAxisId: 0,
  reversed: false,
  scale: "auto",
  tick: true,
  type: "category"
};
var defaultPolarRadiusAxisProps = {
  allowDataOverflow: false,
  allowDuplicatedCategory: true,
  radiusAxisId: 0,
  scale: "auto",
  tick: true,
  tickCount: 5,
  type: "number"
};
var combineAxisRangeWithReverse = (axisSettings, axisRange) => {
  if (!axisSettings || !axisRange) {
    return void 0;
  }
  if (axisSettings !== null && axisSettings !== void 0 && axisSettings.reversed) {
    return [axisRange[1], axisRange[0]];
  }
  return axisRange;
};
var implicitAngleAxis = {
  allowDataOverflow: false,
  allowDecimals: false,
  allowDuplicatedCategory: false,
  // defaultPolarAngleAxisProps.allowDuplicatedCategory has it set to true but the actual axis rendering ignores the prop because reasons,
  dataKey: void 0,
  domain: void 0,
  id: defaultPolarAngleAxisProps.angleAxisId,
  includeHidden: false,
  name: void 0,
  reversed: defaultPolarAngleAxisProps.reversed,
  scale: defaultPolarAngleAxisProps.scale,
  tick: defaultPolarAngleAxisProps.tick,
  tickCount: void 0,
  ticks: void 0,
  type: defaultPolarAngleAxisProps.type,
  unit: void 0
};
var implicitRadiusAxis = {
  allowDataOverflow: defaultPolarRadiusAxisProps.allowDataOverflow,
  allowDecimals: false,
  allowDuplicatedCategory: defaultPolarRadiusAxisProps.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: defaultPolarRadiusAxisProps.radiusAxisId,
  includeHidden: false,
  name: void 0,
  reversed: false,
  scale: defaultPolarRadiusAxisProps.scale,
  tick: defaultPolarRadiusAxisProps.tick,
  tickCount: defaultPolarRadiusAxisProps.tickCount,
  ticks: void 0,
  type: defaultPolarRadiusAxisProps.type,
  unit: void 0
};
var implicitRadialBarAngleAxis = {
  allowDataOverflow: false,
  allowDecimals: false,
  allowDuplicatedCategory: defaultPolarAngleAxisProps.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: defaultPolarAngleAxisProps.angleAxisId,
  includeHidden: false,
  name: void 0,
  reversed: false,
  scale: defaultPolarAngleAxisProps.scale,
  tick: defaultPolarAngleAxisProps.tick,
  tickCount: void 0,
  ticks: void 0,
  type: "number",
  unit: void 0
};
var implicitRadialBarRadiusAxis = {
  allowDataOverflow: defaultPolarRadiusAxisProps.allowDataOverflow,
  allowDecimals: false,
  allowDuplicatedCategory: defaultPolarRadiusAxisProps.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: defaultPolarRadiusAxisProps.radiusAxisId,
  includeHidden: false,
  name: void 0,
  reversed: false,
  scale: defaultPolarRadiusAxisProps.scale,
  tick: defaultPolarRadiusAxisProps.tick,
  tickCount: defaultPolarRadiusAxisProps.tickCount,
  ticks: void 0,
  type: "category",
  unit: void 0
};
var selectAngleAxis = (state, angleAxisId) => {
  if (state.polarAxis.angleAxis[angleAxisId] != null) {
    return state.polarAxis.angleAxis[angleAxisId];
  }
  if (state.layout.layoutType === "radial") {
    return implicitRadialBarAngleAxis;
  }
  return implicitAngleAxis;
};
var selectRadiusAxis = (state, radiusAxisId) => {
  if (state.polarAxis.radiusAxis[radiusAxisId] != null) {
    return state.polarAxis.radiusAxis[radiusAxisId];
  }
  if (state.layout.layoutType === "radial") {
    return implicitRadialBarRadiusAxis;
  }
  return implicitRadiusAxis;
};
var selectPolarOptions = (state) => state.polarOptions;
var selectMaxRadius = createSelector([selectChartWidth, selectChartHeight, selectChartOffsetInternal], getMaxRadius);
var selectInnerRadius = createSelector([selectPolarOptions, selectMaxRadius], (polarChartOptions, maxRadius) => {
  if (polarChartOptions == null) {
    return void 0;
  }
  return getPercentValue(polarChartOptions.innerRadius, maxRadius, 0);
});
var selectOuterRadius = createSelector([selectPolarOptions, selectMaxRadius], (polarChartOptions, maxRadius) => {
  if (polarChartOptions == null) {
    return void 0;
  }
  return getPercentValue(polarChartOptions.outerRadius, maxRadius, maxRadius * 0.8);
});
var combineAngleAxisRange = (polarOptions) => {
  if (polarOptions == null) {
    return [0, 0];
  }
  var {
    startAngle,
    endAngle
  } = polarOptions;
  return [startAngle, endAngle];
};
var selectAngleAxisRange = createSelector([selectPolarOptions], combineAngleAxisRange);
createSelector([selectAngleAxis, selectAngleAxisRange], combineAxisRangeWithReverse);
var selectRadiusAxisRange = createSelector([selectMaxRadius, selectInnerRadius, selectOuterRadius], (maxRadius, innerRadius, outerRadius) => {
  if (maxRadius == null || innerRadius == null || outerRadius == null) {
    return void 0;
  }
  return [innerRadius, outerRadius];
});
createSelector([selectRadiusAxis, selectRadiusAxisRange], combineAxisRangeWithReverse);
var selectPolarViewBox = createSelector([selectChartLayout, selectPolarOptions, selectInnerRadius, selectOuterRadius, selectChartWidth, selectChartHeight], (layout, polarOptions, innerRadius, outerRadius, width, height) => {
  if (layout !== "centric" && layout !== "radial" || polarOptions == null || innerRadius == null || outerRadius == null) {
    return void 0;
  }
  var {
    cx,
    cy,
    startAngle,
    endAngle
  } = polarOptions;
  return {
    cx: getPercentValue(cx, width, width / 2),
    cy: getPercentValue(cy, height, height / 2),
    innerRadius,
    outerRadius,
    startAngle,
    endAngle,
    clockWise: false
    // this property look useful, why not use it?
  };
});
var pickAxisType = (_state, axisType) => axisType;
var pickAxisId = (_state, _axisType, axisId) => axisId;
function getStackSeriesIdentifier(graphicalItem) {
  return graphicalItem === null || graphicalItem === void 0 ? void 0 : graphicalItem.id;
}
var selectTooltipAxisType = (state) => {
  var layout = selectChartLayout(state);
  if (layout === "horizontal") {
    return "xAxis";
  }
  if (layout === "vertical") {
    return "yAxis";
  }
  if (layout === "centric") {
    return "angleAxis";
  }
  return "radiusAxis";
};
var selectTooltipAxisId = (state) => state.tooltip.settings.axisId;
var selectTooltipAxis = (state) => {
  var axisType = selectTooltipAxisType(state);
  var axisId = selectTooltipAxisId(state);
  return selectAxisSettings(state, axisType, axisId);
};
var selectTooltipAxisDataKey = createSelector([selectTooltipAxis], (axis) => axis === null || axis === void 0 ? void 0 : axis.dataKey);
function combineDisplayedStackedData(stackedGraphicalItems, _ref2, tooltipAxisSettings) {
  var {
    chartData = []
  } = _ref2;
  var {
    allowDuplicatedCategory,
    dataKey: tooltipDataKey
  } = tooltipAxisSettings;
  var knownItemsByDataKey = /* @__PURE__ */ new Map();
  stackedGraphicalItems.forEach((item) => {
    var _item$data;
    var resolvedData = (_item$data = item.data) !== null && _item$data !== void 0 ? _item$data : chartData;
    if (resolvedData == null || resolvedData.length === 0) {
      return;
    }
    var stackIdentifier = getStackSeriesIdentifier(item);
    resolvedData.forEach((entry, index) => {
      var tooltipValue = tooltipDataKey == null || allowDuplicatedCategory ? index : String(getValueByDataKey(entry, tooltipDataKey, null));
      var numericValue = getValueByDataKey(entry, item.dataKey, 0);
      var curr;
      if (knownItemsByDataKey.has(tooltipValue)) {
        curr = knownItemsByDataKey.get(tooltipValue);
      } else {
        curr = {};
      }
      Object.assign(curr, {
        [stackIdentifier]: numericValue
      });
      knownItemsByDataKey.set(tooltipValue, curr);
    });
  });
  return Array.from(knownItemsByDataKey.values());
}
function isStacked(graphicalItem) {
  return graphicalItem.stackId != null && graphicalItem.dataKey != null;
}
var numberDomainEqualityCheck = (a2, b2) => {
  if (a2 === b2) {
    return true;
  }
  if (a2 == null || b2 == null) {
    return false;
  }
  return a2[0] === b2[0] && a2[1] === b2[1];
};
function arrayEqualityCheck(a2, b2) {
  if (Array.isArray(a2) && Array.isArray(b2) && a2.length === 0 && b2.length === 0) {
    return true;
  }
  return a2 === b2;
}
function ownKeys$m(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$m(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$m(Object(t2), true).forEach(function(r3) {
      _defineProperty$o(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$m(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$o(e3, r2, t2) {
  return (r2 = _toPropertyKey$o(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$o(t2) {
  var i2 = _toPrimitive$o(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$o(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var defaultNumericDomain = [0, "auto"];
var implicitXAxis = {
  allowDataOverflow: false,
  allowDecimals: true,
  allowDuplicatedCategory: true,
  angle: 0,
  dataKey: void 0,
  domain: void 0,
  height: 30,
  hide: true,
  id: 0,
  includeHidden: false,
  interval: "preserveEnd",
  minTickGap: 5,
  mirror: false,
  name: void 0,
  orientation: "bottom",
  padding: {
    left: 0,
    right: 0
  },
  reversed: false,
  scale: "auto",
  tick: true,
  tickCount: 5,
  tickFormatter: void 0,
  ticks: void 0,
  type: "category",
  unit: void 0
};
var selectXAxisSettingsNoDefaults = (state, axisId) => {
  return state.cartesianAxis.xAxis[axisId];
};
var selectXAxisSettings = (state, axisId) => {
  var axis = selectXAxisSettingsNoDefaults(state, axisId);
  if (axis == null) {
    return implicitXAxis;
  }
  return axis;
};
var implicitYAxis = {
  allowDataOverflow: false,
  allowDecimals: true,
  allowDuplicatedCategory: true,
  angle: 0,
  dataKey: void 0,
  domain: defaultNumericDomain,
  hide: true,
  id: 0,
  includeHidden: false,
  interval: "preserveEnd",
  minTickGap: 5,
  mirror: false,
  name: void 0,
  orientation: "left",
  padding: {
    top: 0,
    bottom: 0
  },
  reversed: false,
  scale: "auto",
  tick: true,
  tickCount: 5,
  tickFormatter: void 0,
  ticks: void 0,
  type: "number",
  unit: void 0,
  width: DEFAULT_Y_AXIS_WIDTH
};
var selectYAxisSettingsNoDefaults = (state, axisId) => {
  return state.cartesianAxis.yAxis[axisId];
};
var selectYAxisSettings = (state, axisId) => {
  var axis = selectYAxisSettingsNoDefaults(state, axisId);
  if (axis == null) {
    return implicitYAxis;
  }
  return axis;
};
var implicitZAxis = {
  domain: [0, "auto"],
  includeHidden: false,
  reversed: false,
  allowDataOverflow: false,
  allowDuplicatedCategory: false,
  dataKey: void 0,
  id: 0,
  name: "",
  range: [64, 64],
  scale: "auto",
  type: "number",
  unit: ""
};
var selectZAxisSettings = (state, axisId) => {
  var axis = state.cartesianAxis.zAxis[axisId];
  if (axis == null) {
    return implicitZAxis;
  }
  return axis;
};
var selectBaseAxis = (state, axisType, axisId) => {
  switch (axisType) {
    case "xAxis": {
      return selectXAxisSettings(state, axisId);
    }
    case "yAxis": {
      return selectYAxisSettings(state, axisId);
    }
    case "zAxis": {
      return selectZAxisSettings(state, axisId);
    }
    case "angleAxis": {
      return selectAngleAxis(state, axisId);
    }
    case "radiusAxis": {
      return selectRadiusAxis(state, axisId);
    }
    default:
      throw new Error("Unexpected axis type: ".concat(axisType));
  }
};
var selectCartesianAxisSettings = (state, axisType, axisId) => {
  switch (axisType) {
    case "xAxis": {
      return selectXAxisSettings(state, axisId);
    }
    case "yAxis": {
      return selectYAxisSettings(state, axisId);
    }
    default:
      throw new Error("Unexpected axis type: ".concat(axisType));
  }
};
var selectAxisSettings = (state, axisType, axisId) => {
  switch (axisType) {
    case "xAxis": {
      return selectXAxisSettings(state, axisId);
    }
    case "yAxis": {
      return selectYAxisSettings(state, axisId);
    }
    case "angleAxis": {
      return selectAngleAxis(state, axisId);
    }
    case "radiusAxis": {
      return selectRadiusAxis(state, axisId);
    }
    default:
      throw new Error("Unexpected axis type: ".concat(axisType));
  }
};
var selectHasBar = (state) => state.graphicalItems.cartesianItems.some((item) => item.type === "bar") || state.graphicalItems.polarItems.some((item) => item.type === "radialBar");
function itemAxisPredicate(axisType, axisId) {
  return (item) => {
    switch (axisType) {
      case "xAxis":
        return "xAxisId" in item && item.xAxisId === axisId;
      case "yAxis":
        return "yAxisId" in item && item.yAxisId === axisId;
      case "zAxis":
        return "zAxisId" in item && item.zAxisId === axisId;
      case "angleAxis":
        return "angleAxisId" in item && item.angleAxisId === axisId;
      case "radiusAxis":
        return "radiusAxisId" in item && item.radiusAxisId === axisId;
      default:
        return false;
    }
  };
}
var selectUnfilteredCartesianItems = (state) => state.graphicalItems.cartesianItems;
var selectAxisPredicate$1 = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);
var combineGraphicalItemsSettings = (graphicalItems, axisSettings, axisPredicate) => graphicalItems.filter(axisPredicate).filter((item) => {
  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.includeHidden) === true) {
    return true;
  }
  return !item.hide;
});
var selectCartesianItemsSettings = createSelector([selectUnfilteredCartesianItems, selectBaseAxis, selectAxisPredicate$1], combineGraphicalItemsSettings, {
  memoizeOptions: {
    resultEqualityCheck: arrayEqualityCheck
  }
});
var selectStackedCartesianItemsSettings = createSelector([selectCartesianItemsSettings], (cartesianItems) => {
  return cartesianItems.filter((item) => item.type === "area" || item.type === "bar").filter(isStacked);
});
var filterGraphicalNotStackedItems = (cartesianItems) => cartesianItems.filter((item) => !("stackId" in item) || item.stackId === void 0);
var selectCartesianItemsSettingsExceptStacked = createSelector([selectCartesianItemsSettings], filterGraphicalNotStackedItems);
var combineGraphicalItemsData = (cartesianItems) => cartesianItems.map((item) => item.data).filter(Boolean).flat(1);
var selectCartesianGraphicalItemsData = createSelector([selectCartesianItemsSettings], combineGraphicalItemsData, {
  memoizeOptions: {
    resultEqualityCheck: arrayEqualityCheck
  }
});
var combineDisplayedData = (graphicalItemsData, _ref2) => {
  var {
    chartData = [],
    dataStartIndex,
    dataEndIndex
  } = _ref2;
  if (graphicalItemsData.length > 0) {
    return graphicalItemsData;
  }
  return chartData.slice(dataStartIndex, dataEndIndex + 1);
};
var selectDisplayedData$1 = createSelector([selectCartesianGraphicalItemsData, selectChartDataWithIndexesIfNotInPanorama], combineDisplayedData);
var combineAppliedValues = (data, axisSettings, items) => {
  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {
    return data.map((item) => ({
      value: getValueByDataKey(item, axisSettings.dataKey)
    }));
  }
  if (items.length > 0) {
    return items.map((item) => item.dataKey).flatMap((dataKey) => data.map((entry) => ({
      value: getValueByDataKey(entry, dataKey)
    })));
  }
  return data.map((entry) => ({
    value: entry
  }));
};
var selectAllAppliedValues = createSelector([selectDisplayedData$1, selectBaseAxis, selectCartesianItemsSettings], combineAppliedValues);
function isErrorBarRelevantForAxisType(axisType, errorBar) {
  switch (axisType) {
    case "xAxis":
      return errorBar.direction === "x";
    case "yAxis":
      return errorBar.direction === "y";
    default:
      return false;
  }
}
function makeNumber(val) {
  if (isNumOrStr(val) || val instanceof Date) {
    var n2 = Number(val);
    if (isWellBehavedNumber(n2)) {
      return n2;
    }
  }
  return void 0;
}
function makeDomain(val) {
  if (Array.isArray(val)) {
    var attempt = [makeNumber(val[0]), makeNumber(val[1])];
    if (isWellFormedNumberDomain(attempt)) {
      return attempt;
    }
    return void 0;
  }
  var n2 = makeNumber(val);
  if (n2 == null) {
    return void 0;
  }
  return [n2, n2];
}
function onlyAllowNumbers(data) {
  return data.map(makeNumber).filter(isNotNil);
}
function getErrorDomainByDataKey(entry, appliedValue, relevantErrorBars) {
  if (!relevantErrorBars || typeof appliedValue !== "number" || isNan(appliedValue)) {
    return [];
  }
  if (!relevantErrorBars.length) {
    return [];
  }
  return onlyAllowNumbers(relevantErrorBars.flatMap((eb) => {
    var errorValue = getValueByDataKey(entry, eb.dataKey);
    var lowBound, highBound;
    if (Array.isArray(errorValue)) {
      [lowBound, highBound] = errorValue;
    } else {
      lowBound = highBound = errorValue;
    }
    if (!isWellBehavedNumber(lowBound) || !isWellBehavedNumber(highBound)) {
      return void 0;
    }
    return [appliedValue - lowBound, appliedValue + highBound];
  }));
}
var selectDisplayedStackedData = createSelector([selectStackedCartesianItemsSettings, selectChartDataWithIndexesIfNotInPanorama, selectTooltipAxis], combineDisplayedStackedData);
var combineStackGroups = (displayedData, items, stackOffsetType) => {
  var initialItemsGroups = {};
  var itemsGroup = items.reduce((acc, item) => {
    if (item.stackId == null) {
      return acc;
    }
    if (acc[item.stackId] == null) {
      acc[item.stackId] = [];
    }
    acc[item.stackId].push(item);
    return acc;
  }, initialItemsGroups);
  return Object.fromEntries(Object.entries(itemsGroup).map((_ref2) => {
    var [stackId, graphicalItems] = _ref2;
    var dataKeys = graphicalItems.map(getStackSeriesIdentifier);
    return [stackId, {
      // @ts-expect-error getStackedData requires that the input is array of objects, Recharts does not test for that
      stackedData: getStackedData(displayedData, dataKeys, stackOffsetType),
      graphicalItems
    }];
  }));
};
var selectStackGroups = createSelector([selectDisplayedStackedData, selectStackedCartesianItemsSettings, selectStackOffsetType], combineStackGroups);
var combineDomainOfStackGroups = (stackGroups, _ref3, axisType, domainFromUserPreference) => {
  var {
    dataStartIndex,
    dataEndIndex
  } = _ref3;
  if (domainFromUserPreference != null) {
    return void 0;
  }
  if (axisType === "zAxis") {
    return void 0;
  }
  var domainOfStackGroups = getDomainOfStackGroups(stackGroups, dataStartIndex, dataEndIndex);
  if (domainOfStackGroups != null && domainOfStackGroups[0] === 0 && domainOfStackGroups[1] === 0) {
    return void 0;
  }
  return domainOfStackGroups;
};
var selectAllowsDataOverflow = createSelector([selectBaseAxis], (axisSettings) => axisSettings.allowDataOverflow);
var getDomainDefinition = (axisSettings) => {
  var _axisSettings$domain;
  if (axisSettings == null || !("domain" in axisSettings)) {
    return defaultNumericDomain;
  }
  if (axisSettings.domain != null) {
    return axisSettings.domain;
  }
  if (axisSettings.ticks != null) {
    if (axisSettings.type === "number") {
      var allValues = onlyAllowNumbers(axisSettings.ticks);
      return [Math.min(...allValues), Math.max(...allValues)];
    }
    if (axisSettings.type === "category") {
      return axisSettings.ticks.map(String);
    }
  }
  return (_axisSettings$domain = axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.domain) !== null && _axisSettings$domain !== void 0 ? _axisSettings$domain : defaultNumericDomain;
};
var selectDomainDefinition = createSelector([selectBaseAxis], getDomainDefinition);
var selectDomainFromUserPreference = createSelector([selectDomainDefinition, selectAllowsDataOverflow], numericalDomainSpecifiedWithoutRequiringData);
var selectDomainOfStackGroups = createSelector([selectStackGroups, selectChartDataWithIndexes, pickAxisType, selectDomainFromUserPreference], combineDomainOfStackGroups, {
  memoizeOptions: {
    resultEqualityCheck: numberDomainEqualityCheck
  }
});
var selectAllErrorBarSettings = (state) => state.errorBars;
var combineRelevantErrorBarSettings = (cartesianItemsSettings, allErrorBarSettings, axisType) => {
  return cartesianItemsSettings.flatMap((item) => {
    return allErrorBarSettings[item.id];
  }).filter(Boolean).filter((e3) => {
    return isErrorBarRelevantForAxisType(axisType, e3);
  });
};
var mergeDomains = function mergeDomains2() {
  for (var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++) {
    domains[_key] = arguments[_key];
  }
  var allDomains = domains.filter(Boolean);
  if (allDomains.length === 0) {
    return void 0;
  }
  var allValues = allDomains.flat();
  var min2 = Math.min(...allValues);
  var max2 = Math.max(...allValues);
  return [min2, max2];
};
var combineDomainOfAllAppliedNumericalValuesIncludingErrorValues = (data, axisSettings, items, errorBars, axisType) => {
  var lowerEnd, upperEnd;
  if (items.length > 0) {
    data.forEach((entry) => {
      items.forEach((item) => {
        var _errorBars$item$id, _axisSettings$dataKey;
        var relevantErrorBars = (_errorBars$item$id = errorBars[item.id]) === null || _errorBars$item$id === void 0 ? void 0 : _errorBars$item$id.filter((errorBar) => isErrorBarRelevantForAxisType(axisType, errorBar));
        var valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);
        var errorDomain = getErrorDomainByDataKey(entry, valueByDataKey, relevantErrorBars);
        if (errorDomain.length >= 2) {
          var localLower = Math.min(...errorDomain);
          var localUpper = Math.max(...errorDomain);
          if (lowerEnd == null || localLower < lowerEnd) {
            lowerEnd = localLower;
          }
          if (upperEnd == null || localUpper > upperEnd) {
            upperEnd = localUpper;
          }
        }
        var dataValueDomain = makeDomain(valueByDataKey);
        if (dataValueDomain != null) {
          lowerEnd = lowerEnd == null ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0]);
          upperEnd = upperEnd == null ? dataValueDomain[1] : Math.max(upperEnd, dataValueDomain[1]);
        }
      });
    });
  }
  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {
    data.forEach((item) => {
      var dataValueDomain = makeDomain(getValueByDataKey(item, axisSettings.dataKey));
      if (dataValueDomain != null) {
        lowerEnd = lowerEnd == null ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0]);
        upperEnd = upperEnd == null ? dataValueDomain[1] : Math.max(upperEnd, dataValueDomain[1]);
      }
    });
  }
  if (isWellBehavedNumber(lowerEnd) && isWellBehavedNumber(upperEnd)) {
    return [lowerEnd, upperEnd];
  }
  return void 0;
};
var selectDomainOfAllAppliedNumericalValuesIncludingErrorValues$1 = createSelector([selectDisplayedData$1, selectBaseAxis, selectCartesianItemsSettingsExceptStacked, selectAllErrorBarSettings, pickAxisType], combineDomainOfAllAppliedNumericalValuesIncludingErrorValues, {
  memoizeOptions: {
    resultEqualityCheck: numberDomainEqualityCheck
  }
});
function onlyAllowNumbersAndStringsAndDates(item) {
  var {
    value
  } = item;
  if (isNumOrStr(value) || value instanceof Date) {
    return value;
  }
  return void 0;
}
var computeDomainOfTypeCategory = (allDataSquished, axisSettings, isCategorical) => {
  var categoricalDomain = allDataSquished.map(onlyAllowNumbersAndStringsAndDates).filter((v2) => v2 != null);
  if (isCategorical && (axisSettings.dataKey == null || axisSettings.allowDuplicatedCategory && hasDuplicate(categoricalDomain))) {
    return range$2(0, allDataSquished.length);
  }
  if (axisSettings.allowDuplicatedCategory) {
    return categoricalDomain;
  }
  return Array.from(new Set(categoricalDomain));
};
var selectReferenceDots = (state) => state.referenceElements.dots;
var filterReferenceElements = (elements, axisType, axisId) => {
  return elements.filter((el) => el.ifOverflow === "extendDomain").filter((el) => {
    if (axisType === "xAxis") {
      return el.xAxisId === axisId;
    }
    return el.yAxisId === axisId;
  });
};
var selectReferenceDotsByAxis = createSelector([selectReferenceDots, pickAxisType, pickAxisId], filterReferenceElements);
var selectReferenceAreas = (state) => state.referenceElements.areas;
var selectReferenceAreasByAxis = createSelector([selectReferenceAreas, pickAxisType, pickAxisId], filterReferenceElements);
var selectReferenceLines = (state) => state.referenceElements.lines;
var selectReferenceLinesByAxis = createSelector([selectReferenceLines, pickAxisType, pickAxisId], filterReferenceElements);
var combineDotsDomain = (dots, axisType) => {
  var allCoords = onlyAllowNumbers(dots.map((dot) => axisType === "xAxis" ? dot.x : dot.y));
  if (allCoords.length === 0) {
    return void 0;
  }
  return [Math.min(...allCoords), Math.max(...allCoords)];
};
var selectReferenceDotsDomain = createSelector(selectReferenceDotsByAxis, pickAxisType, combineDotsDomain);
var combineAreasDomain = (areas, axisType) => {
  var allCoords = onlyAllowNumbers(areas.flatMap((area) => [axisType === "xAxis" ? area.x1 : area.y1, axisType === "xAxis" ? area.x2 : area.y2]));
  if (allCoords.length === 0) {
    return void 0;
  }
  return [Math.min(...allCoords), Math.max(...allCoords)];
};
var selectReferenceAreasDomain = createSelector([selectReferenceAreasByAxis, pickAxisType], combineAreasDomain);
var combineLinesDomain = (lines, axisType) => {
  var allCoords = onlyAllowNumbers(lines.map((line) => axisType === "xAxis" ? line.x : line.y));
  if (allCoords.length === 0) {
    return void 0;
  }
  return [Math.min(...allCoords), Math.max(...allCoords)];
};
var selectReferenceLinesDomain = createSelector(selectReferenceLinesByAxis, pickAxisType, combineLinesDomain);
var selectReferenceElementsDomain = createSelector(selectReferenceDotsDomain, selectReferenceLinesDomain, selectReferenceAreasDomain, (dotsDomain, linesDomain, areasDomain) => {
  return mergeDomains(dotsDomain, areasDomain, linesDomain);
});
var combineNumericalDomain = (axisSettings, domainDefinition, domainFromUserPreference, domainOfStackGroups, dataAndErrorBarsDomain, referenceElementsDomain, layout, axisType) => {
  if (domainFromUserPreference != null) {
    return domainFromUserPreference;
  }
  var shouldIncludeDomainOfStackGroups = layout === "vertical" && axisType === "xAxis" || layout === "horizontal" && axisType === "yAxis";
  var mergedDomains = shouldIncludeDomainOfStackGroups ? mergeDomains(domainOfStackGroups, referenceElementsDomain, dataAndErrorBarsDomain) : mergeDomains(referenceElementsDomain, dataAndErrorBarsDomain);
  return parseNumericalUserDomain(domainDefinition, mergedDomains, axisSettings.allowDataOverflow);
};
var selectNumericalDomain = createSelector([selectBaseAxis, selectDomainDefinition, selectDomainFromUserPreference, selectDomainOfStackGroups, selectDomainOfAllAppliedNumericalValuesIncludingErrorValues$1, selectReferenceElementsDomain, selectChartLayout, pickAxisType], combineNumericalDomain, {
  memoizeOptions: {
    resultEqualityCheck: numberDomainEqualityCheck
  }
});
var expandDomain = [0, 1];
var combineAxisDomain = (axisSettings, layout, displayedData, allAppliedValues, stackOffsetType, axisType, numericalDomain) => {
  if ((axisSettings == null || displayedData == null || displayedData.length === 0) && numericalDomain === void 0) {
    return void 0;
  }
  var {
    dataKey,
    type
  } = axisSettings;
  var isCategorical = isCategoricalAxis(layout, axisType);
  if (isCategorical && dataKey == null) {
    return range$2(0, displayedData.length);
  }
  if (type === "category") {
    return computeDomainOfTypeCategory(allAppliedValues, axisSettings, isCategorical);
  }
  if (stackOffsetType === "expand") {
    return expandDomain;
  }
  return numericalDomain;
};
var selectAxisDomain = createSelector([selectBaseAxis, selectChartLayout, selectDisplayedData$1, selectAllAppliedValues, selectStackOffsetType, pickAxisType, selectNumericalDomain], combineAxisDomain);
var combineRealScaleType = (axisConfig, layout, hasBar, chartType, axisType) => {
  if (axisConfig == null) {
    return void 0;
  }
  var {
    scale,
    type
  } = axisConfig;
  if (scale === "auto") {
    if (layout === "radial" && axisType === "radiusAxis") {
      return "band";
    }
    if (layout === "radial" && axisType === "angleAxis") {
      return "linear";
    }
    if (type === "category" && chartType && (chartType.indexOf("LineChart") >= 0 || chartType.indexOf("AreaChart") >= 0 || chartType.indexOf("ComposedChart") >= 0 && !hasBar)) {
      return "point";
    }
    if (type === "category") {
      return "band";
    }
    return "linear";
  }
  if (typeof scale === "string") {
    var name = "scale".concat(upperFirst(scale));
    return name in d3Scales ? name : "point";
  }
  return void 0;
};
var selectRealScaleType = createSelector([selectBaseAxis, selectChartLayout, selectHasBar, selectChartName, pickAxisType], combineRealScaleType);
function getD3ScaleFromType(realScaleType) {
  if (realScaleType == null) {
    return void 0;
  }
  if (realScaleType in d3Scales) {
    return d3Scales[realScaleType]();
  }
  var name = "scale".concat(upperFirst(realScaleType));
  if (name in d3Scales) {
    return d3Scales[name]();
  }
  return void 0;
}
function combineScaleFunction(axis, realScaleType, axisDomain, axisRange) {
  if (axisDomain == null || axisRange == null) {
    return void 0;
  }
  if (typeof axis.scale === "function") {
    return axis.scale.copy().domain(axisDomain).range(axisRange);
  }
  var d3ScaleFunction = getD3ScaleFromType(realScaleType);
  if (d3ScaleFunction == null) {
    return void 0;
  }
  var scale = d3ScaleFunction.domain(axisDomain).range(axisRange);
  checkDomainOfScale(scale);
  return scale;
}
var combineNiceTicks = (axisDomain, axisSettings, realScaleType) => {
  var domainDefinition = getDomainDefinition(axisSettings);
  if (realScaleType !== "auto" && realScaleType !== "linear") {
    return void 0;
  }
  if (axisSettings != null && axisSettings.tickCount && Array.isArray(domainDefinition) && (domainDefinition[0] === "auto" || domainDefinition[1] === "auto") && isWellFormedNumberDomain(axisDomain)) {
    return getNiceTickValues(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);
  }
  if (axisSettings != null && axisSettings.tickCount && axisSettings.type === "number" && isWellFormedNumberDomain(axisDomain)) {
    return getTickValuesFixedDomain(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);
  }
  return void 0;
};
var selectNiceTicks = createSelector([selectAxisDomain, selectAxisSettings, selectRealScaleType], combineNiceTicks);
var combineAxisDomainWithNiceTicks = (axisSettings, domain2, niceTicks, axisType) => {
  if (
    /*
     * Angle axis for some reason uses nice ticks when rendering axis tick labels,
     * but doesn't use nice ticks for extending domain like all the other axes do.
     * Not really sure why? Is there a good reason,
     * or is it just because someone added support for nice ticks to the other axes and forgot this one?
     */
    axisType !== "angleAxis" && (axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.type) === "number" && isWellFormedNumberDomain(domain2) && Array.isArray(niceTicks) && niceTicks.length > 0
  ) {
    var minFromDomain = domain2[0];
    var minFromTicks = niceTicks[0];
    var maxFromDomain = domain2[1];
    var maxFromTicks = niceTicks[niceTicks.length - 1];
    return [Math.min(minFromDomain, minFromTicks), Math.max(maxFromDomain, maxFromTicks)];
  }
  return domain2;
};
var selectAxisDomainIncludingNiceTicks = createSelector([selectBaseAxis, selectAxisDomain, selectNiceTicks, pickAxisType], combineAxisDomainWithNiceTicks);
var selectSmallestDistanceBetweenValues = createSelector(selectAllAppliedValues, selectBaseAxis, (allDataSquished, axisSettings) => {
  if (!axisSettings || axisSettings.type !== "number") {
    return void 0;
  }
  var smallestDistanceBetweenValues = Infinity;
  var sortedValues = Array.from(onlyAllowNumbers(allDataSquished.map((d2) => d2.value))).sort((a2, b2) => a2 - b2);
  if (sortedValues.length < 2) {
    return Infinity;
  }
  var diff = sortedValues[sortedValues.length - 1] - sortedValues[0];
  if (diff === 0) {
    return Infinity;
  }
  for (var i2 = 0; i2 < sortedValues.length - 1; i2++) {
    var distance = sortedValues[i2 + 1] - sortedValues[i2];
    smallestDistanceBetweenValues = Math.min(smallestDistanceBetweenValues, distance);
  }
  return smallestDistanceBetweenValues / diff;
});
var selectCalculatedPadding = createSelector(selectSmallestDistanceBetweenValues, selectChartLayout, selectBarCategoryGap, selectChartOffsetInternal, (_1, _2, _3, padding) => padding, (smallestDistanceInPercent, layout, barCategoryGap, offset, padding) => {
  if (!isWellBehavedNumber(smallestDistanceInPercent)) {
    return 0;
  }
  var rangeWidth = layout === "vertical" ? offset.height : offset.width;
  if (padding === "gap") {
    return smallestDistanceInPercent * rangeWidth / 2;
  }
  if (padding === "no-gap") {
    var gap = getPercentValue(barCategoryGap, smallestDistanceInPercent * rangeWidth);
    var halfBand = smallestDistanceInPercent * rangeWidth / 2;
    return halfBand - gap - (halfBand - gap) / rangeWidth * gap;
  }
  return 0;
});
var selectCalculatedXAxisPadding = (state, axisId) => {
  var xAxisSettings = selectXAxisSettings(state, axisId);
  if (xAxisSettings == null || typeof xAxisSettings.padding !== "string") {
    return 0;
  }
  return selectCalculatedPadding(state, "xAxis", axisId, xAxisSettings.padding);
};
var selectCalculatedYAxisPadding = (state, axisId) => {
  var yAxisSettings = selectYAxisSettings(state, axisId);
  if (yAxisSettings == null || typeof yAxisSettings.padding !== "string") {
    return 0;
  }
  return selectCalculatedPadding(state, "yAxis", axisId, yAxisSettings.padding);
};
var selectXAxisPadding = createSelector(selectXAxisSettings, selectCalculatedXAxisPadding, (xAxisSettings, calculated) => {
  var _padding$left, _padding$right;
  if (xAxisSettings == null) {
    return {
      left: 0,
      right: 0
    };
  }
  var {
    padding
  } = xAxisSettings;
  if (typeof padding === "string") {
    return {
      left: calculated,
      right: calculated
    };
  }
  return {
    left: ((_padding$left = padding.left) !== null && _padding$left !== void 0 ? _padding$left : 0) + calculated,
    right: ((_padding$right = padding.right) !== null && _padding$right !== void 0 ? _padding$right : 0) + calculated
  };
});
var selectYAxisPadding = createSelector(selectYAxisSettings, selectCalculatedYAxisPadding, (yAxisSettings, calculated) => {
  var _padding$top, _padding$bottom;
  if (yAxisSettings == null) {
    return {
      top: 0,
      bottom: 0
    };
  }
  var {
    padding
  } = yAxisSettings;
  if (typeof padding === "string") {
    return {
      top: calculated,
      bottom: calculated
    };
  }
  return {
    top: ((_padding$top = padding.top) !== null && _padding$top !== void 0 ? _padding$top : 0) + calculated,
    bottom: ((_padding$bottom = padding.bottom) !== null && _padding$bottom !== void 0 ? _padding$bottom : 0) + calculated
  };
});
var combineXAxisRange = createSelector([selectChartOffsetInternal, selectXAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, padding, brushDimensions, _ref4, isPanorama) => {
  var {
    padding: brushPadding
  } = _ref4;
  if (isPanorama) {
    return [brushPadding.left, brushDimensions.width - brushPadding.right];
  }
  return [offset.left + padding.left, offset.left + offset.width - padding.right];
});
var combineYAxisRange = createSelector([selectChartOffsetInternal, selectChartLayout, selectYAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, layout, padding, brushDimensions, _ref5, isPanorama) => {
  var {
    padding: brushPadding
  } = _ref5;
  if (isPanorama) {
    return [brushDimensions.height - brushPadding.bottom, brushPadding.top];
  }
  if (layout === "horizontal") {
    return [offset.top + offset.height - padding.bottom, offset.top + padding.top];
  }
  return [offset.top + padding.top, offset.top + offset.height - padding.bottom];
});
var selectAxisRange = (state, axisType, axisId, isPanorama) => {
  var _selectZAxisSettings;
  switch (axisType) {
    case "xAxis":
      return combineXAxisRange(state, axisId, isPanorama);
    case "yAxis":
      return combineYAxisRange(state, axisId, isPanorama);
    case "zAxis":
      return (_selectZAxisSettings = selectZAxisSettings(state, axisId)) === null || _selectZAxisSettings === void 0 ? void 0 : _selectZAxisSettings.range;
    case "angleAxis":
      return selectAngleAxisRange(state);
    case "radiusAxis":
      return selectRadiusAxisRange(state, axisId);
    default:
      return void 0;
  }
};
var selectAxisRangeWithReverse = createSelector([selectBaseAxis, selectAxisRange], combineAxisRangeWithReverse);
var selectAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomainIncludingNiceTicks, selectAxisRangeWithReverse], combineScaleFunction);
createSelector([selectCartesianItemsSettings, selectAllErrorBarSettings, pickAxisType], combineRelevantErrorBarSettings);
function compareIds(a2, b2) {
  if (a2.id < b2.id) {
    return -1;
  }
  if (a2.id > b2.id) {
    return 1;
  }
  return 0;
}
var pickAxisOrientation = (_state, orientation2) => orientation2;
var pickMirror = (_state, _orientation, mirror) => mirror;
var selectAllXAxesWithOffsetType = createSelector(selectAllXAxes, pickAxisOrientation, pickMirror, (allAxes, orientation2, mirror) => allAxes.filter((axis) => axis.orientation === orientation2).filter((axis) => axis.mirror === mirror).sort(compareIds));
var selectAllYAxesWithOffsetType = createSelector(selectAllYAxes, pickAxisOrientation, pickMirror, (allAxes, orientation2, mirror) => allAxes.filter((axis) => axis.orientation === orientation2).filter((axis) => axis.mirror === mirror).sort(compareIds));
var getXAxisSize = (offset, axisSettings) => {
  return {
    width: offset.width,
    height: axisSettings.height
  };
};
var getYAxisSize = (offset, axisSettings) => {
  var width = typeof axisSettings.width === "number" ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;
  return {
    width,
    height: offset.height
  };
};
var selectXAxisSize = createSelector(selectChartOffsetInternal, selectXAxisSettings, getXAxisSize);
var combineXAxisPositionStartingPoint = (offset, orientation2, chartHeight) => {
  switch (orientation2) {
    case "top":
      return offset.top;
    case "bottom":
      return chartHeight - offset.bottom;
    default:
      return 0;
  }
};
var combineYAxisPositionStartingPoint = (offset, orientation2, chartWidth) => {
  switch (orientation2) {
    case "left":
      return offset.left;
    case "right":
      return chartWidth - offset.right;
    default:
      return 0;
  }
};
var selectAllXAxesOffsetSteps = createSelector(selectChartHeight, selectChartOffsetInternal, selectAllXAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartHeight, offset, allAxesWithSameOffsetType, orientation2, mirror) => {
  var steps = {};
  var position;
  allAxesWithSameOffsetType.forEach((axis) => {
    var axisSize = getXAxisSize(offset, axis);
    if (position == null) {
      position = combineXAxisPositionStartingPoint(offset, orientation2, chartHeight);
    }
    var needSpace = orientation2 === "top" && !mirror || orientation2 === "bottom" && mirror;
    steps[axis.id] = position - Number(needSpace) * axisSize.height;
    position += (needSpace ? -1 : 1) * axisSize.height;
  });
  return steps;
});
var selectAllYAxesOffsetSteps = createSelector(selectChartWidth, selectChartOffsetInternal, selectAllYAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartWidth, offset, allAxesWithSameOffsetType, orientation2, mirror) => {
  var steps = {};
  var position;
  allAxesWithSameOffsetType.forEach((axis) => {
    var axisSize = getYAxisSize(offset, axis);
    if (position == null) {
      position = combineYAxisPositionStartingPoint(offset, orientation2, chartWidth);
    }
    var needSpace = orientation2 === "left" && !mirror || orientation2 === "right" && mirror;
    steps[axis.id] = position - Number(needSpace) * axisSize.width;
    position += (needSpace ? -1 : 1) * axisSize.width;
  });
  return steps;
});
var selectXAxisOffsetSteps = (state, axisId) => {
  var axisSettings = selectXAxisSettings(state, axisId);
  if (axisSettings == null) {
    return void 0;
  }
  return selectAllXAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);
};
var selectXAxisPosition = createSelector([selectChartOffsetInternal, selectXAxisSettings, selectXAxisOffsetSteps, (_2, axisId) => axisId], (offset, axisSettings, allSteps, axisId) => {
  if (axisSettings == null) {
    return void 0;
  }
  var stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];
  if (stepOfThisAxis == null) {
    return {
      x: offset.left,
      y: 0
    };
  }
  return {
    x: offset.left,
    y: stepOfThisAxis
  };
});
var selectYAxisOffsetSteps = (state, axisId) => {
  var axisSettings = selectYAxisSettings(state, axisId);
  if (axisSettings == null) {
    return void 0;
  }
  return selectAllYAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);
};
var selectYAxisPosition = createSelector([selectChartOffsetInternal, selectYAxisSettings, selectYAxisOffsetSteps, (_2, axisId) => axisId], (offset, axisSettings, allSteps, axisId) => {
  if (axisSettings == null) {
    return void 0;
  }
  var stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];
  if (stepOfThisAxis == null) {
    return {
      x: 0,
      y: offset.top
    };
  }
  return {
    x: stepOfThisAxis,
    y: offset.top
  };
});
var selectYAxisSize = createSelector(selectChartOffsetInternal, selectYAxisSettings, (offset, axisSettings) => {
  var width = typeof axisSettings.width === "number" ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;
  return {
    width,
    height: offset.height
  };
});
var selectCartesianAxisSize = (state, axisType, axisId) => {
  switch (axisType) {
    case "xAxis": {
      return selectXAxisSize(state, axisId).width;
    }
    case "yAxis": {
      return selectYAxisSize(state, axisId).height;
    }
    default: {
      return void 0;
    }
  }
};
var combineDuplicateDomain = (chartLayout, appliedValues, axis, axisType) => {
  if (axis == null) {
    return void 0;
  }
  var {
    allowDuplicatedCategory,
    type,
    dataKey
  } = axis;
  var isCategorical = isCategoricalAxis(chartLayout, axisType);
  var allData = appliedValues.map((av) => av.value);
  if (dataKey && isCategorical && type === "category" && allowDuplicatedCategory && hasDuplicate(allData)) {
    return allData;
  }
  return void 0;
};
var selectDuplicateDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectBaseAxis, pickAxisType], combineDuplicateDomain);
var combineCategoricalDomain = (layout, appliedValues, axis, axisType) => {
  if (axis == null || axis.dataKey == null) {
    return void 0;
  }
  var {
    type,
    scale
  } = axis;
  var isCategorical = isCategoricalAxis(layout, axisType);
  if (isCategorical && (type === "number" || scale !== "auto")) {
    return appliedValues.map((d2) => d2.value);
  }
  return void 0;
};
var selectCategoricalDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectAxisSettings, pickAxisType], combineCategoricalDomain);
var selectAxisPropsNeededForCartesianGridTicksGenerator = createSelector([selectChartLayout, selectCartesianAxisSettings, selectRealScaleType, selectAxisScale, selectDuplicateDomain, selectCategoricalDomain, selectAxisRange, selectNiceTicks, pickAxisType], (layout, axis, realScaleType, scale, duplicateDomain, categoricalDomain, axisRange, niceTicks, axisType) => {
  if (axis == null) {
    return null;
  }
  var isCategorical = isCategoricalAxis(layout, axisType);
  return {
    angle: axis.angle,
    interval: axis.interval,
    minTickGap: axis.minTickGap,
    orientation: axis.orientation,
    tick: axis.tick,
    tickCount: axis.tickCount,
    tickFormatter: axis.tickFormatter,
    ticks: axis.ticks,
    type: axis.type,
    unit: axis.unit,
    axisType,
    categoricalDomain,
    duplicateDomain,
    isCategorical,
    niceTicks,
    range: axisRange,
    realScaleType,
    scale
  };
});
var combineAxisTicks = (layout, axis, realScaleType, scale, niceTicks, axisRange, duplicateDomain, categoricalDomain, axisType) => {
  if (axis == null || scale == null) {
    return void 0;
  }
  var isCategorical = isCategoricalAxis(layout, axisType);
  var {
    type,
    ticks: ticks2,
    tickCount
  } = axis;
  var offsetForBand = realScaleType === "scaleBand" && typeof scale.bandwidth === "function" ? scale.bandwidth() / 2 : 2;
  var offset = type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
  offset = axisType === "angleAxis" && axisRange != null && axisRange.length >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;
  var ticksOrNiceTicks = ticks2 || niceTicks;
  if (ticksOrNiceTicks) {
    var result = ticksOrNiceTicks.map((entry, index) => {
      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
      return {
        index,
        // If the scaleContent is not a number, the coordinate will be NaN.
        // That could be the case for example with a PointScale and a string as domain.
        coordinate: scale(scaleContent) + offset,
        value: entry,
        offset
      };
    });
    return result.filter((row) => !isNan(row.coordinate));
  }
  if (isCategorical && categoricalDomain) {
    return categoricalDomain.map((entry, index) => ({
      coordinate: scale(entry) + offset,
      value: entry,
      index,
      offset
    }));
  }
  if (scale.ticks) {
    return scale.ticks(tickCount).map((entry) => ({
      coordinate: scale(entry) + offset,
      value: entry,
      offset
    }));
  }
  return scale.domain().map((entry, index) => ({
    coordinate: scale(entry) + offset,
    value: duplicateDomain ? duplicateDomain[entry] : entry,
    index,
    offset
  }));
};
var selectTicksOfAxis = createSelector([selectChartLayout, selectAxisSettings, selectRealScaleType, selectAxisScale, selectNiceTicks, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineAxisTicks);
var combineGraphicalItemTicks = (layout, axis, scale, axisRange, duplicateDomain, categoricalDomain, axisType) => {
  if (axis == null || scale == null || axisRange == null || axisRange[0] === axisRange[1]) {
    return void 0;
  }
  var isCategorical = isCategoricalAxis(layout, axisType);
  var {
    tickCount
  } = axis;
  var offset = 0;
  offset = axisType === "angleAxis" && (axisRange === null || axisRange === void 0 ? void 0 : axisRange.length) >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;
  if (isCategorical && categoricalDomain) {
    return categoricalDomain.map((entry, index) => ({
      coordinate: scale(entry) + offset,
      value: entry,
      index,
      offset
    }));
  }
  if (scale.ticks) {
    return scale.ticks(tickCount).map((entry) => ({
      coordinate: scale(entry) + offset,
      value: entry,
      offset
    }));
  }
  return scale.domain().map((entry, index) => ({
    coordinate: scale(entry) + offset,
    value: duplicateDomain ? duplicateDomain[entry] : entry,
    index,
    offset
  }));
};
var selectTicksOfGraphicalItem = createSelector([selectChartLayout, selectAxisSettings, selectAxisScale, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineGraphicalItemTicks);
var selectAxisWithScale = createSelector(selectBaseAxis, selectAxisScale, (axis, scale) => {
  if (axis == null || scale == null) {
    return void 0;
  }
  return _objectSpread$m(_objectSpread$m({}, axis), {}, {
    scale
  });
});
var selectZAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomain, selectAxisRangeWithReverse], combineScaleFunction);
createSelector((state, _axisType, axisId) => selectZAxisSettings(state, axisId), selectZAxisScale, (axis, scale) => {
  if (axis == null || scale == null) {
    return void 0;
  }
  return _objectSpread$m(_objectSpread$m({}, axis), {}, {
    scale
  });
});
var selectChartDirection = createSelector([selectChartLayout, selectAllXAxes, selectAllYAxes], (layout, allXAxes, allYAxes) => {
  switch (layout) {
    case "horizontal": {
      return allXAxes.some((axis) => axis.reversed) ? "right-to-left" : "left-to-right";
    }
    case "vertical": {
      return allYAxes.some((axis) => axis.reversed) ? "bottom-to-top" : "top-to-bottom";
    }
    // TODO: make this better. For now, right arrow triggers "forward", left arrow "back"
    // however, the tooltip moves an unintuitive direction because of how the indices are rendered
    case "centric":
    case "radial": {
      return "left-to-right";
    }
    default: {
      return void 0;
    }
  }
});
var selectDefaultTooltipEventType = (state) => state.options.defaultTooltipEventType;
var selectValidateTooltipEventTypes = (state) => state.options.validateTooltipEventTypes;
function combineTooltipEventType(shared, defaultTooltipEventType, validateTooltipEventTypes) {
  if (shared == null) {
    return defaultTooltipEventType;
  }
  var eventType = shared ? "axis" : "item";
  if (validateTooltipEventTypes == null) {
    return defaultTooltipEventType;
  }
  return validateTooltipEventTypes.includes(eventType) ? eventType : defaultTooltipEventType;
}
function selectTooltipEventType$1(state, shared) {
  var defaultTooltipEventType = selectDefaultTooltipEventType(state);
  var validateTooltipEventTypes = selectValidateTooltipEventTypes(state);
  return combineTooltipEventType(shared, defaultTooltipEventType, validateTooltipEventTypes);
}
function useTooltipEventType(shared) {
  return useAppSelector((state) => selectTooltipEventType$1(state, shared));
}
var combineActiveLabel = (tooltipTicks, activeIndex) => {
  var _tooltipTicks$n;
  var n2 = Number(activeIndex);
  if (isNan(n2) || activeIndex == null) {
    return void 0;
  }
  return n2 >= 0 ? tooltipTicks === null || tooltipTicks === void 0 || (_tooltipTicks$n = tooltipTicks[n2]) === null || _tooltipTicks$n === void 0 ? void 0 : _tooltipTicks$n.value : void 0;
};
var selectTooltipSettings = (state) => state.tooltip.settings;
var noInteraction = {
  active: false,
  index: null,
  dataKey: void 0,
  coordinate: void 0
};
var initialState$8 = {
  itemInteraction: {
    click: noInteraction,
    hover: noInteraction
  },
  axisInteraction: {
    click: noInteraction,
    hover: noInteraction
  },
  keyboardInteraction: noInteraction,
  syncInteraction: {
    active: false,
    index: null,
    dataKey: void 0,
    label: void 0,
    coordinate: void 0,
    sourceViewBox: void 0
  },
  tooltipItemPayloads: [],
  settings: {
    shared: void 0,
    trigger: "hover",
    axisId: 0,
    active: false,
    defaultIndex: void 0
  }
};
var tooltipSlice = createSlice({
  name: "tooltip",
  initialState: initialState$8,
  reducers: {
    addTooltipEntrySettings: {
      reducer(state, action) {
        state.tooltipItemPayloads.push(castDraft(action.payload));
      },
      prepare: prepareAutoBatched()
    },
    removeTooltipEntrySettings: {
      reducer(state, action) {
        var index = current(state).tooltipItemPayloads.indexOf(castDraft(action.payload));
        if (index > -1) {
          state.tooltipItemPayloads.splice(index, 1);
        }
      },
      prepare: prepareAutoBatched()
    },
    setTooltipSettingsState(state, action) {
      state.settings = action.payload;
    },
    setActiveMouseOverItemIndex(state, action) {
      state.syncInteraction.active = false;
      state.keyboardInteraction.active = false;
      state.itemInteraction.hover.active = true;
      state.itemInteraction.hover.index = action.payload.activeIndex;
      state.itemInteraction.hover.dataKey = action.payload.activeDataKey;
      state.itemInteraction.hover.coordinate = action.payload.activeCoordinate;
    },
    mouseLeaveChart(state) {
      state.itemInteraction.hover.active = false;
      state.axisInteraction.hover.active = false;
    },
    mouseLeaveItem(state) {
      state.itemInteraction.hover.active = false;
    },
    setActiveClickItemIndex(state, action) {
      state.syncInteraction.active = false;
      state.itemInteraction.click.active = true;
      state.keyboardInteraction.active = false;
      state.itemInteraction.click.index = action.payload.activeIndex;
      state.itemInteraction.click.dataKey = action.payload.activeDataKey;
      state.itemInteraction.click.coordinate = action.payload.activeCoordinate;
    },
    setMouseOverAxisIndex(state, action) {
      state.syncInteraction.active = false;
      state.axisInteraction.hover.active = true;
      state.keyboardInteraction.active = false;
      state.axisInteraction.hover.index = action.payload.activeIndex;
      state.axisInteraction.hover.dataKey = action.payload.activeDataKey;
      state.axisInteraction.hover.coordinate = action.payload.activeCoordinate;
    },
    setMouseClickAxisIndex(state, action) {
      state.syncInteraction.active = false;
      state.keyboardInteraction.active = false;
      state.axisInteraction.click.active = true;
      state.axisInteraction.click.index = action.payload.activeIndex;
      state.axisInteraction.click.dataKey = action.payload.activeDataKey;
      state.axisInteraction.click.coordinate = action.payload.activeCoordinate;
    },
    setSyncInteraction(state, action) {
      state.syncInteraction = action.payload;
    },
    setKeyboardInteraction(state, action) {
      state.keyboardInteraction.active = action.payload.active;
      state.keyboardInteraction.index = action.payload.activeIndex;
      state.keyboardInteraction.coordinate = action.payload.activeCoordinate;
      state.keyboardInteraction.dataKey = action.payload.activeDataKey;
    }
  }
});
var {
  addTooltipEntrySettings,
  removeTooltipEntrySettings,
  setTooltipSettingsState,
  setActiveMouseOverItemIndex,
  mouseLeaveItem,
  mouseLeaveChart,
  setActiveClickItemIndex,
  setMouseOverAxisIndex,
  setMouseClickAxisIndex,
  setSyncInteraction,
  setKeyboardInteraction
} = tooltipSlice.actions;
var tooltipReducer = tooltipSlice.reducer;
function ownKeys$l(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$l(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$l(Object(t2), true).forEach(function(r3) {
      _defineProperty$n(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$l(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$n(e3, r2, t2) {
  return (r2 = _toPropertyKey$n(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$n(t2) {
  var i2 = _toPrimitive$n(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$n(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function chooseAppropriateMouseInteraction(tooltipState, tooltipEventType, trigger) {
  if (tooltipEventType === "axis") {
    if (trigger === "click") {
      return tooltipState.axisInteraction.click;
    }
    return tooltipState.axisInteraction.hover;
  }
  if (trigger === "click") {
    return tooltipState.itemInteraction.click;
  }
  return tooltipState.itemInteraction.hover;
}
function hasBeenActivePreviously(tooltipInteractionState) {
  return tooltipInteractionState.index != null;
}
var combineTooltipInteractionState = (tooltipState, tooltipEventType, trigger, defaultIndex) => {
  if (tooltipEventType == null) {
    return noInteraction;
  }
  var appropriateMouseInteraction = chooseAppropriateMouseInteraction(tooltipState, tooltipEventType, trigger);
  if (appropriateMouseInteraction == null) {
    return noInteraction;
  }
  if (appropriateMouseInteraction.active) {
    return appropriateMouseInteraction;
  }
  if (tooltipState.keyboardInteraction.active) {
    return tooltipState.keyboardInteraction;
  }
  if (tooltipState.syncInteraction.active && tooltipState.syncInteraction.index != null) {
    return tooltipState.syncInteraction;
  }
  var activeFromProps = tooltipState.settings.active === true;
  if (hasBeenActivePreviously(appropriateMouseInteraction)) {
    if (activeFromProps) {
      return _objectSpread$l(_objectSpread$l({}, appropriateMouseInteraction), {}, {
        active: true
      });
    }
  } else if (defaultIndex != null) {
    return {
      active: true,
      coordinate: void 0,
      dataKey: void 0,
      index: defaultIndex
    };
  }
  return _objectSpread$l(_objectSpread$l({}, noInteraction), {}, {
    coordinate: appropriateMouseInteraction.coordinate
  });
};
var combineActiveTooltipIndex = (tooltipInteraction, chartData) => {
  var desiredIndex = tooltipInteraction === null || tooltipInteraction === void 0 ? void 0 : tooltipInteraction.index;
  if (desiredIndex == null) {
    return null;
  }
  var indexAsNumber = Number(desiredIndex);
  if (!isWellBehavedNumber(indexAsNumber)) {
    return desiredIndex;
  }
  var lowerLimit = 0;
  var upperLimit = Infinity;
  if (chartData.length > 0) {
    upperLimit = chartData.length - 1;
  }
  return String(Math.max(lowerLimit, Math.min(indexAsNumber, upperLimit)));
};
var combineCoordinateForDefaultIndex = (width, height, layout, offset, tooltipTicks, defaultIndex, tooltipConfigurations, tooltipPayloadSearcher) => {
  if (defaultIndex == null || tooltipPayloadSearcher == null) {
    return void 0;
  }
  var firstConfiguration = tooltipConfigurations[0];
  var maybePosition = firstConfiguration == null ? void 0 : tooltipPayloadSearcher(firstConfiguration.positions, defaultIndex);
  if (maybePosition != null) {
    return maybePosition;
  }
  var tick = tooltipTicks === null || tooltipTicks === void 0 ? void 0 : tooltipTicks[Number(defaultIndex)];
  if (!tick) {
    return void 0;
  }
  switch (layout) {
    case "horizontal": {
      return {
        x: tick.coordinate,
        y: (offset.top + height) / 2
      };
    }
    default: {
      return {
        x: (offset.left + width) / 2,
        y: tick.coordinate
      };
    }
  }
};
var combineTooltipPayloadConfigurations = (tooltipState, tooltipEventType, trigger, defaultIndex) => {
  if (tooltipEventType === "axis") {
    return tooltipState.tooltipItemPayloads;
  }
  if (tooltipState.tooltipItemPayloads.length === 0) {
    return [];
  }
  var filterByDataKey;
  if (trigger === "hover") {
    filterByDataKey = tooltipState.itemInteraction.hover.dataKey;
  } else {
    filterByDataKey = tooltipState.itemInteraction.click.dataKey;
  }
  if (filterByDataKey == null && defaultIndex != null) {
    return [tooltipState.tooltipItemPayloads[0]];
  }
  return tooltipState.tooltipItemPayloads.filter((tpc) => {
    var _tpc$settings;
    return ((_tpc$settings = tpc.settings) === null || _tpc$settings === void 0 ? void 0 : _tpc$settings.dataKey) === filterByDataKey;
  });
};
var selectTooltipPayloadSearcher = (state) => state.options.tooltipPayloadSearcher;
var selectTooltipState = (state) => state.tooltip;
function ownKeys$k(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$k(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$k(Object(t2), true).forEach(function(r3) {
      _defineProperty$m(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$k(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$m(e3, r2, t2) {
  return (r2 = _toPropertyKey$m(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$m(t2) {
  var i2 = _toPrimitive$m(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$m(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function selectFinalData(dataDefinedOnItem, dataDefinedOnChart) {
  if (dataDefinedOnItem != null) {
    return dataDefinedOnItem;
  }
  return dataDefinedOnChart;
}
var combineTooltipPayload = (tooltipPayloadConfigurations, activeIndex, chartDataState, tooltipAxisDataKey, activeLabel, tooltipPayloadSearcher, tooltipEventType) => {
  if (activeIndex == null || tooltipPayloadSearcher == null) {
    return void 0;
  }
  var {
    chartData,
    computedData,
    dataStartIndex,
    dataEndIndex
  } = chartDataState;
  var init = [];
  return tooltipPayloadConfigurations.reduce((agg, _ref2) => {
    var _settings$dataKey;
    var {
      dataDefinedOnItem,
      settings
    } = _ref2;
    var finalData = selectFinalData(dataDefinedOnItem, chartData);
    var sliced = Array.isArray(finalData) ? getSliced(finalData, dataStartIndex, dataEndIndex) : finalData;
    var finalDataKey = (_settings$dataKey = settings === null || settings === void 0 ? void 0 : settings.dataKey) !== null && _settings$dataKey !== void 0 ? _settings$dataKey : tooltipAxisDataKey;
    var finalNameKey = settings === null || settings === void 0 ? void 0 : settings.nameKey;
    var tooltipPayload;
    if (tooltipAxisDataKey && Array.isArray(sliced) && /*
     * findEntryInArray won't work for Scatter because Scatter provides an array of arrays
     * as tooltip payloads and findEntryInArray is not prepared to handle that.
     * Sad but also ScatterChart only allows 'item' tooltipEventType
     * and also this is only a problem if there are multiple Scatters and each has its own data array
     * so let's fix that some other time.
     */
    !Array.isArray(sliced[0]) && /*
     * If the tooltipEventType is 'axis', we should search for the dataKey in the sliced data
     * because thanks to allowDuplicatedCategory=false, the order of elements in the array
     * no longer matches the order of elements in the original data
     * and so we need to search by the active dataKey + label rather than by index.
     *
     * The same happens if multiple graphical items are present in the chart
     * and each of them has its own data array. Those arrays get concatenated
     * and again the tooltip index no longer matches the original data.
     *
     * On the other hand the tooltipEventType 'item' should always search by index
     * because we get the index from interacting over the individual elements
     * which is always accurate, irrespective of the allowDuplicatedCategory setting.
     */
    tooltipEventType === "axis") {
      tooltipPayload = findEntryInArray(sliced, tooltipAxisDataKey, activeLabel);
    } else {
      tooltipPayload = tooltipPayloadSearcher(sliced, activeIndex, computedData, finalNameKey);
    }
    if (Array.isArray(tooltipPayload)) {
      tooltipPayload.forEach((item) => {
        var newSettings = _objectSpread$k(_objectSpread$k({}, settings), {}, {
          name: item.name,
          unit: item.unit,
          // color and fill are erased to keep 100% the identical behaviour to recharts 2.x - but there's nothing stopping us from returning them here. It's technically a breaking change.
          color: void 0,
          // color and fill are erased to keep 100% the identical behaviour to recharts 2.x - but there's nothing stopping us from returning them here. It's technically a breaking change.
          fill: void 0
        });
        agg.push(getTooltipEntry({
          tooltipEntrySettings: newSettings,
          dataKey: item.dataKey,
          payload: item.payload,
          // @ts-expect-error getValueByDataKey does not validate the output type
          value: getValueByDataKey(item.payload, item.dataKey),
          name: item.name
        }));
      });
    } else {
      var _getValueByDataKey;
      agg.push(getTooltipEntry({
        tooltipEntrySettings: settings,
        dataKey: finalDataKey,
        payload: tooltipPayload,
        // @ts-expect-error getValueByDataKey does not validate the output type
        value: getValueByDataKey(tooltipPayload, finalDataKey),
        // @ts-expect-error getValueByDataKey does not validate the output type
        name: (_getValueByDataKey = getValueByDataKey(tooltipPayload, finalNameKey)) !== null && _getValueByDataKey !== void 0 ? _getValueByDataKey : settings === null || settings === void 0 ? void 0 : settings.name
      }));
    }
    return agg;
  }, init);
};
var selectTooltipAxisRealScaleType = createSelector([selectTooltipAxis, selectChartLayout, selectHasBar, selectChartName, selectTooltipAxisType], combineRealScaleType);
var selectAllUnfilteredGraphicalItems = createSelector([(state) => state.graphicalItems.cartesianItems, (state) => state.graphicalItems.polarItems], (cartesianItems, polarItems) => [...cartesianItems, ...polarItems]);
var selectTooltipAxisPredicate = createSelector([selectTooltipAxisType, selectTooltipAxisId], itemAxisPredicate);
var selectAllGraphicalItemsSettings = createSelector([selectAllUnfilteredGraphicalItems, selectTooltipAxis, selectTooltipAxisPredicate], combineGraphicalItemsSettings, {
  memoizeOptions: {
    resultEqualityCheck: arrayEqualityCheck
  }
});
var selectAllStackedGraphicalItemsSettings = createSelector([selectAllGraphicalItemsSettings], (graphicalItems) => graphicalItems.filter(isStacked));
var selectTooltipGraphicalItemsData = createSelector([selectAllGraphicalItemsSettings], combineGraphicalItemsData, {
  memoizeOptions: {
    resultEqualityCheck: arrayEqualityCheck
  }
});
var selectTooltipDisplayedData = createSelector([selectTooltipGraphicalItemsData, selectChartDataWithIndexes], combineDisplayedData);
var selectTooltipStackedData = createSelector([selectAllStackedGraphicalItemsSettings, selectChartDataWithIndexes, selectTooltipAxis], combineDisplayedStackedData);
var selectAllTooltipAppliedValues = createSelector([selectTooltipDisplayedData, selectTooltipAxis, selectAllGraphicalItemsSettings], combineAppliedValues);
var selectTooltipAxisDomainDefinition = createSelector([selectTooltipAxis], getDomainDefinition);
var selectTooltipDataOverflow = createSelector([selectTooltipAxis], (axisSettings) => axisSettings.allowDataOverflow);
var selectTooltipDomainFromUserPreferences = createSelector([selectTooltipAxisDomainDefinition, selectTooltipDataOverflow], numericalDomainSpecifiedWithoutRequiringData);
var selectAllStackedGraphicalItems = createSelector([selectAllGraphicalItemsSettings], (graphicalItems) => graphicalItems.filter(isStacked));
var selectTooltipStackGroups = createSelector([selectTooltipStackedData, selectAllStackedGraphicalItems, selectStackOffsetType], combineStackGroups);
var selectTooltipDomainOfStackGroups = createSelector([selectTooltipStackGroups, selectChartDataWithIndexes, selectTooltipAxisType, selectTooltipDomainFromUserPreferences], combineDomainOfStackGroups);
var selectTooltipItemsSettingsExceptStacked = createSelector([selectAllGraphicalItemsSettings], filterGraphicalNotStackedItems);
var selectDomainOfAllAppliedNumericalValuesIncludingErrorValues = createSelector([selectTooltipDisplayedData, selectTooltipAxis, selectTooltipItemsSettingsExceptStacked, selectAllErrorBarSettings, selectTooltipAxisType], combineDomainOfAllAppliedNumericalValuesIncludingErrorValues, {
  memoizeOptions: {
    resultEqualityCheck: numberDomainEqualityCheck
  }
});
var selectReferenceDotsByTooltipAxis = createSelector([selectReferenceDots, selectTooltipAxisType, selectTooltipAxisId], filterReferenceElements);
var selectTooltipReferenceDotsDomain = createSelector([selectReferenceDotsByTooltipAxis, selectTooltipAxisType], combineDotsDomain);
var selectReferenceAreasByTooltipAxis = createSelector([selectReferenceAreas, selectTooltipAxisType, selectTooltipAxisId], filterReferenceElements);
var selectTooltipReferenceAreasDomain = createSelector([selectReferenceAreasByTooltipAxis, selectTooltipAxisType], combineAreasDomain);
var selectReferenceLinesByTooltipAxis = createSelector([selectReferenceLines, selectTooltipAxisType, selectTooltipAxisId], filterReferenceElements);
var selectTooltipReferenceLinesDomain = createSelector([selectReferenceLinesByTooltipAxis, selectTooltipAxisType], combineLinesDomain);
var selectTooltipReferenceElementsDomain = createSelector([selectTooltipReferenceDotsDomain, selectTooltipReferenceLinesDomain, selectTooltipReferenceAreasDomain], mergeDomains);
var selectTooltipNumericalDomain = createSelector([selectTooltipAxis, selectTooltipAxisDomainDefinition, selectTooltipDomainFromUserPreferences, selectTooltipDomainOfStackGroups, selectDomainOfAllAppliedNumericalValuesIncludingErrorValues, selectTooltipReferenceElementsDomain, selectChartLayout, selectTooltipAxisType], combineNumericalDomain);
var selectTooltipAxisDomain = createSelector([selectTooltipAxis, selectChartLayout, selectTooltipDisplayedData, selectAllTooltipAppliedValues, selectStackOffsetType, selectTooltipAxisType, selectTooltipNumericalDomain], combineAxisDomain);
var selectTooltipNiceTicks = createSelector([selectTooltipAxisDomain, selectTooltipAxis, selectTooltipAxisRealScaleType], combineNiceTicks);
var selectTooltipAxisDomainIncludingNiceTicks = createSelector([selectTooltipAxis, selectTooltipAxisDomain, selectTooltipNiceTicks, selectTooltipAxisType], combineAxisDomainWithNiceTicks);
var selectTooltipAxisRange = (state) => {
  var axisType = selectTooltipAxisType(state);
  var axisId = selectTooltipAxisId(state);
  var isPanorama = false;
  return selectAxisRange(state, axisType, axisId, isPanorama);
};
var selectTooltipAxisRangeWithReverse = createSelector([selectTooltipAxis, selectTooltipAxisRange], combineAxisRangeWithReverse);
var selectTooltipAxisScale = createSelector([selectTooltipAxis, selectTooltipAxisRealScaleType, selectTooltipAxisDomainIncludingNiceTicks, selectTooltipAxisRangeWithReverse], combineScaleFunction);
var selectTooltipDuplicateDomain = createSelector([selectChartLayout, selectAllTooltipAppliedValues, selectTooltipAxis, selectTooltipAxisType], combineDuplicateDomain);
var selectTooltipCategoricalDomain = createSelector([selectChartLayout, selectAllTooltipAppliedValues, selectTooltipAxis, selectTooltipAxisType], combineCategoricalDomain);
var combineTicksOfTooltipAxis = (layout, axis, realScaleType, scale, range2, duplicateDomain, categoricalDomain, axisType) => {
  if (!axis) {
    return void 0;
  }
  var {
    type
  } = axis;
  var isCategorical = isCategoricalAxis(layout, axisType);
  if (!scale) {
    return void 0;
  }
  var offsetForBand = realScaleType === "scaleBand" && scale.bandwidth ? scale.bandwidth() / 2 : 2;
  var offset = type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
  offset = axisType === "angleAxis" && range2 != null && (range2 === null || range2 === void 0 ? void 0 : range2.length) >= 2 ? mathSign(range2[0] - range2[1]) * 2 * offset : offset;
  if (isCategorical && categoricalDomain) {
    return categoricalDomain.map((entry, index) => ({
      coordinate: scale(entry) + offset,
      value: entry,
      index,
      offset
    }));
  }
  return scale.domain().map((entry, index) => ({
    coordinate: scale(entry) + offset,
    value: duplicateDomain ? duplicateDomain[entry] : entry,
    index,
    offset
  }));
};
var selectTooltipAxisTicks = createSelector([selectChartLayout, selectTooltipAxis, selectTooltipAxisRealScaleType, selectTooltipAxisScale, selectTooltipAxisRange, selectTooltipDuplicateDomain, selectTooltipCategoricalDomain, selectTooltipAxisType], combineTicksOfTooltipAxis);
var selectTooltipEventType = createSelector([selectDefaultTooltipEventType, selectValidateTooltipEventTypes, selectTooltipSettings], (defaultTooltipEventType, validateTooltipEventType, settings) => combineTooltipEventType(settings.shared, defaultTooltipEventType, validateTooltipEventType));
var selectTooltipTrigger = (state) => state.tooltip.settings.trigger;
var selectDefaultIndex = (state) => state.tooltip.settings.defaultIndex;
var selectTooltipInteractionState$1 = createSelector([selectTooltipState, selectTooltipEventType, selectTooltipTrigger, selectDefaultIndex], combineTooltipInteractionState);
var selectActiveTooltipIndex = createSelector([selectTooltipInteractionState$1, selectTooltipDisplayedData], combineActiveTooltipIndex);
var selectActiveLabel$1 = createSelector([selectTooltipAxisTicks, selectActiveTooltipIndex], combineActiveLabel);
var selectActiveTooltipDataKey = createSelector([selectTooltipInteractionState$1], (tooltipInteraction) => {
  if (!tooltipInteraction) {
    return void 0;
  }
  return tooltipInteraction.dataKey;
});
var selectTooltipPayloadConfigurations$1 = createSelector([selectTooltipState, selectTooltipEventType, selectTooltipTrigger, selectDefaultIndex], combineTooltipPayloadConfigurations);
var selectTooltipCoordinateForDefaultIndex = createSelector([selectChartWidth, selectChartHeight, selectChartLayout, selectChartOffsetInternal, selectTooltipAxisTicks, selectDefaultIndex, selectTooltipPayloadConfigurations$1, selectTooltipPayloadSearcher], combineCoordinateForDefaultIndex);
var selectActiveTooltipCoordinate = createSelector([selectTooltipInteractionState$1, selectTooltipCoordinateForDefaultIndex], (tooltipInteractionState, defaultIndexCoordinate) => {
  if (tooltipInteractionState !== null && tooltipInteractionState !== void 0 && tooltipInteractionState.coordinate) {
    return tooltipInteractionState.coordinate;
  }
  return defaultIndexCoordinate;
});
var selectIsTooltipActive$1 = createSelector([selectTooltipInteractionState$1], (tooltipInteractionState) => tooltipInteractionState.active);
var selectActiveTooltipPayload = createSelector([selectTooltipPayloadConfigurations$1, selectActiveTooltipIndex, selectChartDataWithIndexes, selectTooltipAxisDataKey, selectActiveLabel$1, selectTooltipPayloadSearcher, selectTooltipEventType], combineTooltipPayload);
var selectActiveTooltipDataPoints = createSelector([selectActiveTooltipPayload], (payload) => {
  if (payload == null) {
    return void 0;
  }
  var dataPoints = payload.map((p2) => p2.payload).filter((p2) => p2 != null);
  return Array.from(new Set(dataPoints));
});
function ownKeys$j(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$j(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$j(Object(t2), true).forEach(function(r3) {
      _defineProperty$l(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$j(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$l(e3, r2, t2) {
  return (r2 = _toPropertyKey$l(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$l(t2) {
  var i2 = _toPrimitive$l(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$l(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var useTooltipAxis = () => useAppSelector(selectTooltipAxis);
var useTooltipAxisBandSize = () => {
  var tooltipAxis = useTooltipAxis();
  var tooltipTicks = useAppSelector(selectTooltipAxisTicks);
  var tooltipAxisScale = useAppSelector(selectTooltipAxisScale);
  return getBandSizeOfAxis(_objectSpread$j(_objectSpread$j({}, tooltipAxis), {}, {
    scale: tooltipAxisScale
  }), tooltipTicks);
};
var useChartName = () => {
  return useAppSelector(selectChartName);
};
var pickTooltipEventType = (_state, tooltipEventType) => tooltipEventType;
var pickTrigger = (_state, _tooltipEventType, trigger) => trigger;
var pickDefaultIndex = (_state, _tooltipEventType, _trigger, defaultIndex) => defaultIndex;
var selectOrderedTooltipTicks = createSelector(selectTooltipAxisTicks, (ticks2) => sortBy(ticks2, (o2) => o2.coordinate));
var selectTooltipInteractionState = createSelector([selectTooltipState, pickTooltipEventType, pickTrigger, pickDefaultIndex], combineTooltipInteractionState);
var selectActiveIndex = createSelector([selectTooltipInteractionState, selectTooltipDisplayedData], combineActiveTooltipIndex);
var selectTooltipDataKey = (state, tooltipEventType, trigger) => {
  if (tooltipEventType == null) {
    return void 0;
  }
  var tooltipState = selectTooltipState(state);
  if (tooltipEventType === "axis") {
    if (trigger === "hover") {
      return tooltipState.axisInteraction.hover.dataKey;
    }
    return tooltipState.axisInteraction.click.dataKey;
  }
  if (trigger === "hover") {
    return tooltipState.itemInteraction.hover.dataKey;
  }
  return tooltipState.itemInteraction.click.dataKey;
};
var selectTooltipPayloadConfigurations = createSelector([selectTooltipState, pickTooltipEventType, pickTrigger, pickDefaultIndex], combineTooltipPayloadConfigurations);
var selectCoordinateForDefaultIndex = createSelector([selectChartWidth, selectChartHeight, selectChartLayout, selectChartOffsetInternal, selectTooltipAxisTicks, pickDefaultIndex, selectTooltipPayloadConfigurations, selectTooltipPayloadSearcher], combineCoordinateForDefaultIndex);
var selectActiveCoordinate = createSelector([selectTooltipInteractionState, selectCoordinateForDefaultIndex], (tooltipInteractionState, defaultIndexCoordinate) => {
  var _tooltipInteractionSt;
  return (_tooltipInteractionSt = tooltipInteractionState.coordinate) !== null && _tooltipInteractionSt !== void 0 ? _tooltipInteractionSt : defaultIndexCoordinate;
});
var selectActiveLabel = createSelector(selectTooltipAxisTicks, selectActiveIndex, combineActiveLabel);
var selectTooltipPayload = createSelector([selectTooltipPayloadConfigurations, selectActiveIndex, selectChartDataWithIndexes, selectTooltipAxisDataKey, selectActiveLabel, selectTooltipPayloadSearcher, pickTooltipEventType], combineTooltipPayload);
var selectIsTooltipActive = createSelector([selectTooltipInteractionState], (tooltipInteractionState) => {
  return {
    isActive: tooltipInteractionState.active,
    activeIndex: tooltipInteractionState.index
  };
});
var combineActiveProps = (chartEvent, layout, polarViewBox, tooltipAxisType, tooltipAxisRange, tooltipTicks, orderedTooltipTicks, offset) => {
  if (!chartEvent || !layout || !tooltipAxisType || !tooltipAxisRange || !tooltipTicks) {
    return void 0;
  }
  var rangeObj = inRange(chartEvent.chartX, chartEvent.chartY, layout, polarViewBox, offset);
  if (!rangeObj) {
    return void 0;
  }
  var pos = calculateTooltipPos(rangeObj, layout);
  var activeIndex = calculateActiveTickIndex(pos, orderedTooltipTicks, tooltipTicks, tooltipAxisType, tooltipAxisRange);
  var activeCoordinate = getActiveCoordinate(layout, tooltipTicks, activeIndex, rangeObj);
  return {
    activeIndex: String(activeIndex),
    activeCoordinate
  };
};
function _extends$h() {
  return _extends$h = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$h.apply(null, arguments);
}
function ownKeys$i(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$i(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$i(Object(t2), true).forEach(function(r3) {
      _defineProperty$k(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$i(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$k(e3, r2, t2) {
  return (r2 = _toPropertyKey$k(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$k(t2) {
  var i2 = _toPrimitive$k(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$k(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function CursorInternal(props) {
  var {
    coordinate,
    payload,
    index,
    offset,
    tooltipAxisBandSize,
    layout,
    cursor,
    tooltipEventType,
    chartName
  } = props;
  var activeCoordinate = coordinate;
  var activePayload = payload;
  var activeTooltipIndex = index;
  if (!cursor || !activeCoordinate || chartName !== "ScatterChart" && tooltipEventType !== "axis") {
    return null;
  }
  var restProps, cursorComp;
  if (chartName === "ScatterChart") {
    restProps = activeCoordinate;
    cursorComp = Cross;
  } else if (chartName === "BarChart") {
    restProps = getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize);
    cursorComp = Rectangle;
  } else if (layout === "radial") {
    var {
      cx,
      cy,
      radius,
      startAngle,
      endAngle
    } = getRadialCursorPoints(activeCoordinate);
    restProps = {
      cx,
      cy,
      startAngle,
      endAngle,
      innerRadius: radius,
      outerRadius: radius
    };
    cursorComp = Sector;
  } else {
    restProps = {
      points: getCursorPoints(layout, activeCoordinate, offset)
    };
    cursorComp = Curve;
  }
  var extraClassName = typeof cursor === "object" && "className" in cursor ? cursor.className : void 0;
  var cursorProps = _objectSpread$i(_objectSpread$i(_objectSpread$i(_objectSpread$i({
    stroke: "#ccc",
    pointerEvents: "none"
  }, offset), restProps), svgPropertiesNoEventsFromUnknown(cursor)), {}, {
    payload: activePayload,
    payloadIndex: activeTooltipIndex,
    className: clsx("recharts-tooltip-cursor", extraClassName)
  });
  if (/* @__PURE__ */ reactExports.isValidElement(cursor)) {
    return /* @__PURE__ */ reactExports.cloneElement(cursor, cursorProps);
  }
  return /* @__PURE__ */ reactExports.createElement(cursorComp, cursorProps);
}
function Cursor(props) {
  var tooltipAxisBandSize = useTooltipAxisBandSize();
  var offset = useOffsetInternal();
  var layout = useChartLayout();
  var chartName = useChartName();
  return /* @__PURE__ */ reactExports.createElement(CursorInternal, _extends$h({}, props, {
    coordinate: props.coordinate,
    index: props.index,
    payload: props.payload,
    offset,
    layout,
    tooltipAxisBandSize,
    chartName
  }));
}
var TooltipPortalContext = /* @__PURE__ */ reactExports.createContext(null);
var useTooltipPortal = () => reactExports.useContext(TooltipPortalContext);
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3) return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has2 = Object.prototype.hasOwnProperty, prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix2 = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener2(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener2 = new EE(fn, context || emitter, once), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener2, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener2);
      else emitter._events[evt] = [emitter._events[evt], listener2];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has2.call(events, name)) names.push(prefix2 ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j2;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener2(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener2(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener2(event, fn, context, once) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events.push(listeners[i2]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix2;
    EventEmitter3.EventEmitter = EventEmitter3;
    {
      module.exports = EventEmitter3;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var eventemitter3Exports = requireEventemitter3();
const EventEmitter2 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var eventCenter = new EventEmitter2();
var TOOLTIP_SYNC_EVENT = "recharts.syncEvent.tooltip";
var BRUSH_SYNC_EVENT = "recharts.syncEvent.brush";
function arrayTooltipSearcher(data, strIndex) {
  if (!strIndex) return void 0;
  var numIndex = Number.parseInt(strIndex, 10);
  if (isNan(numIndex)) {
    return void 0;
  }
  return data === null || data === void 0 ? void 0 : data[numIndex];
}
var initialState$7 = {
  chartName: "",
  tooltipPayloadSearcher: void 0,
  eventEmitter: void 0,
  defaultTooltipEventType: "axis"
};
var optionsSlice = createSlice({
  name: "options",
  initialState: initialState$7,
  reducers: {
    createEventEmitter: (state) => {
      if (state.eventEmitter == null) {
        state.eventEmitter = Symbol("rechartsEventEmitter");
      }
    }
  }
});
var optionsReducer = optionsSlice.reducer;
var {
  createEventEmitter
} = optionsSlice.actions;
function selectSynchronisedTooltipState(state) {
  return state.tooltip.syncInteraction;
}
var initialChartDataState = {
  chartData: void 0,
  computedData: void 0,
  dataStartIndex: 0,
  dataEndIndex: 0
};
var chartDataSlice = createSlice({
  name: "chartData",
  initialState: initialChartDataState,
  reducers: {
    setChartData(state, action) {
      state.chartData = action.payload;
      if (action.payload == null) {
        state.dataStartIndex = 0;
        state.dataEndIndex = 0;
        return;
      }
      if (action.payload.length > 0 && state.dataEndIndex !== action.payload.length - 1) {
        state.dataEndIndex = action.payload.length - 1;
      }
    },
    setComputedData(state, action) {
      state.computedData = action.payload;
    },
    setDataStartEndIndexes(state, action) {
      var {
        startIndex,
        endIndex
      } = action.payload;
      if (startIndex != null) {
        state.dataStartIndex = startIndex;
      }
      if (endIndex != null) {
        state.dataEndIndex = endIndex;
      }
    }
  }
});
var {
  setChartData,
  setDataStartEndIndexes,
  setComputedData
} = chartDataSlice.actions;
var chartDataReducer = chartDataSlice.reducer;
var _excluded$g = ["x", "y"];
function ownKeys$h(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$h(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$h(Object(t2), true).forEach(function(r3) {
      _defineProperty$j(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$h(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$j(e3, r2, t2) {
  return (r2 = _toPropertyKey$j(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$j(t2) {
  var i2 = _toPrimitive$j(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$j(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$g(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$g(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$g(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
var noop$1 = () => {
};
function useTooltipSyncEventsListener() {
  var mySyncId = useAppSelector(selectSyncId);
  var myEventEmitter = useAppSelector(selectEventEmitter);
  var dispatch = useAppDispatch();
  var syncMethod = useAppSelector(selectSyncMethod);
  var tooltipTicks = useAppSelector(selectTooltipAxisTicks);
  var layout = useChartLayout();
  var viewBox = useViewBox();
  var className = useAppSelector((state) => state.rootProps.className);
  reactExports.useEffect(() => {
    if (mySyncId == null) {
      return noop$1;
    }
    var listener2 = (incomingSyncId, action, emitter) => {
      if (myEventEmitter === emitter) {
        return;
      }
      if (mySyncId !== incomingSyncId) {
        return;
      }
      if (syncMethod === "index") {
        var _action$payload;
        if (viewBox && action !== null && action !== void 0 && (_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.coordinate && action.payload.sourceViewBox) {
          var _action$payload$coord = action.payload.coordinate, {
            x: _x,
            y: _y
          } = _action$payload$coord, otherCoordinateProps = _objectWithoutProperties$g(_action$payload$coord, _excluded$g);
          var {
            x: sourceX,
            y: sourceY,
            width: sourceWidth,
            height: sourceHeight
          } = action.payload.sourceViewBox;
          var scaledCoordinate = _objectSpread$h(_objectSpread$h({}, otherCoordinateProps), {}, {
            x: viewBox.x + (sourceWidth ? (_x - sourceX) / sourceWidth : 0) * viewBox.width,
            y: viewBox.y + (sourceHeight ? (_y - sourceY) / sourceHeight : 0) * viewBox.height
          });
          dispatch(_objectSpread$h(_objectSpread$h({}, action), {}, {
            payload: _objectSpread$h(_objectSpread$h({}, action.payload), {}, {
              coordinate: scaledCoordinate
            })
          }));
        } else {
          dispatch(action);
        }
        return;
      }
      if (tooltipTicks == null) {
        return;
      }
      var activeTick;
      if (typeof syncMethod === "function") {
        var syncMethodParam = {
          activeTooltipIndex: action.payload.index == null ? void 0 : Number(action.payload.index),
          isTooltipActive: action.payload.active,
          activeIndex: action.payload.index == null ? void 0 : Number(action.payload.index),
          activeLabel: action.payload.label,
          activeDataKey: action.payload.dataKey,
          activeCoordinate: action.payload.coordinate
        };
        var activeTooltipIndex = syncMethod(tooltipTicks, syncMethodParam);
        activeTick = tooltipTicks[activeTooltipIndex];
      } else if (syncMethod === "value") {
        activeTick = tooltipTicks.find((tick) => String(tick.value) === action.payload.label);
      }
      var {
        coordinate
      } = action.payload;
      if (activeTick == null || action.payload.active === false || coordinate == null || viewBox == null) {
        dispatch(setSyncInteraction({
          active: false,
          coordinate: void 0,
          dataKey: void 0,
          index: null,
          label: void 0,
          sourceViewBox: void 0
        }));
        return;
      }
      var {
        x: x2,
        y: y2
      } = coordinate;
      var validateChartX = Math.min(x2, viewBox.x + viewBox.width);
      var validateChartY = Math.min(y2, viewBox.y + viewBox.height);
      var activeCoordinate = {
        x: layout === "horizontal" ? activeTick.coordinate : validateChartX,
        y: layout === "horizontal" ? validateChartY : activeTick.coordinate
      };
      var syncAction = setSyncInteraction({
        active: action.payload.active,
        coordinate: activeCoordinate,
        dataKey: action.payload.dataKey,
        index: String(activeTick.index),
        label: action.payload.label,
        sourceViewBox: action.payload.sourceViewBox
      });
      dispatch(syncAction);
    };
    eventCenter.on(TOOLTIP_SYNC_EVENT, listener2);
    return () => {
      eventCenter.off(TOOLTIP_SYNC_EVENT, listener2);
    };
  }, [className, dispatch, myEventEmitter, mySyncId, syncMethod, tooltipTicks, layout, viewBox]);
}
function useBrushSyncEventsListener() {
  var mySyncId = useAppSelector(selectSyncId);
  var myEventEmitter = useAppSelector(selectEventEmitter);
  var dispatch = useAppDispatch();
  reactExports.useEffect(() => {
    if (mySyncId == null) {
      return noop$1;
    }
    var listener2 = (incomingSyncId, action, emitter) => {
      if (myEventEmitter === emitter) {
        return;
      }
      if (mySyncId === incomingSyncId) {
        dispatch(setDataStartEndIndexes(action));
      }
    };
    eventCenter.on(BRUSH_SYNC_EVENT, listener2);
    return () => {
      eventCenter.off(BRUSH_SYNC_EVENT, listener2);
    };
  }, [dispatch, myEventEmitter, mySyncId]);
}
function useSynchronisedEventsFromOtherCharts() {
  var dispatch = useAppDispatch();
  reactExports.useEffect(() => {
    dispatch(createEventEmitter());
  }, [dispatch]);
  useTooltipSyncEventsListener();
  useBrushSyncEventsListener();
}
function useTooltipChartSynchronisation(tooltipEventType, trigger, activeCoordinate, activeLabel, activeIndex, isTooltipActive) {
  var activeDataKey = useAppSelector((state) => selectTooltipDataKey(state, tooltipEventType, trigger));
  var eventEmitterSymbol = useAppSelector(selectEventEmitter);
  var syncId = useAppSelector(selectSyncId);
  var syncMethod = useAppSelector(selectSyncMethod);
  var tooltipState = useAppSelector(selectSynchronisedTooltipState);
  var isReceivingSynchronisation = tooltipState === null || tooltipState === void 0 ? void 0 : tooltipState.active;
  var viewBox = useViewBox();
  reactExports.useEffect(() => {
    if (isReceivingSynchronisation) {
      return;
    }
    if (syncId == null) {
      return;
    }
    if (eventEmitterSymbol == null) {
      return;
    }
    var syncAction = setSyncInteraction({
      active: isTooltipActive,
      coordinate: activeCoordinate,
      dataKey: activeDataKey,
      index: activeIndex,
      label: typeof activeLabel === "number" ? String(activeLabel) : activeLabel,
      sourceViewBox: viewBox
    });
    eventCenter.emit(TOOLTIP_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);
  }, [isReceivingSynchronisation, activeCoordinate, activeDataKey, activeIndex, activeLabel, eventEmitterSymbol, syncId, syncMethod, isTooltipActive, viewBox]);
}
function ownKeys$g(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$g(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$g(Object(t2), true).forEach(function(r3) {
      _defineProperty$i(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$g(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$i(e3, r2, t2) {
  return (r2 = _toPropertyKey$i(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$i(t2) {
  var i2 = _toPrimitive$i(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$i(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function defaultUniqBy(entry) {
  return entry.dataKey;
}
function renderContent(content, props) {
  if (/* @__PURE__ */ reactExports.isValidElement(content)) {
    return /* @__PURE__ */ reactExports.cloneElement(content, props);
  }
  if (typeof content === "function") {
    return /* @__PURE__ */ reactExports.createElement(content, props);
  }
  return /* @__PURE__ */ reactExports.createElement(DefaultTooltipContent, props);
}
var emptyPayload = [];
var defaultTooltipProps = {
  allowEscapeViewBox: {
    x: false,
    y: false
  },
  animationDuration: 400,
  animationEasing: "ease",
  axisId: 0,
  contentStyle: {},
  cursor: true,
  filterNull: true,
  isAnimationActive: !Global.isSsr,
  itemSorter: "name",
  itemStyle: {},
  labelStyle: {},
  offset: 10,
  reverseDirection: {
    x: false,
    y: false
  },
  separator: " : ",
  trigger: "hover",
  useTranslate3d: false,
  wrapperStyle: {}
};
function Tooltip(outsideProps) {
  var props = resolveDefaultProps(outsideProps, defaultTooltipProps);
  var {
    active: activeFromProps,
    allowEscapeViewBox,
    animationDuration,
    animationEasing,
    content,
    filterNull,
    isAnimationActive,
    offset,
    payloadUniqBy,
    position,
    reverseDirection,
    useTranslate3d,
    wrapperStyle,
    cursor,
    shared,
    trigger,
    defaultIndex,
    portal: portalFromProps,
    axisId
  } = props;
  var dispatch = useAppDispatch();
  var defaultIndexAsString = typeof defaultIndex === "number" ? String(defaultIndex) : defaultIndex;
  reactExports.useEffect(() => {
    dispatch(setTooltipSettingsState({
      shared,
      trigger,
      axisId,
      active: activeFromProps,
      defaultIndex: defaultIndexAsString
    }));
  }, [dispatch, shared, trigger, axisId, activeFromProps, defaultIndexAsString]);
  var viewBox = useViewBox();
  var accessibilityLayer = useAccessibilityLayer();
  var tooltipEventType = useTooltipEventType(shared);
  var {
    activeIndex,
    isActive
  } = useAppSelector((state) => selectIsTooltipActive(state, tooltipEventType, trigger, defaultIndexAsString));
  var payloadFromRedux = useAppSelector((state) => selectTooltipPayload(state, tooltipEventType, trigger, defaultIndexAsString));
  var labelFromRedux = useAppSelector((state) => selectActiveLabel(state, tooltipEventType, trigger, defaultIndexAsString));
  var coordinate = useAppSelector((state) => selectActiveCoordinate(state, tooltipEventType, trigger, defaultIndexAsString));
  var payload = payloadFromRedux;
  var tooltipPortalFromContext = useTooltipPortal();
  var finalIsActive = activeFromProps !== null && activeFromProps !== void 0 ? activeFromProps : isActive;
  var [lastBoundingBox, updateBoundingBox] = useElementOffset([payload, finalIsActive]);
  var finalLabel = tooltipEventType === "axis" ? labelFromRedux : void 0;
  useTooltipChartSynchronisation(tooltipEventType, trigger, coordinate, finalLabel, activeIndex, finalIsActive);
  var tooltipPortal = portalFromProps !== null && portalFromProps !== void 0 ? portalFromProps : tooltipPortalFromContext;
  if (tooltipPortal == null) {
    return null;
  }
  var finalPayload = payload !== null && payload !== void 0 ? payload : emptyPayload;
  if (!finalIsActive) {
    finalPayload = emptyPayload;
  }
  if (filterNull && finalPayload.length) {
    finalPayload = getUniqPayload(payload.filter((entry) => entry.value != null && (entry.hide !== true || props.includeHidden)), payloadUniqBy, defaultUniqBy);
  }
  var hasPayload = finalPayload.length > 0;
  var tooltipElement = /* @__PURE__ */ reactExports.createElement(TooltipBoundingBox, {
    allowEscapeViewBox,
    animationDuration,
    animationEasing,
    isAnimationActive,
    active: finalIsActive,
    coordinate,
    hasPayload,
    offset,
    position,
    reverseDirection,
    useTranslate3d,
    viewBox,
    wrapperStyle,
    lastBoundingBox,
    innerRef: updateBoundingBox,
    hasPortalFromProps: Boolean(portalFromProps)
  }, renderContent(content, _objectSpread$g(_objectSpread$g({}, props), {}, {
    // @ts-expect-error renderContent method expects the payload to be mutable, TODO make it immutable
    payload: finalPayload,
    label: finalLabel,
    active: finalIsActive,
    coordinate,
    accessibilityLayer
  })));
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactDomExports.createPortal(tooltipElement, tooltipPortal), finalIsActive && /* @__PURE__ */ reactExports.createElement(Cursor, {
    cursor,
    tooltipEventType,
    coordinate,
    payload,
    index: activeIndex
  }));
}
var Cell = (_props) => null;
Cell.displayName = "Cell";
function _defineProperty$h(e3, r2, t2) {
  return (r2 = _toPropertyKey$h(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$h(t2) {
  var i2 = _toPrimitive$h(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$h(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
class LRUCache {
  constructor(maxSize) {
    _defineProperty$h(this, "cache", /* @__PURE__ */ new Map());
    this.maxSize = maxSize;
  }
  get(key) {
    var value = this.cache.get(key);
    if (value !== void 0) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      var firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
  clear() {
    this.cache.clear();
  }
  size() {
    return this.cache.size;
  }
}
function ownKeys$f(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$f(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$f(Object(t2), true).forEach(function(r3) {
      _defineProperty$g(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$f(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$g(e3, r2, t2) {
  return (r2 = _toPropertyKey$g(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$g(t2) {
  var i2 = _toPrimitive$g(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$g(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var defaultConfig = {
  cacheSize: 2e3,
  enableCache: true
};
var currentConfig = _objectSpread$f({}, defaultConfig);
var stringCache = new LRUCache(currentConfig.cacheSize);
var SPAN_STYLE = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
};
var MEASUREMENT_SPAN_ID = "recharts_measurement_span";
function createCacheKey(text, style) {
  var fontSize = style.fontSize || "";
  var fontFamily = style.fontFamily || "";
  var fontWeight = style.fontWeight || "";
  var fontStyle = style.fontStyle || "";
  var letterSpacing = style.letterSpacing || "";
  var textTransform = style.textTransform || "";
  return "".concat(text, "|").concat(fontSize, "|").concat(fontFamily, "|").concat(fontWeight, "|").concat(fontStyle, "|").concat(letterSpacing, "|").concat(textTransform);
}
var measureTextWithDOM = (text, style) => {
  try {
    var measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
    if (!measurementSpan) {
      measurementSpan = document.createElement("span");
      measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
      measurementSpan.setAttribute("aria-hidden", "true");
      document.body.appendChild(measurementSpan);
    }
    Object.assign(measurementSpan.style, SPAN_STYLE, style);
    measurementSpan.textContent = "".concat(text);
    var rect = measurementSpan.getBoundingClientRect();
    return {
      width: rect.width,
      height: rect.height
    };
  } catch (_unused) {
    return {
      width: 0,
      height: 0
    };
  }
};
var getStringSize = function getStringSize2(text) {
  var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (text === void 0 || text === null || Global.isSsr) {
    return {
      width: 0,
      height: 0
    };
  }
  if (!currentConfig.enableCache) {
    return measureTextWithDOM(text, style);
  }
  var cacheKey = createCacheKey(text, style);
  var cachedResult = stringCache.get(cacheKey);
  if (cachedResult) {
    return cachedResult;
  }
  var result = measureTextWithDOM(text, style);
  stringCache.set(cacheKey, result);
  return result;
};
var MULTIPLY_OR_DIVIDE_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
var ADD_OR_SUBTRACT_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
var CSS_LENGTH_UNIT_REGEX = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/;
var NUM_SPLIT_REGEX = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/;
var CONVERSION_RATES = {
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  pt: 96 / 72,
  pc: 96 / 6,
  in: 96,
  Q: 96 / (2.54 * 40),
  px: 1
};
var FIXED_CSS_LENGTH_UNITS = Object.keys(CONVERSION_RATES);
var STR_NAN = "NaN";
function convertToPx(value, unit2) {
  return value * CONVERSION_RATES[unit2];
}
class DecimalCSS {
  static parse(str) {
    var _NUM_SPLIT_REGEX$exec;
    var [, numStr, unit2] = (_NUM_SPLIT_REGEX$exec = NUM_SPLIT_REGEX.exec(str)) !== null && _NUM_SPLIT_REGEX$exec !== void 0 ? _NUM_SPLIT_REGEX$exec : [];
    return new DecimalCSS(parseFloat(numStr), unit2 !== null && unit2 !== void 0 ? unit2 : "");
  }
  constructor(num, unit2) {
    this.num = num;
    this.unit = unit2;
    this.num = num;
    this.unit = unit2;
    if (isNan(num)) {
      this.unit = "";
    }
    if (unit2 !== "" && !CSS_LENGTH_UNIT_REGEX.test(unit2)) {
      this.num = NaN;
      this.unit = "";
    }
    if (FIXED_CSS_LENGTH_UNITS.includes(unit2)) {
      this.num = convertToPx(num, unit2);
      this.unit = "px";
    }
  }
  add(other) {
    if (this.unit !== other.unit) {
      return new DecimalCSS(NaN, "");
    }
    return new DecimalCSS(this.num + other.num, this.unit);
  }
  subtract(other) {
    if (this.unit !== other.unit) {
      return new DecimalCSS(NaN, "");
    }
    return new DecimalCSS(this.num - other.num, this.unit);
  }
  multiply(other) {
    if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) {
      return new DecimalCSS(NaN, "");
    }
    return new DecimalCSS(this.num * other.num, this.unit || other.unit);
  }
  divide(other) {
    if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) {
      return new DecimalCSS(NaN, "");
    }
    return new DecimalCSS(this.num / other.num, this.unit || other.unit);
  }
  toString() {
    return "".concat(this.num).concat(this.unit);
  }
  isNaN() {
    return isNan(this.num);
  }
}
function calculateArithmetic(expr) {
  if (expr.includes(STR_NAN)) {
    return STR_NAN;
  }
  var newExpr = expr;
  while (newExpr.includes("*") || newExpr.includes("/")) {
    var _MULTIPLY_OR_DIVIDE_R;
    var [, leftOperand, operator, rightOperand] = (_MULTIPLY_OR_DIVIDE_R = MULTIPLY_OR_DIVIDE_REGEX.exec(newExpr)) !== null && _MULTIPLY_OR_DIVIDE_R !== void 0 ? _MULTIPLY_OR_DIVIDE_R : [];
    var lTs = DecimalCSS.parse(leftOperand !== null && leftOperand !== void 0 ? leftOperand : "");
    var rTs = DecimalCSS.parse(rightOperand !== null && rightOperand !== void 0 ? rightOperand : "");
    var result = operator === "*" ? lTs.multiply(rTs) : lTs.divide(rTs);
    if (result.isNaN()) {
      return STR_NAN;
    }
    newExpr = newExpr.replace(MULTIPLY_OR_DIVIDE_REGEX, result.toString());
  }
  while (newExpr.includes("+") || /.-\d+(?:\.\d+)?/.test(newExpr)) {
    var _ADD_OR_SUBTRACT_REGE;
    var [, _leftOperand, _operator, _rightOperand] = (_ADD_OR_SUBTRACT_REGE = ADD_OR_SUBTRACT_REGEX.exec(newExpr)) !== null && _ADD_OR_SUBTRACT_REGE !== void 0 ? _ADD_OR_SUBTRACT_REGE : [];
    var _lTs = DecimalCSS.parse(_leftOperand !== null && _leftOperand !== void 0 ? _leftOperand : "");
    var _rTs = DecimalCSS.parse(_rightOperand !== null && _rightOperand !== void 0 ? _rightOperand : "");
    var _result = _operator === "+" ? _lTs.add(_rTs) : _lTs.subtract(_rTs);
    if (_result.isNaN()) {
      return STR_NAN;
    }
    newExpr = newExpr.replace(ADD_OR_SUBTRACT_REGEX, _result.toString());
  }
  return newExpr;
}
var PARENTHESES_REGEX = /\(([^()]*)\)/;
function calculateParentheses(expr) {
  var newExpr = expr;
  var match;
  while ((match = PARENTHESES_REGEX.exec(newExpr)) != null) {
    var [, parentheticalExpression] = match;
    newExpr = newExpr.replace(PARENTHESES_REGEX, calculateArithmetic(parentheticalExpression));
  }
  return newExpr;
}
function evaluateExpression(expression) {
  var newExpr = expression.replace(/\s+/g, "");
  newExpr = calculateParentheses(newExpr);
  newExpr = calculateArithmetic(newExpr);
  return newExpr;
}
function safeEvaluateExpression(expression) {
  try {
    return evaluateExpression(expression);
  } catch (_unused) {
    return STR_NAN;
  }
}
function reduceCSSCalc(expression) {
  var result = safeEvaluateExpression(expression.slice(5, -1));
  if (result === STR_NAN) {
    return "";
  }
  return result;
}
var _excluded$f = ["x", "y", "lineHeight", "capHeight", "scaleToFit", "textAnchor", "verticalAnchor", "fill"], _excluded2$8 = ["dx", "dy", "angle", "className", "breakAll"];
function _extends$g() {
  return _extends$g = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$g.apply(null, arguments);
}
function _objectWithoutProperties$f(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$f(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$f(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
var BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/;
var calculateWordWidths = (_ref2) => {
  var {
    children,
    breakAll,
    style
  } = _ref2;
  try {
    var words = [];
    if (!isNullish(children)) {
      if (breakAll) {
        words = children.toString().split("");
      } else {
        words = children.toString().split(BREAKING_SPACES);
      }
    }
    var wordsWithComputedWidth = words.map((word) => ({
      word,
      width: getStringSize(word, style).width
    }));
    var spaceWidth = breakAll ? 0 : getStringSize("", style).width;
    return {
      wordsWithComputedWidth,
      spaceWidth
    };
  } catch (_unused) {
    return null;
  }
};
var calculateWordsByLines = (_ref2, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) => {
  var {
    maxLines,
    children,
    style,
    breakAll
  } = _ref2;
  var shouldLimitLines = isNumber(maxLines);
  var text = children;
  var calculate = function calculate2() {
    var words = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return words.reduce((result2, _ref3) => {
      var {
        word,
        width
      } = _ref3;
      var currentLine = result2[result2.length - 1];
      if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < Number(lineWidth))) {
        currentLine.words.push(word);
        currentLine.width += width + spaceWidth;
      } else {
        var newLine = {
          words: [word],
          width
        };
        result2.push(newLine);
      }
      return result2;
    }, []);
  };
  var originalResult = calculate(initialWordsWithComputedWith);
  var findLongestLine = (words) => words.reduce((a2, b2) => a2.width > b2.width ? a2 : b2);
  if (!shouldLimitLines || scaleToFit) {
    return originalResult;
  }
  var overflows = originalResult.length > maxLines || findLongestLine(originalResult).width > Number(lineWidth);
  if (!overflows) {
    return originalResult;
  }
  var suffix = "";
  var checkOverflow = (index) => {
    var tempText = text.slice(0, index);
    var words = calculateWordWidths({
      breakAll,
      style,
      children: tempText + suffix
    }).wordsWithComputedWidth;
    var result2 = calculate(words);
    var doesOverflow = result2.length > maxLines || findLongestLine(result2).width > Number(lineWidth);
    return [doesOverflow, result2];
  };
  var start = 0;
  var end = text.length - 1;
  var iterations = 0;
  var trimmedResult;
  while (start <= end && iterations <= text.length - 1) {
    var middle = Math.floor((start + end) / 2);
    var prev = middle - 1;
    var [doesPrevOverflow, result] = checkOverflow(prev);
    var [doesMiddleOverflow] = checkOverflow(middle);
    if (!doesPrevOverflow && !doesMiddleOverflow) {
      start = middle + 1;
    }
    if (doesPrevOverflow && doesMiddleOverflow) {
      end = middle - 1;
    }
    if (!doesPrevOverflow && doesMiddleOverflow) {
      trimmedResult = result;
      break;
    }
    iterations++;
  }
  return trimmedResult || originalResult;
};
var getWordsWithoutCalculate = (children) => {
  var words = !isNullish(children) ? children.toString().split(BREAKING_SPACES) : [];
  return [{
    words
  }];
};
var getWordsByLines = (_ref4) => {
  var {
    width,
    scaleToFit,
    children,
    style,
    breakAll,
    maxLines
  } = _ref4;
  if ((width || scaleToFit) && !Global.isSsr) {
    var wordsWithComputedWidth, spaceWidth;
    var wordWidths = calculateWordWidths({
      breakAll,
      children,
      style
    });
    if (wordWidths) {
      var {
        wordsWithComputedWidth: wcw,
        spaceWidth: sw
      } = wordWidths;
      wordsWithComputedWidth = wcw;
      spaceWidth = sw;
    } else {
      return getWordsWithoutCalculate(children);
    }
    return calculateWordsByLines({
      breakAll,
      children,
      maxLines,
      style
    }, wordsWithComputedWidth, spaceWidth, width, scaleToFit);
  }
  return getWordsWithoutCalculate(children);
};
var DEFAULT_FILL = "#808080";
var Text = /* @__PURE__ */ reactExports.forwardRef((_ref5, ref) => {
  var {
    x: propsX = 0,
    y: propsY = 0,
    lineHeight = "1em",
    // Magic number from d3
    capHeight = "0.71em",
    scaleToFit = false,
    textAnchor = "start",
    // Maintain compat with existing charts / default SVG behavior
    verticalAnchor = "end",
    fill = DEFAULT_FILL
  } = _ref5, props = _objectWithoutProperties$f(_ref5, _excluded$f);
  var wordsByLines = reactExports.useMemo(() => {
    return getWordsByLines({
      breakAll: props.breakAll,
      children: props.children,
      maxLines: props.maxLines,
      scaleToFit,
      style: props.style,
      width: props.width
    });
  }, [props.breakAll, props.children, props.maxLines, scaleToFit, props.style, props.width]);
  var {
    dx,
    dy,
    angle,
    className,
    breakAll
  } = props, textProps = _objectWithoutProperties$f(props, _excluded2$8);
  if (!isNumOrStr(propsX) || !isNumOrStr(propsY) || wordsByLines.length === 0) {
    return null;
  }
  var x2 = propsX + (isNumber(dx) ? dx : 0);
  var y2 = propsY + (isNumber(dy) ? dy : 0);
  var startDy;
  switch (verticalAnchor) {
    case "start":
      startDy = reduceCSSCalc("calc(".concat(capHeight, ")"));
      break;
    case "middle":
      startDy = reduceCSSCalc("calc(".concat((wordsByLines.length - 1) / 2, " * -").concat(lineHeight, " + (").concat(capHeight, " / 2))"));
      break;
    default:
      startDy = reduceCSSCalc("calc(".concat(wordsByLines.length - 1, " * -").concat(lineHeight, ")"));
      break;
  }
  var transforms = [];
  if (scaleToFit) {
    var lineWidth = wordsByLines[0].width;
    var {
      width
    } = props;
    transforms.push("scale(".concat(isNumber(width) ? width / lineWidth : 1, ")"));
  }
  if (angle) {
    transforms.push("rotate(".concat(angle, ", ").concat(x2, ", ").concat(y2, ")"));
  }
  if (transforms.length) {
    textProps.transform = transforms.join(" ");
  }
  return /* @__PURE__ */ reactExports.createElement("text", _extends$g({}, svgPropertiesAndEvents(textProps), {
    ref,
    x: x2,
    y: y2,
    className: clsx("recharts-text", className),
    textAnchor,
    fill: fill.includes("url") ? DEFAULT_FILL : fill
  }), wordsByLines.map((line, index) => {
    var words = line.words.join(breakAll ? "" : " ");
    return (
      // duplicate words will cause duplicate keys
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ reactExports.createElement("tspan", {
        x: x2,
        dy: index === 0 ? startDy : lineHeight,
        key: "".concat(words, "-").concat(index)
      }, words)
    );
  }));
});
Text.displayName = "Text";
var _excluded$e = ["labelRef"];
function _objectWithoutProperties$e(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$e(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$e(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function ownKeys$e(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$e(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$e(Object(t2), true).forEach(function(r3) {
      _defineProperty$f(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$e(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$f(e3, r2, t2) {
  return (r2 = _toPropertyKey$f(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$f(t2) {
  var i2 = _toPrimitive$f(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$f(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _extends$f() {
  return _extends$f = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$f.apply(null, arguments);
}
var CartesianLabelContext = /* @__PURE__ */ reactExports.createContext(null);
var CartesianLabelContextProvider = (_ref2) => {
  var {
    x: x2,
    y: y2,
    width,
    height,
    children
  } = _ref2;
  var viewBox = reactExports.useMemo(() => ({
    x: x2,
    y: y2,
    width,
    height
  }), [x2, y2, width, height]);
  return /* @__PURE__ */ reactExports.createElement(CartesianLabelContext.Provider, {
    value: viewBox
  }, children);
};
var useCartesianLabelContext = () => {
  var labelChildContext = reactExports.useContext(CartesianLabelContext);
  var chartContext = useViewBox();
  return labelChildContext || chartContext;
};
var PolarLabelContext = /* @__PURE__ */ reactExports.createContext(null);
var usePolarLabelContext = () => {
  var labelChildContext = reactExports.useContext(PolarLabelContext);
  var chartContext = useAppSelector(selectPolarViewBox);
  return labelChildContext || chartContext;
};
var getLabel = (props) => {
  var {
    value,
    formatter
  } = props;
  var label = isNullish(props.children) ? value : props.children;
  if (typeof formatter === "function") {
    return formatter(label);
  }
  return label;
};
var isLabelContentAFunction = (content) => {
  return content != null && typeof content === "function";
};
var getDeltaAngle = (startAngle, endAngle) => {
  var sign2 = mathSign(endAngle - startAngle);
  var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
  return sign2 * deltaAngle;
};
var renderRadialLabel = (labelProps, position, label, attrs, viewBox) => {
  var {
    offset,
    className
  } = labelProps;
  var {
    cx,
    cy,
    innerRadius,
    outerRadius,
    startAngle,
    endAngle,
    clockWise
  } = viewBox;
  var radius = (innerRadius + outerRadius) / 2;
  var deltaAngle = getDeltaAngle(startAngle, endAngle);
  var sign2 = deltaAngle >= 0 ? 1 : -1;
  var labelAngle, direction;
  switch (position) {
    case "insideStart":
      labelAngle = startAngle + sign2 * offset;
      direction = clockWise;
      break;
    case "insideEnd":
      labelAngle = endAngle - sign2 * offset;
      direction = !clockWise;
      break;
    case "end":
      labelAngle = endAngle + sign2 * offset;
      direction = clockWise;
      break;
    default:
      throw new Error("Unsupported position ".concat(position));
  }
  direction = deltaAngle <= 0 ? direction : !direction;
  var startPoint = polarToCartesian(cx, cy, radius, labelAngle);
  var endPoint = polarToCartesian(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359);
  var path2 = "M".concat(startPoint.x, ",").concat(startPoint.y, "\n    A").concat(radius, ",").concat(radius, ",0,1,").concat(direction ? 0 : 1, ",\n    ").concat(endPoint.x, ",").concat(endPoint.y);
  var id = isNullish(labelProps.id) ? uniqueId("recharts-radial-line-") : labelProps.id;
  return /* @__PURE__ */ reactExports.createElement("text", _extends$f({}, attrs, {
    dominantBaseline: "central",
    className: clsx("recharts-radial-bar-label", className)
  }), /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("path", {
    id,
    d: path2
  })), /* @__PURE__ */ reactExports.createElement("textPath", {
    xlinkHref: "#".concat(id)
  }, label));
};
var getAttrsOfPolarLabel = (viewBox, offset, position) => {
  var {
    cx,
    cy,
    innerRadius,
    outerRadius,
    startAngle,
    endAngle
  } = viewBox;
  var midAngle = (startAngle + endAngle) / 2;
  if (position === "outside") {
    var {
      x: _x,
      y: _y
    } = polarToCartesian(cx, cy, outerRadius + offset, midAngle);
    return {
      x: _x,
      y: _y,
      textAnchor: _x >= cx ? "start" : "end",
      verticalAnchor: "middle"
    };
  }
  if (position === "center") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "middle"
    };
  }
  if (position === "centerTop") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "start"
    };
  }
  if (position === "centerBottom") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "end"
    };
  }
  var r2 = (innerRadius + outerRadius) / 2;
  var {
    x: x2,
    y: y2
  } = polarToCartesian(cx, cy, r2, midAngle);
  return {
    x: x2,
    y: y2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  };
};
var isPolar = (viewBox) => "cx" in viewBox && isNumber(viewBox.cx);
var getAttrsOfCartesianLabel = (props, viewBox) => {
  var {
    parentViewBox: parentViewBoxFromProps,
    offset,
    position
  } = props;
  var parentViewBox;
  if (parentViewBoxFromProps != null && !isPolar(parentViewBoxFromProps)) {
    parentViewBox = parentViewBoxFromProps;
  }
  var {
    x: x2,
    y: y2,
    width,
    height
  } = viewBox;
  var verticalSign = height >= 0 ? 1 : -1;
  var verticalOffset = verticalSign * offset;
  var verticalEnd = verticalSign > 0 ? "end" : "start";
  var verticalStart = verticalSign > 0 ? "start" : "end";
  var horizontalSign = width >= 0 ? 1 : -1;
  var horizontalOffset = horizontalSign * offset;
  var horizontalEnd = horizontalSign > 0 ? "end" : "start";
  var horizontalStart = horizontalSign > 0 ? "start" : "end";
  if (position === "top") {
    var attrs = {
      x: x2 + width / 2,
      y: y2 - verticalSign * offset,
      textAnchor: "middle",
      verticalAnchor: verticalEnd
    };
    return _objectSpread$e(_objectSpread$e({}, attrs), parentViewBox ? {
      height: Math.max(y2 - parentViewBox.y, 0),
      width
    } : {});
  }
  if (position === "bottom") {
    var _attrs = {
      x: x2 + width / 2,
      y: y2 + height + verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalStart
    };
    return _objectSpread$e(_objectSpread$e({}, _attrs), parentViewBox ? {
      height: Math.max(parentViewBox.y + parentViewBox.height - (y2 + height), 0),
      width
    } : {});
  }
  if (position === "left") {
    var _attrs2 = {
      x: x2 - horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalEnd,
      verticalAnchor: "middle"
    };
    return _objectSpread$e(_objectSpread$e({}, _attrs2), parentViewBox ? {
      width: Math.max(_attrs2.x - parentViewBox.x, 0),
      height
    } : {});
  }
  if (position === "right") {
    var _attrs3 = {
      x: x2 + width + horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalStart,
      verticalAnchor: "middle"
    };
    return _objectSpread$e(_objectSpread$e({}, _attrs3), parentViewBox ? {
      width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),
      height
    } : {});
  }
  var sizeAttrs = parentViewBox ? {
    width,
    height
  } : {};
  if (position === "insideLeft") {
    return _objectSpread$e({
      x: x2 + horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalStart,
      verticalAnchor: "middle"
    }, sizeAttrs);
  }
  if (position === "insideRight") {
    return _objectSpread$e({
      x: x2 + width - horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalEnd,
      verticalAnchor: "middle"
    }, sizeAttrs);
  }
  if (position === "insideTop") {
    return _objectSpread$e({
      x: x2 + width / 2,
      y: y2 + verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position === "insideBottom") {
    return _objectSpread$e({
      x: x2 + width / 2,
      y: y2 + height - verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (position === "insideTopLeft") {
    return _objectSpread$e({
      x: x2 + horizontalOffset,
      y: y2 + verticalOffset,
      textAnchor: horizontalStart,
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position === "insideTopRight") {
    return _objectSpread$e({
      x: x2 + width - horizontalOffset,
      y: y2 + verticalOffset,
      textAnchor: horizontalEnd,
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position === "insideBottomLeft") {
    return _objectSpread$e({
      x: x2 + horizontalOffset,
      y: y2 + height - verticalOffset,
      textAnchor: horizontalStart,
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (position === "insideBottomRight") {
    return _objectSpread$e({
      x: x2 + width - horizontalOffset,
      y: y2 + height - verticalOffset,
      textAnchor: horizontalEnd,
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (!!position && typeof position === "object" && (isNumber(position.x) || isPercent(position.x)) && (isNumber(position.y) || isPercent(position.y))) {
    return _objectSpread$e({
      x: x2 + getPercentValue(position.x, width),
      y: y2 + getPercentValue(position.y, height),
      textAnchor: "end",
      verticalAnchor: "end"
    }, sizeAttrs);
  }
  return _objectSpread$e({
    x: x2 + width / 2,
    y: y2 + height / 2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  }, sizeAttrs);
};
var defaultLabelProps = {
  offset: 5
};
function Label(outerProps) {
  var props = resolveDefaultProps(outerProps, defaultLabelProps);
  var {
    viewBox: viewBoxFromProps,
    position,
    value,
    children,
    content,
    className = "",
    textBreakAll,
    labelRef
  } = props;
  var polarViewBox = usePolarLabelContext();
  var cartesianViewBox = useCartesianLabelContext();
  var resolvedViewBox = position === "center" ? cartesianViewBox : polarViewBox !== null && polarViewBox !== void 0 ? polarViewBox : cartesianViewBox;
  var viewBox = viewBoxFromProps || resolvedViewBox;
  if (!viewBox || isNullish(value) && isNullish(children) && !/* @__PURE__ */ reactExports.isValidElement(content) && typeof content !== "function") {
    return null;
  }
  var propsWithViewBox = _objectSpread$e(_objectSpread$e({}, props), {}, {
    viewBox
  });
  if (/* @__PURE__ */ reactExports.isValidElement(content)) {
    var {
      labelRef: _2
    } = propsWithViewBox, propsWithoutLabelRef = _objectWithoutProperties$e(propsWithViewBox, _excluded$e);
    return /* @__PURE__ */ reactExports.cloneElement(content, propsWithoutLabelRef);
  }
  var label;
  if (typeof content === "function") {
    label = /* @__PURE__ */ reactExports.createElement(content, propsWithViewBox);
    if (/* @__PURE__ */ reactExports.isValidElement(label)) {
      return label;
    }
  } else {
    label = getLabel(props);
  }
  var isPolarLabel = isPolar(viewBox);
  var attrs = svgPropertiesAndEvents(props);
  if (isPolarLabel && (position === "insideStart" || position === "insideEnd" || position === "end")) {
    return renderRadialLabel(props, position, label, attrs, viewBox);
  }
  var positionAttrs = isPolarLabel ? getAttrsOfPolarLabel(viewBox, props.offset, props.position) : getAttrsOfCartesianLabel(props, viewBox);
  return /* @__PURE__ */ reactExports.createElement(Text, _extends$f({
    ref: labelRef,
    className: clsx("recharts-label", className)
  }, attrs, positionAttrs, {
    breakAll: textBreakAll
  }), label);
}
Label.displayName = "Label";
var parseLabel = (label, viewBox, labelRef) => {
  if (!label) {
    return null;
  }
  var commonProps = {
    viewBox,
    labelRef
  };
  if (label === true) {
    return /* @__PURE__ */ reactExports.createElement(Label, _extends$f({
      key: "label-implicit"
    }, commonProps));
  }
  if (isNumOrStr(label)) {
    return /* @__PURE__ */ reactExports.createElement(Label, _extends$f({
      key: "label-implicit",
      value: label
    }, commonProps));
  }
  if (/* @__PURE__ */ reactExports.isValidElement(label)) {
    if (label.type === Label) {
      return /* @__PURE__ */ reactExports.cloneElement(label, _objectSpread$e({
        key: "label-implicit"
      }, commonProps));
    }
    return /* @__PURE__ */ reactExports.createElement(Label, _extends$f({
      key: "label-implicit",
      content: label
    }, commonProps));
  }
  if (isLabelContentAFunction(label)) {
    return /* @__PURE__ */ reactExports.createElement(Label, _extends$f({
      key: "label-implicit",
      content: label
    }, commonProps));
  }
  if (label && typeof label === "object") {
    return /* @__PURE__ */ reactExports.createElement(Label, _extends$f({}, label, {
      key: "label-implicit"
    }, commonProps));
  }
  return null;
};
function CartesianLabelFromLabelProp(_ref3) {
  var {
    label,
    labelRef
  } = _ref3;
  var viewBox = useCartesianLabelContext();
  return parseLabel(label, viewBox, labelRef) || null;
}
var last$3 = {};
var last$2 = {};
var hasRequiredLast$2;
function requireLast$2() {
  if (hasRequiredLast$2) return last$2;
  hasRequiredLast$2 = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function last2(arr) {
      return arr[arr.length - 1];
    }
    exports.last = last2;
  })(last$2);
  return last$2;
}
var toArray$1 = {};
var hasRequiredToArray;
function requireToArray() {
  if (hasRequiredToArray) return toArray$1;
  hasRequiredToArray = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function toArray2(value) {
      return Array.isArray(value) ? value : Array.from(value);
    }
    exports.toArray = toArray2;
  })(toArray$1);
  return toArray$1;
}
var hasRequiredLast$1;
function requireLast$1() {
  if (hasRequiredLast$1) return last$3;
  hasRequiredLast$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const last$12 = /* @__PURE__ */ requireLast$2();
    const toArray2 = /* @__PURE__ */ requireToArray();
    const isArrayLike2 = /* @__PURE__ */ requireIsArrayLike();
    function last2(array2) {
      if (!isArrayLike2.isArrayLike(array2)) {
        return void 0;
      }
      return last$12.last(toArray2.toArray(array2));
    }
    exports.last = last2;
  })(last$3);
  return last$3;
}
var last$1;
var hasRequiredLast;
function requireLast() {
  if (hasRequiredLast) return last$1;
  hasRequiredLast = 1;
  last$1 = requireLast$1().last;
  return last$1;
}
var lastExports = /* @__PURE__ */ requireLast();
const last = /* @__PURE__ */ getDefaultExportFromCjs(lastExports);
var _excluded$d = ["valueAccessor"], _excluded2$7 = ["dataKey", "clockWise", "id", "textBreakAll"];
function _extends$e() {
  return _extends$e = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$e.apply(null, arguments);
}
function _objectWithoutProperties$d(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$d(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$d(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
var defaultAccessor = (entry) => Array.isArray(entry.value) ? last(entry.value) : entry.value;
var CartesianLabelListContext = /* @__PURE__ */ reactExports.createContext(void 0);
var CartesianLabelListContextProvider = CartesianLabelListContext.Provider;
var PolarLabelListContext = /* @__PURE__ */ reactExports.createContext(void 0);
var PolarLabelListContextProvider = PolarLabelListContext.Provider;
function useCartesianLabelListContext() {
  return reactExports.useContext(CartesianLabelListContext);
}
function usePolarLabelListContext() {
  return reactExports.useContext(PolarLabelListContext);
}
function LabelList(_ref2) {
  var {
    valueAccessor = defaultAccessor
  } = _ref2, restProps = _objectWithoutProperties$d(_ref2, _excluded$d);
  var {
    dataKey,
    clockWise,
    id,
    textBreakAll
  } = restProps, others = _objectWithoutProperties$d(restProps, _excluded2$7);
  var cartesianData = useCartesianLabelListContext();
  var polarData = usePolarLabelListContext();
  var data = cartesianData || polarData;
  if (!data || !data.length) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(Layer, {
    className: "recharts-label-list"
  }, data.map((entry, index) => {
    var _restProps$fill;
    var value = isNullish(dataKey) ? valueAccessor(entry, index) : getValueByDataKey(entry && entry.payload, dataKey);
    var idProps = isNullish(id) ? {} : {
      id: "".concat(id, "-").concat(index)
    };
    return /* @__PURE__ */ reactExports.createElement(Label, _extends$e({
      key: "label-".concat(index)
      // eslint-disable-line react/no-array-index-key
    }, svgPropertiesAndEvents(entry), others, idProps, {
      /*
       * Prefer to use the explicit fill from LabelList props.
       * Only in an absence of that, fall back to the fill of the entry.
       * The entry fill can be quite difficult to see especially in Bar, Pie, RadialBar in inside positions.
       * On the other hand it's quite convenient in Scatter, Line, or when the position is outside the Bar, Pie filled shapes.
       */
      fill: (_restProps$fill = restProps.fill) !== null && _restProps$fill !== void 0 ? _restProps$fill : entry.fill,
      parentViewBox: entry.parentViewBox,
      value,
      textBreakAll,
      viewBox: entry.viewBox,
      index
    }));
  }));
}
LabelList.displayName = "LabelList";
function LabelListFromLabelProp(_ref2) {
  var {
    label
  } = _ref2;
  if (!label) {
    return null;
  }
  if (label === true) {
    return /* @__PURE__ */ reactExports.createElement(LabelList, {
      key: "labelList-implicit"
    });
  }
  if (/* @__PURE__ */ reactExports.isValidElement(label) || isLabelContentAFunction(label)) {
    return /* @__PURE__ */ reactExports.createElement(LabelList, {
      key: "labelList-implicit",
      content: label
    });
  }
  if (typeof label === "object") {
    return /* @__PURE__ */ reactExports.createElement(LabelList, _extends$e({
      key: "labelList-implicit"
    }, label, {
      type: String(label.type)
    }));
  }
  return null;
}
function _extends$d() {
  return _extends$d = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$d.apply(null, arguments);
}
var Dot = (props) => {
  var {
    cx,
    cy,
    r: r2,
    className
  } = props;
  var layerClass = clsx("recharts-dot", className);
  if (cx === +cx && cy === +cy && r2 === +r2) {
    return /* @__PURE__ */ reactExports.createElement("circle", _extends$d({}, svgPropertiesNoEvents(props), adaptEventHandlers(props), {
      className: layerClass,
      cx,
      cy,
      r: r2
    }));
  }
  return null;
};
var selectUnfilteredPolarItems = (state) => state.graphicalItems.polarItems;
var selectAxisPredicate = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);
var selectPolarItemsSettings = createSelector([selectUnfilteredPolarItems, selectBaseAxis, selectAxisPredicate], combineGraphicalItemsSettings);
var selectPolarGraphicalItemsData = createSelector([selectPolarItemsSettings], combineGraphicalItemsData);
var selectPolarDisplayedData = createSelector([selectPolarGraphicalItemsData, selectChartDataAndAlwaysIgnoreIndexes], combineDisplayedData);
var selectPolarAppliedValues = createSelector([selectPolarDisplayedData, selectBaseAxis, selectPolarItemsSettings], combineAppliedValues);
createSelector([selectPolarDisplayedData, selectBaseAxis, selectPolarItemsSettings], (data, axisSettings, items) => {
  if (items.length > 0) {
    return data.flatMap((entry) => {
      return items.flatMap((item) => {
        var _axisSettings$dataKey;
        var valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);
        return {
          value: valueByDataKey,
          errorDomain: []
          // polar charts do not have error bars
        };
      });
    }).filter(Boolean);
  }
  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {
    return data.map((item) => ({
      value: getValueByDataKey(item, axisSettings.dataKey),
      errorDomain: []
    }));
  }
  return data.map((entry) => ({
    value: entry,
    errorDomain: []
  }));
});
var unsupportedInPolarChart = () => void 0;
var selectDomainOfAllPolarAppliedNumericalValues = createSelector([selectPolarDisplayedData, selectBaseAxis, selectPolarItemsSettings, selectAllErrorBarSettings, pickAxisType], combineDomainOfAllAppliedNumericalValuesIncludingErrorValues);
var selectPolarNumericalDomain = createSelector([selectBaseAxis, selectDomainDefinition, selectDomainFromUserPreference, unsupportedInPolarChart, selectDomainOfAllPolarAppliedNumericalValues, unsupportedInPolarChart, selectChartLayout, pickAxisType], combineNumericalDomain);
var selectPolarAxisDomain = createSelector([selectBaseAxis, selectChartLayout, selectPolarDisplayedData, selectPolarAppliedValues, selectStackOffsetType, pickAxisType, selectPolarNumericalDomain], combineAxisDomain);
var selectPolarNiceTicks = createSelector([selectPolarAxisDomain, selectBaseAxis, selectRealScaleType], combineNiceTicks);
createSelector([selectBaseAxis, selectPolarAxisDomain, selectPolarNiceTicks, pickAxisType], combineAxisDomainWithNiceTicks);
var initialState$6 = {
  radiusAxis: {},
  angleAxis: {}
};
var polarAxisSlice = createSlice({
  name: "polarAxis",
  initialState: initialState$6,
  reducers: {
    addRadiusAxis(state, action) {
      state.radiusAxis[action.payload.id] = castDraft(action.payload);
    },
    removeRadiusAxis(state, action) {
      delete state.radiusAxis[action.payload.id];
    },
    addAngleAxis(state, action) {
      state.angleAxis[action.payload.id] = castDraft(action.payload);
    },
    removeAngleAxis(state, action) {
      delete state.angleAxis[action.payload.id];
    }
  }
});
var {
  addRadiusAxis,
  removeRadiusAxis,
  addAngleAxis,
  removeAngleAxis
} = polarAxisSlice.actions;
var polarAxisReducer = polarAxisSlice.reducer;
function ownKeys$d(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$d(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$d(Object(t2), true).forEach(function(r3) {
      _defineProperty$e(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$d(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$e(e3, r2, t2) {
  return (r2 = _toPropertyKey$e(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$e(t2) {
  var i2 = _toPrimitive$e(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$e(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var pickId = (_state, id) => id;
var selectSynchronisedPieSettings = createSelector([selectUnfilteredPolarItems, pickId], (graphicalItems, id) => graphicalItems.filter((item) => item.type === "pie").find((item) => item.id === id));
var emptyArray = [];
var pickCells$1 = (_state, _id, cells) => {
  if ((cells === null || cells === void 0 ? void 0 : cells.length) === 0) {
    return emptyArray;
  }
  return cells;
};
var selectDisplayedData = createSelector([selectChartDataAndAlwaysIgnoreIndexes, selectSynchronisedPieSettings, pickCells$1], (_ref2, pieSettings, cells) => {
  var {
    chartData
  } = _ref2;
  if (pieSettings == null) {
    return void 0;
  }
  var displayedData;
  if ((pieSettings === null || pieSettings === void 0 ? void 0 : pieSettings.data) != null && pieSettings.data.length > 0) {
    displayedData = pieSettings.data;
  } else {
    displayedData = chartData;
  }
  if ((!displayedData || !displayedData.length) && cells != null) {
    displayedData = cells.map((cell) => _objectSpread$d(_objectSpread$d({}, pieSettings.presentationProps), cell.props));
  }
  if (displayedData == null) {
    return void 0;
  }
  return displayedData;
});
var selectPieLegend = createSelector([selectDisplayedData, selectSynchronisedPieSettings, pickCells$1], (displayedData, pieSettings, cells) => {
  if (displayedData == null || pieSettings == null) {
    return void 0;
  }
  return displayedData.map((entry, i2) => {
    var _cells$i;
    var name = getValueByDataKey(entry, pieSettings.nameKey, pieSettings.name);
    var color2;
    if (cells !== null && cells !== void 0 && (_cells$i = cells[i2]) !== null && _cells$i !== void 0 && (_cells$i = _cells$i.props) !== null && _cells$i !== void 0 && _cells$i.fill) {
      color2 = cells[i2].props.fill;
    } else if (typeof entry === "object" && entry != null && "fill" in entry) {
      color2 = entry.fill;
    } else {
      color2 = pieSettings.fill;
    }
    return {
      value: getTooltipNameProp(name, pieSettings.dataKey),
      color: color2,
      payload: entry,
      type: pieSettings.legendType
    };
  });
});
var selectPieSectors = createSelector([selectDisplayedData, selectSynchronisedPieSettings, pickCells$1, selectChartOffsetInternal], (displayedData, pieSettings, cells, offset) => {
  if (pieSettings == null || displayedData == null) {
    return void 0;
  }
  return computePieSectors({
    offset,
    pieSettings,
    displayedData,
    cells
  });
});
var reactIs = { exports: {} };
var reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b2 = Symbol.for("react.element"), c2 = Symbol.for("react.portal"), d2 = Symbol.for("react.fragment"), e3 = Symbol.for("react.strict_mode"), f2 = Symbol.for("react.profiler"), g2 = Symbol.for("react.provider"), h2 = Symbol.for("react.context"), k2 = Symbol.for("react.server_context"), l2 = Symbol.for("react.forward_ref"), m2 = Symbol.for("react.suspense"), n2 = Symbol.for("react.suspense_list"), p2 = Symbol.for("react.memo"), q2 = Symbol.for("react.lazy"), t2 = Symbol.for("react.offscreen"), u2;
  u2 = Symbol.for("react.module.reference");
  function v2(a2) {
    if ("object" === typeof a2 && null !== a2) {
      var r2 = a2.$$typeof;
      switch (r2) {
        case b2:
          switch (a2 = a2.type, a2) {
            case d2:
            case f2:
            case e3:
            case m2:
            case n2:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k2:
                case h2:
                case l2:
                case q2:
                case p2:
                case g2:
                  return a2;
                default:
                  return r2;
              }
          }
        case c2:
          return r2;
      }
    }
  }
  reactIs_production_min.ContextConsumer = h2;
  reactIs_production_min.ContextProvider = g2;
  reactIs_production_min.Element = b2;
  reactIs_production_min.ForwardRef = l2;
  reactIs_production_min.Fragment = d2;
  reactIs_production_min.Lazy = q2;
  reactIs_production_min.Memo = p2;
  reactIs_production_min.Portal = c2;
  reactIs_production_min.Profiler = f2;
  reactIs_production_min.StrictMode = e3;
  reactIs_production_min.Suspense = m2;
  reactIs_production_min.SuspenseList = n2;
  reactIs_production_min.isAsyncMode = function() {
    return false;
  };
  reactIs_production_min.isConcurrentMode = function() {
    return false;
  };
  reactIs_production_min.isContextConsumer = function(a2) {
    return v2(a2) === h2;
  };
  reactIs_production_min.isContextProvider = function(a2) {
    return v2(a2) === g2;
  };
  reactIs_production_min.isElement = function(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === b2;
  };
  reactIs_production_min.isForwardRef = function(a2) {
    return v2(a2) === l2;
  };
  reactIs_production_min.isFragment = function(a2) {
    return v2(a2) === d2;
  };
  reactIs_production_min.isLazy = function(a2) {
    return v2(a2) === q2;
  };
  reactIs_production_min.isMemo = function(a2) {
    return v2(a2) === p2;
  };
  reactIs_production_min.isPortal = function(a2) {
    return v2(a2) === c2;
  };
  reactIs_production_min.isProfiler = function(a2) {
    return v2(a2) === f2;
  };
  reactIs_production_min.isStrictMode = function(a2) {
    return v2(a2) === e3;
  };
  reactIs_production_min.isSuspense = function(a2) {
    return v2(a2) === m2;
  };
  reactIs_production_min.isSuspenseList = function(a2) {
    return v2(a2) === n2;
  };
  reactIs_production_min.isValidElementType = function(a2) {
    return "string" === typeof a2 || "function" === typeof a2 || a2 === d2 || a2 === f2 || a2 === e3 || a2 === m2 || a2 === n2 || a2 === t2 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q2 || a2.$$typeof === p2 || a2.$$typeof === g2 || a2.$$typeof === h2 || a2.$$typeof === l2 || a2.$$typeof === u2 || void 0 !== a2.getModuleId) ? true : false;
  };
  reactIs_production_min.typeOf = v2;
  return reactIs_production_min;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  {
    reactIs.exports = requireReactIs_production_min();
  }
  return reactIs.exports;
}
var reactIsExports = requireReactIs();
var getDisplayName = (Comp) => {
  if (typeof Comp === "string") {
    return Comp;
  }
  if (!Comp) {
    return "";
  }
  return Comp.displayName || Comp.name || "Component";
};
var lastChildren = null;
var lastResult = null;
var toArray = (children) => {
  if (children === lastChildren && Array.isArray(lastResult)) {
    return lastResult;
  }
  var result = [];
  reactExports.Children.forEach(children, (child) => {
    if (isNullish(child)) return;
    if (reactIsExports.isFragment(child)) {
      result = result.concat(toArray(child.props.children));
    } else {
      result.push(child);
    }
  });
  lastResult = result;
  lastChildren = children;
  return result;
};
function findAllByType(children, type) {
  var result = [];
  var types = [];
  if (Array.isArray(type)) {
    types = type.map((t2) => getDisplayName(t2));
  } else {
    types = [getDisplayName(type)];
  }
  toArray(children).forEach((child) => {
    var childType = get(child, "type.displayName") || get(child, "type.name");
    if (types.indexOf(childType) !== -1) {
      result.push(child);
    }
  });
  return result;
}
var isClipDot = (dot) => {
  if (dot && typeof dot === "object" && "clipDot" in dot) {
    return Boolean(dot.clipDot);
  }
  return true;
};
var isPlainObject$2 = {};
var hasRequiredIsPlainObject$1;
function requireIsPlainObject$1() {
  if (hasRequiredIsPlainObject$1) return isPlainObject$2;
  hasRequiredIsPlainObject$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isPlainObject2(object2) {
      if (typeof object2 !== "object") {
        return false;
      }
      if (object2 == null) {
        return false;
      }
      if (Object.getPrototypeOf(object2) === null) {
        return true;
      }
      if (Object.prototype.toString.call(object2) !== "[object Object]") {
        const tag = object2[Symbol.toStringTag];
        if (tag == null) {
          return false;
        }
        const isTagReadonly = !Object.getOwnPropertyDescriptor(object2, Symbol.toStringTag)?.writable;
        if (isTagReadonly) {
          return false;
        }
        return object2.toString() === `[object ${tag}]`;
      }
      let proto = object2;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(object2) === proto;
    }
    exports.isPlainObject = isPlainObject2;
  })(isPlainObject$2);
  return isPlainObject$2;
}
var isPlainObject$1;
var hasRequiredIsPlainObject;
function requireIsPlainObject() {
  if (hasRequiredIsPlainObject) return isPlainObject$1;
  hasRequiredIsPlainObject = 1;
  isPlainObject$1 = requireIsPlainObject$1().isPlainObject;
  return isPlainObject$1;
}
var isPlainObjectExports = /* @__PURE__ */ requireIsPlainObject();
const isPlainObject = /* @__PURE__ */ getDefaultExportFromCjs(isPlainObjectExports);
function ownKeys$c(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$c(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$c(Object(t2), true).forEach(function(r3) {
      _defineProperty$d(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$c(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$d(e3, r2, t2) {
  return (r2 = _toPropertyKey$d(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$d(t2) {
  var i2 = _toPrimitive$d(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$d(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _extends$c() {
  return _extends$c = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$c.apply(null, arguments);
}
var getTrapezoidPath = (x2, y2, upperWidth, lowerWidth, height) => {
  var widthGap = upperWidth - lowerWidth;
  var path2;
  path2 = "M ".concat(x2, ",").concat(y2);
  path2 += "L ".concat(x2 + upperWidth, ",").concat(y2);
  path2 += "L ".concat(x2 + upperWidth - widthGap / 2, ",").concat(y2 + height);
  path2 += "L ".concat(x2 + upperWidth - widthGap / 2 - lowerWidth, ",").concat(y2 + height);
  path2 += "L ".concat(x2, ",").concat(y2, " Z");
  return path2;
};
var defaultProps$4 = {
  x: 0,
  y: 0,
  upperWidth: 0,
  lowerWidth: 0,
  height: 0,
  isUpdateAnimationActive: false,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
};
var Trapezoid = (outsideProps) => {
  var trapezoidProps = resolveDefaultProps(outsideProps, defaultProps$4);
  var {
    x: x2,
    y: y2,
    upperWidth,
    lowerWidth,
    height,
    className
  } = trapezoidProps;
  var {
    animationEasing,
    animationDuration,
    animationBegin,
    isUpdateAnimationActive
  } = trapezoidProps;
  var pathRef = reactExports.useRef(null);
  var [totalLength, setTotalLength] = reactExports.useState(-1);
  var prevUpperWidthRef = reactExports.useRef(upperWidth);
  var prevLowerWidthRef = reactExports.useRef(lowerWidth);
  var prevHeightRef = reactExports.useRef(height);
  var prevXRef = reactExports.useRef(x2);
  var prevYRef = reactExports.useRef(y2);
  var animationId = useAnimationId(outsideProps, "trapezoid-");
  reactExports.useEffect(() => {
    if (pathRef.current && pathRef.current.getTotalLength) {
      try {
        var pathTotalLength = pathRef.current.getTotalLength();
        if (pathTotalLength) {
          setTotalLength(pathTotalLength);
        }
      } catch (_unused) {
      }
    }
  }, []);
  if (x2 !== +x2 || y2 !== +y2 || upperWidth !== +upperWidth || lowerWidth !== +lowerWidth || height !== +height || upperWidth === 0 && lowerWidth === 0 || height === 0) {
    return null;
  }
  var layerClass = clsx("recharts-trapezoid", className);
  if (!isUpdateAnimationActive) {
    return /* @__PURE__ */ reactExports.createElement("g", null, /* @__PURE__ */ reactExports.createElement("path", _extends$c({}, svgPropertiesAndEvents(trapezoidProps), {
      className: layerClass,
      d: getTrapezoidPath(x2, y2, upperWidth, lowerWidth, height)
    })));
  }
  var prevUpperWidth = prevUpperWidthRef.current;
  var prevLowerWidth = prevLowerWidthRef.current;
  var prevHeight = prevHeightRef.current;
  var prevX = prevXRef.current;
  var prevY = prevYRef.current;
  var from2 = "0px ".concat(totalLength === -1 ? 1 : totalLength, "px");
  var to2 = "".concat(totalLength, "px 0px");
  var transition = getTransitionVal(["strokeDasharray"], animationDuration, animationEasing);
  return /* @__PURE__ */ reactExports.createElement(JavascriptAnimate, {
    animationId,
    key: animationId,
    canBegin: totalLength > 0,
    duration: animationDuration,
    easing: animationEasing,
    isActive: isUpdateAnimationActive,
    begin: animationBegin
  }, (t2) => {
    var currUpperWidth = interpolate$1(prevUpperWidth, upperWidth, t2);
    var currLowerWidth = interpolate$1(prevLowerWidth, lowerWidth, t2);
    var currHeight = interpolate$1(prevHeight, height, t2);
    var currX = interpolate$1(prevX, x2, t2);
    var currY = interpolate$1(prevY, y2, t2);
    if (pathRef.current) {
      prevUpperWidthRef.current = currUpperWidth;
      prevLowerWidthRef.current = currLowerWidth;
      prevHeightRef.current = currHeight;
      prevXRef.current = currX;
      prevYRef.current = currY;
    }
    var animationStyle = t2 > 0 ? {
      transition,
      strokeDasharray: to2
    } : {
      strokeDasharray: from2
    };
    return /* @__PURE__ */ reactExports.createElement("path", _extends$c({}, svgPropertiesAndEvents(trapezoidProps), {
      className: layerClass,
      d: getTrapezoidPath(currX, currY, currUpperWidth, currLowerWidth, currHeight),
      ref: pathRef,
      style: _objectSpread$c(_objectSpread$c({}, animationStyle), trapezoidProps.style)
    }));
  });
};
var _excluded$c = ["option", "shapeType", "propTransformer", "activeClassName", "isActive"];
function _objectWithoutProperties$c(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$c(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$c(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function ownKeys$b(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$b(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$b(Object(t2), true).forEach(function(r3) {
      _defineProperty$c(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$b(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$c(e3, r2, t2) {
  return (r2 = _toPropertyKey$c(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$c(t2) {
  var i2 = _toPrimitive$c(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$c(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function defaultPropTransformer(option, props) {
  return _objectSpread$b(_objectSpread$b({}, props), option);
}
function isSymbolsProps(shapeType, _elementProps) {
  return shapeType === "symbols";
}
function ShapeSelector(_ref2) {
  var {
    shapeType,
    elementProps
  } = _ref2;
  switch (shapeType) {
    case "rectangle":
      return /* @__PURE__ */ reactExports.createElement(Rectangle, elementProps);
    case "trapezoid":
      return /* @__PURE__ */ reactExports.createElement(Trapezoid, elementProps);
    case "sector":
      return /* @__PURE__ */ reactExports.createElement(Sector, elementProps);
    case "symbols":
      if (isSymbolsProps(shapeType)) {
        return /* @__PURE__ */ reactExports.createElement(Symbols, elementProps);
      }
      break;
    default:
      return null;
  }
}
function getPropsFromShapeOption(option) {
  if (/* @__PURE__ */ reactExports.isValidElement(option)) {
    return option.props;
  }
  return option;
}
function Shape(_ref2) {
  var {
    option,
    shapeType,
    propTransformer = defaultPropTransformer,
    activeClassName = "recharts-active-shape",
    isActive
  } = _ref2, props = _objectWithoutProperties$c(_ref2, _excluded$c);
  var shape;
  if (/* @__PURE__ */ reactExports.isValidElement(option)) {
    shape = /* @__PURE__ */ reactExports.cloneElement(option, _objectSpread$b(_objectSpread$b({}, props), getPropsFromShapeOption(option)));
  } else if (typeof option === "function") {
    shape = option(props);
  } else if (isPlainObject(option) && typeof option !== "boolean") {
    var nextProps = propTransformer(option, props);
    shape = /* @__PURE__ */ reactExports.createElement(ShapeSelector, {
      shapeType,
      elementProps: nextProps
    });
  } else {
    var elementProps = props;
    shape = /* @__PURE__ */ reactExports.createElement(ShapeSelector, {
      shapeType,
      elementProps
    });
  }
  if (isActive) {
    return /* @__PURE__ */ reactExports.createElement(Layer, {
      className: activeClassName
    }, shape);
  }
  return shape;
}
var useMouseEnterItemDispatch = (onMouseEnterFromProps, dataKey) => {
  var dispatch = useAppDispatch();
  return (data, index) => (event) => {
    onMouseEnterFromProps === null || onMouseEnterFromProps === void 0 || onMouseEnterFromProps(data, index, event);
    dispatch(setActiveMouseOverItemIndex({
      activeIndex: String(index),
      activeDataKey: dataKey,
      activeCoordinate: data.tooltipPosition
    }));
  };
};
var useMouseLeaveItemDispatch = (onMouseLeaveFromProps) => {
  var dispatch = useAppDispatch();
  return (data, index) => (event) => {
    onMouseLeaveFromProps === null || onMouseLeaveFromProps === void 0 || onMouseLeaveFromProps(data, index, event);
    dispatch(mouseLeaveItem());
  };
};
var useMouseClickItemDispatch = (onMouseClickFromProps, dataKey) => {
  var dispatch = useAppDispatch();
  return (data, index) => (event) => {
    onMouseClickFromProps === null || onMouseClickFromProps === void 0 || onMouseClickFromProps(data, index, event);
    dispatch(setActiveClickItemIndex({
      activeIndex: String(index),
      activeDataKey: dataKey,
      activeCoordinate: data.tooltipPosition
    }));
  };
};
function SetTooltipEntrySettings(_ref2) {
  var {
    fn,
    args
  } = _ref2;
  var dispatch = useAppDispatch();
  var isPanorama = useIsPanorama();
  reactExports.useLayoutEffect(() => {
    if (isPanorama) {
      return void 0;
    }
    var tooltipEntrySettings = fn(args);
    dispatch(addTooltipEntrySettings(tooltipEntrySettings));
    return () => {
      dispatch(removeTooltipEntrySettings(tooltipEntrySettings));
    };
  }, [fn, args, dispatch, isPanorama]);
  return null;
}
var noop = () => {
};
function SetLegendPayload(_ref2) {
  var {
    legendPayload
  } = _ref2;
  var dispatch = useAppDispatch();
  var isPanorama = useIsPanorama();
  reactExports.useLayoutEffect(() => {
    if (isPanorama) {
      return noop;
    }
    dispatch(addLegendPayload(legendPayload));
    return () => {
      dispatch(removeLegendPayload(legendPayload));
    };
  }, [dispatch, isPanorama, legendPayload]);
  return null;
}
function SetPolarLegendPayload(_ref2) {
  var {
    legendPayload
  } = _ref2;
  var dispatch = useAppDispatch();
  var layout = useAppSelector(selectChartLayout);
  reactExports.useLayoutEffect(() => {
    if (layout !== "centric" && layout !== "radial") {
      return noop;
    }
    dispatch(addLegendPayload(legendPayload));
    return () => {
      dispatch(removeLegendPayload(legendPayload));
    };
  }, [dispatch, layout, legendPayload]);
  return null;
}
var _ref;
var useIdFallback = () => {
  var [id] = reactExports.useState(() => uniqueId("uid-"));
  return id;
};
var useId = (_ref = React$1["useId".toString()]) !== null && _ref !== void 0 ? _ref : useIdFallback;
function useUniqueId(prefix2, customId) {
  var generatedId = useId();
  if (customId) {
    return customId;
  }
  return prefix2 ? "".concat(prefix2, "-").concat(generatedId) : generatedId;
}
var GraphicalItemIdContext = /* @__PURE__ */ reactExports.createContext(void 0);
var RegisterGraphicalItemId = (_ref2) => {
  var {
    id,
    type,
    children
  } = _ref2;
  var resolvedId = useUniqueId("recharts-".concat(type), id);
  return /* @__PURE__ */ reactExports.createElement(GraphicalItemIdContext.Provider, {
    value: resolvedId
  }, children(resolvedId));
};
var initialState$5 = {
  cartesianItems: [],
  polarItems: []
};
var graphicalItemsSlice = createSlice({
  name: "graphicalItems",
  initialState: initialState$5,
  reducers: {
    addCartesianGraphicalItem: {
      reducer(state, action) {
        state.cartesianItems.push(castDraft(action.payload));
      },
      prepare: prepareAutoBatched()
    },
    replaceCartesianGraphicalItem: {
      reducer(state, action) {
        var {
          prev,
          next
        } = action.payload;
        var index = current(state).cartesianItems.indexOf(castDraft(prev));
        if (index > -1) {
          state.cartesianItems[index] = castDraft(next);
        }
      },
      prepare: prepareAutoBatched()
    },
    removeCartesianGraphicalItem: {
      reducer(state, action) {
        var index = current(state).cartesianItems.indexOf(castDraft(action.payload));
        if (index > -1) {
          state.cartesianItems.splice(index, 1);
        }
      },
      prepare: prepareAutoBatched()
    },
    addPolarGraphicalItem: {
      reducer(state, action) {
        state.polarItems.push(castDraft(action.payload));
      },
      prepare: prepareAutoBatched()
    },
    removePolarGraphicalItem: {
      reducer(state, action) {
        var index = current(state).polarItems.indexOf(castDraft(action.payload));
        if (index > -1) {
          state.polarItems.splice(index, 1);
        }
      },
      prepare: prepareAutoBatched()
    }
  }
});
var {
  addCartesianGraphicalItem,
  replaceCartesianGraphicalItem,
  removeCartesianGraphicalItem,
  addPolarGraphicalItem,
  removePolarGraphicalItem
} = graphicalItemsSlice.actions;
var graphicalItemsReducer = graphicalItemsSlice.reducer;
function SetCartesianGraphicalItem(props) {
  var dispatch = useAppDispatch();
  var prevPropsRef = reactExports.useRef(null);
  reactExports.useLayoutEffect(() => {
    if (prevPropsRef.current === null) {
      dispatch(addCartesianGraphicalItem(props));
    } else if (prevPropsRef.current !== props) {
      dispatch(replaceCartesianGraphicalItem({
        prev: prevPropsRef.current,
        next: props
      }));
    }
    prevPropsRef.current = props;
  }, [dispatch, props]);
  reactExports.useLayoutEffect(() => {
    return () => {
      if (prevPropsRef.current) {
        dispatch(removeCartesianGraphicalItem(prevPropsRef.current));
        prevPropsRef.current = null;
      }
    };
  }, [dispatch]);
  return null;
}
function SetPolarGraphicalItem(props) {
  var dispatch = useAppDispatch();
  reactExports.useLayoutEffect(() => {
    dispatch(addPolarGraphicalItem(props));
    return () => {
      dispatch(removePolarGraphicalItem(props));
    };
  }, [dispatch, props]);
  return null;
}
var _excluded$b = ["onMouseEnter", "onClick", "onMouseLeave"], _excluded2$6 = ["id"], _excluded3$6 = ["id"];
function _objectWithoutProperties$b(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$b(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$b(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function ownKeys$a(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$a(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$a(Object(t2), true).forEach(function(r3) {
      _defineProperty$b(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$a(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$b(e3, r2, t2) {
  return (r2 = _toPropertyKey$b(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$b(t2) {
  var i2 = _toPrimitive$b(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$b(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _extends$b() {
  return _extends$b = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$b.apply(null, arguments);
}
function SetPiePayloadLegend(props) {
  var cells = reactExports.useMemo(() => findAllByType(props.children, Cell), [props.children]);
  var legendPayload = useAppSelector((state) => selectPieLegend(state, props.id, cells));
  if (legendPayload == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(SetPolarLegendPayload, {
    legendPayload
  });
}
function getTooltipEntrySettings$2(props) {
  var {
    dataKey,
    nameKey,
    sectors,
    stroke,
    strokeWidth,
    fill,
    name,
    hide,
    tooltipType
  } = props;
  return {
    dataDefinedOnItem: sectors.map((p2) => p2.tooltipPayload),
    positions: sectors.map((p2) => p2.tooltipPosition),
    settings: {
      stroke,
      strokeWidth,
      fill,
      dataKey,
      nameKey,
      name: getTooltipNameProp(name, dataKey),
      hide,
      type: tooltipType,
      color: fill,
      unit: ""
      // why doesn't Pie support unit?
    }
  };
}
var getTextAnchor = (x2, cx) => {
  if (x2 > cx) {
    return "start";
  }
  if (x2 < cx) {
    return "end";
  }
  return "middle";
};
var getOuterRadius = (dataPoint, outerRadius, maxPieRadius) => {
  if (typeof outerRadius === "function") {
    return getPercentValue(outerRadius(dataPoint), maxPieRadius, maxPieRadius * 0.8);
  }
  return getPercentValue(outerRadius, maxPieRadius, maxPieRadius * 0.8);
};
var parseCoordinateOfPie = (pieSettings, offset, dataPoint) => {
  var {
    top,
    left,
    width,
    height
  } = offset;
  var maxPieRadius = getMaxRadius(width, height);
  var cx = left + getPercentValue(pieSettings.cx, width, width / 2);
  var cy = top + getPercentValue(pieSettings.cy, height, height / 2);
  var innerRadius = getPercentValue(pieSettings.innerRadius, maxPieRadius, 0);
  var outerRadius = getOuterRadius(dataPoint, pieSettings.outerRadius, maxPieRadius);
  var maxRadius = pieSettings.maxRadius || Math.sqrt(width * width + height * height) / 2;
  return {
    cx,
    cy,
    innerRadius,
    outerRadius,
    maxRadius
  };
};
var parseDeltaAngle = (startAngle, endAngle) => {
  var sign2 = mathSign(endAngle - startAngle);
  var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
  return sign2 * deltaAngle;
};
function getClassNamePropertyIfExists(u2) {
  if (u2 && typeof u2 === "object" && "className" in u2 && typeof u2.className === "string") {
    return u2.className;
  }
  return "";
}
var renderLabelLineItem = (option, props) => {
  if (/* @__PURE__ */ reactExports.isValidElement(option)) {
    return /* @__PURE__ */ reactExports.cloneElement(option, props);
  }
  if (typeof option === "function") {
    return option(props);
  }
  var className = clsx("recharts-pie-label-line", typeof option !== "boolean" ? option.className : "");
  return /* @__PURE__ */ reactExports.createElement(Curve, _extends$b({}, props, {
    type: "linear",
    className
  }));
};
var renderLabelItem = (option, props, value) => {
  if (/* @__PURE__ */ reactExports.isValidElement(option)) {
    return /* @__PURE__ */ reactExports.cloneElement(option, props);
  }
  var label = value;
  if (typeof option === "function") {
    label = option(props);
    if (/* @__PURE__ */ reactExports.isValidElement(label)) {
      return label;
    }
  }
  var className = clsx("recharts-pie-label-text", getClassNamePropertyIfExists(option));
  return /* @__PURE__ */ reactExports.createElement(Text, _extends$b({}, props, {
    alignmentBaseline: "middle",
    className
  }), label);
};
function PieLabels(_ref2) {
  var {
    sectors,
    props,
    showLabels
  } = _ref2;
  var {
    label,
    labelLine,
    dataKey
  } = props;
  if (!showLabels || !label || !sectors) {
    return null;
  }
  var pieProps = svgPropertiesNoEvents(props);
  var customLabelProps = svgPropertiesNoEventsFromUnknown(label);
  var customLabelLineProps = svgPropertiesNoEventsFromUnknown(labelLine);
  var offsetRadius = typeof label === "object" && "offsetRadius" in label && typeof label.offsetRadius === "number" && label.offsetRadius || 20;
  var labels = sectors.map((entry, i2) => {
    var midAngle = (entry.startAngle + entry.endAngle) / 2;
    var endPoint = polarToCartesian(entry.cx, entry.cy, entry.outerRadius + offsetRadius, midAngle);
    var labelProps = _objectSpread$a(_objectSpread$a(_objectSpread$a(_objectSpread$a({}, pieProps), entry), {}, {
      // @ts-expect-error customLabelProps is contributing unknown props
      stroke: "none"
    }, customLabelProps), {}, {
      index: i2,
      textAnchor: getTextAnchor(endPoint.x, entry.cx)
    }, endPoint);
    var lineProps = _objectSpread$a(_objectSpread$a(_objectSpread$a(_objectSpread$a({}, pieProps), entry), {}, {
      // @ts-expect-error customLabelLineProps is contributing unknown props
      fill: "none",
      // @ts-expect-error customLabelLineProps is contributing unknown props
      stroke: entry.fill
    }, customLabelLineProps), {}, {
      index: i2,
      points: [polarToCartesian(entry.cx, entry.cy, entry.outerRadius, midAngle), endPoint],
      key: "line"
    });
    return (
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ reactExports.createElement(Layer, {
        key: "label-".concat(entry.startAngle, "-").concat(entry.endAngle, "-").concat(entry.midAngle, "-").concat(i2)
      }, labelLine && renderLabelLineItem(labelLine, lineProps), renderLabelItem(label, labelProps, getValueByDataKey(entry, dataKey)))
    );
  });
  return /* @__PURE__ */ reactExports.createElement(Layer, {
    className: "recharts-pie-labels"
  }, labels);
}
function PieLabelList(_ref2) {
  var {
    sectors,
    props,
    showLabels
  } = _ref2;
  var {
    label
  } = props;
  if (typeof label === "object" && label != null && "position" in label) {
    return /* @__PURE__ */ reactExports.createElement(LabelListFromLabelProp, {
      label
    });
  }
  return /* @__PURE__ */ reactExports.createElement(PieLabels, {
    sectors,
    props,
    showLabels
  });
}
function PieSectors(props) {
  var {
    sectors,
    activeShape,
    inactiveShape: inactiveShapeProp,
    allOtherPieProps
  } = props;
  var activeIndex = useAppSelector(selectActiveTooltipIndex);
  var {
    onMouseEnter: onMouseEnterFromProps,
    onClick: onItemClickFromProps,
    onMouseLeave: onMouseLeaveFromProps
  } = allOtherPieProps, restOfAllOtherProps = _objectWithoutProperties$b(allOtherPieProps, _excluded$b);
  var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherPieProps.dataKey);
  var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
  var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherPieProps.dataKey);
  if (sectors == null || sectors.length === 0) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, sectors.map((entry, i2) => {
    if ((entry === null || entry === void 0 ? void 0 : entry.startAngle) === 0 && (entry === null || entry === void 0 ? void 0 : entry.endAngle) === 0 && sectors.length !== 1) return null;
    var isSectorActive = activeShape && String(i2) === activeIndex;
    var inactiveShape = activeIndex ? inactiveShapeProp : null;
    var sectorOptions = isSectorActive ? activeShape : inactiveShape;
    var sectorProps = _objectSpread$a(_objectSpread$a({}, entry), {}, {
      stroke: entry.stroke,
      tabIndex: -1,
      [DATA_ITEM_INDEX_ATTRIBUTE_NAME]: i2,
      [DATA_ITEM_DATAKEY_ATTRIBUTE_NAME]: allOtherPieProps.dataKey
    });
    return /* @__PURE__ */ reactExports.createElement(
      Layer,
      _extends$b({
        key: "sector-".concat(entry === null || entry === void 0 ? void 0 : entry.startAngle, "-").concat(entry === null || entry === void 0 ? void 0 : entry.endAngle, "-").concat(entry.midAngle, "-").concat(i2),
        tabIndex: -1,
        className: "recharts-pie-sector"
      }, adaptEventsOfChild(restOfAllOtherProps, entry, i2), {
        // @ts-expect-error the types need a bit of attention
        onMouseEnter: onMouseEnterFromContext(entry, i2),
        onMouseLeave: onMouseLeaveFromContext(entry, i2),
        onClick: onClickFromContext(entry, i2)
      }),
      /* @__PURE__ */ reactExports.createElement(Shape, _extends$b({
        option: sectorOptions,
        isActive: isSectorActive,
        shapeType: "sector"
      }, sectorProps))
    );
  }));
}
function computePieSectors(_ref3) {
  var _pieSettings$paddingA;
  var {
    pieSettings,
    displayedData,
    cells,
    offset
  } = _ref3;
  var {
    cornerRadius,
    startAngle,
    endAngle,
    dataKey,
    nameKey,
    tooltipType
  } = pieSettings;
  var minAngle = Math.abs(pieSettings.minAngle);
  var deltaAngle = parseDeltaAngle(startAngle, endAngle);
  var absDeltaAngle = Math.abs(deltaAngle);
  var paddingAngle = displayedData.length <= 1 ? 0 : (_pieSettings$paddingA = pieSettings.paddingAngle) !== null && _pieSettings$paddingA !== void 0 ? _pieSettings$paddingA : 0;
  var notZeroItemCount = displayedData.filter((entry) => getValueByDataKey(entry, dataKey, 0) !== 0).length;
  var totalPaddingAngle = (absDeltaAngle >= 360 ? notZeroItemCount : notZeroItemCount - 1) * paddingAngle;
  var realTotalAngle = absDeltaAngle - notZeroItemCount * minAngle - totalPaddingAngle;
  var sum = displayedData.reduce((result, entry) => {
    var val = getValueByDataKey(entry, dataKey, 0);
    return result + (isNumber(val) ? val : 0);
  }, 0);
  var sectors;
  if (sum > 0) {
    var prev;
    sectors = displayedData.map((entry, i2) => {
      var val = getValueByDataKey(entry, dataKey, 0);
      var name = getValueByDataKey(entry, nameKey, i2);
      var coordinate = parseCoordinateOfPie(pieSettings, offset, entry);
      var percent = (isNumber(val) ? val : 0) / sum;
      var tempStartAngle;
      var entryWithCellInfo = _objectSpread$a(_objectSpread$a({}, entry), cells && cells[i2] && cells[i2].props);
      if (i2) {
        tempStartAngle = prev.endAngle + mathSign(deltaAngle) * paddingAngle * (val !== 0 ? 1 : 0);
      } else {
        tempStartAngle = startAngle;
      }
      var tempEndAngle = tempStartAngle + mathSign(deltaAngle) * ((val !== 0 ? minAngle : 0) + percent * realTotalAngle);
      var midAngle = (tempStartAngle + tempEndAngle) / 2;
      var middleRadius = (coordinate.innerRadius + coordinate.outerRadius) / 2;
      var tooltipPayload = [{
        name,
        value: val,
        payload: entryWithCellInfo,
        dataKey,
        type: tooltipType
      }];
      var tooltipPosition = polarToCartesian(coordinate.cx, coordinate.cy, middleRadius, midAngle);
      prev = _objectSpread$a(_objectSpread$a(_objectSpread$a(_objectSpread$a({}, pieSettings.presentationProps), {}, {
        percent,
        cornerRadius,
        name,
        tooltipPayload,
        midAngle,
        middleRadius,
        tooltipPosition
      }, entryWithCellInfo), coordinate), {}, {
        value: val,
        startAngle: tempStartAngle,
        endAngle: tempEndAngle,
        payload: entryWithCellInfo,
        paddingAngle: mathSign(deltaAngle) * paddingAngle
      });
      return prev;
    });
  }
  return sectors;
}
function PieLabelListProvider(_ref4) {
  var {
    showLabels,
    sectors,
    children
  } = _ref4;
  var labelListEntries = reactExports.useMemo(() => {
    if (!showLabels || !sectors) {
      return [];
    }
    return sectors.map((entry) => ({
      value: entry.value,
      payload: entry.payload,
      clockWise: false,
      parentViewBox: void 0,
      viewBox: {
        cx: entry.cx,
        cy: entry.cy,
        innerRadius: entry.innerRadius,
        outerRadius: entry.outerRadius,
        startAngle: entry.startAngle,
        endAngle: entry.endAngle,
        clockWise: false
      },
      fill: entry.fill
    }));
  }, [sectors, showLabels]);
  return /* @__PURE__ */ reactExports.createElement(PolarLabelListContextProvider, {
    value: showLabels ? labelListEntries : void 0
  }, children);
}
function SectorsWithAnimation(_ref5) {
  var {
    props,
    previousSectorsRef
  } = _ref5;
  var {
    sectors,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing,
    activeShape,
    inactiveShape,
    onAnimationStart,
    onAnimationEnd
  } = props;
  var animationId = useAnimationId(props, "recharts-pie-");
  var prevSectors = previousSectorsRef.current;
  var [isAnimating, setIsAnimating] = reactExports.useState(false);
  var handleAnimationEnd = reactExports.useCallback(() => {
    if (typeof onAnimationEnd === "function") {
      onAnimationEnd();
    }
    setIsAnimating(false);
  }, [onAnimationEnd]);
  var handleAnimationStart = reactExports.useCallback(() => {
    if (typeof onAnimationStart === "function") {
      onAnimationStart();
    }
    setIsAnimating(true);
  }, [onAnimationStart]);
  return /* @__PURE__ */ reactExports.createElement(PieLabelListProvider, {
    showLabels: !isAnimating,
    sectors
  }, /* @__PURE__ */ reactExports.createElement(JavascriptAnimate, {
    animationId,
    begin: animationBegin,
    duration: animationDuration,
    isActive: isAnimationActive,
    easing: animationEasing,
    onAnimationStart: handleAnimationStart,
    onAnimationEnd: handleAnimationEnd,
    key: animationId
  }, (t2) => {
    var stepData = [];
    var first = sectors && sectors[0];
    var curAngle = first === null || first === void 0 ? void 0 : first.startAngle;
    sectors === null || sectors === void 0 || sectors.forEach((entry, index) => {
      var prev = prevSectors && prevSectors[index];
      var paddingAngle = index > 0 ? get(entry, "paddingAngle", 0) : 0;
      if (prev) {
        var angle = interpolate$1(prev.endAngle - prev.startAngle, entry.endAngle - entry.startAngle, t2);
        var latest2 = _objectSpread$a(_objectSpread$a({}, entry), {}, {
          startAngle: curAngle + paddingAngle,
          endAngle: curAngle + angle + paddingAngle
        });
        stepData.push(latest2);
        curAngle = latest2.endAngle;
      } else {
        var {
          endAngle,
          startAngle
        } = entry;
        var deltaAngle = interpolate$1(0, endAngle - startAngle, t2);
        var _latest = _objectSpread$a(_objectSpread$a({}, entry), {}, {
          startAngle: curAngle + paddingAngle,
          endAngle: curAngle + deltaAngle + paddingAngle
        });
        stepData.push(_latest);
        curAngle = _latest.endAngle;
      }
    });
    previousSectorsRef.current = stepData;
    return /* @__PURE__ */ reactExports.createElement(Layer, null, /* @__PURE__ */ reactExports.createElement(PieSectors, {
      sectors: stepData,
      activeShape,
      inactiveShape,
      allOtherPieProps: props
    }));
  }), /* @__PURE__ */ reactExports.createElement(PieLabelList, {
    showLabels: !isAnimating,
    sectors,
    props
  }), props.children);
}
var defaultPieProps = {
  animationBegin: 400,
  animationDuration: 1500,
  animationEasing: "ease",
  cx: "50%",
  cy: "50%",
  dataKey: "value",
  endAngle: 360,
  fill: "#808080",
  hide: false,
  innerRadius: 0,
  isAnimationActive: !Global.isSsr,
  labelLine: true,
  legendType: "rect",
  minAngle: 0,
  nameKey: "name",
  outerRadius: "80%",
  paddingAngle: 0,
  rootTabIndex: 0,
  startAngle: 0,
  stroke: "#fff"
};
function PieImpl(props) {
  var {
    id
  } = props, propsWithoutId = _objectWithoutProperties$b(props, _excluded2$6);
  var {
    hide,
    className,
    rootTabIndex
  } = props;
  var cells = reactExports.useMemo(() => findAllByType(props.children, Cell), [props.children]);
  var sectors = useAppSelector((state) => selectPieSectors(state, id, cells));
  var previousSectorsRef = reactExports.useRef(null);
  var layerClass = clsx("recharts-pie", className);
  if (hide || sectors == null) {
    previousSectorsRef.current = null;
    return /* @__PURE__ */ reactExports.createElement(Layer, {
      tabIndex: rootTabIndex,
      className: layerClass
    });
  }
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(SetTooltipEntrySettings, {
    fn: getTooltipEntrySettings$2,
    args: _objectSpread$a(_objectSpread$a({}, props), {}, {
      sectors
    })
  }), /* @__PURE__ */ reactExports.createElement(Layer, {
    tabIndex: rootTabIndex,
    className: layerClass
  }, /* @__PURE__ */ reactExports.createElement(SectorsWithAnimation, {
    props: _objectSpread$a(_objectSpread$a({}, propsWithoutId), {}, {
      sectors
    }),
    previousSectorsRef
  })));
}
function Pie(outsideProps) {
  var props = resolveDefaultProps(outsideProps, defaultPieProps);
  var {
    id: externalId
  } = props, propsWithoutId = _objectWithoutProperties$b(props, _excluded3$6);
  var presentationProps = svgPropertiesNoEvents(propsWithoutId);
  return /* @__PURE__ */ reactExports.createElement(RegisterGraphicalItemId, {
    id: externalId,
    type: "pie"
  }, (id) => /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(SetPolarGraphicalItem, {
    type: "pie",
    id,
    data: propsWithoutId.data,
    dataKey: propsWithoutId.dataKey,
    hide: propsWithoutId.hide,
    angleAxisId: 0,
    radiusAxisId: 0,
    name: propsWithoutId.name,
    nameKey: propsWithoutId.nameKey,
    tooltipType: propsWithoutId.tooltipType,
    legendType: propsWithoutId.legendType,
    fill: propsWithoutId.fill,
    cx: propsWithoutId.cx,
    cy: propsWithoutId.cy,
    startAngle: propsWithoutId.startAngle,
    endAngle: propsWithoutId.endAngle,
    paddingAngle: propsWithoutId.paddingAngle,
    minAngle: propsWithoutId.minAngle,
    innerRadius: propsWithoutId.innerRadius,
    outerRadius: propsWithoutId.outerRadius,
    cornerRadius: propsWithoutId.cornerRadius,
    presentationProps,
    maxRadius: props.maxRadius
  }), /* @__PURE__ */ reactExports.createElement(SetPiePayloadLegend, _extends$b({}, propsWithoutId, {
    id
  })), /* @__PURE__ */ reactExports.createElement(PieImpl, _extends$b({}, propsWithoutId, {
    id
  }))));
}
Pie.displayName = "Pie";
function ownKeys$9(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$9(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$9(Object(t2), true).forEach(function(r3) {
      _defineProperty$a(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$9(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$a(e3, r2, t2) {
  return (r2 = _toPropertyKey$a(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$a(t2) {
  var i2 = _toPrimitive$a(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$a(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var initialState$4 = {
  xAxis: {},
  yAxis: {},
  zAxis: {}
};
var cartesianAxisSlice = createSlice({
  name: "cartesianAxis",
  initialState: initialState$4,
  reducers: {
    addXAxis: {
      reducer(state, action) {
        state.xAxis[action.payload.id] = castDraft(action.payload);
      },
      prepare: prepareAutoBatched()
    },
    removeXAxis: {
      reducer(state, action) {
        delete state.xAxis[action.payload.id];
      },
      prepare: prepareAutoBatched()
    },
    addYAxis: {
      reducer(state, action) {
        state.yAxis[action.payload.id] = castDraft(action.payload);
      },
      prepare: prepareAutoBatched()
    },
    removeYAxis: {
      reducer(state, action) {
        delete state.yAxis[action.payload.id];
      },
      prepare: prepareAutoBatched()
    },
    addZAxis: {
      reducer(state, action) {
        state.zAxis[action.payload.id] = castDraft(action.payload);
      },
      prepare: prepareAutoBatched()
    },
    removeZAxis: {
      reducer(state, action) {
        delete state.zAxis[action.payload.id];
      },
      prepare: prepareAutoBatched()
    },
    updateYAxisWidth(state, action) {
      var {
        id,
        width
      } = action.payload;
      var axis = state.yAxis[id];
      if (axis) {
        var history = axis.widthHistory || [];
        if (history.length === 3 && history[0] === history[2] && width === history[1] && width !== axis.width && Math.abs(width - history[0]) <= 1) {
          return;
        }
        var newHistory = [...history, width].slice(-3);
        state.yAxis[id] = _objectSpread$9(_objectSpread$9({}, state.yAxis[id]), {}, {
          width,
          widthHistory: newHistory
        });
      }
    }
  }
});
var {
  addXAxis,
  removeXAxis,
  addYAxis,
  removeYAxis,
  addZAxis,
  removeZAxis,
  updateYAxisWidth
} = cartesianAxisSlice.actions;
var cartesianAxisReducer = cartesianAxisSlice.reducer;
var selectChartOffset = createSelector([selectChartOffsetInternal], (offsetInternal) => {
  if (!offsetInternal) {
    return void 0;
  }
  return {
    top: offsetInternal.top,
    bottom: offsetInternal.bottom,
    left: offsetInternal.left,
    right: offsetInternal.right
  };
});
var selectPlotArea = createSelector([selectChartOffset, selectChartWidth, selectChartHeight], (offset, chartWidth, chartHeight) => {
  if (!offset || chartWidth == null || chartHeight == null) {
    return void 0;
  }
  return {
    x: offset.left,
    y: offset.top,
    width: Math.max(0, chartWidth - offset.left - offset.right),
    height: Math.max(0, chartHeight - offset.top - offset.bottom)
  };
});
var usePlotArea = () => {
  return useAppSelector(selectPlotArea);
};
var useActiveTooltipDataPoints = () => {
  return useAppSelector(selectActiveTooltipDataPoints);
};
function ownKeys$8(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$8(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$8(Object(t2), true).forEach(function(r3) {
      _defineProperty$9(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$8(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$9(e3, r2, t2) {
  return (r2 = _toPropertyKey$9(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$9(t2) {
  var i2 = _toPrimitive$9(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$9(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var renderActivePoint = (_ref2) => {
  var {
    point: point2,
    childIndex,
    mainColor,
    activeDot,
    dataKey
  } = _ref2;
  if (activeDot === false || point2.x == null || point2.y == null) {
    return null;
  }
  var dotProps = _objectSpread$8(_objectSpread$8({
    index: childIndex,
    dataKey,
    // @ts-expect-error activeDot is contributing unknown props
    cx: point2.x,
    // @ts-expect-error activeDot is contributing unknown props
    cy: point2.y,
    // @ts-expect-error activeDot is contributing unknown props
    r: 4,
    // @ts-expect-error activeDot is contributing unknown props
    fill: mainColor !== null && mainColor !== void 0 ? mainColor : "none",
    // @ts-expect-error activeDot is contributing unknown props
    strokeWidth: 2,
    // @ts-expect-error activeDot is contributing unknown props
    stroke: "#fff",
    payload: point2.payload,
    value: point2.value
  }, svgPropertiesNoEventsFromUnknown(activeDot)), adaptEventHandlers(activeDot));
  var dot;
  if (/* @__PURE__ */ reactExports.isValidElement(activeDot)) {
    dot = /* @__PURE__ */ reactExports.cloneElement(activeDot, dotProps);
  } else if (typeof activeDot === "function") {
    dot = activeDot(dotProps);
  } else {
    dot = /* @__PURE__ */ reactExports.createElement(Dot, dotProps);
  }
  return /* @__PURE__ */ reactExports.createElement(Layer, {
    className: "recharts-active-dot"
  }, dot);
};
function ActivePoints(_ref2) {
  var {
    points,
    mainColor,
    activeDot,
    itemDataKey
  } = _ref2;
  var activeTooltipIndex = useAppSelector(selectActiveTooltipIndex);
  var activeDataPoints = useActiveTooltipDataPoints();
  if (points == null || activeDataPoints == null) {
    return null;
  }
  var activePoint = points.find((p2) => activeDataPoints.includes(p2.payload));
  if (isNullish(activePoint)) {
    return null;
  }
  return renderActivePoint({
    point: activePoint,
    childIndex: Number(activeTooltipIndex),
    mainColor,
    dataKey: itemDataKey,
    activeDot
  });
}
var prefix = "Invariant failed";
function invariant(condition, message) {
  {
    throw new Error(prefix);
  }
}
var _excluded$a = ["x", "y"];
function _extends$a() {
  return _extends$a = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$a.apply(null, arguments);
}
function ownKeys$7(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r22) {
      return Object.getOwnPropertyDescriptor(e3, r22).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$7(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$7(Object(t2), true).forEach(function(r22) {
      _defineProperty$8(e3, r22, t2[r22]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$7(Object(t2)).forEach(function(r22) {
      Object.defineProperty(e3, r22, Object.getOwnPropertyDescriptor(t2, r22));
    });
  }
  return e3;
}
function _defineProperty$8(e3, r2, t2) {
  return (r2 = _toPropertyKey$8(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$8(t2) {
  var i2 = _toPrimitive$8(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$8(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$a(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$a(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$a(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function typeguardBarRectangleProps(_ref2, props) {
  var {
    x: xProp,
    y: yProp
  } = _ref2, option = _objectWithoutProperties$a(_ref2, _excluded$a);
  var xValue = "".concat(xProp);
  var x2 = parseInt(xValue, 10);
  var yValue = "".concat(yProp);
  var y2 = parseInt(yValue, 10);
  var heightValue = "".concat(props.height || option.height);
  var height = parseInt(heightValue, 10);
  var widthValue = "".concat(props.width || option.width);
  var width = parseInt(widthValue, 10);
  return _objectSpread$7(_objectSpread$7(_objectSpread$7(_objectSpread$7(_objectSpread$7({}, props), option), x2 ? {
    x: x2
  } : {}), y2 ? {
    y: y2
  } : {}), {}, {
    height,
    width,
    name: props.name,
    radius: props.radius
  });
}
function BarRectangle(props) {
  return /* @__PURE__ */ reactExports.createElement(Shape, _extends$a({
    shapeType: "rectangle",
    propTransformer: typeguardBarRectangleProps,
    activeClassName: "recharts-active-bar"
  }, props));
}
var minPointSizeCallback = function minPointSizeCallback2(minPointSize) {
  var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return (value, index) => {
    if (isNumber(minPointSize)) return minPointSize;
    var isValueNumberOrNil = isNumber(value) || isNullish(value);
    if (isValueNumberOrNil) {
      return minPointSize(value, index);
    }
    !isValueNumberOrNil ? invariant() : void 0;
    return defaultValue;
  };
};
var initialState$3 = {};
var errorBarSlice = createSlice({
  name: "errorBars",
  initialState: initialState$3,
  reducers: {
    addErrorBar: (state, action) => {
      var {
        itemId,
        errorBar
      } = action.payload;
      if (!state[itemId]) {
        state[itemId] = [];
      }
      state[itemId].push(errorBar);
    },
    replaceErrorBar: (state, action) => {
      var {
        itemId,
        prev,
        next
      } = action.payload;
      if (state[itemId]) {
        state[itemId] = state[itemId].map((e3) => e3.dataKey === prev.dataKey && e3.direction === prev.direction ? next : e3);
      }
    },
    removeErrorBar: (state, action) => {
      var {
        itemId,
        errorBar
      } = action.payload;
      if (state[itemId]) {
        state[itemId] = state[itemId].filter((e3) => e3.dataKey !== errorBar.dataKey || e3.direction !== errorBar.direction);
      }
    }
  }
});
var {
  addErrorBar,
  replaceErrorBar,
  removeErrorBar
} = errorBarSlice.actions;
var errorBarReducer = errorBarSlice.reducer;
var _excluded$9 = ["children"];
function _objectWithoutProperties$9(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$9(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$9(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
var initialContextState = {
  data: [],
  xAxisId: "xAxis-0",
  yAxisId: "yAxis-0",
  dataPointFormatter: () => ({
    x: 0,
    y: 0,
    value: 0
  }),
  errorBarOffset: 0
};
var ErrorBarContext = /* @__PURE__ */ reactExports.createContext(initialContextState);
function SetErrorBarContext(props) {
  var {
    children
  } = props, rest = _objectWithoutProperties$9(props, _excluded$9);
  return /* @__PURE__ */ reactExports.createElement(ErrorBarContext.Provider, {
    value: rest
  }, children);
}
function useNeedsClip(xAxisId, yAxisId) {
  var _xAxis$allowDataOverf, _yAxis$allowDataOverf;
  var xAxis = useAppSelector((state) => selectXAxisSettings(state, xAxisId));
  var yAxis = useAppSelector((state) => selectYAxisSettings(state, yAxisId));
  var needClipX = (_xAxis$allowDataOverf = xAxis === null || xAxis === void 0 ? void 0 : xAxis.allowDataOverflow) !== null && _xAxis$allowDataOverf !== void 0 ? _xAxis$allowDataOverf : implicitXAxis.allowDataOverflow;
  var needClipY = (_yAxis$allowDataOverf = yAxis === null || yAxis === void 0 ? void 0 : yAxis.allowDataOverflow) !== null && _yAxis$allowDataOverf !== void 0 ? _yAxis$allowDataOverf : implicitYAxis.allowDataOverflow;
  var needClip = needClipX || needClipY;
  return {
    needClip,
    needClipX,
    needClipY
  };
}
function GraphicalItemClipPath(_ref2) {
  var {
    xAxisId,
    yAxisId,
    clipPathId
  } = _ref2;
  var plotArea = usePlotArea();
  var {
    needClipX,
    needClipY,
    needClip
  } = useNeedsClip(xAxisId, yAxisId);
  if (!needClip) {
    return null;
  }
  var {
    x: x2,
    y: y2,
    width,
    height
  } = plotArea;
  return /* @__PURE__ */ reactExports.createElement("clipPath", {
    id: "clipPath-".concat(clipPathId)
  }, /* @__PURE__ */ reactExports.createElement("rect", {
    x: needClipX ? x2 : x2 - width / 2,
    y: needClipY ? y2 : y2 - height / 2,
    width: needClipX ? width : width * 2,
    height: needClipY ? height : height * 2
  }));
}
var _excluded$8 = ["onMouseEnter", "onMouseLeave", "onClick"], _excluded2$5 = ["value", "background", "tooltipPosition"], _excluded3$5 = ["id"], _excluded4$3 = ["onMouseEnter", "onClick", "onMouseLeave"];
function _extends$9() {
  return _extends$9 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$9.apply(null, arguments);
}
function ownKeys$6(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$6(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$6(Object(t2), true).forEach(function(r3) {
      _defineProperty$7(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$6(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$7(e3, r2, t2) {
  return (r2 = _toPropertyKey$7(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$7(t2) {
  var i2 = _toPrimitive$7(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$7(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$8(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$8(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$8(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
var computeLegendPayloadFromBarData = (props) => {
  var {
    dataKey,
    name,
    fill,
    legendType,
    hide
  } = props;
  return [{
    inactive: hide,
    dataKey,
    type: legendType,
    color: fill,
    value: getTooltipNameProp(name, dataKey),
    payload: props
  }];
};
function getTooltipEntrySettings$1(props) {
  var {
    dataKey,
    stroke,
    strokeWidth,
    fill,
    name,
    hide,
    unit: unit2
  } = props;
  return {
    dataDefinedOnItem: void 0,
    positions: void 0,
    settings: {
      stroke,
      strokeWidth,
      fill,
      dataKey,
      nameKey: void 0,
      name: getTooltipNameProp(name, dataKey),
      hide,
      type: props.tooltipType,
      color: props.fill,
      unit: unit2
    }
  };
}
function BarBackground(props) {
  var activeIndex = useAppSelector(selectActiveTooltipIndex);
  var {
    data,
    dataKey,
    background: backgroundFromProps,
    allOtherBarProps
  } = props;
  var {
    onMouseEnter: onMouseEnterFromProps,
    onMouseLeave: onMouseLeaveFromProps,
    onClick: onItemClickFromProps
  } = allOtherBarProps, restOfAllOtherProps = _objectWithoutProperties$8(allOtherBarProps, _excluded$8);
  var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, dataKey);
  var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
  var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, dataKey);
  if (!backgroundFromProps || data == null) {
    return null;
  }
  var backgroundProps = svgPropertiesNoEventsFromUnknown(backgroundFromProps);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, data.map((entry, i2) => {
    var {
      value,
      background: backgroundFromDataEntry,
      tooltipPosition
    } = entry, rest = _objectWithoutProperties$8(entry, _excluded2$5);
    if (!backgroundFromDataEntry) {
      return null;
    }
    var onMouseEnter = onMouseEnterFromContext(entry, i2);
    var onMouseLeave = onMouseLeaveFromContext(entry, i2);
    var onClick = onClickFromContext(entry, i2);
    var barRectangleProps = _objectSpread$6(_objectSpread$6(_objectSpread$6(_objectSpread$6(_objectSpread$6({
      option: backgroundFromProps,
      isActive: String(i2) === activeIndex
    }, rest), {}, {
      // @ts-expect-error backgroundProps is contributing unknown props
      fill: "#eee"
    }, backgroundFromDataEntry), backgroundProps), adaptEventsOfChild(restOfAllOtherProps, entry, i2)), {}, {
      onMouseEnter,
      onMouseLeave,
      onClick,
      dataKey,
      index: i2,
      className: "recharts-bar-background-rectangle"
    });
    return /* @__PURE__ */ reactExports.createElement(BarRectangle, _extends$9({
      key: "background-bar-".concat(i2)
    }, barRectangleProps));
  }));
}
function BarLabelListProvider(_ref2) {
  var {
    showLabels,
    children,
    rects
  } = _ref2;
  var labelListEntries = rects === null || rects === void 0 ? void 0 : rects.map((entry) => {
    var viewBox = {
      x: entry.x,
      y: entry.y,
      width: entry.width,
      height: entry.height
    };
    return _objectSpread$6(_objectSpread$6({}, viewBox), {}, {
      value: entry.value,
      payload: entry.payload,
      parentViewBox: entry.parentViewBox,
      viewBox,
      fill: entry.fill
    });
  });
  return /* @__PURE__ */ reactExports.createElement(CartesianLabelListContextProvider, {
    value: showLabels ? labelListEntries : void 0
  }, children);
}
function BarRectangleWithActiveState(props) {
  var {
    shape,
    activeBar,
    baseProps,
    entry,
    index,
    dataKey
  } = props;
  var activeIndex = useAppSelector(selectActiveTooltipIndex);
  var activeDataKey = useAppSelector(selectActiveTooltipDataKey);
  var isActive = activeBar && String(index) === activeIndex && (activeDataKey == null || dataKey === activeDataKey);
  var option = isActive ? activeBar : shape;
  return /* @__PURE__ */ reactExports.createElement(BarRectangle, _extends$9({}, baseProps, {
    name: String(baseProps.name)
  }, entry, {
    isActive,
    option,
    index,
    dataKey
  }));
}
function BarRectangleNeverActive(props) {
  var {
    shape,
    baseProps,
    entry,
    index,
    dataKey
  } = props;
  return /* @__PURE__ */ reactExports.createElement(BarRectangle, _extends$9({}, baseProps, {
    name: String(baseProps.name)
  }, entry, {
    isActive: false,
    option: shape,
    index,
    dataKey
  }));
}
function BarRectangles(_ref2) {
  var {
    data,
    props
  } = _ref2;
  var _svgPropertiesNoEvent = svgPropertiesNoEvents(props), {
    id
  } = _svgPropertiesNoEvent, baseProps = _objectWithoutProperties$8(_svgPropertiesNoEvent, _excluded3$5);
  var {
    shape,
    dataKey,
    activeBar
  } = props;
  var {
    onMouseEnter: onMouseEnterFromProps,
    onClick: onItemClickFromProps,
    onMouseLeave: onMouseLeaveFromProps
  } = props, restOfAllOtherProps = _objectWithoutProperties$8(props, _excluded4$3);
  var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, dataKey);
  var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
  var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, dataKey);
  if (!data) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, data.map((entry, i2) => {
    return /* @__PURE__ */ reactExports.createElement(
      Layer,
      _extends$9({
        key: "rectangle-".concat(entry === null || entry === void 0 ? void 0 : entry.x, "-").concat(entry === null || entry === void 0 ? void 0 : entry.y, "-").concat(entry === null || entry === void 0 ? void 0 : entry.value, "-").concat(i2),
        className: "recharts-bar-rectangle"
      }, adaptEventsOfChild(restOfAllOtherProps, entry, i2), {
        // @ts-expect-error BarRectangleItem type definition says it's missing properties, but I can see them present in debugger!
        onMouseEnter: onMouseEnterFromContext(entry, i2),
        onMouseLeave: onMouseLeaveFromContext(entry, i2),
        onClick: onClickFromContext(entry, i2)
      }),
      activeBar ? /* @__PURE__ */ reactExports.createElement(BarRectangleWithActiveState, {
        shape,
        activeBar,
        baseProps,
        entry,
        index: i2,
        dataKey
      }) : (
        /*
         * If the `activeBar` prop is falsy, then let's call the variant without hooks.
         * Using the `selectActiveTooltipIndex` selector is usually fast
         * but in charts with large-ish amount of data even the few nanoseconds add up to a noticeable jank.
         * If the activeBar is false then we don't need to know which index is active - because we won't use it anyway.
         * So let's just skip the hooks altogether. That way, React can skip rendering the component,
         * and can skip the tree reconciliation for its children too.
         * Because we can't call hooks conditionally, we need to have a separate component for that.
         */
        /* @__PURE__ */ reactExports.createElement(BarRectangleNeverActive, {
          shape,
          baseProps,
          entry,
          index: i2,
          dataKey
        })
      )
    );
  }));
}
function RectanglesWithAnimation(_ref3) {
  var {
    props,
    previousRectanglesRef
  } = _ref3;
  var {
    data,
    layout,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing,
    onAnimationEnd,
    onAnimationStart
  } = props;
  var prevData = previousRectanglesRef.current;
  var animationId = useAnimationId(props, "recharts-bar-");
  var [isAnimating, setIsAnimating] = reactExports.useState(false);
  var showLabels = !isAnimating;
  var handleAnimationEnd = reactExports.useCallback(() => {
    if (typeof onAnimationEnd === "function") {
      onAnimationEnd();
    }
    setIsAnimating(false);
  }, [onAnimationEnd]);
  var handleAnimationStart = reactExports.useCallback(() => {
    if (typeof onAnimationStart === "function") {
      onAnimationStart();
    }
    setIsAnimating(true);
  }, [onAnimationStart]);
  return /* @__PURE__ */ reactExports.createElement(BarLabelListProvider, {
    showLabels,
    rects: data
  }, /* @__PURE__ */ reactExports.createElement(JavascriptAnimate, {
    animationId,
    begin: animationBegin,
    duration: animationDuration,
    isActive: isAnimationActive,
    easing: animationEasing,
    onAnimationEnd: handleAnimationEnd,
    onAnimationStart: handleAnimationStart,
    key: animationId
  }, (t2) => {
    var stepData = t2 === 1 ? data : data === null || data === void 0 ? void 0 : data.map((entry, index) => {
      var prev = prevData && prevData[index];
      if (prev) {
        return _objectSpread$6(_objectSpread$6({}, entry), {}, {
          x: interpolate$1(prev.x, entry.x, t2),
          y: interpolate$1(prev.y, entry.y, t2),
          width: interpolate$1(prev.width, entry.width, t2),
          height: interpolate$1(prev.height, entry.height, t2)
        });
      }
      if (layout === "horizontal") {
        var h2 = interpolate$1(0, entry.height, t2);
        return _objectSpread$6(_objectSpread$6({}, entry), {}, {
          y: entry.y + entry.height - h2,
          height: h2
        });
      }
      var w2 = interpolate$1(0, entry.width, t2);
      return _objectSpread$6(_objectSpread$6({}, entry), {}, {
        width: w2
      });
    });
    if (t2 > 0) {
      previousRectanglesRef.current = stepData !== null && stepData !== void 0 ? stepData : null;
    }
    if (stepData == null) {
      return null;
    }
    return /* @__PURE__ */ reactExports.createElement(Layer, null, /* @__PURE__ */ reactExports.createElement(BarRectangles, {
      props,
      data: stepData
    }));
  }), /* @__PURE__ */ reactExports.createElement(LabelListFromLabelProp, {
    label: props.label
  }), props.children);
}
function RenderRectangles(props) {
  var previousRectanglesRef = reactExports.useRef(null);
  return /* @__PURE__ */ reactExports.createElement(RectanglesWithAnimation, {
    previousRectanglesRef,
    props
  });
}
var defaultMinPointSize = 0;
var errorBarDataPointFormatter$1 = (dataPoint, dataKey) => {
  var value = Array.isArray(dataPoint.value) ? dataPoint.value[1] : dataPoint.value;
  return {
    x: dataPoint.x,
    y: dataPoint.y,
    value,
    // @ts-expect-error getValueByDataKey does not validate the output type
    errorVal: getValueByDataKey(dataPoint, dataKey)
  };
};
class BarWithState extends reactExports.PureComponent {
  render() {
    var {
      hide,
      data,
      dataKey,
      className,
      xAxisId,
      yAxisId,
      needClip,
      background,
      id
    } = this.props;
    if (hide || data == null) {
      return null;
    }
    var layerClass = clsx("recharts-bar", className);
    var clipPathId = id;
    return /* @__PURE__ */ reactExports.createElement(Layer, {
      className: layerClass,
      id
    }, needClip && /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement(GraphicalItemClipPath, {
      clipPathId,
      xAxisId,
      yAxisId
    })), /* @__PURE__ */ reactExports.createElement(Layer, {
      className: "recharts-bar-rectangles",
      clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : void 0
    }, /* @__PURE__ */ reactExports.createElement(BarBackground, {
      data,
      dataKey,
      background,
      allOtherBarProps: this.props
    }), /* @__PURE__ */ reactExports.createElement(RenderRectangles, this.props)));
  }
}
var defaultBarProps = {
  activeBar: false,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "ease",
  hide: false,
  isAnimationActive: !Global.isSsr,
  legendType: "rect",
  minPointSize: defaultMinPointSize,
  xAxisId: 0,
  yAxisId: 0
};
function BarImpl(props) {
  var {
    xAxisId,
    yAxisId,
    hide,
    legendType,
    minPointSize,
    activeBar,
    animationBegin,
    animationDuration,
    animationEasing,
    isAnimationActive
  } = props;
  var {
    needClip
  } = useNeedsClip(xAxisId, yAxisId);
  var layout = useChartLayout();
  var isPanorama = useIsPanorama();
  var cells = findAllByType(props.children, Cell);
  var rects = useAppSelector((state) => selectBarRectangles(state, xAxisId, yAxisId, isPanorama, props.id, cells));
  if (layout !== "vertical" && layout !== "horizontal") {
    return null;
  }
  var errorBarOffset;
  var firstDataPoint = rects === null || rects === void 0 ? void 0 : rects[0];
  if (firstDataPoint == null || firstDataPoint.height == null || firstDataPoint.width == null) {
    errorBarOffset = 0;
  } else {
    errorBarOffset = layout === "vertical" ? firstDataPoint.height / 2 : firstDataPoint.width / 2;
  }
  return /* @__PURE__ */ reactExports.createElement(SetErrorBarContext, {
    xAxisId,
    yAxisId,
    data: rects,
    dataPointFormatter: errorBarDataPointFormatter$1,
    errorBarOffset
  }, /* @__PURE__ */ reactExports.createElement(BarWithState, _extends$9({}, props, {
    layout,
    needClip,
    data: rects,
    xAxisId,
    yAxisId,
    hide,
    legendType,
    minPointSize,
    activeBar,
    animationBegin,
    animationDuration,
    animationEasing,
    isAnimationActive
  })));
}
function computeBarRectangles(_ref4) {
  var {
    layout,
    barSettings: {
      dataKey,
      minPointSize: minPointSizeProp
    },
    pos,
    bandSize,
    xAxis,
    yAxis,
    xAxisTicks,
    yAxisTicks,
    stackedData,
    displayedData,
    offset,
    cells,
    parentViewBox
  } = _ref4;
  var numericAxis = layout === "horizontal" ? yAxis : xAxis;
  var stackedDomain = stackedData ? numericAxis.scale.domain() : null;
  var baseValue = getBaseValueOfBar({
    numericAxis
  });
  return displayedData.map((entry, index) => {
    var value, x2, y2, width, height, background;
    if (stackedData) {
      value = truncateByDomain(stackedData[index], stackedDomain);
    } else {
      value = getValueByDataKey(entry, dataKey);
      if (!Array.isArray(value)) {
        value = [baseValue, value];
      }
    }
    var minPointSize = minPointSizeCallback(minPointSizeProp, defaultMinPointSize)(value[1], index);
    if (layout === "horizontal") {
      var _ref5;
      var [baseValueScale, currentValueScale] = [yAxis.scale(value[0]), yAxis.scale(value[1])];
      x2 = getCateCoordinateOfBar({
        axis: xAxis,
        ticks: xAxisTicks,
        bandSize,
        offset: pos.offset,
        entry,
        index
      });
      y2 = (_ref5 = currentValueScale !== null && currentValueScale !== void 0 ? currentValueScale : baseValueScale) !== null && _ref5 !== void 0 ? _ref5 : void 0;
      width = pos.size;
      var computedHeight = baseValueScale - currentValueScale;
      height = isNan(computedHeight) ? 0 : computedHeight;
      background = {
        x: x2,
        y: offset.top,
        width,
        height: offset.height
      };
      if (Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize)) {
        var delta = mathSign(height || minPointSize) * (Math.abs(minPointSize) - Math.abs(height));
        y2 -= delta;
        height += delta;
      }
    } else {
      var [_baseValueScale, _currentValueScale] = [xAxis.scale(value[0]), xAxis.scale(value[1])];
      x2 = _baseValueScale;
      y2 = getCateCoordinateOfBar({
        axis: yAxis,
        ticks: yAxisTicks,
        bandSize,
        offset: pos.offset,
        entry,
        index
      });
      width = _currentValueScale - _baseValueScale;
      height = pos.size;
      background = {
        x: offset.left,
        y: y2,
        width: offset.width,
        height
      };
      if (Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize)) {
        var _delta = mathSign(width || minPointSize) * (Math.abs(minPointSize) - Math.abs(width));
        width += _delta;
      }
    }
    if (x2 == null || y2 == null || width == null || height == null) {
      return null;
    }
    var barRectangleItem = _objectSpread$6(_objectSpread$6({}, entry), {}, {
      x: x2,
      y: y2,
      width,
      height,
      value: stackedData ? value : value[1],
      payload: entry,
      background,
      tooltipPosition: {
        x: x2 + width / 2,
        y: y2 + height / 2
      },
      parentViewBox
    }, cells && cells[index] && cells[index].props);
    return barRectangleItem;
  }).filter(Boolean);
}
function BarFn(outsideProps) {
  var props = resolveDefaultProps(outsideProps, defaultBarProps);
  var isPanorama = useIsPanorama();
  return /* @__PURE__ */ reactExports.createElement(RegisterGraphicalItemId, {
    id: props.id,
    type: "bar"
  }, (id) => /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(SetLegendPayload, {
    legendPayload: computeLegendPayloadFromBarData(props)
  }), /* @__PURE__ */ reactExports.createElement(SetTooltipEntrySettings, {
    fn: getTooltipEntrySettings$1,
    args: props
  }), /* @__PURE__ */ reactExports.createElement(SetCartesianGraphicalItem, {
    type: "bar",
    id,
    data: void 0,
    xAxisId: props.xAxisId,
    yAxisId: props.yAxisId,
    zAxisId: 0,
    dataKey: props.dataKey,
    stackId: getNormalizedStackId(props.stackId),
    hide: props.hide,
    barSize: props.barSize,
    minPointSize: props.minPointSize,
    maxBarSize: props.maxBarSize,
    isPanorama
  }), /* @__PURE__ */ reactExports.createElement(BarImpl, _extends$9({}, props, {
    id
  }))));
}
var Bar = /* @__PURE__ */ reactExports.memo(BarFn);
Bar.displayName = "Bar";
function ownKeys$5(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r22) {
      return Object.getOwnPropertyDescriptor(e3, r22).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$5(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$5(Object(t2), true).forEach(function(r22) {
      _defineProperty$6(e3, r22, t2[r22]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$5(Object(t2)).forEach(function(r22) {
      Object.defineProperty(e3, r22, Object.getOwnPropertyDescriptor(t2, r22));
    });
  }
  return e3;
}
function _defineProperty$6(e3, r2, t2) {
  return (r2 = _toPropertyKey$6(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$6(t2) {
  var i2 = _toPrimitive$6(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$6(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var pickXAxisId = (_state, xAxisId) => xAxisId;
var pickYAxisId = (_state, _xAxisId, yAxisId) => yAxisId;
var pickIsPanorama = (_state, _xAxisId, _yAxisId, isPanorama) => isPanorama;
var pickBarId = (_state, _xAxisId, _yAxisId, _isPanorama, id) => id;
var selectSynchronisedBarSettings = createSelector([selectUnfilteredCartesianItems, pickBarId], (graphicalItems, id) => graphicalItems.filter((item) => item.type === "bar").find((item) => item.id === id));
var selectMaxBarSize = createSelector([selectSynchronisedBarSettings], (barSettings) => barSettings === null || barSettings === void 0 ? void 0 : barSettings.maxBarSize);
var pickCells = (_state, _xAxisId, _yAxisId, _isPanorama, _id, cells) => cells;
var getBarSize = (globalSize, totalSize, selfSize) => {
  var barSize = selfSize !== null && selfSize !== void 0 ? selfSize : globalSize;
  if (isNullish(barSize)) {
    return void 0;
  }
  return getPercentValue(barSize, totalSize, 0);
};
var selectAllVisibleBars = createSelector([selectChartLayout, selectUnfilteredCartesianItems, pickXAxisId, pickYAxisId, pickIsPanorama], (layout, allItems, xAxisId, yAxisId, isPanorama) => allItems.filter((i2) => {
  if (layout === "horizontal") {
    return i2.xAxisId === xAxisId;
  }
  return i2.yAxisId === yAxisId;
}).filter((i2) => i2.isPanorama === isPanorama).filter((i2) => i2.hide === false).filter((i2) => i2.type === "bar"));
var selectBarStackGroups = (state, xAxisId, yAxisId, isPanorama) => {
  var layout = selectChartLayout(state);
  if (layout === "horizontal") {
    return selectStackGroups(state, "yAxis", yAxisId, isPanorama);
  }
  return selectStackGroups(state, "xAxis", xAxisId, isPanorama);
};
var selectBarCartesianAxisSize = (state, xAxisId, yAxisId) => {
  var layout = selectChartLayout(state);
  if (layout === "horizontal") {
    return selectCartesianAxisSize(state, "xAxis", xAxisId);
  }
  return selectCartesianAxisSize(state, "yAxis", yAxisId);
};
var combineBarSizeList = (allBars, globalSize, totalSize) => {
  var initialValue = {};
  var stackedBars = allBars.filter(isStacked);
  var unstackedBars = allBars.filter((b2) => b2.stackId == null);
  var groupByStack = stackedBars.reduce((acc, bar) => {
    if (!acc[bar.stackId]) {
      acc[bar.stackId] = [];
    }
    acc[bar.stackId].push(bar);
    return acc;
  }, initialValue);
  var stackedSizeList = Object.entries(groupByStack).map((_ref2) => {
    var [stackId, bars] = _ref2;
    var dataKeys = bars.map((b2) => b2.dataKey);
    var barSize = getBarSize(globalSize, totalSize, bars[0].barSize);
    return {
      stackId,
      dataKeys,
      barSize
    };
  });
  var unstackedSizeList = unstackedBars.map((b2) => {
    var dataKeys = [b2.dataKey].filter((dk) => dk != null);
    var barSize = getBarSize(globalSize, totalSize, b2.barSize);
    return {
      stackId: void 0,
      dataKeys,
      barSize
    };
  });
  return [...stackedSizeList, ...unstackedSizeList];
};
var selectBarSizeList = createSelector([selectAllVisibleBars, selectRootBarSize, selectBarCartesianAxisSize], combineBarSizeList);
var selectBarBandSize = (state, xAxisId, yAxisId, isPanorama, id) => {
  var _ref2, _getBandSizeOfAxis;
  var barSettings = selectSynchronisedBarSettings(state, xAxisId, yAxisId, isPanorama, id);
  if (barSettings == null) {
    return void 0;
  }
  var layout = selectChartLayout(state);
  var globalMaxBarSize = selectRootMaxBarSize(state);
  var {
    maxBarSize: childMaxBarSize
  } = barSettings;
  var maxBarSize = isNullish(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
  var axis, ticks2;
  if (layout === "horizontal") {
    axis = selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
    ticks2 = selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
  } else {
    axis = selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
    ticks2 = selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
  }
  return (_ref2 = (_getBandSizeOfAxis = getBandSizeOfAxis(axis, ticks2, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref2 !== void 0 ? _ref2 : 0;
};
var selectAxisBandSize = (state, xAxisId, yAxisId, isPanorama) => {
  var layout = selectChartLayout(state);
  var axis, ticks2;
  if (layout === "horizontal") {
    axis = selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
    ticks2 = selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
  } else {
    axis = selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
    ticks2 = selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
  }
  return getBandSizeOfAxis(axis, ticks2);
};
function getBarPositions(barGap, barCategoryGap, bandSize, sizeList, maxBarSize) {
  var len = sizeList.length;
  if (len < 1) {
    return void 0;
  }
  var realBarGap = getPercentValue(barGap, bandSize, 0, true);
  var result;
  var initialValue = [];
  if (isWellBehavedNumber(sizeList[0].barSize)) {
    var useFull = false;
    var fullBarSize = bandSize / len;
    var sum = sizeList.reduce((res, entry) => res + (entry.barSize || 0), 0);
    sum += (len - 1) * realBarGap;
    if (sum >= bandSize) {
      sum -= (len - 1) * realBarGap;
      realBarGap = 0;
    }
    if (sum >= bandSize && fullBarSize > 0) {
      useFull = true;
      fullBarSize *= 0.9;
      sum = len * fullBarSize;
    }
    var offset = (bandSize - sum) / 2 >> 0;
    var prev = {
      offset: offset - realBarGap,
      size: 0
    };
    result = sizeList.reduce((res, entry) => {
      var _entry$barSize;
      var newPosition = {
        stackId: entry.stackId,
        dataKeys: entry.dataKeys,
        position: {
          offset: prev.offset + prev.size + realBarGap,
          size: useFull ? fullBarSize : (_entry$barSize = entry.barSize) !== null && _entry$barSize !== void 0 ? _entry$barSize : 0
        }
      };
      var newRes = [...res, newPosition];
      prev = newRes[newRes.length - 1].position;
      return newRes;
    }, initialValue);
  } else {
    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);
    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {
      realBarGap = 0;
    }
    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;
    if (originalSize > 1) {
      originalSize >>= 0;
    }
    var size = isWellBehavedNumber(maxBarSize) ? Math.min(originalSize, maxBarSize) : originalSize;
    result = sizeList.reduce((res, entry, i2) => [...res, {
      stackId: entry.stackId,
      dataKeys: entry.dataKeys,
      position: {
        offset: _offset + (originalSize + realBarGap) * i2 + (originalSize - size) / 2,
        size
      }
    }], initialValue);
  }
  return result;
}
var combineAllBarPositions = (sizeList, globalMaxBarSize, barGap, barCategoryGap, barBandSize, bandSize, childMaxBarSize) => {
  var maxBarSize = isNullish(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
  var allBarPositions = getBarPositions(barGap, barCategoryGap, barBandSize !== bandSize ? barBandSize : bandSize, sizeList, maxBarSize);
  if (barBandSize !== bandSize && allBarPositions != null) {
    allBarPositions = allBarPositions.map((pos) => _objectSpread$5(_objectSpread$5({}, pos), {}, {
      position: _objectSpread$5(_objectSpread$5({}, pos.position), {}, {
        offset: pos.position.offset - barBandSize / 2
      })
    }));
  }
  return allBarPositions;
};
var selectAllBarPositions = createSelector([selectBarSizeList, selectRootMaxBarSize, selectBarGap, selectBarCategoryGap, selectBarBandSize, selectAxisBandSize, selectMaxBarSize], combineAllBarPositions);
var selectXAxisWithScale$1 = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
var selectYAxisWithScale$1 = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
var selectXAxisTicks$1 = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
var selectYAxisTicks$1 = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
var selectBarPosition = createSelector([selectAllBarPositions, selectSynchronisedBarSettings], (allBarPositions, barSettings) => {
  if (allBarPositions == null || barSettings == null) {
    return void 0;
  }
  var position = allBarPositions.find((p2) => p2.stackId === barSettings.stackId && barSettings.dataKey != null && p2.dataKeys.includes(barSettings.dataKey));
  if (position == null) {
    return void 0;
  }
  return position.position;
});
var combineStackedData = (stackGroups, barSettings) => {
  var stackSeriesIdentifier = getStackSeriesIdentifier(barSettings);
  if (!stackGroups || stackSeriesIdentifier == null || barSettings == null) {
    return void 0;
  }
  var {
    stackId
  } = barSettings;
  if (stackId == null) {
    return void 0;
  }
  var stackGroup = stackGroups[stackId];
  if (!stackGroup) {
    return void 0;
  }
  var {
    stackedData
  } = stackGroup;
  if (!stackedData) {
    return void 0;
  }
  return stackedData.find((sd) => sd.key === stackSeriesIdentifier);
};
var selectStackedDataOfItem = createSelector([selectBarStackGroups, selectSynchronisedBarSettings], combineStackedData);
var selectBarRectangles = createSelector([selectChartOffsetInternal, selectAxisViewBox, selectXAxisWithScale$1, selectYAxisWithScale$1, selectXAxisTicks$1, selectYAxisTicks$1, selectBarPosition, selectChartLayout, selectChartDataWithIndexesIfNotInPanorama, selectAxisBandSize, selectStackedDataOfItem, selectSynchronisedBarSettings, pickCells], (offset, axisViewBox, xAxis, yAxis, xAxisTicks, yAxisTicks, pos, layout, _ref3, bandSize, stackedData, barSettings, cells) => {
  var {
    chartData,
    dataStartIndex,
    dataEndIndex
  } = _ref3;
  if (barSettings == null || pos == null || axisViewBox == null || layout !== "horizontal" && layout !== "vertical" || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || bandSize == null) {
    return void 0;
  }
  var {
    data
  } = barSettings;
  var displayedData;
  if (data != null && data.length > 0) {
    displayedData = data;
  } else {
    displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
  }
  if (displayedData == null) {
    return void 0;
  }
  return computeBarRectangles({
    layout,
    barSettings,
    pos,
    parentViewBox: axisViewBox,
    bandSize,
    xAxis,
    yAxis,
    xAxisTicks,
    yAxisTicks,
    stackedData,
    displayedData,
    offset,
    cells
  });
});
var ChartDataContextProvider = (props) => {
  var {
    chartData
  } = props;
  var dispatch = useAppDispatch();
  var isPanorama = useIsPanorama();
  reactExports.useEffect(() => {
    if (isPanorama) {
      return () => {
      };
    }
    dispatch(setChartData(chartData));
    return () => {
      dispatch(setChartData(void 0));
    };
  }, [chartData, dispatch, isPanorama]);
  return null;
};
var initialState$2 = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
};
var brushSlice = createSlice({
  name: "brush",
  initialState: initialState$2,
  reducers: {
    setBrushSettings(_state, action) {
      if (action.payload == null) {
        return initialState$2;
      }
      return action.payload;
    }
  }
});
var {
  setBrushSettings
} = brushSlice.actions;
var brushReducer = brushSlice.reducer;
function _defineProperty$5(e3, r2, t2) {
  return (r2 = _toPropertyKey$5(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$5(t2) {
  var i2 = _toPrimitive$5(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$5(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
class ScaleHelper {
  static create(obj) {
    return new ScaleHelper(obj);
  }
  constructor(scale) {
    this.scale = scale;
  }
  get domain() {
    return this.scale.domain;
  }
  get range() {
    return this.scale.range;
  }
  get rangeMin() {
    return this.range()[0];
  }
  get rangeMax() {
    return this.range()[1];
  }
  get bandwidth() {
    return this.scale.bandwidth;
  }
  apply(value) {
    var {
      bandAware,
      position
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (value === void 0) {
      return void 0;
    }
    if (position) {
      switch (position) {
        case "start": {
          return this.scale(value);
        }
        case "middle": {
          var offset = this.bandwidth ? this.bandwidth() / 2 : 0;
          return this.scale(value) + offset;
        }
        case "end": {
          var _offset = this.bandwidth ? this.bandwidth() : 0;
          return this.scale(value) + _offset;
        }
        default: {
          return this.scale(value);
        }
      }
    }
    if (bandAware) {
      var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
      return this.scale(value) + _offset2;
    }
    return this.scale(value);
  }
  isInRange(value) {
    var range2 = this.range();
    var first = range2[0];
    var last2 = range2[range2.length - 1];
    return first <= last2 ? value >= first && value <= last2 : value >= last2 && value <= first;
  }
}
_defineProperty$5(ScaleHelper, "EPS", 1e-4);
function normalizeAngle(angle) {
  return (angle % 180 + 180) % 180;
}
var getAngledRectangleWidth = function getAngledRectangleWidth2(_ref5) {
  var {
    width,
    height
  } = _ref5;
  var angle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var normalizedAngle = normalizeAngle(angle);
  var angleRadians = normalizedAngle * Math.PI / 180;
  var angleThreshold = Math.atan(height / width);
  var angledWidth = angleRadians > angleThreshold && angleRadians < Math.PI - angleThreshold ? height / Math.sin(angleRadians) : width / Math.cos(angleRadians);
  return Math.abs(angledWidth);
};
var initialState$1 = {
  dots: [],
  areas: [],
  lines: []
};
var referenceElementsSlice = createSlice({
  name: "referenceElements",
  initialState: initialState$1,
  reducers: {
    addDot: (state, action) => {
      state.dots.push(action.payload);
    },
    removeDot: (state, action) => {
      var index = current(state).dots.findIndex((dot) => dot === action.payload);
      if (index !== -1) {
        state.dots.splice(index, 1);
      }
    },
    addArea: (state, action) => {
      state.areas.push(action.payload);
    },
    removeArea: (state, action) => {
      var index = current(state).areas.findIndex((area) => area === action.payload);
      if (index !== -1) {
        state.areas.splice(index, 1);
      }
    },
    addLine: (state, action) => {
      state.lines.push(action.payload);
    },
    removeLine: (state, action) => {
      var index = current(state).lines.findIndex((line) => line === action.payload);
      if (index !== -1) {
        state.lines.splice(index, 1);
      }
    }
  }
});
var {
  addDot,
  removeDot,
  addArea,
  removeArea,
  addLine,
  removeLine
} = referenceElementsSlice.actions;
var referenceElementsReducer = referenceElementsSlice.reducer;
var ClipPathIdContext = /* @__PURE__ */ reactExports.createContext(void 0);
var ClipPathProvider = (_ref2) => {
  var {
    children
  } = _ref2;
  var [clipPathId] = reactExports.useState("".concat(uniqueId("recharts"), "-clip"));
  var plotArea = usePlotArea();
  if (plotArea == null) {
    return null;
  }
  var {
    x: x2,
    y: y2,
    width,
    height
  } = plotArea;
  return /* @__PURE__ */ reactExports.createElement(ClipPathIdContext.Provider, {
    value: clipPathId
  }, /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("clipPath", {
    id: clipPathId
  }, /* @__PURE__ */ reactExports.createElement("rect", {
    x: x2,
    y: y2,
    height,
    width
  }))), children);
};
function shallowEqual(a2, b2) {
  for (var key in a2) {
    if ({}.hasOwnProperty.call(a2, key) && (!{}.hasOwnProperty.call(b2, key) || a2[key] !== b2[key])) {
      return false;
    }
  }
  for (var _key in b2) {
    if ({}.hasOwnProperty.call(b2, _key) && !{}.hasOwnProperty.call(a2, _key)) {
      return false;
    }
  }
  return true;
}
function getEveryNthWithCondition(array2, n2, isValid) {
  if (n2 < 1) {
    return [];
  }
  if (n2 === 1 && isValid === void 0) {
    return array2;
  }
  var result = [];
  for (var i2 = 0; i2 < array2.length; i2 += n2) {
    {
      result.push(array2[i2]);
    }
  }
  return result;
}
function getAngledTickWidth(contentSize, unitSize, angle) {
  var size = {
    width: contentSize.width + unitSize.width,
    height: contentSize.height + unitSize.height
  };
  return getAngledRectangleWidth(size, angle);
}
function getTickBoundaries(viewBox, sign2, sizeKey) {
  var isWidth = sizeKey === "width";
  var {
    x: x2,
    y: y2,
    width,
    height
  } = viewBox;
  if (sign2 === 1) {
    return {
      start: isWidth ? x2 : y2,
      end: isWidth ? x2 + width : y2 + height
    };
  }
  return {
    start: isWidth ? x2 + width : y2 + height,
    end: isWidth ? x2 : y2
  };
}
function isVisible(sign2, tickPosition, getSize, start, end) {
  if (sign2 * tickPosition < sign2 * start || sign2 * tickPosition > sign2 * end) {
    return false;
  }
  var size = getSize();
  return sign2 * (tickPosition - sign2 * size / 2 - start) >= 0 && sign2 * (tickPosition + sign2 * size / 2 - end) <= 0;
}
function getNumberIntervalTicks(ticks2, interval) {
  return getEveryNthWithCondition(ticks2, interval + 1);
}
function getEquidistantTicks(sign2, boundaries, getTickSize, ticks2, minTickGap) {
  var result = (ticks2 || []).slice();
  var {
    start: initialStart,
    end
  } = boundaries;
  var index = 0;
  var stepsize = 1;
  var start = initialStart;
  var _loop = function _loop2() {
    var entry = ticks2 === null || ticks2 === void 0 ? void 0 : ticks2[index];
    if (entry === void 0) {
      return {
        v: getEveryNthWithCondition(ticks2, stepsize)
      };
    }
    var i2 = index;
    var size;
    var getSize = () => {
      if (size === void 0) {
        size = getTickSize(entry, i2);
      }
      return size;
    };
    var tickCoord = entry.coordinate;
    var isShow = index === 0 || isVisible(sign2, tickCoord, getSize, start, end);
    if (!isShow) {
      index = 0;
      start = initialStart;
      stepsize += 1;
    }
    if (isShow) {
      start = tickCoord + sign2 * (getSize() / 2 + minTickGap);
      index += stepsize;
    }
  }, _ret;
  while (stepsize <= result.length) {
    _ret = _loop();
    if (_ret) return _ret.v;
  }
  return [];
}
function ownKeys$4(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$4(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$4(Object(t2), true).forEach(function(r3) {
      _defineProperty$4(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$4(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$4(e3, r2, t2) {
  return (r2 = _toPropertyKey$4(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$4(t2) {
  var i2 = _toPrimitive$4(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$4(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function getTicksEnd(sign2, boundaries, getTickSize, ticks2, minTickGap) {
  var result = (ticks2 || []).slice();
  var len = result.length;
  var {
    start
  } = boundaries;
  var {
    end
  } = boundaries;
  var _loop = function _loop2(i3) {
    var entry = result[i3];
    var size;
    var getSize = () => {
      if (size === void 0) {
        size = getTickSize(entry, i3);
      }
      return size;
    };
    if (i3 === len - 1) {
      var gap = sign2 * (entry.coordinate + sign2 * getSize() / 2 - end);
      result[i3] = entry = _objectSpread$4(_objectSpread$4({}, entry), {}, {
        tickCoord: gap > 0 ? entry.coordinate - gap * sign2 : entry.coordinate
      });
    } else {
      result[i3] = entry = _objectSpread$4(_objectSpread$4({}, entry), {}, {
        tickCoord: entry.coordinate
      });
    }
    var isShow = isVisible(sign2, entry.tickCoord, getSize, start, end);
    if (isShow) {
      end = entry.tickCoord - sign2 * (getSize() / 2 + minTickGap);
      result[i3] = _objectSpread$4(_objectSpread$4({}, entry), {}, {
        isShow: true
      });
    }
  };
  for (var i2 = len - 1; i2 >= 0; i2--) {
    _loop(i2);
  }
  return result;
}
function getTicksStart(sign2, boundaries, getTickSize, ticks2, minTickGap, preserveEnd) {
  var result = (ticks2 || []).slice();
  var len = result.length;
  var {
    start,
    end
  } = boundaries;
  if (preserveEnd) {
    var tail = ticks2[len - 1];
    var tailSize = getTickSize(tail, len - 1);
    var tailGap = sign2 * (tail.coordinate + sign2 * tailSize / 2 - end);
    result[len - 1] = tail = _objectSpread$4(_objectSpread$4({}, tail), {}, {
      tickCoord: tailGap > 0 ? tail.coordinate - tailGap * sign2 : tail.coordinate
    });
    var isTailShow = isVisible(sign2, tail.tickCoord, () => tailSize, start, end);
    if (isTailShow) {
      end = tail.tickCoord - sign2 * (tailSize / 2 + minTickGap);
      result[len - 1] = _objectSpread$4(_objectSpread$4({}, tail), {}, {
        isShow: true
      });
    }
  }
  var count = preserveEnd ? len - 1 : len;
  var _loop2 = function _loop22(i3) {
    var entry = result[i3];
    var size;
    var getSize = () => {
      if (size === void 0) {
        size = getTickSize(entry, i3);
      }
      return size;
    };
    if (i3 === 0) {
      var gap = sign2 * (entry.coordinate - sign2 * getSize() / 2 - start);
      result[i3] = entry = _objectSpread$4(_objectSpread$4({}, entry), {}, {
        tickCoord: gap < 0 ? entry.coordinate - gap * sign2 : entry.coordinate
      });
    } else {
      result[i3] = entry = _objectSpread$4(_objectSpread$4({}, entry), {}, {
        tickCoord: entry.coordinate
      });
    }
    var isShow = isVisible(sign2, entry.tickCoord, getSize, start, end);
    if (isShow) {
      start = entry.tickCoord + sign2 * (getSize() / 2 + minTickGap);
      result[i3] = _objectSpread$4(_objectSpread$4({}, entry), {}, {
        isShow: true
      });
    }
  };
  for (var i2 = 0; i2 < count; i2++) {
    _loop2(i2);
  }
  return result;
}
function getTicks(props, fontSize, letterSpacing) {
  var {
    tick,
    ticks: ticks2,
    viewBox,
    minTickGap,
    orientation: orientation2,
    interval,
    tickFormatter,
    unit: unit2,
    angle
  } = props;
  if (!ticks2 || !ticks2.length || !tick) {
    return [];
  }
  if (isNumber(interval) || Global.isSsr) {
    var _getNumberIntervalTic;
    return (_getNumberIntervalTic = getNumberIntervalTicks(ticks2, isNumber(interval) ? interval : 0)) !== null && _getNumberIntervalTic !== void 0 ? _getNumberIntervalTic : [];
  }
  var candidates = [];
  var sizeKey = orientation2 === "top" || orientation2 === "bottom" ? "width" : "height";
  var unitSize = unit2 && sizeKey === "width" ? getStringSize(unit2, {
    fontSize,
    letterSpacing
  }) : {
    width: 0,
    height: 0
  };
  var getTickSize = (content, index) => {
    var value = typeof tickFormatter === "function" ? tickFormatter(content.value, index) : content.value;
    return sizeKey === "width" ? getAngledTickWidth(getStringSize(value, {
      fontSize,
      letterSpacing
    }), unitSize, angle) : getStringSize(value, {
      fontSize,
      letterSpacing
    })[sizeKey];
  };
  var sign2 = ticks2.length >= 2 ? mathSign(ticks2[1].coordinate - ticks2[0].coordinate) : 1;
  var boundaries = getTickBoundaries(viewBox, sign2, sizeKey);
  if (interval === "equidistantPreserveStart") {
    return getEquidistantTicks(sign2, boundaries, getTickSize, ticks2, minTickGap);
  }
  if (interval === "preserveStart" || interval === "preserveStartEnd") {
    candidates = getTicksStart(sign2, boundaries, getTickSize, ticks2, minTickGap, interval === "preserveStartEnd");
  } else {
    candidates = getTicksEnd(sign2, boundaries, getTickSize, ticks2, minTickGap);
  }
  return candidates.filter((entry) => entry.isShow);
}
var getCalculatedYAxisWidth = (_ref2) => {
  var {
    ticks: ticks2,
    label,
    labelGapWithTick = 5,
    // Default gap between label and tick
    tickSize = 0,
    tickMargin = 0
  } = _ref2;
  var maxTickWidth = 0;
  if (ticks2) {
    Array.from(ticks2).forEach((tickNode) => {
      if (tickNode) {
        var bbox = tickNode.getBoundingClientRect();
        if (bbox.width > maxTickWidth) {
          maxTickWidth = bbox.width;
        }
      }
    });
    var labelWidth = label ? label.getBoundingClientRect().width : 0;
    var tickWidth = tickSize + tickMargin;
    var updatedYAxisWidth = maxTickWidth + tickWidth + labelWidth + (label ? labelGapWithTick : 0);
    return Math.round(updatedYAxisWidth);
  }
  return 0;
};
var _excluded$7 = ["axisLine", "width", "height", "className", "hide", "ticks"], _excluded2$4 = ["viewBox"], _excluded3$4 = ["viewBox"];
function _objectWithoutProperties$7(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$7(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$7(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function _extends$8() {
  return _extends$8 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$8.apply(null, arguments);
}
function ownKeys$3(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$3(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$3(Object(t2), true).forEach(function(r3) {
      _defineProperty$3(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$3(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$3(e3, r2, t2) {
  return (r2 = _toPropertyKey$3(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$3(t2) {
  var i2 = _toPrimitive$3(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$3(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var defaultCartesianAxisProps = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  viewBox: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  // The orientation of axis
  orientation: "bottom",
  // The ticks
  ticks: [],
  stroke: "#666",
  tickLine: true,
  axisLine: true,
  tick: true,
  mirror: false,
  minTickGap: 5,
  // The width or height of tick
  tickSize: 6,
  tickMargin: 2,
  interval: "preserveEnd"
};
function AxisLine(axisLineProps) {
  var {
    x: x2,
    y: y2,
    width,
    height,
    orientation: orientation2,
    mirror,
    axisLine,
    otherSvgProps
  } = axisLineProps;
  if (!axisLine) {
    return null;
  }
  var props = _objectSpread$3(_objectSpread$3(_objectSpread$3({}, otherSvgProps), svgPropertiesNoEvents(axisLine)), {}, {
    fill: "none"
  });
  if (orientation2 === "top" || orientation2 === "bottom") {
    var needHeight = +(orientation2 === "top" && !mirror || orientation2 === "bottom" && mirror);
    props = _objectSpread$3(_objectSpread$3({}, props), {}, {
      x1: x2,
      y1: y2 + needHeight * height,
      x2: x2 + width,
      y2: y2 + needHeight * height
    });
  } else {
    var needWidth = +(orientation2 === "left" && !mirror || orientation2 === "right" && mirror);
    props = _objectSpread$3(_objectSpread$3({}, props), {}, {
      x1: x2 + needWidth * width,
      y1: y2,
      x2: x2 + needWidth * width,
      y2: y2 + height
    });
  }
  return /* @__PURE__ */ reactExports.createElement("line", _extends$8({}, props, {
    className: clsx("recharts-cartesian-axis-line", get(axisLine, "className"))
  }));
}
function getTickLineCoord(data, x2, y2, width, height, orientation2, tickSize, mirror, tickMargin) {
  var x1, x22, y1, y22, tx, ty;
  var sign2 = mirror ? -1 : 1;
  var finalTickSize = data.tickSize || tickSize;
  var tickCoord = isNumber(data.tickCoord) ? data.tickCoord : data.coordinate;
  switch (orientation2) {
    case "top":
      x1 = x22 = data.coordinate;
      y22 = y2 + +!mirror * height;
      y1 = y22 - sign2 * finalTickSize;
      ty = y1 - sign2 * tickMargin;
      tx = tickCoord;
      break;
    case "left":
      y1 = y22 = data.coordinate;
      x22 = x2 + +!mirror * width;
      x1 = x22 - sign2 * finalTickSize;
      tx = x1 - sign2 * tickMargin;
      ty = tickCoord;
      break;
    case "right":
      y1 = y22 = data.coordinate;
      x22 = x2 + +mirror * width;
      x1 = x22 + sign2 * finalTickSize;
      tx = x1 + sign2 * tickMargin;
      ty = tickCoord;
      break;
    default:
      x1 = x22 = data.coordinate;
      y22 = y2 + +mirror * height;
      y1 = y22 + sign2 * finalTickSize;
      ty = y1 + sign2 * tickMargin;
      tx = tickCoord;
      break;
  }
  return {
    line: {
      x1,
      y1,
      x2: x22,
      y2: y22
    },
    tick: {
      x: tx,
      y: ty
    }
  };
}
function getTickTextAnchor(orientation2, mirror) {
  switch (orientation2) {
    case "left":
      return mirror ? "start" : "end";
    case "right":
      return mirror ? "end" : "start";
    default:
      return "middle";
  }
}
function getTickVerticalAnchor(orientation2, mirror) {
  switch (orientation2) {
    case "left":
    case "right":
      return "middle";
    case "top":
      return mirror ? "start" : "end";
    default:
      return mirror ? "end" : "start";
  }
}
function TickItem(props) {
  var {
    option,
    tickProps,
    value
  } = props;
  var tickItem;
  var combinedClassName = clsx(tickProps.className, "recharts-cartesian-axis-tick-value");
  if (/* @__PURE__ */ reactExports.isValidElement(option)) {
    tickItem = /* @__PURE__ */ reactExports.cloneElement(option, _objectSpread$3(_objectSpread$3({}, tickProps), {}, {
      className: combinedClassName
    }));
  } else if (typeof option === "function") {
    tickItem = option(_objectSpread$3(_objectSpread$3({}, tickProps), {}, {
      className: combinedClassName
    }));
  } else {
    var className = "recharts-cartesian-axis-tick-value";
    if (typeof option !== "boolean") {
      className = clsx(className, option === null || option === void 0 ? void 0 : option.className);
    }
    tickItem = /* @__PURE__ */ reactExports.createElement(Text, _extends$8({}, tickProps, {
      className
    }), value);
  }
  return tickItem;
}
function Ticks(props) {
  var {
    ticks: ticks2 = [],
    tick,
    tickLine,
    stroke,
    tickFormatter,
    unit: unit2,
    padding,
    tickTextProps,
    orientation: orientation2,
    mirror,
    x: x2,
    y: y2,
    width,
    height,
    tickSize,
    tickMargin,
    fontSize,
    letterSpacing,
    getTicksConfig,
    events
  } = props;
  var finalTicks = getTicks(_objectSpread$3(_objectSpread$3({}, getTicksConfig), {}, {
    ticks: ticks2
  }), fontSize, letterSpacing);
  var textAnchor = getTickTextAnchor(orientation2, mirror);
  var verticalAnchor = getTickVerticalAnchor(orientation2, mirror);
  var axisProps = svgPropertiesNoEvents(getTicksConfig);
  var customTickProps = svgPropertiesNoEventsFromUnknown(tick);
  var tickLinePropsObject = {};
  if (typeof tickLine === "object") {
    tickLinePropsObject = tickLine;
  }
  var tickLineProps = _objectSpread$3(_objectSpread$3({}, axisProps), {}, {
    fill: "none"
  }, tickLinePropsObject);
  var items = finalTicks.map((entry, i2) => {
    var {
      line: lineCoord,
      tick: tickCoord
    } = getTickLineCoord(entry, x2, y2, width, height, orientation2, tickSize, mirror, tickMargin);
    var tickProps = _objectSpread$3(_objectSpread$3(_objectSpread$3(_objectSpread$3({
      // @ts-expect-error textAnchor from axisProps is typed as `string` but Text wants type `TextAnchor`
      textAnchor,
      verticalAnchor
    }, axisProps), {}, {
      // @ts-expect-error customTickProps is contributing unknown props
      stroke: "none",
      // @ts-expect-error customTickProps is contributing unknown props
      fill: stroke
    }, customTickProps), tickCoord), {}, {
      index: i2,
      payload: entry,
      visibleTicksCount: finalTicks.length,
      tickFormatter,
      padding
    }, tickTextProps);
    return /* @__PURE__ */ reactExports.createElement(Layer, _extends$8({
      className: "recharts-cartesian-axis-tick",
      key: "tick-".concat(entry.value, "-").concat(entry.coordinate, "-").concat(entry.tickCoord)
    }, adaptEventsOfChild(events, entry, i2)), tickLine && /* @__PURE__ */ reactExports.createElement("line", _extends$8({}, tickLineProps, lineCoord, {
      className: clsx("recharts-cartesian-axis-tick-line", get(tickLine, "className"))
    })), tick && /* @__PURE__ */ reactExports.createElement(TickItem, {
      option: tick,
      tickProps,
      value: "".concat(typeof tickFormatter === "function" ? tickFormatter(entry.value, i2) : entry.value).concat(unit2 || "")
    }));
  });
  if (items.length > 0) {
    return /* @__PURE__ */ reactExports.createElement("g", {
      className: "recharts-cartesian-axis-ticks"
    }, items);
  }
  return null;
}
var CartesianAxisComponent = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  var {
    axisLine,
    width,
    height,
    className,
    hide,
    ticks: ticks2
  } = props, rest = _objectWithoutProperties$7(props, _excluded$7);
  var [fontSize, setFontSize] = reactExports.useState("");
  var [letterSpacing, setLetterSpacing] = reactExports.useState("");
  var tickRefs = reactExports.useRef(null);
  reactExports.useImperativeHandle(ref, () => ({
    getCalculatedWidth: () => {
      var _props$labelRef;
      return getCalculatedYAxisWidth({
        ticks: tickRefs.current,
        label: (_props$labelRef = props.labelRef) === null || _props$labelRef === void 0 ? void 0 : _props$labelRef.current,
        labelGapWithTick: 5,
        tickSize: props.tickSize,
        tickMargin: props.tickMargin
      });
    }
  }));
  var layerRef = reactExports.useCallback((el) => {
    if (el) {
      var tickNodes = el.getElementsByClassName("recharts-cartesian-axis-tick-value");
      tickRefs.current = tickNodes;
      var tick = tickNodes[0];
      if (tick) {
        var computedStyle = window.getComputedStyle(tick);
        var calculatedFontSize = computedStyle.fontSize;
        var calculatedLetterSpacing = computedStyle.letterSpacing;
        if (calculatedFontSize !== fontSize || calculatedLetterSpacing !== letterSpacing) {
          setFontSize(calculatedFontSize);
          setLetterSpacing(calculatedLetterSpacing);
        }
      }
    }
  }, [fontSize, letterSpacing]);
  if (hide) {
    return null;
  }
  if (width != null && width <= 0 || height != null && height <= 0) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(Layer, {
    className: clsx("recharts-cartesian-axis", className),
    ref: layerRef
  }, /* @__PURE__ */ reactExports.createElement(AxisLine, {
    x: props.x,
    y: props.y,
    width,
    height,
    orientation: props.orientation,
    mirror: props.mirror,
    axisLine,
    otherSvgProps: svgPropertiesNoEvents(props)
  }), /* @__PURE__ */ reactExports.createElement(Ticks, {
    ticks: ticks2,
    tick: props.tick,
    tickLine: props.tickLine,
    stroke: props.stroke,
    tickFormatter: props.tickFormatter,
    unit: props.unit,
    padding: props.padding,
    tickTextProps: props.tickTextProps,
    orientation: props.orientation,
    mirror: props.mirror,
    x: props.x,
    y: props.y,
    width: props.width,
    height: props.height,
    tickSize: props.tickSize,
    tickMargin: props.tickMargin,
    fontSize,
    letterSpacing,
    getTicksConfig: props,
    events: rest
  }), /* @__PURE__ */ reactExports.createElement(CartesianLabelContextProvider, {
    x: props.x,
    y: props.y,
    width: props.width,
    height: props.height
  }, /* @__PURE__ */ reactExports.createElement(CartesianLabelFromLabelProp, {
    label: props.label,
    labelRef: props.labelRef
  }), props.children));
});
var MemoCartesianAxis = /* @__PURE__ */ reactExports.memo(CartesianAxisComponent, (prevProps, nextProps) => {
  var {
    viewBox: prevViewBox
  } = prevProps, prevRestProps = _objectWithoutProperties$7(prevProps, _excluded2$4);
  var {
    viewBox: nextViewBox
  } = nextProps, nextRestProps = _objectWithoutProperties$7(nextProps, _excluded3$4);
  return shallowEqual(prevViewBox, nextViewBox) && shallowEqual(prevRestProps, nextRestProps);
});
var CartesianAxis = /* @__PURE__ */ reactExports.forwardRef((outsideProps, ref) => {
  var props = resolveDefaultProps(outsideProps, defaultCartesianAxisProps);
  return /* @__PURE__ */ reactExports.createElement(MemoCartesianAxis, _extends$8({}, props, {
    ref
  }));
});
CartesianAxis.displayName = "CartesianAxis";
var _excluded$6 = ["x1", "y1", "x2", "y2", "key"], _excluded2$3 = ["offset"], _excluded3$3 = ["xAxisId", "yAxisId"], _excluded4$2 = ["xAxisId", "yAxisId"];
function ownKeys$2(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$2(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$2(Object(t2), true).forEach(function(r3) {
      _defineProperty$2(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$2(e3, r2, t2) {
  return (r2 = _toPropertyKey$2(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$2(t2) {
  var i2 = _toPrimitive$2(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$2(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _extends$7() {
  return _extends$7 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$7.apply(null, arguments);
}
function _objectWithoutProperties$6(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$6(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$6(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
var Background = (props) => {
  var {
    fill
  } = props;
  if (!fill || fill === "none") {
    return null;
  }
  var {
    fillOpacity,
    x: x2,
    y: y2,
    width,
    height,
    ry
  } = props;
  return /* @__PURE__ */ reactExports.createElement("rect", {
    x: x2,
    y: y2,
    ry,
    width,
    height,
    stroke: "none",
    fill,
    fillOpacity,
    className: "recharts-cartesian-grid-bg"
  });
};
function renderLineItem(option, props) {
  var lineItem;
  if (/* @__PURE__ */ reactExports.isValidElement(option)) {
    lineItem = /* @__PURE__ */ reactExports.cloneElement(option, props);
  } else if (typeof option === "function") {
    lineItem = option(props);
  } else {
    var {
      x1,
      y1,
      x2,
      y2,
      key
    } = props, others = _objectWithoutProperties$6(props, _excluded$6);
    var _svgPropertiesNoEvent = svgPropertiesNoEvents(others), {
      offset: __
    } = _svgPropertiesNoEvent, restOfFilteredProps = _objectWithoutProperties$6(_svgPropertiesNoEvent, _excluded2$3);
    lineItem = /* @__PURE__ */ reactExports.createElement("line", _extends$7({}, restOfFilteredProps, {
      x1,
      y1,
      x2,
      y2,
      fill: "none",
      key
    }));
  }
  return lineItem;
}
function HorizontalGridLines(props) {
  var {
    x: x2,
    width,
    horizontal = true,
    horizontalPoints
  } = props;
  if (!horizontal || !horizontalPoints || !horizontalPoints.length) {
    return null;
  }
  var {
    xAxisId,
    yAxisId
  } = props, otherLineItemProps = _objectWithoutProperties$6(props, _excluded3$3);
  var items = horizontalPoints.map((entry, i2) => {
    var lineItemProps = _objectSpread$2(_objectSpread$2({}, otherLineItemProps), {}, {
      x1: x2,
      y1: entry,
      x2: x2 + width,
      y2: entry,
      key: "line-".concat(i2),
      index: i2
    });
    return renderLineItem(horizontal, lineItemProps);
  });
  return /* @__PURE__ */ reactExports.createElement("g", {
    className: "recharts-cartesian-grid-horizontal"
  }, items);
}
function VerticalGridLines(props) {
  var {
    y: y2,
    height,
    vertical = true,
    verticalPoints
  } = props;
  if (!vertical || !verticalPoints || !verticalPoints.length) {
    return null;
  }
  var {
    xAxisId,
    yAxisId
  } = props, otherLineItemProps = _objectWithoutProperties$6(props, _excluded4$2);
  var items = verticalPoints.map((entry, i2) => {
    var lineItemProps = _objectSpread$2(_objectSpread$2({}, otherLineItemProps), {}, {
      x1: entry,
      y1: y2,
      x2: entry,
      y2: y2 + height,
      key: "line-".concat(i2),
      index: i2
    });
    return renderLineItem(vertical, lineItemProps);
  });
  return /* @__PURE__ */ reactExports.createElement("g", {
    className: "recharts-cartesian-grid-vertical"
  }, items);
}
function HorizontalStripes(props) {
  var {
    horizontalFill,
    fillOpacity,
    x: x2,
    y: y2,
    width,
    height,
    horizontalPoints,
    horizontal = true
  } = props;
  if (!horizontal || !horizontalFill || !horizontalFill.length) {
    return null;
  }
  var roundedSortedHorizontalPoints = horizontalPoints.map((e3) => Math.round(e3 + y2 - y2)).sort((a2, b2) => a2 - b2);
  if (y2 !== roundedSortedHorizontalPoints[0]) {
    roundedSortedHorizontalPoints.unshift(0);
  }
  var items = roundedSortedHorizontalPoints.map((entry, i2) => {
    var lastStripe = !roundedSortedHorizontalPoints[i2 + 1];
    var lineHeight = lastStripe ? y2 + height - entry : roundedSortedHorizontalPoints[i2 + 1] - entry;
    if (lineHeight <= 0) {
      return null;
    }
    var colorIndex = i2 % horizontalFill.length;
    return /* @__PURE__ */ reactExports.createElement("rect", {
      key: "react-".concat(i2),
      y: entry,
      x: x2,
      height: lineHeight,
      width,
      stroke: "none",
      fill: horizontalFill[colorIndex],
      fillOpacity,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return /* @__PURE__ */ reactExports.createElement("g", {
    className: "recharts-cartesian-gridstripes-horizontal"
  }, items);
}
function VerticalStripes(props) {
  var {
    vertical = true,
    verticalFill,
    fillOpacity,
    x: x2,
    y: y2,
    width,
    height,
    verticalPoints
  } = props;
  if (!vertical || !verticalFill || !verticalFill.length) {
    return null;
  }
  var roundedSortedVerticalPoints = verticalPoints.map((e3) => Math.round(e3 + x2 - x2)).sort((a2, b2) => a2 - b2);
  if (x2 !== roundedSortedVerticalPoints[0]) {
    roundedSortedVerticalPoints.unshift(0);
  }
  var items = roundedSortedVerticalPoints.map((entry, i2) => {
    var lastStripe = !roundedSortedVerticalPoints[i2 + 1];
    var lineWidth = lastStripe ? x2 + width - entry : roundedSortedVerticalPoints[i2 + 1] - entry;
    if (lineWidth <= 0) {
      return null;
    }
    var colorIndex = i2 % verticalFill.length;
    return /* @__PURE__ */ reactExports.createElement("rect", {
      key: "react-".concat(i2),
      x: entry,
      y: y2,
      width: lineWidth,
      height,
      stroke: "none",
      fill: verticalFill[colorIndex],
      fillOpacity,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return /* @__PURE__ */ reactExports.createElement("g", {
    className: "recharts-cartesian-gridstripes-vertical"
  }, items);
}
var defaultVerticalCoordinatesGenerator = (_ref2, syncWithTicks) => {
  var {
    xAxis,
    width,
    height,
    offset
  } = _ref2;
  return getCoordinatesOfGrid(getTicks(_objectSpread$2(_objectSpread$2(_objectSpread$2({}, defaultCartesianAxisProps), xAxis), {}, {
    ticks: getTicksOfAxis(xAxis),
    viewBox: {
      x: 0,
      y: 0,
      width,
      height
    }
  })), offset.left, offset.left + offset.width, syncWithTicks);
};
var defaultHorizontalCoordinatesGenerator = (_ref2, syncWithTicks) => {
  var {
    yAxis,
    width,
    height,
    offset
  } = _ref2;
  return getCoordinatesOfGrid(getTicks(_objectSpread$2(_objectSpread$2(_objectSpread$2({}, defaultCartesianAxisProps), yAxis), {}, {
    ticks: getTicksOfAxis(yAxis),
    viewBox: {
      x: 0,
      y: 0,
      width,
      height
    }
  })), offset.top, offset.top + offset.height, syncWithTicks);
};
var defaultProps$3 = {
  horizontal: true,
  vertical: true,
  // The ordinates of horizontal grid lines
  horizontalPoints: [],
  // The abscissas of vertical grid lines
  verticalPoints: [],
  stroke: "#ccc",
  fill: "none",
  // The fill of colors of grid lines
  verticalFill: [],
  horizontalFill: [],
  xAxisId: 0,
  yAxisId: 0
};
function CartesianGrid(props) {
  var chartWidth = useChartWidth();
  var chartHeight = useChartHeight();
  var offset = useOffsetInternal();
  var propsIncludingDefaults = _objectSpread$2(_objectSpread$2({}, resolveDefaultProps(props, defaultProps$3)), {}, {
    x: isNumber(props.x) ? props.x : offset.left,
    y: isNumber(props.y) ? props.y : offset.top,
    width: isNumber(props.width) ? props.width : offset.width,
    height: isNumber(props.height) ? props.height : offset.height
  });
  var {
    xAxisId,
    yAxisId,
    x: x2,
    y: y2,
    width,
    height,
    syncWithTicks,
    horizontalValues,
    verticalValues
  } = propsIncludingDefaults;
  var isPanorama = useIsPanorama();
  var xAxis = useAppSelector((state) => selectAxisPropsNeededForCartesianGridTicksGenerator(state, "xAxis", xAxisId, isPanorama));
  var yAxis = useAppSelector((state) => selectAxisPropsNeededForCartesianGridTicksGenerator(state, "yAxis", yAxisId, isPanorama));
  if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0 || !isNumber(x2) || x2 !== +x2 || !isNumber(y2) || y2 !== +y2) {
    return null;
  }
  var verticalCoordinatesGenerator = propsIncludingDefaults.verticalCoordinatesGenerator || defaultVerticalCoordinatesGenerator;
  var horizontalCoordinatesGenerator = propsIncludingDefaults.horizontalCoordinatesGenerator || defaultHorizontalCoordinatesGenerator;
  var {
    horizontalPoints,
    verticalPoints
  } = propsIncludingDefaults;
  if ((!horizontalPoints || !horizontalPoints.length) && typeof horizontalCoordinatesGenerator === "function") {
    var isHorizontalValues = horizontalValues && horizontalValues.length;
    var generatorResult = horizontalCoordinatesGenerator({
      yAxis: yAxis ? _objectSpread$2(_objectSpread$2({}, yAxis), {}, {
        ticks: isHorizontalValues ? horizontalValues : yAxis.ticks
      }) : void 0,
      width: chartWidth,
      height: chartHeight,
      offset
    }, isHorizontalValues ? true : syncWithTicks);
    warn(Array.isArray(generatorResult), "horizontalCoordinatesGenerator should return Array but instead it returned [".concat(typeof generatorResult, "]"));
    if (Array.isArray(generatorResult)) {
      horizontalPoints = generatorResult;
    }
  }
  if ((!verticalPoints || !verticalPoints.length) && typeof verticalCoordinatesGenerator === "function") {
    var isVerticalValues = verticalValues && verticalValues.length;
    var _generatorResult = verticalCoordinatesGenerator({
      xAxis: xAxis ? _objectSpread$2(_objectSpread$2({}, xAxis), {}, {
        ticks: isVerticalValues ? verticalValues : xAxis.ticks
      }) : void 0,
      width: chartWidth,
      height: chartHeight,
      offset
    }, isVerticalValues ? true : syncWithTicks);
    warn(Array.isArray(_generatorResult), "verticalCoordinatesGenerator should return Array but instead it returned [".concat(typeof _generatorResult, "]"));
    if (Array.isArray(_generatorResult)) {
      verticalPoints = _generatorResult;
    }
  }
  return /* @__PURE__ */ reactExports.createElement("g", {
    className: "recharts-cartesian-grid"
  }, /* @__PURE__ */ reactExports.createElement(Background, {
    fill: propsIncludingDefaults.fill,
    fillOpacity: propsIncludingDefaults.fillOpacity,
    x: propsIncludingDefaults.x,
    y: propsIncludingDefaults.y,
    width: propsIncludingDefaults.width,
    height: propsIncludingDefaults.height,
    ry: propsIncludingDefaults.ry
  }), /* @__PURE__ */ reactExports.createElement(HorizontalStripes, _extends$7({}, propsIncludingDefaults, {
    horizontalPoints
  })), /* @__PURE__ */ reactExports.createElement(VerticalStripes, _extends$7({}, propsIncludingDefaults, {
    verticalPoints
  })), /* @__PURE__ */ reactExports.createElement(HorizontalGridLines, _extends$7({}, propsIncludingDefaults, {
    offset,
    horizontalPoints,
    xAxis,
    yAxis
  })), /* @__PURE__ */ reactExports.createElement(VerticalGridLines, _extends$7({}, propsIncludingDefaults, {
    offset,
    verticalPoints,
    xAxis,
    yAxis
  })));
}
CartesianGrid.displayName = "CartesianGrid";
var selectXAxisWithScale = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
var selectXAxisTicks = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
var selectYAxisWithScale = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
var selectYAxisTicks = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
var selectBandSize = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {
  if (isCategoricalAxis(layout, "xAxis")) {
    return getBandSizeOfAxis(xAxis, xAxisTicks, false);
  }
  return getBandSizeOfAxis(yAxis, yAxisTicks, false);
});
var pickLineId = (_state, _xAxisId, _yAxisId, _isPanorama, id) => id;
function isLineSettings(item) {
  return item.type === "line";
}
var selectSynchronisedLineSettings = createSelector([selectUnfilteredCartesianItems, pickLineId], (graphicalItems, id) => graphicalItems.filter(isLineSettings).find((x2) => x2.id === id));
var selectLinePoints = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks, selectSynchronisedLineSettings, selectBandSize, selectChartDataWithIndexesIfNotInPanorama], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, lineSettings, bandSize, _ref2) => {
  var {
    chartData,
    dataStartIndex,
    dataEndIndex
  } = _ref2;
  if (lineSettings == null || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) {
    return void 0;
  }
  var {
    dataKey,
    data
  } = lineSettings;
  var displayedData;
  if (data != null && data.length > 0) {
    displayedData = data;
  } else {
    displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
  }
  if (displayedData == null) {
    return void 0;
  }
  return computeLinePoints({
    layout,
    xAxis,
    yAxis,
    xAxisTicks,
    yAxisTicks,
    dataKey,
    bandSize,
    displayedData
  });
});
function getRadiusAndStrokeWidthFromDot(dot) {
  var props = svgPropertiesNoEventsFromUnknown(dot);
  var defaultR = 3;
  var defaultStrokeWidth = 2;
  if (props != null) {
    var {
      r: r2,
      strokeWidth
    } = props;
    var realR = Number(r2);
    var realStrokeWidth = Number(strokeWidth);
    if (Number.isNaN(realR) || realR < 0) {
      realR = defaultR;
    }
    if (Number.isNaN(realStrokeWidth) || realStrokeWidth < 0) {
      realStrokeWidth = defaultStrokeWidth;
    }
    return {
      r: realR,
      strokeWidth: realStrokeWidth
    };
  }
  return {
    r: defaultR,
    strokeWidth: defaultStrokeWidth
  };
}
var _excluded$5 = ["id"], _excluded2$2 = ["type", "layout", "connectNulls", "needClip"], _excluded3$2 = ["activeDot", "animateNewValues", "animationBegin", "animationDuration", "animationEasing", "connectNulls", "dot", "hide", "isAnimationActive", "label", "legendType", "xAxisId", "yAxisId", "id"];
function ownKeys$1(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread$1(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$1(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty$1(e3, r2, t2) {
  return (r2 = _toPropertyKey$1(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey$1(t2) {
  var i2 = _toPrimitive$1(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive$1(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$5(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$5(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$5(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function _extends$6() {
  return _extends$6 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$6.apply(null, arguments);
}
var computeLegendPayloadFromAreaData = (props) => {
  var {
    dataKey,
    name,
    stroke,
    legendType,
    hide
  } = props;
  return [{
    inactive: hide,
    dataKey,
    type: legendType,
    color: stroke,
    value: getTooltipNameProp(name, dataKey),
    payload: props
  }];
};
function getTooltipEntrySettings(props) {
  var {
    dataKey,
    data,
    stroke,
    strokeWidth,
    fill,
    name,
    hide,
    unit: unit2
  } = props;
  return {
    dataDefinedOnItem: data,
    positions: void 0,
    settings: {
      stroke,
      strokeWidth,
      fill,
      dataKey,
      nameKey: void 0,
      name: getTooltipNameProp(name, dataKey),
      hide,
      type: props.tooltipType,
      color: props.stroke,
      unit: unit2
    }
  };
}
var generateSimpleStrokeDasharray = (totalLength, length) => {
  return "".concat(length, "px ").concat(totalLength - length, "px");
};
function repeat(lines, count) {
  var linesUnit = lines.length % 2 !== 0 ? [...lines, 0] : lines;
  var result = [];
  for (var i2 = 0; i2 < count; ++i2) {
    result = [...result, ...linesUnit];
  }
  return result;
}
var getStrokeDasharray = (length, totalLength, lines) => {
  var lineLength = lines.reduce((pre, next) => pre + next);
  if (!lineLength) {
    return generateSimpleStrokeDasharray(totalLength, length);
  }
  var count = Math.floor(length / lineLength);
  var remainLength = length % lineLength;
  var restLength = totalLength - length;
  var remainLines = [];
  for (var i2 = 0, sum = 0; i2 < lines.length; sum += lines[i2], ++i2) {
    if (sum + lines[i2] > remainLength) {
      remainLines = [...lines.slice(0, i2), remainLength - sum];
      break;
    }
  }
  var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];
  return [...repeat(lines, count), ...remainLines, ...emptyLines].map((line) => "".concat(line, "px")).join(", ");
};
function renderDotItem(option, props) {
  var dotItem;
  if (/* @__PURE__ */ reactExports.isValidElement(option)) {
    dotItem = /* @__PURE__ */ reactExports.cloneElement(option, props);
  } else if (typeof option === "function") {
    dotItem = option(props);
  } else {
    var className = clsx("recharts-line-dot", typeof option !== "boolean" ? option.className : "");
    dotItem = /* @__PURE__ */ reactExports.createElement(Dot, _extends$6({}, props, {
      className
    }));
  }
  return dotItem;
}
function shouldRenderDots(points, dot) {
  if (points == null) {
    return false;
  }
  if (dot) {
    return true;
  }
  return points.length === 1;
}
function Dots(_ref2) {
  var {
    clipPathId,
    points,
    props
  } = _ref2;
  var {
    dot,
    dataKey,
    needClip
  } = props;
  if (!shouldRenderDots(points, dot)) {
    return null;
  }
  var {
    id
  } = props, propsWithoutId = _objectWithoutProperties$5(props, _excluded$5);
  var clipDot = isClipDot(dot);
  var lineProps = svgPropertiesNoEvents(propsWithoutId);
  var customDotProps = svgPropertiesAndEventsFromUnknown(dot);
  var dots = points.map((entry, i2) => {
    var dotProps = _objectSpread$1(_objectSpread$1(_objectSpread$1({
      key: "dot-".concat(i2),
      r: 3
    }, lineProps), customDotProps), {}, {
      index: i2,
      cx: entry.x,
      cy: entry.y,
      dataKey,
      value: entry.value,
      payload: entry.payload,
      // @ts-expect-error we're passing extra property 'points' that the props are not expecting
      points
    });
    return renderDotItem(dot, dotProps);
  });
  var dotsProps = {
    clipPath: needClip ? "url(#clipPath-".concat(clipDot ? "" : "dots-").concat(clipPathId, ")") : void 0
  };
  return /* @__PURE__ */ reactExports.createElement(Layer, _extends$6({
    className: "recharts-line-dots",
    key: "dots"
  }, dotsProps), dots);
}
function LineLabelListProvider(_ref2) {
  var {
    showLabels,
    children,
    points
  } = _ref2;
  var labelListEntries = reactExports.useMemo(() => {
    return points === null || points === void 0 ? void 0 : points.map((point2) => {
      var viewBox = {
        x: point2.x,
        y: point2.y,
        width: 0,
        height: 0
      };
      return _objectSpread$1(_objectSpread$1({}, viewBox), {}, {
        value: point2.value,
        payload: point2.payload,
        viewBox,
        /*
         * Line is not passing parentViewBox to the LabelList so the labels can escape - looks like a bug, should we pass parentViewBox?
         * Or should this just be the root chart viewBox?
         */
        parentViewBox: void 0,
        fill: void 0
      });
    });
  }, [points]);
  return /* @__PURE__ */ reactExports.createElement(CartesianLabelListContextProvider, {
    value: showLabels ? labelListEntries : null
  }, children);
}
function StaticCurve(_ref3) {
  var {
    clipPathId,
    pathRef,
    points,
    strokeDasharray,
    props
  } = _ref3;
  var {
    type,
    layout,
    connectNulls,
    needClip
  } = props, others = _objectWithoutProperties$5(props, _excluded2$2);
  var curveProps = _objectSpread$1(_objectSpread$1({}, svgPropertiesAndEvents(others)), {}, {
    fill: "none",
    className: "recharts-line-curve",
    clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : void 0,
    points,
    type,
    layout,
    connectNulls,
    strokeDasharray: strokeDasharray !== null && strokeDasharray !== void 0 ? strokeDasharray : props.strokeDasharray
  });
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /* @__PURE__ */ reactExports.createElement(Curve, _extends$6({}, curveProps, {
    pathRef
  })), /* @__PURE__ */ reactExports.createElement(Dots, {
    points,
    clipPathId,
    props
  }));
}
function getTotalLength(mainCurve) {
  try {
    return mainCurve && mainCurve.getTotalLength && mainCurve.getTotalLength() || 0;
  } catch (_unused) {
    return 0;
  }
}
function CurveWithAnimation(_ref4) {
  var {
    clipPathId,
    props,
    pathRef,
    previousPointsRef,
    longestAnimatedLengthRef
  } = _ref4;
  var {
    points,
    strokeDasharray,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing,
    animateNewValues,
    width,
    height,
    onAnimationEnd,
    onAnimationStart
  } = props;
  var prevPoints = previousPointsRef.current;
  var animationId = useAnimationId(props, "recharts-line-");
  var [isAnimating, setIsAnimating] = reactExports.useState(false);
  var showLabels = !isAnimating;
  var handleAnimationEnd = reactExports.useCallback(() => {
    if (typeof onAnimationEnd === "function") {
      onAnimationEnd();
    }
    setIsAnimating(false);
  }, [onAnimationEnd]);
  var handleAnimationStart = reactExports.useCallback(() => {
    if (typeof onAnimationStart === "function") {
      onAnimationStart();
    }
    setIsAnimating(true);
  }, [onAnimationStart]);
  var totalLength = getTotalLength(pathRef.current);
  var startingPoint = longestAnimatedLengthRef.current;
  return /* @__PURE__ */ reactExports.createElement(LineLabelListProvider, {
    points,
    showLabels
  }, props.children, /* @__PURE__ */ reactExports.createElement(JavascriptAnimate, {
    animationId,
    begin: animationBegin,
    duration: animationDuration,
    isActive: isAnimationActive,
    easing: animationEasing,
    onAnimationEnd: handleAnimationEnd,
    onAnimationStart: handleAnimationStart,
    key: animationId
  }, (t2) => {
    var lengthInterpolated = interpolate$1(startingPoint, totalLength + startingPoint, t2);
    var curLength = Math.min(lengthInterpolated, totalLength);
    var currentStrokeDasharray;
    if (isAnimationActive) {
      if (strokeDasharray) {
        var lines = "".concat(strokeDasharray).split(/[,\s]+/gim).map((num) => parseFloat(num));
        currentStrokeDasharray = getStrokeDasharray(curLength, totalLength, lines);
      } else {
        currentStrokeDasharray = generateSimpleStrokeDasharray(totalLength, curLength);
      }
    } else {
      currentStrokeDasharray = strokeDasharray == null ? void 0 : String(strokeDasharray);
    }
    if (prevPoints) {
      var prevPointsDiffFactor = prevPoints.length / points.length;
      var stepData = t2 === 1 ? points : points.map((entry, index) => {
        var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
        if (prevPoints[prevPointIndex]) {
          var prev = prevPoints[prevPointIndex];
          return _objectSpread$1(_objectSpread$1({}, entry), {}, {
            x: interpolate$1(prev.x, entry.x, t2),
            y: interpolate$1(prev.y, entry.y, t2)
          });
        }
        if (animateNewValues) {
          return _objectSpread$1(_objectSpread$1({}, entry), {}, {
            x: interpolate$1(width * 2, entry.x, t2),
            y: interpolate$1(height / 2, entry.y, t2)
          });
        }
        return _objectSpread$1(_objectSpread$1({}, entry), {}, {
          x: entry.x,
          y: entry.y
        });
      });
      previousPointsRef.current = stepData;
      return /* @__PURE__ */ reactExports.createElement(StaticCurve, {
        props,
        points: stepData,
        clipPathId,
        pathRef,
        strokeDasharray: currentStrokeDasharray
      });
    }
    if (t2 > 0 && totalLength > 0) {
      previousPointsRef.current = points;
      longestAnimatedLengthRef.current = curLength;
    }
    return /* @__PURE__ */ reactExports.createElement(StaticCurve, {
      props,
      points,
      clipPathId,
      pathRef,
      strokeDasharray: currentStrokeDasharray
    });
  }), /* @__PURE__ */ reactExports.createElement(LabelListFromLabelProp, {
    label: props.label
  }));
}
function RenderCurve(_ref5) {
  var {
    clipPathId,
    props
  } = _ref5;
  var previousPointsRef = reactExports.useRef(null);
  var longestAnimatedLengthRef = reactExports.useRef(0);
  var pathRef = reactExports.useRef(null);
  return /* @__PURE__ */ reactExports.createElement(CurveWithAnimation, {
    props,
    clipPathId,
    previousPointsRef,
    longestAnimatedLengthRef,
    pathRef
  });
}
var errorBarDataPointFormatter = (dataPoint, dataKey) => {
  return {
    x: dataPoint.x,
    y: dataPoint.y,
    value: dataPoint.value,
    // @ts-expect-error getValueByDataKey does not validate the output type
    errorVal: getValueByDataKey(dataPoint.payload, dataKey)
  };
};
class LineWithState extends reactExports.Component {
  render() {
    var {
      hide,
      dot,
      points,
      className,
      xAxisId,
      yAxisId,
      top,
      left,
      width,
      height,
      id,
      needClip
    } = this.props;
    if (hide) {
      return null;
    }
    var layerClass = clsx("recharts-line", className);
    var clipPathId = id;
    var {
      r: r2,
      strokeWidth
    } = getRadiusAndStrokeWidthFromDot(dot);
    var clipDot = isClipDot(dot);
    var dotSize = r2 * 2 + strokeWidth;
    return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Layer, {
      className: layerClass
    }, needClip && /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement(GraphicalItemClipPath, {
      clipPathId,
      xAxisId,
      yAxisId
    }), !clipDot && /* @__PURE__ */ reactExports.createElement("clipPath", {
      id: "clipPath-dots-".concat(clipPathId)
    }, /* @__PURE__ */ reactExports.createElement("rect", {
      x: left - dotSize / 2,
      y: top - dotSize / 2,
      width: width + dotSize,
      height: height + dotSize
    }))), /* @__PURE__ */ reactExports.createElement(SetErrorBarContext, {
      xAxisId,
      yAxisId,
      data: points,
      dataPointFormatter: errorBarDataPointFormatter,
      errorBarOffset: 0
    }, /* @__PURE__ */ reactExports.createElement(RenderCurve, {
      props: this.props,
      clipPathId
    }))), /* @__PURE__ */ reactExports.createElement(ActivePoints, {
      activeDot: this.props.activeDot,
      points,
      mainColor: this.props.stroke,
      itemDataKey: this.props.dataKey
    }));
  }
}
var defaultLineProps = {
  activeDot: true,
  animateNewValues: true,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease",
  connectNulls: false,
  dot: true,
  fill: "#fff",
  hide: false,
  isAnimationActive: !Global.isSsr,
  label: false,
  legendType: "line",
  stroke: "#3182bd",
  strokeWidth: 1,
  xAxisId: 0,
  yAxisId: 0
};
function LineImpl(props) {
  var _resolveDefaultProps = resolveDefaultProps(props, defaultLineProps), {
    activeDot,
    animateNewValues,
    animationBegin,
    animationDuration,
    animationEasing,
    connectNulls,
    dot,
    hide,
    isAnimationActive,
    label,
    legendType,
    xAxisId,
    yAxisId,
    id
  } = _resolveDefaultProps, everythingElse = _objectWithoutProperties$5(_resolveDefaultProps, _excluded3$2);
  var {
    needClip
  } = useNeedsClip(xAxisId, yAxisId);
  var plotArea = usePlotArea();
  var layout = useChartLayout();
  var isPanorama = useIsPanorama();
  var points = useAppSelector((state) => selectLinePoints(state, xAxisId, yAxisId, isPanorama, id));
  if (layout !== "horizontal" && layout !== "vertical" || points == null || plotArea == null) {
    return null;
  }
  var {
    height,
    width,
    x: left,
    y: top
  } = plotArea;
  return /* @__PURE__ */ reactExports.createElement(LineWithState, _extends$6({}, everythingElse, {
    id,
    connectNulls,
    dot,
    activeDot,
    animateNewValues,
    animationBegin,
    animationDuration,
    animationEasing,
    isAnimationActive,
    hide,
    label,
    legendType,
    xAxisId,
    yAxisId,
    points,
    layout,
    height,
    width,
    left,
    top,
    needClip
  }));
}
function computeLinePoints(_ref6) {
  var {
    layout,
    xAxis,
    yAxis,
    xAxisTicks,
    yAxisTicks,
    dataKey,
    bandSize,
    displayedData
  } = _ref6;
  return displayedData.map((entry, index) => {
    var value = getValueByDataKey(entry, dataKey);
    if (layout === "horizontal") {
      var _x = getCateCoordinateOfLine({
        axis: xAxis,
        ticks: xAxisTicks,
        bandSize,
        entry,
        index
      });
      var _y = isNullish(value) ? null : yAxis.scale(value);
      return {
        x: _x,
        y: _y,
        value,
        payload: entry
      };
    }
    var x2 = isNullish(value) ? null : xAxis.scale(value);
    var y2 = getCateCoordinateOfLine({
      axis: yAxis,
      ticks: yAxisTicks,
      bandSize,
      entry,
      index
    });
    if (x2 == null || y2 == null) {
      return null;
    }
    return {
      x: x2,
      y: y2,
      value,
      payload: entry
    };
  }).filter(Boolean);
}
function LineFn(outsideProps) {
  var props = resolveDefaultProps(outsideProps, defaultLineProps);
  var isPanorama = useIsPanorama();
  return /* @__PURE__ */ reactExports.createElement(RegisterGraphicalItemId, {
    id: props.id,
    type: "line"
  }, (id) => /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(SetLegendPayload, {
    legendPayload: computeLegendPayloadFromAreaData(props)
  }), /* @__PURE__ */ reactExports.createElement(SetTooltipEntrySettings, {
    fn: getTooltipEntrySettings,
    args: props
  }), /* @__PURE__ */ reactExports.createElement(SetCartesianGraphicalItem, {
    type: "line",
    id,
    data: props.data,
    xAxisId: props.xAxisId,
    yAxisId: props.yAxisId,
    zAxisId: 0,
    dataKey: props.dataKey,
    hide: props.hide,
    isPanorama
  }), /* @__PURE__ */ reactExports.createElement(LineImpl, _extends$6({}, props, {
    id
  }))));
}
var Line = /* @__PURE__ */ reactExports.memo(LineFn);
Line.displayName = "Line";
var _excluded$4 = ["dangerouslySetInnerHTML", "ticks"], _excluded2$1 = ["id"], _excluded3$1 = ["domain"], _excluded4$1 = ["domain"];
function _extends$5() {
  return _extends$5 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$5.apply(null, arguments);
}
function _objectWithoutProperties$4(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$4(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$4(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function SetXAxisSettings(settings) {
  var dispatch = useAppDispatch();
  reactExports.useLayoutEffect(() => {
    dispatch(addXAxis(settings));
    return () => {
      dispatch(removeXAxis(settings));
    };
  }, [settings, dispatch]);
  return null;
}
var XAxisImpl = (props) => {
  var {
    xAxisId,
    className
  } = props;
  var viewBox = useAppSelector(selectAxisViewBox);
  var isPanorama = useIsPanorama();
  var axisType = "xAxis";
  var scale = useAppSelector((state) => selectAxisScale(state, axisType, xAxisId, isPanorama));
  var cartesianTickItems = useAppSelector((state) => selectTicksOfAxis(state, axisType, xAxisId, isPanorama));
  var axisSize = useAppSelector((state) => selectXAxisSize(state, xAxisId));
  var position = useAppSelector((state) => selectXAxisPosition(state, xAxisId));
  var synchronizedSettings = useAppSelector((state) => selectXAxisSettingsNoDefaults(state, xAxisId));
  if (axisSize == null || position == null || synchronizedSettings == null) {
    return null;
  }
  var {
    dangerouslySetInnerHTML,
    ticks: ticks2
  } = props, allOtherProps = _objectWithoutProperties$4(props, _excluded$4);
  var {
    id
  } = synchronizedSettings, restSynchronizedSettings = _objectWithoutProperties$4(synchronizedSettings, _excluded2$1);
  return /* @__PURE__ */ reactExports.createElement(CartesianAxis, _extends$5({}, allOtherProps, restSynchronizedSettings, {
    scale,
    x: position.x,
    y: position.y,
    width: axisSize.width,
    height: axisSize.height,
    className: clsx("recharts-".concat(axisType, " ").concat(axisType), className),
    viewBox,
    ticks: cartesianTickItems
  }));
};
var xAxisDefaultProps = {
  allowDataOverflow: implicitXAxis.allowDataOverflow,
  allowDecimals: implicitXAxis.allowDecimals,
  allowDuplicatedCategory: implicitXAxis.allowDuplicatedCategory,
  height: implicitXAxis.height,
  hide: false,
  mirror: implicitXAxis.mirror,
  orientation: implicitXAxis.orientation,
  padding: implicitXAxis.padding,
  reversed: implicitXAxis.reversed,
  scale: implicitXAxis.scale,
  tickCount: implicitXAxis.tickCount,
  type: implicitXAxis.type,
  xAxisId: 0
};
var XAxisSettingsDispatcher = (outsideProps) => {
  var _props$interval, _props$includeHidden, _props$angle, _props$minTickGap, _props$tick;
  var props = resolveDefaultProps(outsideProps, xAxisDefaultProps);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(SetXAxisSettings, {
    interval: (_props$interval = props.interval) !== null && _props$interval !== void 0 ? _props$interval : "preserveEnd",
    id: props.xAxisId,
    scale: props.scale,
    type: props.type,
    padding: props.padding,
    allowDataOverflow: props.allowDataOverflow,
    domain: props.domain,
    dataKey: props.dataKey,
    allowDuplicatedCategory: props.allowDuplicatedCategory,
    allowDecimals: props.allowDecimals,
    tickCount: props.tickCount,
    includeHidden: (_props$includeHidden = props.includeHidden) !== null && _props$includeHidden !== void 0 ? _props$includeHidden : false,
    reversed: props.reversed,
    ticks: props.ticks,
    height: props.height,
    orientation: props.orientation,
    mirror: props.mirror,
    hide: props.hide,
    unit: props.unit,
    name: props.name,
    angle: (_props$angle = props.angle) !== null && _props$angle !== void 0 ? _props$angle : 0,
    minTickGap: (_props$minTickGap = props.minTickGap) !== null && _props$minTickGap !== void 0 ? _props$minTickGap : 5,
    tick: (_props$tick = props.tick) !== null && _props$tick !== void 0 ? _props$tick : true,
    tickFormatter: props.tickFormatter
  }), /* @__PURE__ */ reactExports.createElement(XAxisImpl, props));
};
var XAxisMemoComparator = (prevProps, nextProps) => {
  var {
    domain: prevDomain
  } = prevProps, prevRest = _objectWithoutProperties$4(prevProps, _excluded3$1);
  var {
    domain: nextDomain
  } = nextProps, nextRest = _objectWithoutProperties$4(nextProps, _excluded4$1);
  if (!shallowEqual(prevRest, nextRest)) {
    return false;
  }
  if (Array.isArray(prevDomain) && prevDomain.length === 2 && Array.isArray(nextDomain) && nextDomain.length === 2) {
    return prevDomain[0] === nextDomain[0] && prevDomain[1] === nextDomain[1];
  }
  return shallowEqual({
    domain: prevDomain
  }, {
    domain: nextDomain
  });
};
var XAxis = /* @__PURE__ */ reactExports.memo(XAxisSettingsDispatcher, XAxisMemoComparator);
XAxis.displayName = "XAxis";
var _excluded$3 = ["dangerouslySetInnerHTML", "ticks"], _excluded2 = ["id"], _excluded3 = ["domain"], _excluded4 = ["domain"];
function _extends$4() {
  return _extends$4 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$4.apply(null, arguments);
}
function _objectWithoutProperties$3(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$3(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$3(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function SetYAxisSettings(settings) {
  var dispatch = useAppDispatch();
  reactExports.useLayoutEffect(() => {
    dispatch(addYAxis(settings));
    return () => {
      dispatch(removeYAxis(settings));
    };
  }, [settings, dispatch]);
  return null;
}
var YAxisImpl = (props) => {
  var {
    yAxisId,
    className,
    width,
    label
  } = props;
  var cartesianAxisRef = reactExports.useRef(null);
  var labelRef = reactExports.useRef(null);
  var viewBox = useAppSelector(selectAxisViewBox);
  var isPanorama = useIsPanorama();
  var dispatch = useAppDispatch();
  var axisType = "yAxis";
  var scale = useAppSelector((state) => selectAxisScale(state, axisType, yAxisId, isPanorama));
  var axisSize = useAppSelector((state) => selectYAxisSize(state, yAxisId));
  var position = useAppSelector((state) => selectYAxisPosition(state, yAxisId));
  var cartesianTickItems = useAppSelector((state) => selectTicksOfAxis(state, axisType, yAxisId, isPanorama));
  var synchronizedSettings = useAppSelector((state) => selectYAxisSettingsNoDefaults(state, yAxisId));
  reactExports.useLayoutEffect(() => {
    if (width !== "auto" || !axisSize || isLabelContentAFunction(label) || /* @__PURE__ */ reactExports.isValidElement(label) || synchronizedSettings == null) {
      return;
    }
    var axisComponent = cartesianAxisRef.current;
    if (!axisComponent) {
      return;
    }
    var updatedYAxisWidth = axisComponent.getCalculatedWidth();
    if (Math.round(axisSize.width) !== Math.round(updatedYAxisWidth)) {
      dispatch(updateYAxisWidth({
        id: yAxisId,
        width: updatedYAxisWidth
      }));
    }
  }, [
    // The dependency on cartesianAxisRef.current is not needed because useLayoutEffect will run after every render.
    // The ref will be populated by then.
    // To re-run this effect when ticks change, we can depend on the ticks array from the store.
    cartesianTickItems,
    axisSize,
    dispatch,
    label,
    yAxisId,
    width,
    synchronizedSettings
  ]);
  if (axisSize == null || position == null || synchronizedSettings == null) {
    return null;
  }
  var {
    dangerouslySetInnerHTML,
    ticks: ticks2
  } = props, allOtherProps = _objectWithoutProperties$3(props, _excluded$3);
  var {
    id
  } = synchronizedSettings, restSynchronizedSettings = _objectWithoutProperties$3(synchronizedSettings, _excluded2);
  return /* @__PURE__ */ reactExports.createElement(CartesianAxis, _extends$4({}, allOtherProps, restSynchronizedSettings, {
    ref: cartesianAxisRef,
    labelRef,
    scale,
    x: position.x,
    y: position.y,
    tickTextProps: width === "auto" ? {
      width: void 0
    } : {
      width
    },
    width: axisSize.width,
    height: axisSize.height,
    className: clsx("recharts-".concat(axisType, " ").concat(axisType), className),
    viewBox,
    ticks: cartesianTickItems
  }));
};
var yAxisDefaultProps = {
  allowDataOverflow: implicitYAxis.allowDataOverflow,
  allowDecimals: implicitYAxis.allowDecimals,
  allowDuplicatedCategory: implicitYAxis.allowDuplicatedCategory,
  hide: false,
  mirror: implicitYAxis.mirror,
  orientation: implicitYAxis.orientation,
  padding: implicitYAxis.padding,
  reversed: implicitYAxis.reversed,
  scale: implicitYAxis.scale,
  tickCount: implicitYAxis.tickCount,
  type: implicitYAxis.type,
  width: implicitYAxis.width,
  yAxisId: 0
};
var YAxisSettingsDispatcher = (outsideProps) => {
  var _props$interval, _props$includeHidden, _props$angle, _props$minTickGap, _props$tick;
  var props = resolveDefaultProps(outsideProps, yAxisDefaultProps);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(SetYAxisSettings, {
    interval: (_props$interval = props.interval) !== null && _props$interval !== void 0 ? _props$interval : "preserveEnd",
    id: props.yAxisId,
    scale: props.scale,
    type: props.type,
    domain: props.domain,
    allowDataOverflow: props.allowDataOverflow,
    dataKey: props.dataKey,
    allowDuplicatedCategory: props.allowDuplicatedCategory,
    allowDecimals: props.allowDecimals,
    tickCount: props.tickCount,
    padding: props.padding,
    includeHidden: (_props$includeHidden = props.includeHidden) !== null && _props$includeHidden !== void 0 ? _props$includeHidden : false,
    reversed: props.reversed,
    ticks: props.ticks,
    width: props.width,
    orientation: props.orientation,
    mirror: props.mirror,
    hide: props.hide,
    unit: props.unit,
    name: props.name,
    angle: (_props$angle = props.angle) !== null && _props$angle !== void 0 ? _props$angle : 0,
    minTickGap: (_props$minTickGap = props.minTickGap) !== null && _props$minTickGap !== void 0 ? _props$minTickGap : 5,
    tick: (_props$tick = props.tick) !== null && _props$tick !== void 0 ? _props$tick : true,
    tickFormatter: props.tickFormatter
  }), /* @__PURE__ */ reactExports.createElement(YAxisImpl, props));
};
var YAxisMemoComparator = (prevProps, nextProps) => {
  var {
    domain: prevDomain
  } = prevProps, prevRest = _objectWithoutProperties$3(prevProps, _excluded3);
  var {
    domain: nextDomain
  } = nextProps, nextRest = _objectWithoutProperties$3(nextProps, _excluded4);
  if (!shallowEqual(prevRest, nextRest)) {
    return false;
  }
  if (Array.isArray(prevDomain) && prevDomain.length === 2 && Array.isArray(nextDomain) && nextDomain.length === 2) {
    return prevDomain[0] === nextDomain[0] && prevDomain[1] === nextDomain[1];
  }
  return shallowEqual({
    domain: prevDomain
  }, {
    domain: nextDomain
  });
};
var YAxis = /* @__PURE__ */ reactExports.memo(YAxisSettingsDispatcher, YAxisMemoComparator);
YAxis.displayName = "YAxis";
var withSelector = { exports: {} };
var useSyncExternalStoreWithSelector_production = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreWithSelector_production;
function requireUseSyncExternalStoreWithSelector_production() {
  if (hasRequiredUseSyncExternalStoreWithSelector_production) return useSyncExternalStoreWithSelector_production;
  hasRequiredUseSyncExternalStoreWithSelector_production = 1;
  var React2 = requireReact();
  function is2(x2, y2) {
    return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore = React2.useSyncExternalStore, useRef = React2.useRef, useEffect = React2.useEffect, useMemo = React2.useMemo, useDebugValue = React2.useDebugValue;
  useSyncExternalStoreWithSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef(null);
    if (null === instRef.current) {
      var inst = { hasValue: false, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            hasMemo = true;
            memoizedSnapshot = nextSnapshot;
            nextSnapshot = selector(nextSnapshot);
            if (void 0 !== isEqual && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          currentSelection = memoizedSelection;
          if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
            return memoizedSnapshot = nextSnapshot, currentSelection;
          memoizedSnapshot = nextSnapshot;
          return memoizedSelection = nextSelection;
        }
        var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          null === maybeGetServerSnapshot ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector, isEqual]
    );
    var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    useEffect(
      function() {
        inst.hasValue = true;
        inst.value = value;
      },
      [value]
    );
    useDebugValue(value);
    return value;
  };
  return useSyncExternalStoreWithSelector_production;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  if (hasRequiredWithSelector) return withSelector.exports;
  hasRequiredWithSelector = 1;
  {
    withSelector.exports = requireUseSyncExternalStoreWithSelector_production();
  }
  return withSelector.exports;
}
requireWithSelector();
function defaultNoopBatch(callback) {
  callback();
}
function createListenerCollection() {
  let first = null;
  let last2 = null;
  return {
    clear() {
      first = null;
      last2 = null;
    },
    notify() {
      defaultNoopBatch(() => {
        let listener2 = first;
        while (listener2) {
          listener2.callback();
          listener2 = listener2.next;
        }
      });
    },
    get() {
      const listeners = [];
      let listener2 = first;
      while (listener2) {
        listeners.push(listener2);
        listener2 = listener2.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      const listener2 = last2 = {
        callback,
        next: null,
        prev: last2
      };
      if (listener2.prev) {
        listener2.prev.next = listener2;
      } else {
        first = listener2;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;
        if (listener2.next) {
          listener2.next.prev = listener2.prev;
        } else {
          last2 = listener2.prev;
        }
        if (listener2.prev) {
          listener2.prev.next = listener2.next;
        } else {
          first = listener2.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener2) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener2);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}
var canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = /* @__PURE__ */ canUseDOM();
var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = /* @__PURE__ */ isRunningInReactNative();
var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? reactExports.useLayoutEffect : reactExports.useEffect;
var useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
var ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);
var gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  if (!reactExports.createContext) return {};
  const contextMap = gT[ContextKey] ??= /* @__PURE__ */ new Map();
  let realContext = contextMap.get(reactExports.createContext);
  if (!realContext) {
    realContext = reactExports.createContext(
      null
    );
    contextMap.set(reactExports.createContext, realContext);
  }
  return realContext;
}
var ReactReduxContext = /* @__PURE__ */ getContext();
function Provider(providerProps) {
  const { children, context, serverState, store } = providerProps;
  const contextValue = reactExports.useMemo(() => {
    const subscription = createSubscription(store);
    const baseContextValue = {
      store,
      subscription,
      getServerState: serverState ? () => serverState : void 0
    };
    {
      return baseContextValue;
    }
  }, [store, serverState]);
  const previousState = reactExports.useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect(() => {
    const { subscription } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context || ReactReduxContext;
  return /* @__PURE__ */ reactExports.createElement(Context.Provider, { value: contextValue }, children);
}
var Provider_default = Provider;
var pickChartPointer = (_state, chartPointer) => chartPointer;
var selectActivePropsFromChartPointer = createSelector([pickChartPointer, selectChartLayout, selectPolarViewBox, selectTooltipAxisType, selectTooltipAxisRangeWithReverse, selectTooltipAxisTicks, selectOrderedTooltipTicks, selectChartOffsetInternal], combineActiveProps);
var getChartPointer = (event) => {
  var rect = event.currentTarget.getBoundingClientRect();
  var scaleX = rect.width / event.currentTarget.offsetWidth;
  var scaleY = rect.height / event.currentTarget.offsetHeight;
  return {
    /*
     * Here it's important to use:
     * - event.clientX and event.clientY to get the mouse position relative to the viewport, including scroll.
     * - pageX and pageY are not used because they are relative to the whole document, and ignore scroll.
     * - rect.left and rect.top are used to get the position of the chart relative to the viewport.
     * - offsetX and offsetY are not used because they are relative to the offset parent
     *  which may or may not be the same as the clientX and clientY, depending on the position of the chart in the DOM
     *  and surrounding element styles. CSS position: relative, absolute, fixed, will change the offset parent.
     * - scaleX and scaleY are necessary for when the chart element is scaled using CSS `transform: scale(N)`.
     */
    chartX: Math.round((event.clientX - rect.left) / scaleX),
    chartY: Math.round((event.clientY - rect.top) / scaleY)
  };
};
var mouseClickAction = createAction("mouseClick");
var mouseClickMiddleware = createListenerMiddleware();
mouseClickMiddleware.startListening({
  actionCreator: mouseClickAction,
  effect: (action, listenerApi) => {
    var mousePointer = action.payload;
    var activeProps = selectActivePropsFromChartPointer(listenerApi.getState(), getChartPointer(mousePointer));
    if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) {
      listenerApi.dispatch(setMouseClickAxisIndex({
        activeIndex: activeProps.activeIndex,
        activeDataKey: void 0,
        activeCoordinate: activeProps.activeCoordinate
      }));
    }
  }
});
var mouseMoveAction = createAction("mouseMove");
var mouseMoveMiddleware = createListenerMiddleware();
mouseMoveMiddleware.startListening({
  actionCreator: mouseMoveAction,
  effect: (action, listenerApi) => {
    var mousePointer = action.payload;
    var state = listenerApi.getState();
    var tooltipEventType = selectTooltipEventType$1(state, state.tooltip.settings.shared);
    var activeProps = selectActivePropsFromChartPointer(state, getChartPointer(mousePointer));
    if (tooltipEventType === "axis") {
      if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) {
        listenerApi.dispatch(setMouseOverAxisIndex({
          activeIndex: activeProps.activeIndex,
          activeDataKey: void 0,
          activeCoordinate: activeProps.activeCoordinate
        }));
      } else {
        listenerApi.dispatch(mouseLeaveChart());
      }
    }
  }
});
var initialState = {
  accessibilityLayer: true,
  barCategoryGap: "10%",
  barGap: 4,
  barSize: void 0,
  className: void 0,
  maxBarSize: void 0,
  stackOffset: "none",
  syncId: void 0,
  syncMethod: "index"
};
var rootPropsSlice = createSlice({
  name: "rootProps",
  initialState,
  reducers: {
    updateOptions: (state, action) => {
      var _action$payload$barGa;
      state.accessibilityLayer = action.payload.accessibilityLayer;
      state.barCategoryGap = action.payload.barCategoryGap;
      state.barGap = (_action$payload$barGa = action.payload.barGap) !== null && _action$payload$barGa !== void 0 ? _action$payload$barGa : initialState.barGap;
      state.barSize = action.payload.barSize;
      state.maxBarSize = action.payload.maxBarSize;
      state.stackOffset = action.payload.stackOffset;
      state.syncId = action.payload.syncId;
      state.syncMethod = action.payload.syncMethod;
      state.className = action.payload.className;
    }
  }
});
var rootPropsReducer = rootPropsSlice.reducer;
var {
  updateOptions
} = rootPropsSlice.actions;
var polarOptionsSlice = createSlice({
  name: "polarOptions",
  initialState: null,
  reducers: {
    updatePolarOptions: (_state, action) => {
      return action.payload;
    }
  }
});
var {
  updatePolarOptions
} = polarOptionsSlice.actions;
var polarOptionsReducer = polarOptionsSlice.reducer;
var keyDownAction = createAction("keyDown");
var focusAction = createAction("focus");
var keyboardEventsMiddleware = createListenerMiddleware();
keyboardEventsMiddleware.startListening({
  actionCreator: keyDownAction,
  effect: (action, listenerApi) => {
    var state = listenerApi.getState();
    var accessibilityLayerIsActive = state.rootProps.accessibilityLayer !== false;
    if (!accessibilityLayerIsActive) {
      return;
    }
    var {
      keyboardInteraction
    } = state.tooltip;
    var key = action.payload;
    if (key !== "ArrowRight" && key !== "ArrowLeft" && key !== "Enter") {
      return;
    }
    var currentIndex = Number(combineActiveTooltipIndex(keyboardInteraction, selectTooltipDisplayedData(state)));
    var tooltipTicks = selectTooltipAxisTicks(state);
    if (key === "Enter") {
      var _coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(keyboardInteraction.index));
      listenerApi.dispatch(setKeyboardInteraction({
        active: !keyboardInteraction.active,
        activeIndex: keyboardInteraction.index,
        activeDataKey: keyboardInteraction.dataKey,
        activeCoordinate: _coordinate
      }));
      return;
    }
    var direction = selectChartDirection(state);
    var directionMultiplier = direction === "left-to-right" ? 1 : -1;
    var movement = key === "ArrowRight" ? 1 : -1;
    var nextIndex = currentIndex + movement * directionMultiplier;
    if (tooltipTicks == null || nextIndex >= tooltipTicks.length || nextIndex < 0) {
      return;
    }
    var coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(nextIndex));
    listenerApi.dispatch(setKeyboardInteraction({
      active: true,
      activeIndex: nextIndex.toString(),
      activeDataKey: void 0,
      activeCoordinate: coordinate
    }));
  }
});
keyboardEventsMiddleware.startListening({
  actionCreator: focusAction,
  effect: (_action, listenerApi) => {
    var state = listenerApi.getState();
    var accessibilityLayerIsActive = state.rootProps.accessibilityLayer !== false;
    if (!accessibilityLayerIsActive) {
      return;
    }
    var {
      keyboardInteraction
    } = state.tooltip;
    if (keyboardInteraction.active) {
      return;
    }
    if (keyboardInteraction.index == null) {
      var nextIndex = "0";
      var coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(nextIndex));
      listenerApi.dispatch(setKeyboardInteraction({
        activeDataKey: void 0,
        active: true,
        activeIndex: nextIndex,
        activeCoordinate: coordinate
      }));
    }
  }
});
var externalEventAction = createAction("externalEvent");
var externalEventsMiddleware = createListenerMiddleware();
externalEventsMiddleware.startListening({
  actionCreator: externalEventAction,
  effect: (action, listenerApi) => {
    if (action.payload.handler == null) {
      return;
    }
    var state = listenerApi.getState();
    var nextState = {
      activeCoordinate: selectActiveTooltipCoordinate(state),
      activeDataKey: selectActiveTooltipDataKey(state),
      activeIndex: selectActiveTooltipIndex(state),
      activeLabel: selectActiveLabel$1(state),
      activeTooltipIndex: selectActiveTooltipIndex(state),
      isTooltipActive: selectIsTooltipActive$1(state)
    };
    action.payload.handler(nextState, action.payload.reactEvent);
  }
});
var selectAllTooltipPayloadConfiguration = createSelector([selectTooltipState], (tooltipState) => tooltipState.tooltipItemPayloads);
var selectTooltipCoordinate = createSelector([selectAllTooltipPayloadConfiguration, selectTooltipPayloadSearcher, (_state, tooltipIndex, _dataKey) => tooltipIndex, (_state, _tooltipIndex, dataKey) => dataKey], (allTooltipConfigurations, tooltipPayloadSearcher, tooltipIndex, dataKey) => {
  var mostRelevantTooltipConfiguration = allTooltipConfigurations.find((tooltipConfiguration) => {
    return tooltipConfiguration.settings.dataKey === dataKey;
  });
  if (mostRelevantTooltipConfiguration == null) {
    return void 0;
  }
  var {
    positions
  } = mostRelevantTooltipConfiguration;
  if (positions == null) {
    return void 0;
  }
  var maybePosition = tooltipPayloadSearcher(positions, tooltipIndex);
  return maybePosition;
});
var touchEventAction = createAction("touchMove");
var touchEventMiddleware = createListenerMiddleware();
touchEventMiddleware.startListening({
  actionCreator: touchEventAction,
  effect: (action, listenerApi) => {
    var touchEvent = action.payload;
    var state = listenerApi.getState();
    var tooltipEventType = selectTooltipEventType$1(state, state.tooltip.settings.shared);
    if (tooltipEventType === "axis") {
      var activeProps = selectActivePropsFromChartPointer(state, getChartPointer({
        clientX: touchEvent.touches[0].clientX,
        clientY: touchEvent.touches[0].clientY,
        currentTarget: touchEvent.currentTarget
      }));
      if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) {
        listenerApi.dispatch(setMouseOverAxisIndex({
          activeIndex: activeProps.activeIndex,
          activeDataKey: void 0,
          activeCoordinate: activeProps.activeCoordinate
        }));
      }
    } else if (tooltipEventType === "item") {
      var _target$getAttribute;
      var touch = touchEvent.touches[0];
      var target = document.elementFromPoint(touch.clientX, touch.clientY);
      if (!target || !target.getAttribute) {
        return;
      }
      var itemIndex = target.getAttribute(DATA_ITEM_INDEX_ATTRIBUTE_NAME);
      var dataKey = (_target$getAttribute = target.getAttribute(DATA_ITEM_DATAKEY_ATTRIBUTE_NAME)) !== null && _target$getAttribute !== void 0 ? _target$getAttribute : void 0;
      var coordinate = selectTooltipCoordinate(listenerApi.getState(), itemIndex, dataKey);
      listenerApi.dispatch(setActiveMouseOverItemIndex({
        activeDataKey: dataKey,
        activeIndex: itemIndex,
        activeCoordinate: coordinate
      }));
    }
  }
});
var rootReducer = combineReducers({
  brush: brushReducer,
  cartesianAxis: cartesianAxisReducer,
  chartData: chartDataReducer,
  errorBars: errorBarReducer,
  graphicalItems: graphicalItemsReducer,
  layout: chartLayoutReducer,
  legend: legendReducer,
  options: optionsReducer,
  polarAxis: polarAxisReducer,
  polarOptions: polarOptionsReducer,
  referenceElements: referenceElementsReducer,
  rootProps: rootPropsReducer,
  tooltip: tooltipReducer
});
var createRechartsStore = function createRechartsStore2(preloadedState) {
  return configureStore({
    reducer: rootReducer,
    // redux-toolkit v1 types are unhappy with the preloadedState type. Remove the `as any` when bumping to v2
    preloadedState,
    // @ts-expect-error redux-toolkit v1 types are unhappy with the middleware array. Remove this comment when bumping to v2
    middleware: (getDefaultMiddleware) => getDefaultMiddleware({
      serializableCheck: false
    }).concat([mouseClickMiddleware.middleware, mouseMoveMiddleware.middleware, keyboardEventsMiddleware.middleware, externalEventsMiddleware.middleware, touchEventMiddleware.middleware]),
    /*
     * I can't find out how to satisfy typescript here.
     * We return `EnhancerArray<[StoreEnhancer<{}, {}>, StoreEnhancer]>` from this function,
     * but the types say we should return `EnhancerArray<StoreEnhancer<{}, {}>`.
     * Looks like it's badly inferred generics, but it won't allow me to provide the correct type manually either.
     * So let's just ignore the error for now.
     */
    // @ts-expect-error mismatched generics
    enhancers: (getDefaultEnhancers) => {
      var enhancers = getDefaultEnhancers;
      if (typeof getDefaultEnhancers === "function") {
        enhancers = getDefaultEnhancers();
      }
      return enhancers.concat(autoBatchEnhancer({
        type: "raf"
      }));
    },
    devTools: Global.devToolsEnabled
  });
};
function RechartsStoreProvider(_ref2) {
  var {
    preloadedState,
    children,
    reduxStoreName
  } = _ref2;
  var isPanorama = useIsPanorama();
  var storeRef = reactExports.useRef(null);
  if (isPanorama) {
    return children;
  }
  if (storeRef.current == null) {
    storeRef.current = createRechartsStore(preloadedState);
  }
  var nonNullContext = RechartsReduxContext;
  return /* @__PURE__ */ reactExports.createElement(Provider_default, {
    context: nonNullContext,
    store: storeRef.current
  }, children);
}
function ReportMainChartProps(_ref2) {
  var {
    layout,
    margin
  } = _ref2;
  var dispatch = useAppDispatch();
  var isPanorama = useIsPanorama();
  reactExports.useEffect(() => {
    if (!isPanorama) {
      dispatch(setLayout(layout));
      dispatch(setMargin(margin));
    }
  }, [dispatch, isPanorama, layout, margin]);
  return null;
}
function ReportChartProps(props) {
  var dispatch = useAppDispatch();
  reactExports.useEffect(() => {
    dispatch(updateOptions(props));
  }, [dispatch, props]);
  return null;
}
var _excluded$2 = ["children"];
function _objectWithoutProperties$2(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$2(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$2(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function _extends$3() {
  return _extends$3 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$3.apply(null, arguments);
}
var FULL_WIDTH_AND_HEIGHT = {
  width: "100%",
  height: "100%",
  /*
   * display: block is necessary here because the default for an SVG is display: inline,
   * which in some browsers (Chrome) adds a little bit of extra space above and below the SVG
   * to make space for the descender of letters like "g" and "y". This throws off the height calculation
   * and causes the container to grow indefinitely on each render with responsive=true.
   * Display: block removes that extra space.
   *
   * Interestingly, Firefox does not have this problem, but it doesn't hurt to add the style anyway.
   */
  display: "block"
};
var MainChartSurface = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  var width = useChartWidth();
  var height = useChartHeight();
  var hasAccessibilityLayer = useAccessibilityLayer();
  if (!isPositiveNumber(width) || !isPositiveNumber(height)) {
    return null;
  }
  var {
    children,
    otherAttributes,
    title,
    desc
  } = props;
  var tabIndex, role;
  if (typeof otherAttributes.tabIndex === "number") {
    tabIndex = otherAttributes.tabIndex;
  } else {
    tabIndex = hasAccessibilityLayer ? 0 : void 0;
  }
  if (typeof otherAttributes.role === "string") {
    role = otherAttributes.role;
  } else {
    role = hasAccessibilityLayer ? "application" : void 0;
  }
  return /* @__PURE__ */ reactExports.createElement(Surface, _extends$3({}, otherAttributes, {
    title,
    desc,
    role,
    tabIndex,
    width,
    height,
    style: FULL_WIDTH_AND_HEIGHT,
    ref
  }), children);
});
var BrushPanoramaSurface = (_ref2) => {
  var {
    children
  } = _ref2;
  var brushDimensions = useAppSelector(selectBrushDimensions);
  if (!brushDimensions) {
    return null;
  }
  var {
    width,
    height,
    y: y2,
    x: x2
  } = brushDimensions;
  return /* @__PURE__ */ reactExports.createElement(Surface, {
    width,
    height,
    x: x2,
    y: y2
  }, children);
};
var RootSurface = /* @__PURE__ */ reactExports.forwardRef((_ref2, ref) => {
  var {
    children
  } = _ref2, rest = _objectWithoutProperties$2(_ref2, _excluded$2);
  var isPanorama = useIsPanorama();
  if (isPanorama) {
    return /* @__PURE__ */ reactExports.createElement(BrushPanoramaSurface, null, children);
  }
  return /* @__PURE__ */ reactExports.createElement(MainChartSurface, _extends$3({
    ref
  }, rest), children);
});
function useReportScale() {
  var dispatch = useAppDispatch();
  var [ref, setRef] = reactExports.useState(null);
  var scale = useAppSelector(selectContainerScale);
  reactExports.useEffect(() => {
    if (ref == null) {
      return;
    }
    var rect = ref.getBoundingClientRect();
    var newScale = rect.width / ref.offsetWidth;
    if (isWellBehavedNumber(newScale) && newScale !== scale) {
      dispatch(setScale(newScale));
    }
  }, [ref, dispatch, scale]);
  return setRef;
}
function ownKeys(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty(e3, r2, t2) {
  return (r2 = _toPropertyKey(r2)) in e3 ? Object.defineProperty(e3, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e3[r2] = t2, e3;
}
function _toPropertyKey(t2) {
  var i2 = _toPrimitive(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _extends$2() {
  return _extends$2 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$2.apply(null, arguments);
}
var EventSynchronizer = () => {
  useSynchronisedEventsFromOtherCharts();
  return null;
};
function getNumberOrZero(value) {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "string") {
    var parsed = parseFloat(value);
    if (!Number.isNaN(parsed)) {
      return parsed;
    }
  }
  return 0;
}
var ResponsiveDiv = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  var _props$style, _props$style2;
  var observerRef = reactExports.useRef(null);
  var [sizes, setSizes] = reactExports.useState({
    containerWidth: getNumberOrZero((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.width),
    containerHeight: getNumberOrZero((_props$style2 = props.style) === null || _props$style2 === void 0 ? void 0 : _props$style2.height)
  });
  var setContainerSize = reactExports.useCallback((newWidth, newHeight) => {
    setSizes((prevState) => {
      var roundedWidth = Math.round(newWidth);
      var roundedHeight = Math.round(newHeight);
      if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) {
        return prevState;
      }
      return {
        containerWidth: roundedWidth,
        containerHeight: roundedHeight
      };
    });
  }, []);
  var innerRef = reactExports.useCallback((node) => {
    if (typeof ref === "function") {
      ref(node);
    }
    if (node != null) {
      var {
        width: containerWidth,
        height: containerHeight
      } = node.getBoundingClientRect();
      setContainerSize(containerWidth, containerHeight);
      var callback = (entries) => {
        var {
          width,
          height
        } = entries[0].contentRect;
        setContainerSize(width, height);
      };
      var observer = new ResizeObserver(callback);
      observer.observe(node);
      observerRef.current = observer;
    }
  }, [ref, setContainerSize]);
  reactExports.useEffect(() => {
    return () => {
      var observer = observerRef.current;
      if (observer != null) {
        observer.disconnect();
      }
    };
  }, [setContainerSize]);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(ReportChartSize, {
    width: sizes.containerWidth,
    height: sizes.containerHeight
  }), /* @__PURE__ */ reactExports.createElement("div", _extends$2({
    ref: innerRef
  }, props)));
});
var ReadSizeOnceDiv = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  var {
    width,
    height
  } = props;
  var [sizes, setSizes] = reactExports.useState({
    containerWidth: getNumberOrZero(width),
    containerHeight: getNumberOrZero(height)
  });
  var setContainerSize = reactExports.useCallback((newWidth, newHeight) => {
    setSizes((prevState) => {
      var roundedWidth = Math.round(newWidth);
      var roundedHeight = Math.round(newHeight);
      if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) {
        return prevState;
      }
      return {
        containerWidth: roundedWidth,
        containerHeight: roundedHeight
      };
    });
  }, []);
  var innerRef = reactExports.useCallback((node) => {
    if (typeof ref === "function") {
      ref(node);
    }
    if (node != null) {
      var {
        width: containerWidth,
        height: containerHeight
      } = node.getBoundingClientRect();
      setContainerSize(containerWidth, containerHeight);
    }
  }, [ref, setContainerSize]);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(ReportChartSize, {
    width: sizes.containerWidth,
    height: sizes.containerHeight
  }), /* @__PURE__ */ reactExports.createElement("div", _extends$2({
    ref: innerRef
  }, props)));
});
var StaticDiv = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  var {
    width,
    height
  } = props;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(ReportChartSize, {
    width,
    height
  }), /* @__PURE__ */ reactExports.createElement("div", _extends$2({
    ref
  }, props)));
});
var NonResponsiveDiv = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  var {
    width,
    height
  } = props;
  if (isPercent(width) || isPercent(height)) {
    return /* @__PURE__ */ reactExports.createElement(ReadSizeOnceDiv, _extends$2({}, props, {
      ref
    }));
  }
  return /* @__PURE__ */ reactExports.createElement(StaticDiv, _extends$2({}, props, {
    ref
  }));
});
function getWrapperDivComponent(responsive) {
  return responsive === true ? ResponsiveDiv : NonResponsiveDiv;
}
var RechartsWrapper = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  var {
    children,
    className,
    height: heightFromProps,
    onClick,
    onContextMenu,
    onDoubleClick,
    onMouseDown,
    onMouseEnter,
    onMouseLeave,
    onMouseMove,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    style,
    width: widthFromProps,
    responsive,
    dispatchTouchEvents = true
  } = props;
  var containerRef = reactExports.useRef(null);
  var dispatch = useAppDispatch();
  var [tooltipPortal, setTooltipPortal] = reactExports.useState(null);
  var [legendPortal, setLegendPortal] = reactExports.useState(null);
  var setScaleRef = useReportScale();
  var responsiveContainerCalculations = useResponsiveContainerContext();
  var width = (responsiveContainerCalculations === null || responsiveContainerCalculations === void 0 ? void 0 : responsiveContainerCalculations.width) > 0 ? responsiveContainerCalculations.width : widthFromProps;
  var height = (responsiveContainerCalculations === null || responsiveContainerCalculations === void 0 ? void 0 : responsiveContainerCalculations.height) > 0 ? responsiveContainerCalculations.height : heightFromProps;
  var innerRef = reactExports.useCallback((node) => {
    setScaleRef(node);
    if (typeof ref === "function") {
      ref(node);
    }
    setTooltipPortal(node);
    setLegendPortal(node);
    if (node != null) {
      containerRef.current = node;
    }
  }, [setScaleRef, ref, setTooltipPortal, setLegendPortal]);
  var myOnClick = reactExports.useCallback((e3) => {
    dispatch(mouseClickAction(e3));
    dispatch(externalEventAction({
      handler: onClick,
      reactEvent: e3
    }));
  }, [dispatch, onClick]);
  var myOnMouseEnter = reactExports.useCallback((e3) => {
    dispatch(mouseMoveAction(e3));
    dispatch(externalEventAction({
      handler: onMouseEnter,
      reactEvent: e3
    }));
  }, [dispatch, onMouseEnter]);
  var myOnMouseLeave = reactExports.useCallback((e3) => {
    dispatch(mouseLeaveChart());
    dispatch(externalEventAction({
      handler: onMouseLeave,
      reactEvent: e3
    }));
  }, [dispatch, onMouseLeave]);
  var myOnMouseMove = reactExports.useCallback((e3) => {
    dispatch(mouseMoveAction(e3));
    dispatch(externalEventAction({
      handler: onMouseMove,
      reactEvent: e3
    }));
  }, [dispatch, onMouseMove]);
  var onFocus = reactExports.useCallback(() => {
    dispatch(focusAction());
  }, [dispatch]);
  var onKeyDown = reactExports.useCallback((e3) => {
    dispatch(keyDownAction(e3.key));
  }, [dispatch]);
  var myOnContextMenu = reactExports.useCallback((e3) => {
    dispatch(externalEventAction({
      handler: onContextMenu,
      reactEvent: e3
    }));
  }, [dispatch, onContextMenu]);
  var myOnDoubleClick = reactExports.useCallback((e3) => {
    dispatch(externalEventAction({
      handler: onDoubleClick,
      reactEvent: e3
    }));
  }, [dispatch, onDoubleClick]);
  var myOnMouseDown = reactExports.useCallback((e3) => {
    dispatch(externalEventAction({
      handler: onMouseDown,
      reactEvent: e3
    }));
  }, [dispatch, onMouseDown]);
  var myOnMouseUp = reactExports.useCallback((e3) => {
    dispatch(externalEventAction({
      handler: onMouseUp,
      reactEvent: e3
    }));
  }, [dispatch, onMouseUp]);
  var myOnTouchStart = reactExports.useCallback((e3) => {
    dispatch(externalEventAction({
      handler: onTouchStart,
      reactEvent: e3
    }));
  }, [dispatch, onTouchStart]);
  var myOnTouchMove = reactExports.useCallback((e3) => {
    if (dispatchTouchEvents) {
      dispatch(touchEventAction(e3));
    }
    dispatch(externalEventAction({
      handler: onTouchMove,
      reactEvent: e3
    }));
  }, [dispatch, dispatchTouchEvents, onTouchMove]);
  var myOnTouchEnd = reactExports.useCallback((e3) => {
    dispatch(externalEventAction({
      handler: onTouchEnd,
      reactEvent: e3
    }));
  }, [dispatch, onTouchEnd]);
  var WrapperDiv = getWrapperDivComponent(responsive);
  return /* @__PURE__ */ reactExports.createElement(TooltipPortalContext.Provider, {
    value: tooltipPortal
  }, /* @__PURE__ */ reactExports.createElement(LegendPortalContext.Provider, {
    value: legendPortal
  }, /* @__PURE__ */ reactExports.createElement(WrapperDiv, {
    width: width !== null && width !== void 0 ? width : style === null || style === void 0 ? void 0 : style.width,
    height: height !== null && height !== void 0 ? height : style === null || style === void 0 ? void 0 : style.height,
    className: clsx("recharts-wrapper", className),
    style: _objectSpread({
      position: "relative",
      cursor: "default",
      width,
      height
    }, style),
    onClick: myOnClick,
    onContextMenu: myOnContextMenu,
    onDoubleClick: myOnDoubleClick,
    onFocus,
    onKeyDown,
    onMouseDown: myOnMouseDown,
    onMouseEnter: myOnMouseEnter,
    onMouseLeave: myOnMouseLeave,
    onMouseMove: myOnMouseMove,
    onMouseUp: myOnMouseUp,
    onTouchEnd: myOnTouchEnd,
    onTouchMove: myOnTouchMove,
    onTouchStart: myOnTouchStart,
    ref: innerRef
  }, /* @__PURE__ */ reactExports.createElement(EventSynchronizer, null), children)));
});
var _excluded$1 = ["width", "height", "responsive", "children", "className", "style", "compact", "title", "desc"];
function _objectWithoutProperties$1(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose$1(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$1(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
var CategoricalChart = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  var {
    width,
    height,
    responsive,
    children,
    className,
    style,
    compact,
    title,
    desc
  } = props, others = _objectWithoutProperties$1(props, _excluded$1);
  var attrs = svgPropertiesNoEvents(others);
  if (compact) {
    return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(ReportChartSize, {
      width,
      height
    }), /* @__PURE__ */ reactExports.createElement(RootSurface, {
      otherAttributes: attrs,
      title,
      desc
    }, children));
  }
  return /* @__PURE__ */ reactExports.createElement(RechartsWrapper, {
    className,
    style,
    width,
    height,
    responsive,
    onClick: props.onClick,
    onMouseLeave: props.onMouseLeave,
    onMouseEnter: props.onMouseEnter,
    onMouseMove: props.onMouseMove,
    onMouseDown: props.onMouseDown,
    onMouseUp: props.onMouseUp,
    onContextMenu: props.onContextMenu,
    onDoubleClick: props.onDoubleClick,
    onTouchStart: props.onTouchStart,
    onTouchMove: props.onTouchMove,
    onTouchEnd: props.onTouchEnd
  }, /* @__PURE__ */ reactExports.createElement(RootSurface, {
    otherAttributes: attrs,
    title,
    desc,
    ref
  }, /* @__PURE__ */ reactExports.createElement(ClipPathProvider, null, children)));
});
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$1.apply(null, arguments);
}
var defaultMargin$1 = {
  top: 5,
  right: 5,
  bottom: 5,
  left: 5
};
var defaultProps$2 = {
  accessibilityLayer: true,
  layout: "horizontal",
  stackOffset: "none",
  barCategoryGap: "10%",
  barGap: 4,
  margin: defaultMargin$1,
  reverseStackOrder: false,
  syncMethod: "index",
  responsive: false
};
var CartesianChart = /* @__PURE__ */ reactExports.forwardRef(function CartesianChart2(props, ref) {
  var _categoricalChartProp;
  var rootChartProps = resolveDefaultProps(props.categoricalChartProps, defaultProps$2);
  var {
    chartName,
    defaultTooltipEventType,
    validateTooltipEventTypes,
    tooltipPayloadSearcher,
    categoricalChartProps
  } = props;
  var options = {
    chartName,
    defaultTooltipEventType,
    validateTooltipEventTypes,
    tooltipPayloadSearcher,
    eventEmitter: void 0
  };
  return /* @__PURE__ */ reactExports.createElement(RechartsStoreProvider, {
    preloadedState: {
      options
    },
    reduxStoreName: (_categoricalChartProp = categoricalChartProps.id) !== null && _categoricalChartProp !== void 0 ? _categoricalChartProp : chartName
  }, /* @__PURE__ */ reactExports.createElement(ChartDataContextProvider, {
    chartData: categoricalChartProps.data
  }), /* @__PURE__ */ reactExports.createElement(ReportMainChartProps, {
    layout: rootChartProps.layout,
    margin: rootChartProps.margin
  }), /* @__PURE__ */ reactExports.createElement(ReportChartProps, {
    accessibilityLayer: rootChartProps.accessibilityLayer,
    barCategoryGap: rootChartProps.barCategoryGap,
    maxBarSize: rootChartProps.maxBarSize,
    stackOffset: rootChartProps.stackOffset,
    barGap: rootChartProps.barGap,
    barSize: rootChartProps.barSize,
    syncId: rootChartProps.syncId,
    syncMethod: rootChartProps.syncMethod,
    className: rootChartProps.className
  }), /* @__PURE__ */ reactExports.createElement(CategoricalChart, _extends$1({}, rootChartProps, {
    ref
  })));
});
var allowedTooltipTypes$2 = ["axis"];
var LineChart = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  return /* @__PURE__ */ reactExports.createElement(CartesianChart, {
    chartName: "LineChart",
    defaultTooltipEventType: "axis",
    validateTooltipEventTypes: allowedTooltipTypes$2,
    tooltipPayloadSearcher: arrayTooltipSearcher,
    categoricalChartProps: props,
    ref
  });
});
var allowedTooltipTypes$1 = ["axis", "item"];
var BarChart = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  return /* @__PURE__ */ reactExports.createElement(CartesianChart, {
    chartName: "BarChart",
    defaultTooltipEventType: "axis",
    validateTooltipEventTypes: allowedTooltipTypes$1,
    tooltipPayloadSearcher: arrayTooltipSearcher,
    categoricalChartProps: props,
    ref
  });
});
function ReportPolarOptions(props) {
  var dispatch = useAppDispatch();
  reactExports.useEffect(() => {
    dispatch(updatePolarOptions(props));
  }, [dispatch, props]);
  return null;
}
var _excluded = ["layout"];
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends.apply(null, arguments);
}
function _objectWithoutProperties(e3, t2) {
  if (null == e3) return {};
  var o2, r2, i2 = _objectWithoutPropertiesLoose(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e3, o2) && (i2[o2] = e3[o2]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
var defaultMargin = {
  top: 5,
  right: 5,
  bottom: 5,
  left: 5
};
var defaultProps$1 = {
  accessibilityLayer: true,
  stackOffset: "none",
  barCategoryGap: "10%",
  barGap: 4,
  margin: defaultMargin,
  reverseStackOrder: false,
  syncMethod: "index",
  layout: "radial",
  responsive: false
};
var PolarChart = /* @__PURE__ */ reactExports.forwardRef(function PolarChart2(props, ref) {
  var _polarChartProps$id;
  var polarChartProps = resolveDefaultProps(props.categoricalChartProps, defaultProps$1);
  var {
    layout
  } = polarChartProps, otherCategoricalProps = _objectWithoutProperties(polarChartProps, _excluded);
  var {
    chartName,
    defaultTooltipEventType,
    validateTooltipEventTypes,
    tooltipPayloadSearcher
  } = props;
  var options = {
    chartName,
    defaultTooltipEventType,
    validateTooltipEventTypes,
    tooltipPayloadSearcher,
    eventEmitter: void 0
  };
  return /* @__PURE__ */ reactExports.createElement(RechartsStoreProvider, {
    preloadedState: {
      options
    },
    reduxStoreName: (_polarChartProps$id = polarChartProps.id) !== null && _polarChartProps$id !== void 0 ? _polarChartProps$id : chartName
  }, /* @__PURE__ */ reactExports.createElement(ChartDataContextProvider, {
    chartData: polarChartProps.data
  }), /* @__PURE__ */ reactExports.createElement(ReportMainChartProps, {
    layout,
    margin: polarChartProps.margin
  }), /* @__PURE__ */ reactExports.createElement(ReportChartProps, {
    accessibilityLayer: polarChartProps.accessibilityLayer,
    barCategoryGap: polarChartProps.barCategoryGap,
    maxBarSize: polarChartProps.maxBarSize,
    stackOffset: polarChartProps.stackOffset,
    barGap: polarChartProps.barGap,
    barSize: polarChartProps.barSize,
    syncId: polarChartProps.syncId,
    syncMethod: polarChartProps.syncMethod,
    className: polarChartProps.className
  }), /* @__PURE__ */ reactExports.createElement(ReportPolarOptions, {
    cx: polarChartProps.cx,
    cy: polarChartProps.cy,
    startAngle: polarChartProps.startAngle,
    endAngle: polarChartProps.endAngle,
    innerRadius: polarChartProps.innerRadius,
    outerRadius: polarChartProps.outerRadius
  }), /* @__PURE__ */ reactExports.createElement(CategoricalChart, _extends({}, otherCategoricalProps, {
    ref
  })));
});
var allowedTooltipTypes = ["item"];
var defaultProps = {
  layout: "centric",
  startAngle: 0,
  endAngle: 360,
  cx: "50%",
  cy: "50%",
  innerRadius: 0,
  outerRadius: "80%"
};
var PieChart = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  var propsWithDefaults = resolveDefaultProps(props, defaultProps);
  return /* @__PURE__ */ reactExports.createElement(PolarChart, {
    chartName: "PieChart",
    defaultTooltipEventType: "item",
    validateTooltipEventTypes: allowedTooltipTypes,
    tooltipPayloadSearcher: arrayTooltipSearcher,
    categoricalChartProps: propsWithDefaults,
    ref
  });
});
const DisasterStatsChart = ({ stateData = null }) => {
  const { t: t2 } = useTranslation();
  const [chartType, setChartType] = reactExports.useState("bar");
  const [dataType, setDataType] = reactExports.useState("frequency");
  const disasterData = [
    { name: t2("home.disaster_flood"), frequency: 42, affected: 15.2, funds: 2500 },
    { name: t2("home.disaster_earthquake"), frequency: 18, affected: 8.7, funds: 1800 },
    { name: t2("home.disaster_cyclone"), frequency: 25, affected: 12.4, funds: 3200 },
    { name: t2("home.disaster_drought"), frequency: 35, affected: 22.1, funds: 1900 },
    { name: t2("home.disaster_landslide"), frequency: 28, affected: 6.3, funds: 1200 },
    { name: t2("home.disaster_fire"), frequency: 38, affected: 4.8, funds: 900 }
  ];
  const stateWiseData = stateData || [
    { name: "Maharashtra", floods: 120, cyclones: 5, earthquakes: 2, droughts: 8 },
    { name: "West Bengal", floods: 95, cyclones: 12, earthquakes: 1, droughts: 5 },
    { name: "Odisha", floods: 80, cyclones: 15, earthquakes: 0, droughts: 6 },
    { name: "Andhra Pradesh", floods: 70, cyclones: 8, earthquakes: 1, droughts: 9 },
    { name: "Tamil Nadu", floods: 65, cyclones: 7, earthquakes: 3, droughts: 7 },
    { name: "Uttar Pradesh", floods: 90, cyclones: 2, earthquakes: 4, droughts: 10 },
    { name: "Bihar", floods: 85, cyclones: 1, earthquakes: 2, droughts: 6 },
    { name: "Gujarat", floods: 55, cyclones: 6, earthquakes: 5, droughts: 12 },
    { name: "Kerala", floods: 60, cyclones: 3, earthquakes: 1, droughts: 4 },
    { name: "Assam", floods: 110, cyclones: 2, earthquakes: 3, droughts: 5 }
  ];
  const COLORS = ["#3b82f6", "#10b981", "#f59e0b", "#ef4444", "#8b5cf6", "#ec4899"];
  const renderChart = () => {
    switch (chartType) {
      case "bar":
        if (stateData) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: 400, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(BarChart, { data: stateWiseData, margin: { top: 20, right: 30, left: 20, bottom: 60 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "name", angle: -45, textAnchor: "end", height: 60 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "floods", name: t2("home.disaster_flood"), fill: COLORS[0] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "cyclones", name: t2("home.disaster_cyclone"), fill: COLORS[1] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "earthquakes", name: t2("home.disaster_earthquake"), fill: COLORS[2] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "droughts", name: t2("home.disaster_drought"), fill: COLORS[3] })
          ] }) });
        } else {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: 400, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(BarChart, { data: disasterData, margin: { top: 20, right: 30, left: 20, bottom: 60 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "name", angle: -45, textAnchor: "end", height: 60 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Tooltip,
              {
                formatter: (value, name) => {
                  if (name === "frequency") return [value, t2("home.disaster_frequency")];
                  if (name === "affected") return [`${value}M`, t2("home.people_affected")];
                  if (name === "funds") return [`${value}Cr`, t2("home.funds_allocated")];
                  return [value, name];
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Legend,
              {
                formatter: (value) => {
                  if (value === "frequency") return t2("home.disaster_frequency");
                  if (value === "affected") return t2("home.people_affected");
                  if (value === "funds") return t2("home.funds_allocated");
                  return value;
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "frequency", name: t2("home.disaster_frequency"), fill: COLORS[0] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "affected", name: t2("home.people_affected"), fill: COLORS[1] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "funds", name: t2("home.funds_allocated"), fill: COLORS[2] })
          ] }) });
        }
      case "line":
        if (stateData) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: 400, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(LineChart, { data: stateWiseData, margin: { top: 20, right: 30, left: 20, bottom: 60 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "name", angle: -45, textAnchor: "end", height: 60 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { type: "monotone", dataKey: "floods", name: t2("home.disaster_flood"), stroke: COLORS[0], strokeWidth: 2, activeDot: { r: 8 } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { type: "monotone", dataKey: "cyclones", name: t2("home.disaster_cyclone"), stroke: COLORS[1], strokeWidth: 2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { type: "monotone", dataKey: "earthquakes", name: t2("home.disaster_earthquake"), stroke: COLORS[2], strokeWidth: 2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { type: "monotone", dataKey: "droughts", name: t2("home.disaster_drought"), stroke: COLORS[3], strokeWidth: 2 })
          ] }) });
        } else {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: 400, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(LineChart, { data: disasterData, margin: { top: 20, right: 30, left: 20, bottom: 60 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "name", angle: -45, textAnchor: "end", height: 60 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Tooltip,
              {
                formatter: (value, name) => {
                  if (name === "frequency") return [value, t2("home.disaster_frequency")];
                  if (name === "affected") return [`${value}M`, t2("home.people_affected")];
                  if (name === "funds") return [`${value}Cr`, t2("home.funds_allocated")];
                  return [value, name];
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Legend,
              {
                formatter: (value) => {
                  if (value === "frequency") return t2("home.disaster_frequency");
                  if (value === "affected") return t2("home.people_affected");
                  if (value === "funds") return t2("home.funds_allocated");
                  return value;
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { type: "monotone", dataKey: "frequency", name: t2("home.disaster_frequency"), stroke: COLORS[0], strokeWidth: 2, activeDot: { r: 8 } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { type: "monotone", dataKey: "affected", name: t2("home.people_affected"), stroke: COLORS[1], strokeWidth: 2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { type: "monotone", dataKey: "funds", name: t2("home.funds_allocated"), stroke: COLORS[2], strokeWidth: 2 })
          ] }) });
        }
      case "pie":
        if (stateData) {
          const pieData = stateWiseData.map((state) => ({
            name: state.name,
            value: state.floods + state.cyclones + state.earthquakes + state.droughts
          }));
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: 400, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(PieChart, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Pie,
              {
                data: pieData,
                cx: "50%",
                cy: "50%",
                labelLine: true,
                outerRadius: 120,
                fill: "#8884d8",
                dataKey: "value",
                nameKey: "name",
                label: ({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`,
                children: pieData.map((entry, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(Cell, { fill: COLORS[index % COLORS.length] }, `cell-${index}`))
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {})
          ] }) });
        } else {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: 400, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(PieChart, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Pie,
              {
                data: disasterData,
                cx: "50%",
                cy: "50%",
                labelLine: true,
                outerRadius: 120,
                fill: "#8884d8",
                dataKey: "frequency",
                nameKey: "name",
                label: ({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`,
                children: disasterData.map((entry, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(Cell, { fill: COLORS[index % COLORS.length] }, `cell-${index}`))
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Tooltip,
              {
                formatter: (value) => [value, t2("home.disaster_frequency")]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {})
          ] }) });
        }
      default:
        return null;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 mb-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col md:flex-row md:items-center md:justify-between mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white mb-4 md:mb-0", children: stateData ? t2("disasterStatistics.tabs.regional") : t2("home.disaster_statistics") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col sm:flex-row gap-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setChartType("bar"),
            className: `px-4 py-2 rounded-lg text-sm font-medium transition-colors ${chartType === "bar" ? "bg-blue-600 text-white" : "bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-600"}`,
            children: t2("home.bar_chart")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setChartType("line"),
            className: `px-4 py-2 rounded-lg text-sm font-medium transition-colors ${chartType === "line" ? "bg-blue-600 text-white" : "bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-600"}`,
            children: t2("home.line_chart")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setChartType("pie"),
            className: `px-4 py-2 rounded-lg text-sm font-medium transition-colors ${chartType === "pie" ? "bg-blue-600 text-white" : "bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-600"}`,
            children: t2("home.pie_chart")
          }
        )
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-96", children: renderChart() }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6 p-4 bg-blue-50 dark:bg-blue-900 rounded-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-blue-800 dark:text-blue-200 mb-2", children: t2("home.disaster_statistics_insight") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-blue-700 dark:text-blue-300 text-sm", children: stateData ? t2("disasterStatistics.regional.description") : t2("home.disaster_statistics_desc") })
    ] })
  ] });
};
const localeDateOptions = {
  en: {
    dateStyle: "long",
    timeStyle: "short"
  },
  hi: {
    dateStyle: "long",
    timeStyle: "short"
  },
  ta: {
    dateStyle: "long",
    timeStyle: "short"
  },
  te: {
    dateStyle: "long",
    timeStyle: "short"
  },
  mr: {
    dateStyle: "long",
    timeStyle: "short"
  },
  bn: {
    dateStyle: "long",
    timeStyle: "short"
  },
  gu: {
    dateStyle: "long",
    timeStyle: "short"
  }
};
const formatLocaleDate = (date2, locale2 = "en") => {
  try {
    const validDate = new Date(date2);
    if (isNaN(validDate.getTime())) {
      throw new Error("Invalid date");
    }
    const options = localeDateOptions[locale2] || localeDateOptions.en;
    return new Intl.DateTimeFormat(locale2, options).format(validDate);
  } catch (error) {
    console.warn("Error formatting date:", error);
    return date2.toString();
  }
};
const formatLocaleCurrency = (amount, locale2 = "en", currency = "INR") => {
  try {
    return new Intl.NumberFormat(locale2, {
      style: "currency",
      currency,
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }).format(amount);
  } catch (error) {
    console.warn("Error formatting currency:", error);
    return `${currency} ${amount.toLocaleString(locale2)}`;
  }
};
const formatLocaleNumber = (number2, locale2 = "en") => {
  try {
    return new Intl.NumberFormat(locale2).format(number2);
  } catch (error) {
    console.warn("Error formatting number:", error);
    return number2.toLocaleString(locale2);
  }
};
const formatIndianNumber = (number2) => {
  if (isNaN(number2)) return "0";
  const [integerPart, decimalPart] = number2.toString().split(".");
  const isNegative = integerPart.startsWith("-");
  const absoluteInteger = isNegative ? integerPart.slice(1) : integerPart;
  let formattedInteger = "";
  if (absoluteInteger.length <= 3) {
    formattedInteger = absoluteInteger;
  } else if (absoluteInteger.length <= 5) {
    const lastThree = absoluteInteger.slice(-3);
    const remaining = absoluteInteger.slice(0, -3);
    formattedInteger = `${remaining},${lastThree}`;
  } else {
    const lastThree = absoluteInteger.slice(-3);
    const beforeLastThree = absoluteInteger.slice(0, -3);
    let formattedBefore = "";
    for (let i2 = beforeLastThree.length; i2 > 0; i2 -= 2) {
      const start = Math.max(0, i2 - 2);
      const part = beforeLastThree.slice(start, i2);
      formattedBefore = formattedBefore ? `${part},${formattedBefore}` : part;
    }
    formattedInteger = `${formattedBefore},${lastThree}`;
  }
  if (isNegative) {
    formattedInteger = `-${formattedInteger}`;
  }
  return decimalPart ? `${formattedInteger}.${decimalPart}` : formattedInteger;
};
const formatIndianCurrency = (amount, locale2 = "en-IN", useUnits = true) => {
  if (isNaN(amount)) return "0";
  const absoluteAmount = Math.abs(amount);
  const isNegative = amount < 0;
  if (!useUnits || absoluteAmount < 1e5) {
    const formattedNumber = formatIndianNumber(absoluteAmount);
    return `${isNegative ? "-" : ""}${formattedNumber}`;
  } else if (absoluteAmount < 1e7) {
    const lakhs = absoluteAmount / 1e5;
    const formattedLakhs = formatIndianNumber(Math.round(lakhs * 100) / 100);
    return `${isNegative ? "-" : ""}${formattedLakhs} ${getLocaleString("lakh", locale2)}`;
  } else {
    const crores = absoluteAmount / 1e7;
    const formattedCrores = formatIndianNumber(Math.round(crores * 100) / 100);
    return `${isNegative ? "-" : ""}${formattedCrores} ${getLocaleString("crore", locale2)}`;
  }
};
const getLocaleString = (unit2, locale2) => {
  const translations = {
    lakh: {
      "en-IN": "Lakh",
      "en": "Lakh",
      "hi-IN": "",
      "hi": "",
      "ta-IN": "",
      "ta": "",
      "te-IN": "",
      "te": "",
      "mr-IN": "",
      "mr": "",
      "bn-IN": "",
      "bn": "",
      "gu-IN": "",
      "gu": ""
    },
    crore: {
      "en-IN": "Crore",
      "en": "Crore",
      "hi-IN": "",
      "hi": "",
      "ta-IN": "",
      "ta": "",
      "te-IN": "",
      "te": "",
      "mr-IN": "",
      "mr": "",
      "bn-IN": "",
      "bn": "",
      "gu-IN": "",
      "gu": ""
    }
  };
  return translations[unit2]?.[locale2] || translations[unit2]?.["en"] || unit2;
};
const formatCurrency = (amount, locale2 = "en", currency = "INR", useIndianFormat = true) => {
  if (useIndianFormat && currency === "INR") {
    return formatIndianCurrency(amount, locale2);
  } else {
    return formatLocaleCurrency(amount, locale2, currency);
  }
};
const formatNumber = (number2, locale2 = "en", useIndianFormat = true) => {
  if (useIndianFormat) {
    return formatIndianNumber(number2);
  } else {
    return formatLocaleNumber(number2, locale2);
  }
};
const formatDate = (date2, locale2 = "en") => {
  return formatLocaleDate(date2, locale2);
};
const formatPercentage = (value, locale2 = "en") => {
  try {
    return new Intl.NumberFormat(locale2, {
      style: "percent",
      minimumFractionDigits: 0,
      maximumFractionDigits: 2
    }).format(value / 100);
  } catch (error) {
    console.warn("Error formatting percentage:", error);
    return `${value}%`;
  }
};
const formatLargeNumber = (number2, locale2 = "en") => {
  const absNumber = Math.abs(number2);
  if (absNumber >= 1e7) {
    const crores = number2 / 1e7;
    return `${formatNumber(crores, locale2, true)} ${getUnitTranslation("crore", locale2)}`;
  } else if (absNumber >= 1e5) {
    const lakhs = number2 / 1e5;
    return `${formatNumber(lakhs, locale2, true)} ${getUnitTranslation("lakh", locale2)}`;
  } else if (absNumber >= 1e3) {
    const thousands = number2 / 1e3;
    return `${formatNumber(thousands, locale2, true)} ${getUnitTranslation("thousand", locale2)}`;
  } else {
    return formatNumber(number2, locale2, true);
  }
};
const getUnitTranslation = (unit2, locale2) => {
  const translations = {
    crore: {
      en: "Cr",
      hi: "",
      ta: "",
      te: "",
      mr: "",
      bn: "",
      gu: ""
    },
    lakh: {
      en: "L",
      hi: "",
      ta: "",
      te: "",
      mr: "",
      bn: "",
      gu: ""
    },
    thousand: {
      en: "K",
      hi: "",
      ta: "",
      te: "",
      mr: "",
      bn: "",
      gu: ""
    }
  };
  return translations[unit2]?.[locale2] || translations[unit2]?.en || unit2;
};
const LocalizationDemo = () => {
  const { t: t2, i18n } = useTranslation();
  const [currentLocale, setCurrentLocale] = reactExports.useState(i18n.language);
  const [sampleData] = reactExports.useState({
    amount: 125e5,
    population: 138e7,
    date: /* @__PURE__ */ new Date(),
    percentage: 75.5,
    largeNumber: 578e5
  });
  reactExports.useEffect(() => {
    setCurrentLocale(i18n.language);
  }, [i18n.language]);
  const formattedData = {
    currency: formatCurrency(sampleData.amount, currentLocale),
    population: formatNumber(sampleData.population, currentLocale),
    date: formatDate(sampleData.date, currentLocale),
    percentage: formatPercentage(sampleData.percentage, currentLocale),
    largeNumber: formatLargeNumber(sampleData.largeNumber, currentLocale)
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 mb-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white mb-6", children: t2("home.localization_demo") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6 mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 dark:bg-blue-900 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-blue-800 dark:text-blue-200 mb-2", children: t2("home.currency_formatting") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-blue-700 dark:text-blue-300", children: formattedData.currency })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-green-50 dark:bg-green-900 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-green-800 dark:text-green-200 mb-2", children: t2("home.number_formatting") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-green-700 dark:text-green-300", children: formattedData.population })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-yellow-50 dark:bg-yellow-900 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-yellow-800 dark:text-yellow-200 mb-2", children: t2("home.date_formatting") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-yellow-700 dark:text-yellow-300", children: formattedData.date })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-purple-50 dark:bg-purple-900 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-purple-800 dark:text-purple-200 mb-2", children: t2("home.percentage_formatting") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-purple-700 dark:text-purple-300", children: formattedData.percentage })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-indigo-50 dark:bg-indigo-900 rounded-lg p-4 mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-indigo-800 dark:text-indigo-200 mb-2", children: t2("home.large_number_formatting") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-indigo-700 dark:text-indigo-300", children: formattedData.largeNumber })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 bg-gray-100 dark:bg-gray-700 rounded-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-gray-800 dark:text-gray-200 mb-2", children: t2("home.current_locale") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-700 dark:text-gray-300", children: currentLocale })
    ] })
  ] });
};
const Home = () => {
  const { t: t2 } = useTranslation();
  const [currentSlide, setCurrentSlide] = reactExports.useState(0);
  const [darkMode, setDarkMode] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      setCurrentSlide((prev) => (prev + 1) % 3);
    }, 5e3);
    return () => clearInterval(interval);
  }, []);
  reactExports.useEffect(() => {
    const savedDarkMode2 = localStorage.getItem("darkMode") === "true";
    setDarkMode(savedDarkMode2);
  }, []);
  const heroSlides = [
    {
      title: t2("home.hero_title_1"),
      description: t2("home.hero_description_1"),
      image: "https://images.unsplash.com/photo-1593062091233-5450f1b5c3c0?ixlib=rb-4.0.3&auto=format&fit=crop&w=1200&q=80",
      progress: 75
    },
    {
      title: t2("home.hero_title_2"),
      description: t2("home.hero_description_2"),
      image: "https://images.unsplash.com/photo-1523050854058-8df90110c9f1?ixlib=rb-4.0.3&auto=format&fit=crop&w=1200&q=80",
      progress: 45
    },
    {
      title: t2("home.hero_title_3"),
      description: t2("home.hero_description_3"),
      image: "https://images.unsplash.com/photo-1591228391010-0a6a3c7b4c1c?ixlib=rb-4.0.3&auto=format&fit=crop&w=1200&q=80",
      progress: 30
    }
  ];
  const features = [
    {
      icon: "",
      title: t2("home.feature_transparency"),
      description: t2("home.feature_transparency_desc")
    },
    {
      icon: "",
      title: t2("home.feature_verification"),
      description: t2("home.feature_verification_desc")
    },
    {
      icon: "",
      title: t2("home.feature_storage"),
      description: t2("home.feature_storage_desc")
    },
    {
      icon: "",
      title: t2("home.feature_india"),
      description: t2("home.feature_india_desc")
    }
  ];
  const stats = [
    { value: t2("home.stats_funds"), label: t2("home.stats_funds_label") },
    { value: t2("home.stats_beneficiaries"), label: t2("home.stats_beneficiaries_label") },
    { value: t2("home.stats_campaigns"), label: t2("home.stats_campaigns_label") },
    { value: t2("home.stats_transparency"), label: t2("home.stats_transparency_label") }
  ];
  const partners = [
    { name: "National Disaster Response Force", logo: "NDRF", description: "India's premier disaster response organization" },
    { name: "Ministry of Home Affairs", logo: "MHA", description: "Government of India disaster management" },
    { name: "Indian Red Cross Society", logo: "IRCS", description: "Humanitarian aid and disaster response" },
    { name: "UNICEF India", logo: "UNICEF", description: "Children's welfare and emergency response" }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-6xl mx-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative rounded-2xl overflow-hidden shadow-2xl mb-12 h-64 md:h-96 lg:h-[500px]", children: [
      heroSlides.map((slide, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `absolute inset-0 transition-opacity duration-1000 ${index === currentSlide ? "opacity-100" : "opacity-0"}`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "w-full h-full bg-cover bg-center",
              style: { backgroundImage: `url(${slide.image})` },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-r from-black/70 to-black/30" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto px-4 md:px-6 lg:px-12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-2xl text-white", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl md:text-4xl lg:text-5xl font-bold mb-2 md:mb-4", children: slide.title }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-base md:text-xl mb-4 md:mb-6", children: slide.description }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-sm mb-1", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("home.funds_raised") }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                        slide.progress,
                        "%"
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-2 md:h-3 bg-gray-300 rounded-full overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "h-full bg-green-500 rounded-full",
                        style: { width: `${slide.progress}%` }
                      }
                    ) })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col sm:flex-row gap-3 md:gap-4", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Link,
                      {
                        to: "/donate",
                        className: "bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white font-bold py-2 md:py-3 px-4 md:px-8 rounded-full transition duration-300 shadow-lg transform hover:scale-105 touch-target",
                        children: t2("common.donate")
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Link,
                      {
                        to: "/campaigns",
                        className: "bg-white/20 backdrop-blur-sm hover:bg-white/30 text-white font-bold py-2 md:py-3 px-4 md:px-8 rounded-full transition duration-300 border border-white/30 touch-target",
                        children: t2("common.campaigns")
                      }
                    )
                  ] })
                ] }) }) })
              ]
            }
          )
        },
        index
      )),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-4 md:bottom-6 left-1/2 transform -translate-x-1/2 flex space-x-2", children: heroSlides.map((_2, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setCurrentSlide(index),
          className: `w-2 h-2 md:w-3 md:h-3 rounded-full transition-colors ${index === currentSlide ? "bg-white" : "bg-white/50"}`,
          "aria-label": `${t2("home.go_to_slide")} ${index + 1}`
        },
        index
      )) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 md:grid-cols-4 gap-4 md:gap-6 mb-12 md:mb-16", children: stats.map((stat, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 p-4 md:p-6 rounded-2xl shadow-lg text-center border border-gray-100 dark:border-gray-700 hover:shadow-xl transition-shadow touch-target", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl md:text-3xl lg:text-4xl font-bold text-blue-700 dark:text-blue-400 mb-1 md:mb-2", children: stat.value }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm md:text-base text-gray-600 dark:text-gray-300", children: stat.label })
    ] }, index)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-12 md:mb-16", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl md:text-3xl font-bold text-center text-gray-800 dark:text-white mb-2 md:mb-4", children: t2("home.why_impactx") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300 text-center mb-8 md:mb-12 max-w-3xl mx-auto px-4", children: t2("home.why_impactx_desc") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6", children: features.map((feature, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-white to-blue-50 dark:from-gray-800 dark:to-gray-900 p-5 md:p-6 rounded-2xl shadow-lg border border-gray-100 dark:border-gray-700 hover:shadow-xl transition-all duration-300 transform hover:-translate-y-1 touch-target", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl md:text-4xl mb-3 md:mb-4", children: feature.icon }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg md:text-xl font-semibold mb-2 text-gray-800 dark:text-white", children: feature.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300 text-sm md:text-base", children: feature.description })
      ] }, index)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DisasterInfo, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(RegionalStats, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DisasterStatsChart, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LocalizationDemo, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-12 md:mb-16", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl md:text-3xl font-bold text-center text-gray-800 dark:text-white mb-2 md:mb-4", children: t2("home.disaster_relief") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300 text-center mb-8 md:mb-12 max-w-3xl mx-auto px-4", children: t2("home.disaster_relief_desc") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Map$1, { darkMode }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 md:mt-6 flex flex-wrap justify-center gap-3 md:gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3 h-3 md:w-4 md:h-4 bg-blue-500 rounded-full mr-2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-700 dark:text-gray-300 text-sm md:text-base", children: t2("home.active_campaigns") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3 h-3 md:w-4 md:h-4 bg-green-500 rounded-full mr-2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-700 dark:text-gray-300 text-sm md:text-base", children: t2("home.completed_campaigns") })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-12 md:mb-16", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl md:text-3xl font-bold text-center text-gray-800 dark:text-white mb-2 md:mb-4", children: t2("home.partners") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300 text-center mb-8 md:mb-12 max-w-3xl mx-auto px-4", children: t2("home.partners_desc") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4 md:gap-6", children: partners.map((partner, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 p-4 md:p-6 rounded-2xl shadow-lg border border-gray-100 dark:border-gray-700 text-center hover:shadow-xl transition-shadow touch-target", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-200 dark:bg-gray-700 border-2 border-dashed rounded-xl w-12 h-12 md:w-16 md:h-16 mx-auto mb-3 md:mb-4 flex items-center justify-center text-lg md:text-xl font-bold", children: partner.logo }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-base md:text-lg font-semibold text-gray-800 dark:text-white mb-1 md:mb-2", children: partner.name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-400 text-xs md:text-sm", children: partner.description })
      ] }, index)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-gray-800 dark:to-gray-900 p-6 md:p-8 rounded-2xl mb-12 md:mb-16", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl md:text-3xl font-bold text-center text-gray-800 dark:text-white mb-2 md:mb-4", children: t2("home.how_it_works") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300 text-center mb-8 md:mb-12 max-w-3xl mx-auto px-4", children: t2("home.how_it_works_desc") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 md:gap-6", children: [
        { step: 1, title: t2("home.step_create"), description: t2("home.step_create_desc") },
        { step: 2, title: t2("home.step_donate"), description: t2("home.step_donate_desc") },
        { step: 3, title: t2("home.step_verify"), description: t2("home.step_verify_desc") },
        { step: 4, title: t2("home.step_release"), description: t2("home.step_release_desc") }
      ].map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center relative touch-target", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-600 text-white rounded-full w-12 h-12 md:w-16 md:h-16 flex items-center justify-center mx-auto mb-3 md:mb-4 text-xl md:text-2xl font-bold shadow-lg", children: item.step }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg md:text-xl font-semibold mb-2 text-gray-800 dark:text-white", children: item.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300 text-sm md:text-base", children: item.description }),
        index < 3 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hidden lg:block absolute top-6 md:top-8 -right-3 md:-right-4 text-blue-400 dark:text-blue-300", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6 md:w-8 md:h-8", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 5l7 7-7 7" }) }) })
      ] }, index)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-r from-blue-600 to-indigo-700 rounded-2xl p-8 md:p-12 text-center text-white mb-12 md:mb-16", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl md:text-3xl lg:text-4xl font-bold mb-3 md:mb-4", children: t2("home.cta_title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-base md:text-xl mb-6 md:mb-8 max-w-2xl mx-auto px-4", children: t2("home.cta_desc") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col sm:flex-row justify-center gap-3 md:gap-4 max-w-md mx-auto", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            to: "/donate",
            className: "bg-white text-blue-700 hover:bg-gray-100 font-bold py-3 md:py-4 px-6 md:px-8 rounded-full transition duration-300 shadow-lg transform hover:scale-105 touch-target",
            children: t2("home.cta_button_donate")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            to: "/campaigns",
            className: "bg-transparent border-2 border-white hover:bg-white/10 text-white font-bold py-3 md:py-4 px-6 md:px-8 rounded-full transition duration-300 touch-target",
            children: t2("home.cta_button_explore")
          }
        )
      ] })
    ] })
  ] });
};
class APIService {
  constructor() {
    this.mockMode = true;
  }
  // Generic API request method that returns mock data
  async request(endpoint, options = {}) {
    console.log("Mock API request to:", endpoint);
    if (endpoint.includes("/donations")) {
      return this.getMockDonations();
    } else if (endpoint.includes("/campaigns")) {
      return this.getMockCampaigns();
    } else if (endpoint.includes("/auth/login")) {
      return this.getMockLogin();
    } else if (endpoint.includes("/auth/register")) {
      return this.getMockRegister();
    }
    return {
      ok: true,
      data: { message: "Mock response" },
      error: null
    };
  }
  // GET request
  async get(endpoint) {
    return await this.request(endpoint, { method: "GET" });
  }
  // POST request
  async post(endpoint, data) {
    return await this.request(endpoint, {
      method: "POST",
      body: JSON.stringify(data)
    });
  }
  // PUT request
  async put(endpoint, data) {
    return await this.request(endpoint, {
      method: "PUT",
      body: JSON.stringify(data)
    });
  }
  // DELETE request
  async delete(endpoint) {
    return await this.request(endpoint, { method: "DELETE" });
  }
  // Mock data methods
  getMockDonations() {
    return {
      ok: true,
      data: [
        { id: 1, amount: 1e3, campaignId: 1, date: "2023-06-15", donor: "Anonymous" },
        { id: 2, amount: 500, campaignId: 2, date: "2023-06-10", donor: "John Doe" },
        { id: 3, amount: 2500, campaignId: 1, date: "2023-06-05", donor: "Jane Smith" }
      ],
      error: null
    };
  }
  getMockCampaigns() {
    return {
      ok: true,
      data: [
        {
          id: 1,
          title: "Flood Relief in Kerala",
          description: "Support flood victims in Kerala with emergency supplies and shelter",
          goal: 1e5,
          raised: 75e3,
          endDate: "2023-12-31",
          image: "/placeholder-image.jpg"
        },
        {
          id: 2,
          title: "Earthquake Recovery in Manipur",
          description: "Help rebuild communities affected by the recent earthquake",
          goal: 5e4,
          raised: 3e4,
          endDate: "2023-11-30",
          image: "/placeholder-image.jpg"
        }
      ],
      error: null
    };
  }
  getMockLogin() {
    return {
      ok: true,
      data: {
        token: "mock-jwt-token",
        user: {
          id: 1,
          email: "user@example.com",
          role: "DONOR",
          name: "Mock User"
        }
      },
      error: null
    };
  }
  getMockRegister() {
    return {
      ok: true,
      data: {
        token: "mock-jwt-token",
        user: {
          id: 1,
          email: "user@example.com",
          role: "DONOR",
          name: "Mock User"
        }
      },
      error: null
    };
  }
  // Donation-specific methods
  async createDonation(amount, campaignId = null) {
    console.log("Mock creating donation:", { amount, campaignId });
    return {
      ok: true,
      data: {
        id: Math.floor(Math.random() * 1e3),
        amount,
        campaignId,
        date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        donor: "Current User"
      },
      error: null
    };
  }
  async getDonations() {
    return this.getMockDonations();
  }
  async getDonationById(id) {
    const donations = await this.getDonations();
    const donation = donations.data.find((d2) => d2.id === parseInt(id));
    return {
      ok: true,
      data: donation || null,
      error: donation ? null : "Donation not found"
    };
  }
  // Campaign-specific methods
  async getCampaigns() {
    return this.getMockCampaigns();
  }
  async getCampaignById(id) {
    const campaigns = await this.getCampaigns();
    const campaign = campaigns.data.find((c2) => c2.id === parseInt(id));
    return {
      ok: true,
      data: campaign || null,
      error: campaign ? null : "Campaign not found"
    };
  }
  // Auth-specific methods
  async login(email, password) {
    console.log("Mock login attempt:", { email });
    return this.getMockLogin();
  }
  async register(email, password, role = "DONOR") {
    console.log("Mock registration attempt:", { email, role });
    return this.getMockRegister();
  }
  // Auto-initialize authentication (no-op in mock mode)
  async initialize() {
    console.log("Mock API service initialized");
  }
}
const apiService = new APIService();
apiService.initialize();
const Campaigns = () => {
  const [campaigns, setCampaigns] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [error, setError] = reactExports.useState(null);
  const [filter, setFilter] = reactExports.useState("all");
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  reactExports.useEffect(() => {
    fetchCampaigns();
  }, []);
  const fetchCampaigns = async () => {
    try {
      setLoading(true);
      const mockCampaigns = [
        {
          id: "1",
          title: "Kerala Flood Relief",
          description: "Providing emergency aid to flood-affected families in Kerala",
          goal: 5e6,
          raised: 375e4,
          status: "active",
          source: "NDRF Kerala Unit",
          creator: { email: "kerala-ngo@example.com" }
        },
        {
          id: "2",
          title: "Rajasthan Drought Support",
          description: "Water conservation and distribution in drought-prone areas of Rajasthan",
          goal: 3e6,
          raised: 285e4,
          status: "active",
          source: "Government of Rajasthan",
          creator: { email: "rajasthan-ngo@example.com" }
        },
        {
          id: "3",
          title: "Himalayan Earthquake Recovery",
          description: "Rebuilding homes and infrastructure after the earthquake in Uttarakhand",
          goal: 8e6,
          raised: 8e6,
          status: "completed",
          source: "Ministry of Home Affairs",
          creator: { email: "mha-ngo@example.com" }
        },
        {
          id: "4",
          title: "Odisha Cyclone Aid",
          description: "Emergency relief and rehabilitation after cyclone damage",
          goal: 45e5,
          raised: 12e5,
          status: "active",
          source: "NDRF Odisha Unit",
          creator: { email: "odisha-ngo@example.com" }
        },
        {
          id: "5",
          title: "Assam Flood Response",
          description: "Providing relief to flood-affected communities in Assam",
          goal: 2e6,
          raised: 825e3,
          status: "active",
          source: "Assam State Disaster Management Authority",
          creator: { email: "assam-ngo@example.com" }
        }
      ];
      setCampaigns(mockCampaigns);
    } catch (err) {
      setError("Failed to fetch campaigns");
      console.error("Fetch campaigns error:", err);
    } finally {
      setLoading(false);
    }
  };
  const filteredCampaigns = campaigns.filter((campaign) => {
    const matchesFilter = filter === "all" || campaign.status === filter;
    const matchesSearch = campaign.title.toLowerCase().includes(searchTerm.toLowerCase()) || campaign.description.toLowerCase().includes(searchTerm.toLowerCase());
    return matchesFilter && matchesSearch;
  });
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center items-center h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600" }) });
  }
  if (error) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative", role: "alert", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: "font-bold", children: "Error! " }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "block sm:inline", children: error })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-10", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-4xl font-bold text-gray-800 dark:text-white mb-4", children: "Disaster Relief Campaigns" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-gray-600 dark:text-gray-300 max-w-2xl mx-auto", children: "Support verified relief efforts across India. Every donation is tracked and verified for maximum impact." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 mb-8 border border-gray-100 dark:border-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "md:col-span-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-5 w-5 text-gray-400 dark:text-gray-500", fill: "currentColor", viewBox: "0 0 20 20", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z", clipRule: "evenodd" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            placeholder: "Search campaigns...",
            value: searchTerm,
            onChange: (e3) => setSearchTerm(e3.target.value),
            className: "block w-full pl-10 pr-3 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
          }
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "select",
        {
          value: filter,
          onChange: (e3) => setFilter(e3.target.value),
          className: "block w-full px-3 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-white",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: "All Campaigns" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "active", children: "Active" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "completed", children: "Completed" })
          ]
        }
      ) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-4 gap-6 mb-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-2xl p-6 shadow-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-bold", children: campaigns.length }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-blue-100", children: "Total Campaigns" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-green-500 to-emerald-600 text-white rounded-2xl p-6 shadow-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-bold", children: campaigns.filter((c2) => c2.status === "active").length }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-green-100", children: "Active Campaigns" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-amber-500 to-orange-600 text-white rounded-2xl p-6 shadow-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-3xl font-bold", children: [
          "",
          campaigns.reduce((sum, c2) => sum + c2.goal, 0).toLocaleString()
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-amber-100", children: "Total Goal" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-purple-500 to-fuchsia-600 text-white rounded-2xl p-6 shadow-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-3xl font-bold", children: [
          "",
          campaigns.reduce((sum, c2) => sum + c2.goal * 0.75, 0).toLocaleString()
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-purple-100", children: "Funds Raised" })
      ] })
    ] }),
    filteredCampaigns.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-12 text-center border border-gray-100 dark:border-gray-700", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-5xl mb-4", children: "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-bold text-gray-800 dark:text-white mb-2", children: "No campaigns found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300 mb-6", children: searchTerm ? "Try adjusting your search terms" : "No campaigns match your selected filter" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Link,
        {
          to: "/donate",
          className: "bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white font-bold py-3 px-6 rounded-xl transition-all shadow-lg",
          children: "Start a New Donation"
        }
      )
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between items-center mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white", children: [
        filter === "all" ? "All Campaigns" : filter === "active" ? "Active Campaigns" : "Completed Campaigns",
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-500 dark:text-gray-400 text-lg font-normal ml-2", children: [
          "(",
          filteredCampaigns.length,
          ")"
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: filteredCampaigns.map((campaign) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-2xl shadow-lg overflow-hidden border border-gray-100 dark:border-gray-700 hover:shadow-xl transition-all duration-300 transform hover:-translate-y-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-48 bg-gradient-to-r from-blue-400 to-indigo-500 relative", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-4 right-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-3 py-1 rounded-full text-sm font-semibold ${campaign.status === "active" ? "bg-green-100 text-green-800" : "bg-gray-100 text-gray-800"}`, children: campaign.status === "active" ? "Active" : "Completed" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-4 left-4 right-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-bold text-white", children: campaign.title }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300 mb-4 line-clamp-2", children: campaign.description }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-sm text-gray-500 dark:text-gray-400 mb-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Raised" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Goal" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "h-full bg-gradient-to-r from-green-400 to-emerald-500 rounded-full",
                style: { width: `${campaign.raised / campaign.goal * 100}%` }
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-sm mt-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-semibold", children: [
                "",
                campaign.raised.toLocaleString()
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-semibold", children: [
                "",
                campaign.goal.toLocaleString()
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500 dark:text-gray-400", children: "Created by" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-semibold text-sm truncate max-w-[120px]", children: campaign.creator.email })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500 dark:text-gray-400", children: "Source" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-semibold text-sm", children: campaign.source })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Link,
            {
              to: `/donate?campaign=${campaign.id}`,
              className: "w-full bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white font-bold py-3 px-4 rounded-xl text-center block transition-all shadow-md hover:shadow-lg",
              children: "Donate Now"
            }
          )
        ] })
      ] }, campaign.id)) })
    ] })
  ] });
};
var errors;
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  const ERRORS = {
    WINDOW_NOT_LOADED: "Window not loaded",
    WINDOW_IS_OPENED: "Windows is opened",
    WINDOW_NOT_OPENED: "Can not open popup window",
    INVALID_WINDOW: "Invalid window"
  };
  class SignTxnsError extends Error {
    constructor(message, code, data) {
      super(message);
      this.code = code;
      this.data = data;
    }
  }
  errors = {
    ERRORS,
    SignTxnsError
  };
  return errors;
}
var popup;
var hasRequiredPopup;
function requirePopup() {
  if (hasRequiredPopup) return popup;
  hasRequiredPopup = 1;
  const { WINDOW_NOT_OPENED } = requireErrors();
  const defaultOptions2 = {
    width: 400,
    height: 600
  };
  function openPopup(url, options = defaultOptions2) {
    let { name = "", width, height, top = 0, left = 0 } = options;
    if (width) {
      if (window.outerWidth) {
        left = Math.round((window.outerWidth - width) / 2) + window.screenX;
      } else if (window.screen.width) {
        left = Math.round((window.screen.width - width) / 2);
      }
    }
    if (height) {
      if (window.outerHeight) {
        top = Math.round((window.outerHeight - height) / 2) + window.screenY;
      } else if (window.screen.height) {
        top = Math.round((window.screen.height - height) / 2);
      }
    }
    if (width && height) {
      options = {
        top,
        left,
        width,
        height,
        status: 1,
        toolbar: 0,
        menubar: 0,
        resizable: 1,
        scrollbars: 1
      };
    }
    const params = Object.keys(options).map((key) => {
      const param = options[key];
      if (param !== null && param !== void 0 && typeof param.toString === "function") {
        return `${key}=${param.toString()}`;
      }
    }).filter(Boolean).join(",");
    let win;
    try {
      win = window.open(url, name, params);
    } catch (err) {
      throw new Error(`${WINDOW_NOT_OPENED} - ${err.stack || err.message}`);
    }
    if (!win || window.closed) {
      throw new Error(`${WINDOW_NOT_OPENED} - blocked`);
    }
    return win;
  }
  popup = {
    openPopup
  };
  return popup;
}
var utils$2;
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  function sleep(msec = 200) {
    return new Promise((resolve) => setTimeout(resolve, msec));
  }
  function prepareTxn(transaction) {
    if (transaction.constructor === Uint8Array)
      return Buffer.from(transaction).toString("base64");
    else if (typeof transaction === "string")
      return transaction;
    const txn = Object.assign({}, transaction);
    if (txn.note && txn.note.constructor === Uint8Array)
      txn.note = Buffer.from(txn.note).toString("base64");
    if (txn.assetMetadataHash && txn.assetMetadataHash.constructor === Uint8Array)
      txn.assetMetadataHash = Buffer.from(txn.assetMetadataHash).toString("base64");
    if (txn.group && txn.group.constructor === Uint8Array)
      txn.group = Buffer.from(txn.group).toString("base64");
    if (txn.type === "appl" && txn.appApprovalProgram && txn.appApprovalProgram.constructor === Uint8Array)
      txn.appApprovalProgram = Buffer.from(txn.appApprovalProgram).toString("base64");
    if (txn.type === "appl" && txn.appClearProgram && txn.appClearProgram.constructor === Uint8Array)
      txn.appClearProgram = Buffer.from(txn.appClearProgram).toString("base64");
    if (txn.type === "appl" && txn.appArgs && txn.appArgs.length > 0) {
      for (let i2 = 0; i2 < txn.appArgs.length; i2++)
        if (txn.appArgs[i2].constructor === Uint8Array)
          txn.appArgs[i2] = Buffer.from(txn.appArgs[i2]).toString("base64");
    }
    return txn;
  }
  utils$2 = {
    sleep,
    prepareTxn
  };
  return utils$2;
}
var messenger;
var hasRequiredMessenger;
function requireMessenger() {
  if (hasRequiredMessenger) return messenger;
  hasRequiredMessenger = 1;
  class Messenger {
    /**
     * @callback onMessage
     * @param {error} err
     * @param {Object} result
     */
    /**
     * @description Callback function to send response to the window source of the message
     * @callback sendResponse
     * @param {Object} response Message response
     * @returns {void}
     */
    /**
     * @description Callback function to manage message received from the channel
        * @callback onMessageCallback
        * @param {Object} json
     * @param {Window} source
        * @param {sendResponse} cb
     * @param {Messenger} bridge
     * @returns {void}
        */
    /**
     * @description Send message options
     * @typedef {Object} sendMessageOptions
     * @property {boolean} waitForReply Wait for a reply from the recipient
     * @property {string} origin Override Window.origin
     * @property {number} timeout Timeout to wait for reply message, default 4000 msec
     */
    /**
        * @param {string} channelName  Channel Name
        * @param {onMessageCallback} [onMessageCallback] Callback function
        */
    constructor(channelName, onMessageCallback) {
      this.channelName = channelName;
      this.onMessage = onMessageCallback;
      this._installListener();
      this._requests = /* @__PURE__ */ new Map();
      this._nextId = 0;
      this._defaultTimeout = 4e3;
    }
    /**
     * @access private
     */
    _installListener() {
      const that = this;
      this._listener = function(event) {
        if (!event.data || typeof event.data !== "string") {
          return;
        }
        let json;
        try {
          json = JSON.parse(event.data);
          if (!json.channel || json.channel !== that.channelName) {
            return;
          }
          if (typeof json.message !== "object") {
            return;
          }
        } catch (err) {
          return;
        }
        if (typeof json.replyId !== "undefined") {
          if (typeof json.replyId !== "number" || json.replyId % 1 !== 0) {
            return;
          }
          const req = that._requests.get(json.replyId);
          if (req) {
            if (event.origin !== req.targetOrigin) {
              return;
            }
            clearTimeout(req.timeout);
            that._requests.delete(json.replyId);
            req.resolve(json.message);
          }
        } else {
          if (typeof json.id !== "number" || json.id % 1 !== 0 || !that.onMessage) {
            return;
          }
          const channel = that.channelName;
          const replyId = json.id;
          const origin = event.origin;
          const replyMessage = function(message) {
            const request = {
              channel,
              replyId,
              message
            };
            event.source.postMessage(
              JSON.stringify(request),
              origin
            );
          };
          that.onMessage(json.message, event.origin, event.source, replyMessage, that);
        }
      };
      window.addEventListener("message", this._listener);
    }
    /**
     * @access public
     * @description Send a message to another window
     * @param {Window} targetWindow Target Window
     * @param {Object} message Object Message
     * @param {string} origin Target origin
     * @param {sendMessageOptions} [options] Object Message
     * @returns {Promise<any>} Returns
     */
    sendMessage(targetWindow, message, origin, options) {
      let targetOrigin;
      try {
        targetOrigin = new URL(origin).origin;
      } catch (e3) {
        throw new Error("Invalid origin URL");
      }
      const request = {
        channel: this.channelName,
        id: this.getNextId(),
        message
      };
      if (options && options.waitForReply) {
        const that = this;
        return new Promise(function(resolve, reject) {
          const timeout = setTimeout(function() {
            const req = that._requests.get(request.id);
            if (req) {
              that._requests.delete(request.id);
              reject(new Error("Timeout expired for the message response"));
            }
          }, options && options.timeout ? options.timeout : that._defaultTimeout);
          that._requests.set(request.id, {
            timeout,
            resolve,
            targetOrigin
          });
          targetWindow.postMessage(
            JSON.stringify(request),
            targetOrigin
          );
        });
      }
      targetWindow.postMessage(
        JSON.stringify(request),
        targetOrigin
      );
    }
    /**
     * @access public
     * @description Close client connection
     */
    close() {
      window.removeEventListener("message", this._listener);
      this._listener = null;
      delete this._requests;
    }
    /**
     * @access private
     */
    getNextId() {
      this._nextId += 1;
      return this._nextId;
    }
  }
  messenger = Messenger;
  return messenger;
}
var communicationBridge;
var hasRequiredCommunicationBridge;
function requireCommunicationBridge() {
  if (hasRequiredCommunicationBridge) return communicationBridge;
  hasRequiredCommunicationBridge = 1;
  communicationBridge = requireMessenger();
  return communicationBridge;
}
var Messaging_1;
var hasRequiredMessaging;
function requireMessaging() {
  if (hasRequiredMessaging) return Messaging_1;
  hasRequiredMessaging = 1;
  const Messenger = requireCommunicationBridge();
  const WALLET_BRIDGE_CHANNEL_NAME = "wallet-bridge-communication-channel";
  class Messaging {
    /**
     * @description Request object
     * @typedef {Object} Request
     * @property {string} method Request method
     * @property {Object} [params] Optionally, request params
     */
    /**
     * @description Response object
     * @typedef {Object} Response
     * @property {"error"|"success"} status Response status
     * @property {string} message Response message
     * @property {Object} [data] Optionally, is the request was a success and sent data
     */
    /**
     * @description Callback function to manage message received from the channel
        * @callback onMessagingCallback
        * @param {Request} request Request received from another window
        * @param {sendResponse} cb Response callback
     * @returns {void}
        */
    /**
        * @constructor Messaging constructor
        * @param {onMessagingCallback} [listenerCallback]
        * @description Create an abstraction of Messenger class
        */
    constructor(listenerCallback) {
      const that = this;
      this.options = { waitForReply: true, timeout: 250 };
      this.listenerCallback = listenerCallback;
      this.bridge = new Messenger(WALLET_BRIDGE_CHANNEL_NAME, function(req, source, cb, bridge) {
        if (that.listenerCallback)
          that.listenerCallback(req, cb);
      });
    }
    /**
     * @access public
        * @description Send message to a target window
        * @param {Window} window Target window
        * @param {Request} request Request
        * @param {string} origin Target origin
     * @param {import("bridge-communication").sendMessageOptions} [options] Override default message options
     * @returns {Promise<Response>} Response of the target window
        */
    sendMessage(window2, request, origin, options) {
      return this.bridge.sendMessage(window2, request, origin, options ? options : this.options);
    }
    /**
     * @access public
     * @description Set new listener
     * @param {onMessagingCallback} [listenerCallback] Set a new listener or override actual listener
     * @returns {void}
     */
    setNewListener(listenerCallback) {
      this.listenerCallback = listenerCallback;
    }
    /**
     * @access public
     * @description Close bridge
     * @returns {void}
     */
    close() {
      this.bridge.close();
    }
  }
  Messaging_1 = Messaging;
  return Messaging_1;
}
var main;
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main;
  hasRequiredMain = 1;
  const { openPopup } = requirePopup();
  const { sleep, prepareTxn } = requireUtils$2();
  const { Errors, SignTxnsError } = requireErrors();
  const Messaging = requireMessaging();
  let bridge = null;
  class MyAlgoConnect2 {
    /**
     * @constructor
     * @param {Options} [options] Operation options
     */
    constructor(options) {
      if (!bridge) {
        bridge = new Messaging();
      }
      this.bridge = bridge;
      this.timeout = options && options.timeout ? options.timeout : 16e5;
      this.url = options && options.bridgeUrl ? options.bridgeUrl : "https://wallet.myalgo.com/bridge";
      if (this.url.endsWith("/"))
        this.url = this.url.slice(0, -1);
      this.currentConnectPopup = null;
      this.currentSigntxPopup = null;
      this.currentSignLogicSigPopup = null;
      this.currentTealSignPopup = null;
      this.currentSignBytesPopup = null;
      this.options = { waitForReply: true, timeout: this.timeout };
      this.disableLedgerNano = options && options.disableLedgerNano ? options.disableLedgerNano : false;
    }
    /**
     * @async
     * @access public
     * @description Open a new window to load accounts from storage.
     * @param {ConnectionSettings} settings Connect settings
     * @returns {Promise<string[]>} Returns allowed accounts by the user.
     */
    async connect(settings = { shouldSelectOneAccount: false, openManager: false }) {
      if (this.currentConnectPopup) {
        if (this.currentConnectPopup.closed) {
          this.currentConnectPopup = null;
        } else {
          this.focusWindow(this.currentConnectPopup);
        }
      }
      try {
        this.currentConnectPopup = openPopup(this.url + "/connect.html");
        await this.waitForWindowToLoad(this.currentConnectPopup);
        const res = await this.bridge.sendMessage(
          this.currentConnectPopup,
          { method: "unlock", params: Object.assign(settings, { disableLedgerNano: this.disableLedgerNano }) },
          this.url,
          this.options
        );
        this.closeWindow(this.currentConnectPopup);
        this.currentConnectPopup = null;
        if (res.status === "error")
          throw new Error(res.message);
        return res.data.accounts;
      } catch (err) {
        this.closeWindow(this.currentConnectPopup);
        this.currentConnectPopup = null;
        throw err;
      }
    }
    /**
     * @async
     * @access public
     * @description Open a new window to sign transaction.
     * @param {Transaction|Transaction[]|EncodedTransaction|EncodedTransaction[]} transaction Transaction object or a Transaction array.
     * @param {SignTransactionOptions} [signOptions] Sign transactions options object.
     * (The signer account must be the same for all transactions).
     * @returns {(SignedTx|SignedTx[])} Returns transaction blob or an Array of blobs, depends if the
     * transaction was an object or an array.
     */
    async signTransaction(transaction, signOptions) {
      let txn;
      if (this.currentSigntxPopup) {
        if (this.currentSigntxPopup.closed) {
          this.currentSigntxPopup = null;
        } else {
          this.focusWindow(this.currentSigntxPopup);
        }
      }
      if (Array.isArray(transaction))
        txn = Array.from(transaction).map((tx) => prepareTxn(tx));
      else
        txn = prepareTxn(transaction);
      try {
        this.currentSigntxPopup = openPopup(this.url + "/signtx.html");
        await this.waitForWindowToLoad(this.currentSigntxPopup);
        const res = await this.bridge.sendMessage(
          this.currentSigntxPopup,
          {
            method: "transaction",
            params: { txn, settings: { disableLedgerNano: this.disableLedgerNano }, options: signOptions }
          },
          this.url,
          this.options
        );
        this.closeWindow(this.currentSigntxPopup);
        this.currentSigntxPopup = null;
        if (res.status === "error")
          throw new Error(res.message);
        if (Array.isArray(res.data)) {
          const result = [];
          for (const t2 of res.data) {
            t2.blob = new Uint8Array(Buffer.from(t2.blob, "hex"));
            result.push(t2);
          }
          return result;
        }
        res.data.blob = new Uint8Array(Buffer.from(res.data.blob, "hex"));
        return res.data;
      } catch (err) {
        this.closeWindow(this.currentSigntxPopup);
        this.currentSigntxPopup = null;
        throw err;
      }
    }
    /**
     * @async
     * @access public
     * @description Open a new window to sign transaction.
     * @param {WalletTransaction[]} txnsToSign Transactions to sign.
     * @param {SignTxnsOpts} [opts] Sign transactions options object.
     * @returns {(SignedTxnStr|null)[]} Returns an array of base64 encoding of the SignedTxn,
     * or null where the transaction was not to be signed.
     */
    async signTxns(txnsToSign, opts) {
      if (this.currentSigntxPopup) {
        if (this.currentSigntxPopup.closed) {
          this.currentSigntxPopup = null;
        } else {
          this.focusWindow(this.currentSigntxPopup);
        }
      }
      try {
        let txns = txnsToSign;
        if (!Array.isArray(txnsToSign)) {
          txns = [txnsToSign];
        }
        this.currentSigntxPopup = openPopup(this.url + "/signtx.html");
        await this.waitForWindowToLoad(this.currentSigntxPopup);
        const res = await this.bridge.sendMessage(
          this.currentSigntxPopup,
          {
            method: "signTxns",
            params: { txns, settings: { disableLedgerNano: this.disableLedgerNano }, opts }
          },
          this.url,
          this.options
        );
        this.closeWindow(this.currentSigntxPopup);
        this.currentSigntxPopup = null;
        if (res.status === "error")
          throw new SignTxnsError(res.message, res.code, res.data);
        return res.data.map((r2) => r2 ? Buffer.from(r2.blob, "hex").toString("base64") : null);
      } catch (err) {
        this.closeWindow(this.currentSigntxPopup);
        this.currentSigntxPopup = null;
        throw err;
      }
    }
    /**
     * @async
     * @access public
     * @description Open a new window to sign a teal program.
     * @param {Uint8Array|Base64} logic LogicSig program
     * @param {Address} address Signer Address
     * @returns {Uint8Array} Returns logicsig blob
     */
    async signLogicSig(logic, address) {
      if (this.currentSignLogicSigPopup) {
        if (this.currentSignLogicSigPopup.closed) {
          this.currentSignLogicSigPopup = null;
        } else {
          this.focusWindow(this.currentSignLogicSigPopup);
        }
      }
      try {
        this.currentSignLogicSigPopup = openPopup(this.url + "/logicsigtx.html");
        await this.waitForWindowToLoad(this.currentSignLogicSigPopup);
        let logicInBase64 = logic;
        if (logic.constructor === Uint8Array)
          logicInBase64 = Buffer.from(logic).toString("base64");
        const res = await this.bridge.sendMessage(
          this.currentSignLogicSigPopup,
          { method: "logicsig", params: { logic: logicInBase64, address } },
          this.url,
          this.options
        );
        this.closeWindow(this.currentSignLogicSigPopup);
        this.currentSignLogicSigPopup = null;
        if (res.status === "error")
          throw new Error(res.message);
        return new Uint8Array(Buffer.from(res.data.signedTeal, "base64"));
      } catch (err) {
        this.closeWindow(this.currentSignLogicSigPopup);
        this.currentSignLogicSigPopup = null;
        throw err;
      }
    }
    /**
     * @async
     * @access public
     * @description Open a new window to sign data to verify in a teal program.
     * @param {Uint8Array|Base64} data Data to sign
     * @param {Address} contractAddress Address of the contract that will verify the data
     * @param {Address} address Signer Address
     * @returns {Uint8Array} Returns data signature
     */
    async tealSign(data, contractAddress, address) {
      if (this.currentTealSignPopup) {
        if (this.currentTealSignPopup.closed) {
          this.currentTealSignPopup = null;
        } else {
          this.focusWindow(this.currentTealSignPopup);
        }
      }
      try {
        this.currentTealSignPopup = openPopup(this.url + "/tealsign.html");
        await this.waitForWindowToLoad(this.currentTealSignPopup);
        let dataInBase64 = data;
        if (data.constructor === Uint8Array)
          dataInBase64 = Buffer.from(data).toString("base64");
        const res = await this.bridge.sendMessage(
          this.currentTealSignPopup,
          { method: "tealsign", params: { data: dataInBase64, contractAddress, address } },
          this.url,
          this.options
        );
        this.closeWindow(this.currentTealSignPopup);
        this.currentTealSignPopup = null;
        if (res.status === "error")
          throw new Error(res.message);
        return new Uint8Array(Buffer.from(res.data.signature, "base64"));
      } catch (err) {
        this.closeWindow(this.currentTealSignPopup);
        this.currentTealSignPopup = null;
        throw err;
      }
    }
    /**
     * @async
     * @access public
     * @description Open a new window to sign an arbitrary array of bytes.
     * @param {Uint8Array} bytes Bytes to sign
     * @param {Address} address Signer Address
     * @returns {Uint8Array} Returns bytes signature
     */
    async signBytes(bytes, address) {
      if (this.currentSignBytesPopup) {
        if (this.currentSignBytesPopup.closed) {
          this.currentSignBytesPopup = null;
        } else {
          this.focusWindow(this.currentSignBytesPopup);
        }
      }
      try {
        this.currentSignBytesPopup = openPopup(this.url + "/signbytes.html");
        await this.waitForWindowToLoad(this.currentSignBytesPopup);
        let messageInBase64 = Buffer.from(bytes).toString("base64");
        const res = await this.bridge.sendMessage(
          this.currentSignBytesPopup,
          { method: "signbytes", params: { data: messageInBase64, address } },
          this.url,
          this.options
        );
        this.closeWindow(this.currentSignBytesPopup);
        this.currentSignBytesPopup = null;
        if (res.status === "error")
          throw new Error(res.message);
        return new Uint8Array(Buffer.from(res.data.signature, "base64"));
      } catch (err) {
        this.closeWindow(this.currentSignBytesPopup);
        this.currentSignBytesPopup = null;
        throw err;
      }
    }
    /**
     * @async
     * @access private
     * @description Wait until the window opened loads.
     * @param {Window} targetWindow Window opened context.
     * @param {number} retries Times to retry before throw an error.
     * @returns {Promise<void>} Throw error if the window does not load.
     */
    async waitForWindowToLoad(targetWindow, retries = 30) {
      for (let i2 = 0; i2 < retries; i2++) {
        await sleep(300);
        if (!targetWindow) break;
        try {
          const res = await bridge.sendMessage(targetWindow, { method: "status" }, this.url);
          if (res.status == "success")
            return;
        } catch (err) {
        }
      }
      throw new Error(Errors.WINDOW_NOT_LOADED);
    }
    /**
     * @access private
     * @description Safely close an opened window
     * @param {Window} window Window object
     * @returns {void}
     */
    closeWindow(window2) {
      if (window2 && !window2.closed && window2.close) {
        window2.close();
      }
    }
    /**
     * @access private
     * @description Focus current popup
     * @param {Window} window Window object
     * @returns {void}
     * @throws {"Windows is opened"}
     */
    focusWindow(window2) {
      if (window2 && window2.focus) {
        window2.focus();
        throw new Error(Errors.WINDOW_IS_OPENED);
      } else {
        throw new Error(Errors.INVALID_WINDOW);
      }
    }
  }
  main = MyAlgoConnect2;
  return main;
}
var myalgoConnect;
var hasRequiredMyalgoConnect;
function requireMyalgoConnect() {
  if (hasRequiredMyalgoConnect) return myalgoConnect;
  hasRequiredMyalgoConnect = 1;
  myalgoConnect = requireMain();
  return myalgoConnect;
}
var myalgoConnectExports = requireMyalgoConnect();
const MyAlgoConnect = /* @__PURE__ */ getDefaultExportFromCjs(myalgoConnectExports);
var cjs$3 = {};
var cjs$2 = {};
var hasRequiredCjs$3;
function requireCjs$3() {
  if (hasRequiredCjs$3) return cjs$2;
  hasRequiredCjs$3 = 1;
  Object.defineProperty(cjs$2, "__esModule", { value: true });
  cjs$2.getLocalStorage = cjs$2.getLocalStorageOrThrow = cjs$2.getCrypto = cjs$2.getCryptoOrThrow = cjs$2.getLocation = cjs$2.getLocationOrThrow = cjs$2.getNavigator = cjs$2.getNavigatorOrThrow = cjs$2.getDocument = cjs$2.getDocumentOrThrow = cjs$2.getFromWindowOrThrow = cjs$2.getFromWindow = void 0;
  function getFromWindow2(name) {
    let res = void 0;
    if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
      res = window[name];
    }
    return res;
  }
  cjs$2.getFromWindow = getFromWindow2;
  function getFromWindowOrThrow2(name) {
    const res = getFromWindow2(name);
    if (!res) {
      throw new Error(`${name} is not defined in Window`);
    }
    return res;
  }
  cjs$2.getFromWindowOrThrow = getFromWindowOrThrow2;
  function getDocumentOrThrow2() {
    return getFromWindowOrThrow2("document");
  }
  cjs$2.getDocumentOrThrow = getDocumentOrThrow2;
  function getDocument2() {
    return getFromWindow2("document");
  }
  cjs$2.getDocument = getDocument2;
  function getNavigatorOrThrow2() {
    return getFromWindowOrThrow2("navigator");
  }
  cjs$2.getNavigatorOrThrow = getNavigatorOrThrow2;
  function getNavigator2() {
    return getFromWindow2("navigator");
  }
  cjs$2.getNavigator = getNavigator2;
  function getLocationOrThrow2() {
    return getFromWindowOrThrow2("location");
  }
  cjs$2.getLocationOrThrow = getLocationOrThrow2;
  function getLocation2() {
    return getFromWindow2("location");
  }
  cjs$2.getLocation = getLocation2;
  function getCryptoOrThrow2() {
    return getFromWindowOrThrow2("crypto");
  }
  cjs$2.getCryptoOrThrow = getCryptoOrThrow2;
  function getCrypto2() {
    return getFromWindow2("crypto");
  }
  cjs$2.getCrypto = getCrypto2;
  function getLocalStorageOrThrow2() {
    return getFromWindowOrThrow2("localStorage");
  }
  cjs$2.getLocalStorageOrThrow = getLocalStorageOrThrow2;
  function getLocalStorage2() {
    return getFromWindow2("localStorage");
  }
  cjs$2.getLocalStorage = getLocalStorage2;
  return cjs$2;
}
var hasRequiredCjs$2;
function requireCjs$2() {
  if (hasRequiredCjs$2) return cjs$3;
  hasRequiredCjs$2 = 1;
  Object.defineProperty(cjs$3, "__esModule", { value: true });
  cjs$3.getWindowMetadata = void 0;
  const window_getters_1 = requireCjs$3();
  function getWindowMetadata() {
    let doc;
    let loc;
    try {
      doc = window_getters_1.getDocumentOrThrow();
      loc = window_getters_1.getLocationOrThrow();
    } catch (e3) {
      return null;
    }
    function getIcons() {
      const links = doc.getElementsByTagName("link");
      const icons2 = [];
      for (let i2 = 0; i2 < links.length; i2++) {
        const link = links[i2];
        const rel = link.getAttribute("rel");
        if (rel) {
          if (rel.toLowerCase().indexOf("icon") > -1) {
            const href = link.getAttribute("href");
            if (href) {
              if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                let absoluteHref = loc.protocol + "//" + loc.host;
                if (href.indexOf("/") === 0) {
                  absoluteHref += href;
                } else {
                  const path2 = loc.pathname.split("/");
                  path2.pop();
                  const finalPath = path2.join("/");
                  absoluteHref += finalPath + "/" + href;
                }
                icons2.push(absoluteHref);
              } else if (href.indexOf("//") === 0) {
                const absoluteUrl = loc.protocol + href;
                icons2.push(absoluteUrl);
              } else {
                icons2.push(href);
              }
            }
          }
        }
      }
      return icons2;
    }
    function getWindowMetadataOfAny(...args) {
      const metaTags = doc.getElementsByTagName("meta");
      for (let i2 = 0; i2 < metaTags.length; i2++) {
        const tag = metaTags[i2];
        const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
          if (attr) {
            return args.includes(attr);
          }
          return false;
        });
        if (attributes.length && attributes) {
          const content = tag.getAttribute("content");
          if (content) {
            return content;
          }
        }
      }
      return "";
    }
    function getName() {
      let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
      if (!name2) {
        name2 = doc.title;
      }
      return name2;
    }
    function getDescription() {
      const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
      return description2;
    }
    const name = getName();
    const description = getDescription();
    const url = loc.origin;
    const icons = getIcons();
    const meta = {
      description,
      url,
      icons,
      name
    };
    return meta;
  }
  cjs$3.getWindowMetadata = getWindowMetadata;
  return cjs$3;
}
var cjsExports$3 = requireCjs$2();
var cjsExports$2 = requireCjs$3();
var __spreadArrays$1 = function() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
};
var BrowserInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BrowserInfo2(name, version2, os) {
      this.name = name;
      this.version = version2;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  })()
);
var NodeInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function NodeInfo2(version2) {
      this.version = version2;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  })()
);
var SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function SearchBotDeviceInfo2(name, version2, os, bot) {
      this.name = name;
      this.version = version2;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  })()
);
var BotInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  })()
);
var ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  })()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FBAV\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser2 = _a[0], regex2 = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex2.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays$1(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os = detectOS$1(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version2, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version2, os);
}
function detectOS$1(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os = _a[0], regex2 = _a[1];
    var match = regex2.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}
function detectEnv(userAgent) {
  return detect(userAgent);
}
function detectOS() {
  const env2 = detectEnv();
  return env2 && env2.os ? env2.os : void 0;
}
function isAndroid() {
  const os = detectOS();
  return os ? os.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os = detectOS();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os = detectOS();
  return os ? isAndroid() || isIOS() : false;
}
function isNode$1() {
  const env2 = detectEnv();
  const result = env2 && env2.name ? env2.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser() {
  const result = !isNode$1() && !!getNavigator();
  return result;
}
const getFromWindow = cjsExports$2.getFromWindow;
const getFromWindowOrThrow = cjsExports$2.getFromWindowOrThrow;
const getDocumentOrThrow = cjsExports$2.getDocumentOrThrow;
const getDocument = cjsExports$2.getDocument;
const getNavigatorOrThrow = cjsExports$2.getNavigatorOrThrow;
const getNavigator = cjsExports$2.getNavigator;
const getLocationOrThrow = cjsExports$2.getLocationOrThrow;
const getLocation = cjsExports$2.getLocation;
const getCryptoOrThrow = cjsExports$2.getCryptoOrThrow;
const getCrypto = cjsExports$2.getCrypto;
const getLocalStorageOrThrow = cjsExports$2.getLocalStorageOrThrow;
const getLocalStorage = cjsExports$2.getLocalStorage;
function getClientMeta() {
  return cjsExports$3.getWindowMetadata();
}
function safeJsonParse$1(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSON.parse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify$1(value) {
  return typeof value === "string" ? value : JSON.stringify(value);
}
const safeJsonParse = safeJsonParse$1;
const safeJsonStringify = safeJsonStringify$1;
function setLocal(key, data) {
  const raw = safeJsonStringify(data);
  const local = getLocalStorage();
  if (local) {
    local.setItem(key, raw);
  }
}
function getLocal(key) {
  let data = null;
  let raw = null;
  const local = getLocalStorage();
  if (local) {
    raw = local.getItem(key);
  }
  data = raw ? safeJsonParse(raw) : raw;
  return data;
}
function removeLocal(key) {
  const local = getLocalStorage();
  if (local) {
    local.removeItem(key);
  }
}
const mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
function formatIOSMobile(uri, entry) {
  const encodedUri = encodeURIComponent(uri);
  return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
}
function saveMobileLinkInfo(data) {
  const focusUri = data.href.split("?")[0];
  setLocal(mobileLinkChoiceKey, Object.assign(Object.assign({}, data), { href: focusUri }));
}
function getMobileRegistryEntry(registry, name) {
  return registry.filter((entry) => entry.name.toLowerCase().includes(name.toLowerCase()))[0];
}
function getMobileLinkRegistry(registry, whitelist) {
  let links = registry;
  if (whitelist) {
    links = whitelist.map((name) => getMobileRegistryEntry(registry, name)).filter(Boolean);
  }
  return links;
}
const API_URL = "https://registry.walletconnect.com";
function getWalletRegistryUrl() {
  return API_URL + "/api/v2/wallets";
}
function getDappRegistryUrl() {
  return API_URL + "/api/v2/dapps";
}
function formatMobileRegistryEntry(entry, platform = "mobile") {
  var _a;
  return {
    name: entry.name || "",
    shortName: entry.metadata.shortName || "",
    color: entry.metadata.colors.primary || "",
    logo: (_a = entry.image_url.sm) !== null && _a !== void 0 ? _a : "",
    universalLink: entry[platform].universal || "",
    deepLink: entry[platform].native || ""
  };
}
function formatMobileRegistry(registry, platform = "mobile") {
  return Object.values(registry).filter((entry) => !!entry[platform].universal || !!entry[platform].native).map((entry) => formatMobileRegistryEntry(entry, platform));
}
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  detectEnv,
  detectOS,
  formatIOSMobile,
  formatMobileRegistry,
  formatMobileRegistryEntry,
  getClientMeta,
  getCrypto,
  getCryptoOrThrow,
  getDappRegistryUrl,
  getDocument,
  getDocumentOrThrow,
  getFromWindow,
  getFromWindowOrThrow,
  getLocal,
  getLocalStorage,
  getLocalStorageOrThrow,
  getLocation,
  getLocationOrThrow,
  getMobileLinkRegistry,
  getMobileRegistryEntry,
  getNavigator,
  getNavigatorOrThrow,
  getWalletRegistryUrl,
  isAndroid,
  isBrowser,
  isIOS,
  isMobile,
  isNode: isNode$1,
  mobileLinkChoiceKey,
  removeLocal,
  safeJsonParse,
  safeJsonStringify,
  saveMobileLinkInfo,
  setLocal
}, Symbol.toStringTag, { value: "Module" }));
const reservedEvents = [
  "session_request",
  "session_update",
  "exchange_key",
  "connect",
  "disconnect",
  "display_uri",
  "modal_closed",
  "transport_open",
  "transport_close",
  "transport_error"
];
const signingMethods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v1",
  "eth_signTypedData_v2",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "personal_sign",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode"
];
var bn$1 = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var bn = bn$1.exports;
var hasRequiredBn;
function requireBn() {
  if (hasRequiredBn) return bn$1.exports;
  hasRequiredBn = 1;
  (function(module) {
    (function(module2, exports) {
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number2, base, endian) {
        if (BN2.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number2 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require$$0$2.Buffer;
      } catch (e3) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN2.prototype._init = function init(number2, base, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number2, start);
        } else {
          this._parseBase(number2, base, start);
        }
        if (number2[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initNumber = function _initNumber(number2, base, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number2, base, endian) {
        assert(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j2, w2;
        var off = 0;
        if (endian === "be") {
          for (i2 = number2.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
            w2 = number2[i2] | number2[i2 - 1] << 8 | number2[i2 - 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j2 = 0; i2 < number2.length; i2 += 3) {
            w2 = number2[i2] | number2[i2 + 1] << 8 | number2[i2 + 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r2 = 0;
        var len = Math.min(str.length, end);
        for (var i2 = start; i2 < len; i2++) {
          var c2 = str.charCodeAt(i2) - 48;
          r2 <<= 4;
          if (c2 >= 49 && c2 <= 54) {
            r2 |= c2 - 49 + 10;
          } else if (c2 >= 17 && c2 <= 22) {
            r2 |= c2 - 17 + 10;
          } else {
            r2 |= c2 & 15;
          }
        }
        return r2;
      }
      BN2.prototype._parseHex = function _parseHex(number2, start) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j2, w2;
        var off = 0;
        for (i2 = number2.length - 6, j2 = 0; i2 >= start; i2 -= 6) {
          w2 = parseHex(number2, i2, i2 + 6);
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] |= w2 >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
        if (i2 + 6 !== start) {
          w2 = parseHex(number2, start, i2 + 6);
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] |= w2 >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r2 = 0;
        var len = Math.min(str.length, end);
        for (var i2 = start; i2 < len; i2++) {
          var c2 = str.charCodeAt(i2) - 48;
          r2 *= mul;
          if (c2 >= 49) {
            r2 += c2 - 49 + 10;
          } else if (c2 >= 17) {
            r2 += c2 - 17 + 10;
          } else {
            r2 += c2;
          }
        }
        return r2;
      }
      BN2.prototype._parseBase = function _parseBase(number2, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number2.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number2, i2, i2 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow2 = 1;
          word = parseBase(number2, i2, number2.length, base);
          for (i2 = 0; i2 < mod; i2++) {
            pow2 *= base;
          }
          this.imuln(pow2);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN2.prototype.copy = function copy2(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone2() {
        var r2 = new BN2(null);
        this.copy(r2);
        return r2;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString2(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w2 = this.words[i2];
            var word = ((w2 << off | carry) & 16777215).toString(16);
            carry = w2 >>> 24 - off & 16777215;
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c2 = this.clone();
          c2.negative = 0;
          while (!c2.isZero()) {
            var r2 = c2.modn(groupBase).toString(base);
            c2 = c2.idivn(groupBase);
            if (!c2.isZero()) {
              out = zeros[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber2() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b2, i2;
        var q2 = this.clone();
        if (!littleEndian) {
          for (i2 = 0; i2 < reqLength - byteLength; i2++) {
            res[i2] = 0;
          }
          for (i2 = 0; !q2.isZero(); i2++) {
            b2 = q2.andln(255);
            q2.iushrn(8);
            res[reqLength - i2 - 1] = b2;
          }
        } else {
          for (i2 = 0; !q2.isZero(); i2++) {
            b2 = q2.andln(255);
            q2.iushrn(8);
            res[i2] = b2;
          }
          for (; i2 < reqLength; i2++) {
            res[i2] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w2) {
          return 32 - Math.clz32(w2);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w2) {
          var t2 = w2;
          var r2 = 0;
          if (t2 >= 4096) {
            r2 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r2 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r2 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r2 += 2;
            t2 >>>= 2;
          }
          return r2 + t2;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w2) {
        if (w2 === 0) return 26;
        var t2 = w2;
        var r2 = 0;
        if ((t2 & 8191) === 0) {
          r2 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r2 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r2 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r2 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w2 = this.words[this.length - 1];
        var hi = this._countBits(w2);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w2 = new Array(num.bitLength());
        for (var bit = 0; bit < w2.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w2[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w2;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r2 = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b2 = this._zeroBits(this.words[i2]);
          r2 += b2;
          if (b2 !== 26) break;
        }
        return r2;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i2 = 0; i2 < b2.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b2.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a2;
        var b2;
        if (this.length > num.length) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        for (var i2 = 0; i2 < b2.length; i2++) {
          this.words[i2] = a2.words[i2] ^ b2.words[i2];
        }
        if (this !== a2) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = a2.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a2, b2;
        if (this.length > num.length) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b2.length; i2++) {
          r2 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r2 = (a2.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a2.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        return this;
      };
      BN2.prototype.add = function add2(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a2, b2;
        if (cmp > 0) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b2.length; i2++) {
          r2 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r2 = (a2.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        if (carry === 0 && i2 < a2.length && a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a2 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a2 = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r2 = a2 * b2;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i2 = k2 - j2 | 0;
            a2 = self2.words[i2] | 0;
            b2 = num.words[j2] | 0;
            r2 = a2 * b2 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a2 = self2.words;
        var b2 = num.words;
        var o2 = out.words;
        var c2 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a2[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a2[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a2[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a3 = a2[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a2[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a2[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a2[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a2[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a2[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a2[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o2[0] = w0;
        o2[1] = w1;
        o2[2] = w2;
        o2[3] = w3;
        o2[4] = w4;
        o2[5] = w5;
        o2[6] = w6;
        o2[7] = w7;
        o2[8] = w8;
        o2[9] = w9;
        o2[10] = w10;
        o2[11] = w11;
        o2[12] = w12;
        o2[13] = w13;
        o2[14] = w14;
        o2[15] = w15;
        o2[16] = w16;
        o2[17] = w17;
        o2[18] = w18;
        if (c2 !== 0) {
          o2[19] = c2;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i2 = k2 - j2;
            var a2 = self2.words[i2] | 0;
            var b2 = num.words[j2] | 0;
            var r2 = a2 * b2;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x2, y2) {
        this.x = x2;
        this.y = y2;
      }
      FFTM.prototype.makeRBT = function makeRBT(N2) {
        var t2 = new Array(N2);
        var l2 = BN2.prototype._countBits(N2) - 1;
        for (var i2 = 0; i2 < N2; i2++) {
          t2[i2] = this.revBin(i2, l2, N2);
        }
        return t2;
      };
      FFTM.prototype.revBin = function revBin(x2, l2, N2) {
        if (x2 === 0 || x2 === N2 - 1) return x2;
        var rb = 0;
        for (var i2 = 0; i2 < l2; i2++) {
          rb |= (x2 & 1) << l2 - i2 - 1;
          x2 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
        for (var i2 = 0; i2 < N2; i2++) {
          rtws[i2] = rws[rbt[i2]];
          itws[i2] = iws[rbt[i2]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N2);
        for (var s2 = 1; s2 < N2; s2 <<= 1) {
          var l2 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l2);
          var itwdf = Math.sin(2 * Math.PI / l2);
          for (var p2 = 0; p2 < N2; p2 += l2) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j2 = 0; j2 < s2; j2++) {
              var re2 = rtws[p2 + j2];
              var ie = itws[p2 + j2];
              var ro = rtws[p2 + j2 + s2];
              var io = itws[p2 + j2 + s2];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p2 + j2] = re2 + ro;
              itws[p2 + j2] = ie + io;
              rtws[p2 + j2 + s2] = re2 - ro;
              itws[p2 + j2 + s2] = ie - io;
              if (j2 !== l2) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m2) {
        var N2 = Math.max(m2, n2) | 1;
        var odd = N2 & 1;
        var i2 = 0;
        for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
          i2++;
        }
        return 1 << i2 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
        if (N2 <= 1) return;
        for (var i2 = 0; i2 < N2 / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N2 - i2 - 1];
          rws[N2 - i2 - 1] = t2;
          t2 = iws[i2];
          iws[i2] = -iws[N2 - i2 - 1];
          iws[N2 - i2 - 1] = -t2;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
        var carry = 0;
        for (var i2 = 0; i2 < N2 / 2; i2++) {
          var w2 = Math.round(ws[2 * i2 + 1] / N2) * 8192 + Math.round(ws[2 * i2] / N2) + carry;
          ws[i2] = w2 & 67108863;
          if (w2 < 67108864) {
            carry = 0;
          } else {
            carry = w2 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
        var carry = 0;
        for (var i2 = 0; i2 < len; i2++) {
          carry = carry + (ws[i2] | 0);
          rws[2 * i2] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i2 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i2 = 2 * len; i2 < N2; ++i2) {
          rws[i2] = 0;
        }
        assert(carry === 0);
        assert((carry & -8192) === 0);
      };
      FFTM.prototype.stub = function stub(N2) {
        var ph = new Array(N2);
        for (var i2 = 0; i2 < N2; i2++) {
          ph[i2] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x2, y2, out) {
        var N2 = 2 * this.guessLen13b(x2.length, y2.length);
        var rbt = this.makeRBT(N2);
        var _2 = this.stub(N2);
        var rws = new Array(N2);
        var rwst = new Array(N2);
        var iwst = new Array(N2);
        var nrws = new Array(N2);
        var nrwst = new Array(N2);
        var niwst = new Array(N2);
        var rmws = out.words;
        rmws.length = N2;
        this.convert13b(x2.words, x2.length, rws, N2);
        this.convert13b(y2.words, y2.length, nrws, N2);
        this.transform(rws, _2, rwst, iwst, N2, rbt);
        this.transform(nrws, _2, nrwst, niwst, N2, rbt);
        for (var i2 = 0; i2 < N2; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
          rwst[i2] = rx;
        }
        this.conjugate(rwst, iwst, N2);
        this.transform(rwst, iwst, rmws, _2, N2, rbt);
        this.conjugate(rmws, _2, N2);
        this.normalize13b(rmws, N2);
        out.negative = x2.negative ^ y2.negative;
        out.length = x2.length + y2.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w2 = (this.words[i2] | 0) * num;
          var lo = (w2 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w2 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow2(num) {
        var w2 = toBitArray(num);
        if (w2.length === 0) return new BN2(1);
        var res = this;
        for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
          if (w2[i2] !== 0) break;
        }
        if (++i2 < w2.length) {
          for (var q2 = res.sqr(); i2 < w2.length; i2++, q2 = q2.sqr()) {
            if (w2[i2] === 0) continue;
            res = res.mul(q2);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i2;
        if (r2 !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c2 = (this.words[i2] | 0) - newCarry << r2;
            this.words[i2] = c2 | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s2] = this.words[i2];
          }
          for (i2 = 0; i2 < s2; i2++) {
            this.words[i2] = 0;
          }
          this.length += s2;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h2;
        if (hint) {
          h2 = (hint - hint % 26) / 26;
        } else {
          h2 = 0;
        }
        var r2 = bits % 26;
        var s2 = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h2 -= s2;
        h2 = Math.max(0, h2);
        if (maskedWords) {
          for (var i2 = 0; i2 < s2; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) ;
        else if (this.length > s2) {
          this.length -= s2;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q2 = 1 << r2;
        if (this.length <= s2) return false;
        var w2 = this.words[s2];
        return !!(w2 & q2);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r2 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i2;
        this._expand(len);
        var w2;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w2 = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w2 -= right & 67108863;
          carry = (w2 >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w2 & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w2 = (this.words[i2 + shift] | 0) + carry;
          carry = w2 >> 26;
          this.words[i2 + shift] = w2 & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w2 = -(this.words[i2] | 0) + carry;
          carry = w2 >> 26;
          this.words[i2] = w2 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode2) {
        var shift = this.length - num.length;
        var a2 = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a2.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m2 = a2.length - b2.length;
        var q2;
        if (mode2 !== "mod") {
          q2 = new BN2(null);
          q2.length = m2 + 1;
          q2.words = new Array(q2.length);
          for (var i2 = 0; i2 < q2.length; i2++) {
            q2.words[i2] = 0;
          }
        }
        var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
        if (diff.negative === 0) {
          a2 = diff;
          if (q2) {
            q2.words[m2] = 1;
          }
        }
        for (var j2 = m2 - 1; j2 >= 0; j2--) {
          var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a2._ishlnsubmul(b2, qj, j2);
          while (a2.negative !== 0) {
            qj--;
            a2.negative = 0;
            a2._ishlnsubmul(b2, 1, j2);
            if (!a2.isZero()) {
              a2.negative ^= 1;
            }
          }
          if (q2) {
            q2.words[j2] = qj;
          }
        }
        if (q2) {
          q2.strip();
        }
        a2.strip();
        if (mode2 !== "div" && shift !== 0) {
          a2.iushrn(shift);
        }
        return {
          div: q2 || null,
          mod: a2
        };
      };
      BN2.prototype.divmod = function divmod(num, mode2, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode2);
          if (mode2 !== "mod") {
            div = res.div.neg();
          }
          if (mode2 !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode2);
          if (mode2 !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode2);
          if (mode2 !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode2 === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode2 === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode2);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p2 = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p2 * acc + (this.words[i2] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w2 = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w2 / num | 0;
          carry = w2 % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p2) {
        assert(p2.negative === 0);
        assert(!p2.isZero());
        var x2 = this;
        var y2 = p2.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p2);
        } else {
          x2 = x2.clone();
        }
        var A2 = new BN2(1);
        var B2 = new BN2(0);
        var C2 = new BN2(0);
        var D2 = new BN2(1);
        var g2 = 0;
        while (x2.isEven() && y2.isEven()) {
          x2.iushrn(1);
          y2.iushrn(1);
          ++g2;
        }
        var yp = y2.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
          if (i2 > 0) {
            x2.iushrn(i2);
            while (i2-- > 0) {
              if (A2.isOdd() || B2.isOdd()) {
                A2.iadd(yp);
                B2.isub(xp);
              }
              A2.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            y2.iushrn(j2);
            while (j2-- > 0) {
              if (C2.isOdd() || D2.isOdd()) {
                C2.iadd(yp);
                D2.isub(xp);
              }
              C2.iushrn(1);
              D2.iushrn(1);
            }
          }
          if (x2.cmp(y2) >= 0) {
            x2.isub(y2);
            A2.isub(C2);
            B2.isub(D2);
          } else {
            y2.isub(x2);
            C2.isub(A2);
            D2.isub(B2);
          }
        }
        return {
          a: C2,
          b: D2,
          gcd: y2.iushln(g2)
        };
      };
      BN2.prototype._invmp = function _invmp(p2) {
        assert(p2.negative === 0);
        assert(!p2.isZero());
        var a2 = this;
        var b2 = p2.clone();
        if (a2.negative !== 0) {
          a2 = a2.umod(p2);
        } else {
          a2 = a2.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b2.clone();
        while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
          if (i2 > 0) {
            a2.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            b2.iushrn(j2);
            while (j2-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a2.cmp(b2) >= 0) {
            a2.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a2);
            x2.isub(x1);
          }
        }
        var res;
        if (a2.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p2);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a2 = this.clone();
        var b2 = num.clone();
        a2.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
          a2.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a2.isEven()) {
            a2.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r2 = a2.cmp(b2);
          if (r2 < 0) {
            var t2 = a2;
            a2 = b2;
            b2 = t2;
          } else if (r2 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a2.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q2 = 1 << r2;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q2;
          return this;
        }
        var carry = q2;
        for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
          var w2 = this.words[i2] | 0;
          w2 += carry;
          carry = w2 >>> 26;
          w2 &= 67108863;
          this.words[i2] = w2;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w2 = this.words[0] | 0;
          res = w2 === num ? 0 : w2 < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a2 = this.words[i2] | 0;
          var b2 = num.words[i2] | 0;
          if (a2 === b2) continue;
          if (a2 < b2) {
            res = -1;
          } else if (a2 > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq2(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p2) {
        this.name = name;
        this.p = new BN2(p2, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          r2.strip();
        }
        return r2;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output.words[i2] = input.words[i2];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10; i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i2 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w2 = num.words[i2] | 0;
          lo += w2 * 977;
          num.words[i2] = lo & 67108863;
          lo = w2 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime = BN2._prime(m2);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m2.gtn(1), "modulus must be greater than 1");
          this.m = m2;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a2) {
        assert(a2.negative === 0, "red works only with positives");
        assert(a2.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a2, b2) {
        assert((a2.negative | b2.negative) === 0, "red works only with positives");
        assert(
          a2.red && a2.red === b2.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a2) {
        if (this.prime) return this.prime.ireduce(a2)._forceRed(this);
        return a2.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a2) {
        if (a2.isZero()) {
          return a2.clone();
        }
        return this.m.sub(a2)._forceRed(this);
      };
      Red.prototype.add = function add2(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a2, num) {
        this._verify1(a2);
        return this.imod(a2.ushln(num));
      };
      Red.prototype.imul = function imul(a2, b2) {
        this._verify2(a2, b2);
        return this.imod(a2.imul(b2));
      };
      Red.prototype.mul = function mul(a2, b2) {
        this._verify2(a2, b2);
        return this.imod(a2.mul(b2));
      };
      Red.prototype.isqr = function isqr(a2) {
        return this.imul(a2, a2.clone());
      };
      Red.prototype.sqr = function sqr(a2) {
        return this.mul(a2, a2);
      };
      Red.prototype.sqrt = function sqrt2(a2) {
        if (a2.isZero()) return a2.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow2 = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a2, pow2);
        }
        var q2 = this.m.subn(1);
        var s2 = 0;
        while (!q2.isZero() && q2.andln(1) === 0) {
          s2++;
          q2.iushrn(1);
        }
        assert(!q2.isZero());
        var one2 = new BN2(1).toRed(this);
        var nOne = one2.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z2 = this.m.bitLength();
        z2 = new BN2(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0) {
          z2.redIAdd(nOne);
        }
        var c2 = this.pow(z2, q2);
        var r2 = this.pow(a2, q2.addn(1).iushrn(1));
        var t2 = this.pow(a2, q2);
        var m2 = s2;
        while (t2.cmp(one2) !== 0) {
          var tmp = t2;
          for (var i2 = 0; tmp.cmp(one2) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert(i2 < m2);
          var b2 = this.pow(c2, new BN2(1).iushln(m2 - i2 - 1));
          r2 = r2.redMul(b2);
          c2 = b2.redSqr();
          t2 = t2.redMul(c2);
          m2 = i2;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a2) {
        var inv = a2._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow2(a2, num) {
        if (num.isZero()) return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0) return a2.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a2;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a2);
        }
        var res = wnd[0];
        var current2 = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j2 = start - 1; j2 >= 0; j2--) {
            var bit = word >> j2 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current2 === 0) {
              currentLen = 0;
              continue;
            }
            current2 <<= 1;
            current2 |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0)) continue;
            res = this.mul(res, wnd[current2]);
            currentLen = 0;
            current2 = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        Red.call(this, m2);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a2, b2) {
        if (a2.isZero() || b2.isZero()) {
          a2.words[0] = 0;
          a2.length = 1;
          return a2;
        }
        var t2 = a2.imul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a2, b2) {
        if (a2.isZero() || b2.isZero()) return new BN2(0)._forceRed(this);
        var t2 = a2.mul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a2) {
        var res = this.imod(a2._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module, bn);
  })(bn$1);
  return bn$1.exports;
}
var bnExports = requireBn();
const BN = /* @__PURE__ */ getDefaultExportFromCjs(bnExports);
var isTypedarray;
var hasRequiredIsTypedarray;
function requireIsTypedarray() {
  if (hasRequiredIsTypedarray) return isTypedarray;
  hasRequiredIsTypedarray = 1;
  isTypedarray = isTypedArray2;
  isTypedArray2.strict = isStrictTypedArray;
  isTypedArray2.loose = isLooseTypedArray;
  var toString2 = Object.prototype.toString;
  var names = {
    "[object Int8Array]": true,
    "[object Int16Array]": true,
    "[object Int32Array]": true,
    "[object Uint8Array]": true,
    "[object Uint8ClampedArray]": true,
    "[object Uint16Array]": true,
    "[object Uint32Array]": true,
    "[object Float32Array]": true,
    "[object Float64Array]": true
  };
  function isTypedArray2(arr) {
    return isStrictTypedArray(arr) || isLooseTypedArray(arr);
  }
  function isStrictTypedArray(arr) {
    return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
  }
  function isLooseTypedArray(arr) {
    return names[toString2.call(arr)];
  }
  return isTypedarray;
}
requireIsTypedarray();
var typedarrayToBuffer;
var hasRequiredTypedarrayToBuffer;
function requireTypedarrayToBuffer() {
  if (hasRequiredTypedarrayToBuffer) return typedarrayToBuffer;
  hasRequiredTypedarrayToBuffer = 1;
  var isTypedArray2 = requireIsTypedarray().strict;
  typedarrayToBuffer = function typedarrayToBuffer2(arr) {
    if (isTypedArray2(arr)) {
      var buf = Buffer.from(arr.buffer);
      if (arr.byteLength !== arr.buffer.byteLength) {
        buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
      }
      return buf;
    } else {
      return Buffer.from(arr);
    }
  };
  return typedarrayToBuffer;
}
var typedarrayToBufferExports = requireTypedarrayToBuffer();
const typedArrayToBuffer = /* @__PURE__ */ getDefaultExportFromCjs(typedarrayToBufferExports);
const ENC_HEX = "hex";
const ENC_UTF8 = "utf8";
const STRING_ZERO = "0";
function bufferToArray(buf) {
  return new Uint8Array(buf);
}
function bufferToHex(buf, prefixed = false) {
  const hex2 = buf.toString(ENC_HEX);
  return prefixed ? addHexPrefix(hex2) : hex2;
}
function bufferToUtf8(buf) {
  return buf.toString(ENC_UTF8);
}
function arrayToBuffer(arr) {
  return typedArrayToBuffer(arr);
}
function arrayToHex(arr, prefixed = false) {
  return bufferToHex(arrayToBuffer(arr), prefixed);
}
function arrayToUtf8(arr) {
  return bufferToUtf8(arrayToBuffer(arr));
}
function hexToBuffer(hex2) {
  return Buffer.from(removeHexPrefix(hex2), ENC_HEX);
}
function hexToArray(hex2) {
  return bufferToArray(hexToBuffer(hex2));
}
function utf8ToBuffer(utf8) {
  return Buffer.from(utf8, ENC_UTF8);
}
function utf8ToArray(utf8) {
  return bufferToArray(utf8ToBuffer(utf8));
}
function utf8ToHex(utf8, prefixed = false) {
  return bufferToHex(utf8ToBuffer(utf8), prefixed);
}
function isHexString$1(str, length) {
  if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  return true;
}
function concatArrays$1(...args) {
  let result = [];
  args.forEach((arg) => result = result.concat(Array.from(arg)));
  return new Uint8Array([...result]);
}
function calcByteLength(length, byteSize = 8) {
  const remainder = length % byteSize;
  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
}
function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
  return padLeft(str, calcByteLength(str.length, byteSize), padding);
}
function padLeft(str, length, padding = STRING_ZERO) {
  return padString(str, length, true, padding);
}
function removeHexPrefix(hex2) {
  return hex2.replace(/^0x/, "");
}
function addHexPrefix(hex2) {
  return hex2.startsWith("0x") ? hex2 : `0x${hex2}`;
}
function sanitizeHex$1(hex2) {
  hex2 = removeHexPrefix(hex2);
  hex2 = sanitizeBytes(hex2, 2);
  if (hex2) {
    hex2 = addHexPrefix(hex2);
  }
  return hex2;
}
function removeHexLeadingZeros$1(hex2) {
  const prefixed = hex2.startsWith("0x");
  hex2 = removeHexPrefix(hex2);
  hex2 = hex2.startsWith(STRING_ZERO) ? hex2.substring(1) : hex2;
  return prefixed ? addHexPrefix(hex2) : hex2;
}
function padString(str, length, left, padding = STRING_ZERO) {
  const diff = length - str.length;
  let result = str;
  if (diff > 0) {
    const pad2 = padding.repeat(diff);
    result = pad2 + str;
  }
  return result;
}
function convertArrayBufferToBuffer(arrBuf) {
  return arrayToBuffer(new Uint8Array(arrBuf));
}
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return arrayToHex(new Uint8Array(arrBuf), false);
}
function convertBufferToArrayBuffer(buf) {
  return bufferToArray(buf).buffer;
}
function convertUtf8ToBuffer(utf8) {
  return utf8ToBuffer(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return utf8ToHex(utf8, true);
}
function convertHexToArrayBuffer(hex2) {
  return hexToArray(hex2).buffer;
}
function convertNumberToHex(num, noPrefix) {
  const hex2 = removeHexPrefix(sanitizeHex$1(new BN(num).toString(16)));
  return noPrefix ? hex2 : addHexPrefix(hex2);
}
var sha3 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
var hasRequiredSha3;
function requireSha3() {
  if (hasRequiredSha3) return sha3.exports;
  hasRequiredSha3 = 1;
  (function(module) {
    (function() {
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = globalThis;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module.exports;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n2, s2) {
          return methods["cshake" + bits2].update(message, outputBits, n2, s2)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message, outputBits, s2) {
          return methods["kmac" + bits2].update(key, message, outputBits, s2)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding) {
        for (var i22 = 0; i22 < OUTPUT_TYPES.length; ++i22) {
          var type = OUTPUT_TYPES[i22];
          method[type] = createMethod2(bits2, padding, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w2 = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n2, s2) {
          if (!n2 && !s2) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n2, s2], w2);
          }
        };
        method.update = function(message, outputBits, n2, s2) {
          return method.create(outputBits, n2, s2).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w2 = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key, outputBits, s2) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s2], w2).bytepad([key], w2);
        };
        method.update = function(key, message, outputBits, s2) {
          return method.create(key, outputBits, s2).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i2 = 0; i2 < algorithms.length; ++i2) {
        var algorithm = algorithms[i2];
        var bits = algorithm.bits;
        for (var j2 = 0; j2 < bits.length; ++j2) {
          var methodName = algorithm.name + "_" + bits[j2];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j2], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j2];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i22 = 0; i22 < 50; ++i22) {
          this.s[i22] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s2 = this.s, i22, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i22 = 1; i22 < blockCount + 1; ++i22) {
              blocks[i22] = 0;
            }
          }
          if (notString) {
            for (i22 = this.start; index < length && i22 < byteCount; ++index) {
              blocks[i22 >> 2] |= message[index] << SHIFT[i22++ & 3];
            }
          } else {
            for (i22 = this.start; index < length && i22 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i22 >> 2] |= code << SHIFT[i22++ & 3];
              } else if (code < 2048) {
                blocks[i22 >> 2] |= (192 | code >> 6) << SHIFT[i22++ & 3];
                blocks[i22 >> 2] |= (128 | code & 63) << SHIFT[i22++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i22 >> 2] |= (224 | code >> 12) << SHIFT[i22++ & 3];
                blocks[i22 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i22++ & 3];
                blocks[i22 >> 2] |= (128 | code & 63) << SHIFT[i22++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i22 >> 2] |= (240 | code >> 18) << SHIFT[i22++ & 3];
                blocks[i22 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i22++ & 3];
                blocks[i22 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i22++ & 3];
                blocks[i22 >> 2] |= (128 | code & 63) << SHIFT[i22++ & 3];
              }
            }
          }
          this.lastByteIndex = i22;
          if (i22 >= byteCount) {
            this.start = i22 - byteCount;
            this.block = blocks[blockCount];
            for (i22 = 0; i22 < blockCount; ++i22) {
              s2[i22] ^= blocks[i22];
            }
            f2(s2);
            this.reset = true;
          } else {
            this.start = i22;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x2, right) {
        var o2 = x2 & 255, n2 = 1;
        var bytes = [o2];
        x2 = x2 >> 8;
        o2 = x2 & 255;
        while (o2 > 0) {
          bytes.unshift(o2);
          x2 = x2 >> 8;
          o2 = x2 & 255;
          ++n2;
        }
        if (right) {
          bytes.push(n2);
        } else {
          bytes.unshift(n2);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i22 = 0; i22 < str.length; ++i22) {
            var code = str.charCodeAt(i22);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i22) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w2) {
        var bytes = this.encode(w2);
        for (var i22 = 0; i22 < strs.length; ++i22) {
          bytes += this.encodeString(strs[i22]);
        }
        var paddingBytes = w2 - bytes % w2;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i22 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
        blocks[i22 >> 2] |= this.padding[i22 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i22 = 1; i22 < blockCount + 1; ++i22) {
            blocks[i22] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i22 = 0; i22 < blockCount; ++i22) {
          s2[i22] ^= blocks[i22];
        }
        f2(s2);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i22 = 0, j22 = 0;
        var hex2 = "", block;
        while (j22 < outputBlocks) {
          for (i22 = 0; i22 < blockCount && j22 < outputBlocks; ++i22, ++j22) {
            block = s2[i22];
            hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j22 % blockCount === 0) {
            f2(s2);
            i22 = 0;
          }
        }
        if (extraBytes) {
          block = s2[i22];
          hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex2 += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex2 += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex2;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i22 = 0, j22 = 0;
        var bytes = this.outputBits >> 3;
        var buffer2;
        if (extraBytes) {
          buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer2 = new ArrayBuffer(bytes);
        }
        var array2 = new Uint32Array(buffer2);
        while (j22 < outputBlocks) {
          for (i22 = 0; i22 < blockCount && j22 < outputBlocks; ++i22, ++j22) {
            array2[j22] = s2[i22];
          }
          if (j22 % blockCount === 0) {
            f2(s2);
          }
        }
        if (extraBytes) {
          array2[i22] = s2[i22];
          buffer2 = buffer2.slice(0, bytes);
        }
        return buffer2;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i22 = 0, j22 = 0;
        var array2 = [], offset, block;
        while (j22 < outputBlocks) {
          for (i22 = 0; i22 < blockCount && j22 < outputBlocks; ++i22, ++j22) {
            offset = j22 << 2;
            block = s2[i22];
            array2[offset] = block & 255;
            array2[offset + 1] = block >> 8 & 255;
            array2[offset + 2] = block >> 16 & 255;
            array2[offset + 3] = block >> 24 & 255;
          }
          if (j22 % blockCount === 0) {
            f2(s2);
          }
        }
        if (extraBytes) {
          offset = j22 << 2;
          block = s2[i22];
          array2[offset] = block & 255;
          if (extraBytes > 1) {
            array2[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array2[offset + 2] = block >> 16 & 255;
          }
        }
        return array2;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f2 = function(s2) {
        var h2, l2, n2, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n2 = 0; n2 < 48; n2 += 2) {
          c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
          c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
          c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
          c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
          c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
          c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
          c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
          c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
          c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
          c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
          h2 = c8 ^ (c2 << 1 | c3 >>> 31);
          l2 = c9 ^ (c3 << 1 | c2 >>> 31);
          s2[0] ^= h2;
          s2[1] ^= l2;
          s2[10] ^= h2;
          s2[11] ^= l2;
          s2[20] ^= h2;
          s2[21] ^= l2;
          s2[30] ^= h2;
          s2[31] ^= l2;
          s2[40] ^= h2;
          s2[41] ^= l2;
          h2 = c0 ^ (c4 << 1 | c5 >>> 31);
          l2 = c1 ^ (c5 << 1 | c4 >>> 31);
          s2[2] ^= h2;
          s2[3] ^= l2;
          s2[12] ^= h2;
          s2[13] ^= l2;
          s2[22] ^= h2;
          s2[23] ^= l2;
          s2[32] ^= h2;
          s2[33] ^= l2;
          s2[42] ^= h2;
          s2[43] ^= l2;
          h2 = c2 ^ (c6 << 1 | c7 >>> 31);
          l2 = c3 ^ (c7 << 1 | c6 >>> 31);
          s2[4] ^= h2;
          s2[5] ^= l2;
          s2[14] ^= h2;
          s2[15] ^= l2;
          s2[24] ^= h2;
          s2[25] ^= l2;
          s2[34] ^= h2;
          s2[35] ^= l2;
          s2[44] ^= h2;
          s2[45] ^= l2;
          h2 = c4 ^ (c8 << 1 | c9 >>> 31);
          l2 = c5 ^ (c9 << 1 | c8 >>> 31);
          s2[6] ^= h2;
          s2[7] ^= l2;
          s2[16] ^= h2;
          s2[17] ^= l2;
          s2[26] ^= h2;
          s2[27] ^= l2;
          s2[36] ^= h2;
          s2[37] ^= l2;
          s2[46] ^= h2;
          s2[47] ^= l2;
          h2 = c6 ^ (c0 << 1 | c1 >>> 31);
          l2 = c7 ^ (c1 << 1 | c0 >>> 31);
          s2[8] ^= h2;
          s2[9] ^= l2;
          s2[18] ^= h2;
          s2[19] ^= l2;
          s2[28] ^= h2;
          s2[29] ^= l2;
          s2[38] ^= h2;
          s2[39] ^= l2;
          s2[48] ^= h2;
          s2[49] ^= l2;
          b0 = s2[0];
          b1 = s2[1];
          b32 = s2[11] << 4 | s2[10] >>> 28;
          b33 = s2[10] << 4 | s2[11] >>> 28;
          b14 = s2[20] << 3 | s2[21] >>> 29;
          b15 = s2[21] << 3 | s2[20] >>> 29;
          b46 = s2[31] << 9 | s2[30] >>> 23;
          b47 = s2[30] << 9 | s2[31] >>> 23;
          b28 = s2[40] << 18 | s2[41] >>> 14;
          b29 = s2[41] << 18 | s2[40] >>> 14;
          b20 = s2[2] << 1 | s2[3] >>> 31;
          b21 = s2[3] << 1 | s2[2] >>> 31;
          b2 = s2[13] << 12 | s2[12] >>> 20;
          b3 = s2[12] << 12 | s2[13] >>> 20;
          b34 = s2[22] << 10 | s2[23] >>> 22;
          b35 = s2[23] << 10 | s2[22] >>> 22;
          b16 = s2[33] << 13 | s2[32] >>> 19;
          b17 = s2[32] << 13 | s2[33] >>> 19;
          b48 = s2[42] << 2 | s2[43] >>> 30;
          b49 = s2[43] << 2 | s2[42] >>> 30;
          b40 = s2[5] << 30 | s2[4] >>> 2;
          b41 = s2[4] << 30 | s2[5] >>> 2;
          b22 = s2[14] << 6 | s2[15] >>> 26;
          b23 = s2[15] << 6 | s2[14] >>> 26;
          b4 = s2[25] << 11 | s2[24] >>> 21;
          b5 = s2[24] << 11 | s2[25] >>> 21;
          b36 = s2[34] << 15 | s2[35] >>> 17;
          b37 = s2[35] << 15 | s2[34] >>> 17;
          b18 = s2[45] << 29 | s2[44] >>> 3;
          b19 = s2[44] << 29 | s2[45] >>> 3;
          b10 = s2[6] << 28 | s2[7] >>> 4;
          b11 = s2[7] << 28 | s2[6] >>> 4;
          b42 = s2[17] << 23 | s2[16] >>> 9;
          b43 = s2[16] << 23 | s2[17] >>> 9;
          b24 = s2[26] << 25 | s2[27] >>> 7;
          b25 = s2[27] << 25 | s2[26] >>> 7;
          b6 = s2[36] << 21 | s2[37] >>> 11;
          b7 = s2[37] << 21 | s2[36] >>> 11;
          b38 = s2[47] << 24 | s2[46] >>> 8;
          b39 = s2[46] << 24 | s2[47] >>> 8;
          b30 = s2[8] << 27 | s2[9] >>> 5;
          b31 = s2[9] << 27 | s2[8] >>> 5;
          b12 = s2[18] << 20 | s2[19] >>> 12;
          b13 = s2[19] << 20 | s2[18] >>> 12;
          b44 = s2[29] << 7 | s2[28] >>> 25;
          b45 = s2[28] << 7 | s2[29] >>> 25;
          b26 = s2[38] << 8 | s2[39] >>> 24;
          b27 = s2[39] << 8 | s2[38] >>> 24;
          b8 = s2[48] << 14 | s2[49] >>> 18;
          b9 = s2[49] << 14 | s2[48] >>> 18;
          s2[0] = b0 ^ ~b2 & b4;
          s2[1] = b1 ^ ~b3 & b5;
          s2[10] = b10 ^ ~b12 & b14;
          s2[11] = b11 ^ ~b13 & b15;
          s2[20] = b20 ^ ~b22 & b24;
          s2[21] = b21 ^ ~b23 & b25;
          s2[30] = b30 ^ ~b32 & b34;
          s2[31] = b31 ^ ~b33 & b35;
          s2[40] = b40 ^ ~b42 & b44;
          s2[41] = b41 ^ ~b43 & b45;
          s2[2] = b2 ^ ~b4 & b6;
          s2[3] = b3 ^ ~b5 & b7;
          s2[12] = b12 ^ ~b14 & b16;
          s2[13] = b13 ^ ~b15 & b17;
          s2[22] = b22 ^ ~b24 & b26;
          s2[23] = b23 ^ ~b25 & b27;
          s2[32] = b32 ^ ~b34 & b36;
          s2[33] = b33 ^ ~b35 & b37;
          s2[42] = b42 ^ ~b44 & b46;
          s2[43] = b43 ^ ~b45 & b47;
          s2[4] = b4 ^ ~b6 & b8;
          s2[5] = b5 ^ ~b7 & b9;
          s2[14] = b14 ^ ~b16 & b18;
          s2[15] = b15 ^ ~b17 & b19;
          s2[24] = b24 ^ ~b26 & b28;
          s2[25] = b25 ^ ~b27 & b29;
          s2[34] = b34 ^ ~b36 & b38;
          s2[35] = b35 ^ ~b37 & b39;
          s2[44] = b44 ^ ~b46 & b48;
          s2[45] = b45 ^ ~b47 & b49;
          s2[6] = b6 ^ ~b8 & b0;
          s2[7] = b7 ^ ~b9 & b1;
          s2[16] = b16 ^ ~b18 & b10;
          s2[17] = b17 ^ ~b19 & b11;
          s2[26] = b26 ^ ~b28 & b20;
          s2[27] = b27 ^ ~b29 & b21;
          s2[36] = b36 ^ ~b38 & b30;
          s2[37] = b37 ^ ~b39 & b31;
          s2[46] = b46 ^ ~b48 & b40;
          s2[47] = b47 ^ ~b49 & b41;
          s2[8] = b8 ^ ~b0 & b2;
          s2[9] = b9 ^ ~b1 & b3;
          s2[18] = b18 ^ ~b10 & b12;
          s2[19] = b19 ^ ~b11 & b13;
          s2[28] = b28 ^ ~b20 & b22;
          s2[29] = b29 ^ ~b21 & b23;
          s2[38] = b38 ^ ~b30 & b32;
          s2[39] = b39 ^ ~b31 & b33;
          s2[48] = b48 ^ ~b40 & b42;
          s2[49] = b49 ^ ~b41 & b43;
          s2[0] ^= RC[n2];
          s2[1] ^= RC[n2 + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i2 = 0; i2 < methodNames.length; ++i2) {
          root[methodNames[i2]] = methods[methodNames[i2]];
        }
      }
    })();
  })(sha3);
  return sha3.exports;
}
var sha3Exports = requireSha3();
var cjs$1 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d22, b22) {
    d22.__proto__ = b22;
  } || function(d22, b22) {
    for (var p2 in b22) if (b22.hasOwnProperty(p2)) d22[p2] = b22[p2];
  };
  return extendStatics(d2, b2);
};
function __extends$1(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e3) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter$1(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$1(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e3) {
      op = [6, e3];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o2, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  o2[k22] = m2[k2];
}
function __exportStar(m2, exports) {
  for (var p2 in m2) if (p2 !== "default" && !exports.hasOwnProperty(p2)) exports[p2] = m2[p2];
}
function __values$1(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read(arguments[i2]));
  return ar;
}
function __spreadArrays() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __await$1(v2) {
  return this instanceof __await$1 ? (this.v = v2, this) : new __await$1(v2);
}
function __asyncGenerator$1(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2]) i2[n2] = function(v2) {
      return new Promise(function(a2, b2) {
        q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
      });
    };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e3) {
      settle(q2[0][3], e3);
    }
  }
  function step(r2) {
    r2.value instanceof __await$1 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e3) {
    throw e3;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f2) {
    i2[n2] = o2[n2] ? function(v2) {
      return (p2 = !p2) ? { value: __await$1(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues$1(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values$1 === "function" ? __values$1(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v22) {
      resolve({ value: v22, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod) if (Object.hasOwnProperty.call(mod, k2)) result[k2] = mod[k2];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator: __asyncGenerator$1,
  __asyncValues: __asyncValues$1,
  __await: __await$1,
  __awaiter: __awaiter$1,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __exportStar,
  __extends: __extends$1,
  __generator: __generator$1,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values: __values$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var crypto$1 = {};
var hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto) return crypto$1;
  hasRequiredCrypto = 1;
  Object.defineProperty(crypto$1, "__esModule", { value: true });
  crypto$1.isBrowserCryptoAvailable = crypto$1.getSubtleCrypto = crypto$1.getBrowerCrypto = void 0;
  function getBrowerCrypto() {
    return (globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) || (globalThis === null || globalThis === void 0 ? void 0 : globalThis.msCrypto) || {};
  }
  crypto$1.getBrowerCrypto = getBrowerCrypto;
  function getSubtleCrypto() {
    const browserCrypto = getBrowerCrypto();
    return browserCrypto.subtle || browserCrypto.webkitSubtle;
  }
  crypto$1.getSubtleCrypto = getSubtleCrypto;
  function isBrowserCryptoAvailable() {
    return !!getBrowerCrypto() && !!getSubtleCrypto();
  }
  crypto$1.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  return crypto$1;
}
var env = {};
var hasRequiredEnv;
function requireEnv() {
  if (hasRequiredEnv) return env;
  hasRequiredEnv = 1;
  Object.defineProperty(env, "__esModule", { value: true });
  env.isBrowser = env.isNode = env.isReactNative = void 0;
  function isReactNative2() {
    return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
  }
  env.isReactNative = isReactNative2;
  function isNode2() {
    return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
  }
  env.isNode = isNode2;
  function isBrowser2() {
    return !isReactNative2() && !isNode2();
  }
  env.isBrowser = isBrowser2;
  return env;
}
var hasRequiredCjs$1;
function requireCjs$1() {
  if (hasRequiredCjs$1) return cjs$1;
  hasRequiredCjs$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0$1;
    tslib_1.__exportStar(requireCrypto(), exports);
    tslib_1.__exportStar(requireEnv(), exports);
  })(cjs$1);
  return cjs$1;
}
var cjsExports$1 = requireCjs$1();
function payloadId$1(entropy = 3) {
  const date2 = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date2 + extra;
}
function sanitizeHex(hex2) {
  return sanitizeHex$1(hex2);
}
function removeHexLeadingZeros(hex2) {
  return removeHexLeadingZeros$1(addHexPrefix(hex2));
}
const payloadId = payloadId$1;
function uuid() {
  const result = ((a2, b2) => {
    for (b2 = a2 = ""; a2++ < 36; b2 += a2 * 51 & 52 ? (a2 ^ 15 ? 8 ^ Math.random() * (a2 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b2;
  })();
  return result;
}
function isEmptyString(value) {
  return value === "" || typeof value === "string" && value.trim() === "";
}
function isEmptyArray(array2) {
  return !(array2 && array2.length);
}
function isHexString(value, length) {
  return isHexString$1(value);
}
function isJsonRpcRequest(object2) {
  return typeof object2.method !== "undefined";
}
function isJsonRpcResponseSuccess(object2) {
  return typeof object2.result !== "undefined";
}
function isJsonRpcResponseError(object2) {
  return typeof object2.error !== "undefined";
}
function isInternalEvent(object2) {
  return typeof object2.event !== "undefined";
}
function isReservedEvent(event) {
  return reservedEvents.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request) {
  if (request.method.startsWith("wc_")) {
    return true;
  }
  if (signingMethods.includes(request.method)) {
    return false;
  }
  return true;
}
function toChecksumAddress(address) {
  address = removeHexPrefix(address.toLowerCase());
  const hash2 = removeHexPrefix(sha3Exports.keccak_256(convertUtf8ToBuffer(address)));
  let checksum = "";
  for (let i2 = 0; i2 < address.length; i2++) {
    if (parseInt(hash2[i2], 16) > 7) {
      checksum += address[i2].toUpperCase();
    } else {
      checksum += address[i2];
    }
  }
  return addHexPrefix(checksum);
}
const isValidAddress$1 = (address) => {
  if (!address) {
    return false;
  } else if (address.toLowerCase().substring(0, 2) !== "0x") {
    return false;
  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
    return false;
  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
    return true;
  } else {
    return address === toChecksumAddress(address);
  }
};
function parsePersonalSign(params) {
  if (!isEmptyArray(params) && !isHexString(params[0])) {
    params[0] = convertUtf8ToHex(params[0]);
  }
  return params;
}
function parseTransactionData(txData) {
  if (typeof txData.type !== "undefined" && txData.type !== "0")
    return txData;
  if (typeof txData.from === "undefined" || !isValidAddress$1(txData.from)) {
    throw new Error(`Transaction object must include a valid 'from' value.`);
  }
  function parseHexValues(value) {
    let result = value;
    if (typeof value === "number" || typeof value === "string" && !isEmptyString(value)) {
      if (!isHexString(value)) {
        result = convertNumberToHex(value);
      } else if (typeof value === "string") {
        result = sanitizeHex(value);
      }
    }
    if (typeof result === "string") {
      result = removeHexLeadingZeros(result);
    }
    return result;
  }
  const txDataRPC = {
    from: sanitizeHex(txData.from),
    to: typeof txData.to === "undefined" ? void 0 : sanitizeHex(txData.to),
    gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
    gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
    value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
    nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
    data: typeof txData.data === "undefined" ? "" : sanitizeHex(txData.data) || "0x"
  };
  const prunable = ["gasPrice", "gas", "value", "nonce"];
  Object.keys(txDataRPC).forEach((key) => {
    if ((typeof txDataRPC[key] === "undefined" || typeof txDataRPC[key] === "string" && !txDataRPC[key].trim().length) && prunable.includes(key)) {
      delete txDataRPC[key];
    }
  });
  return txDataRPC;
}
function formatRpcError(error) {
  const message = error.message || "Failed or Rejected Request";
  let code = -32e3;
  if (error && !error.code) {
    switch (message) {
      case "Parse error":
        code = -32700;
        break;
      case "Invalid request":
        code = -32600;
        break;
      case "Method not found":
        code = -32601;
        break;
      case "Invalid params":
        code = -32602;
        break;
      case "Internal error":
        code = -32603;
        break;
      default:
        code = -32e3;
        break;
    }
  }
  const result = {
    code,
    message
  };
  if (error.data) {
    result.data = error.data;
  }
  return result;
}
var queryString = {};
var strictUriEncode;
var hasRequiredStrictUriEncode;
function requireStrictUriEncode() {
  if (hasRequiredStrictUriEncode) return strictUriEncode;
  hasRequiredStrictUriEncode = 1;
  strictUriEncode = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`);
  return strictUriEncode;
}
var decodeUriComponent;
var hasRequiredDecodeUriComponent;
function requireDecodeUriComponent() {
  if (hasRequiredDecodeUriComponent) return decodeUriComponent;
  hasRequiredDecodeUriComponent = 1;
  var token = "%[a-f0-9]{2}";
  var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
  var multiMatcher = new RegExp("(" + token + ")+", "gi");
  function decodeComponents(components, split) {
    try {
      return [decodeURIComponent(components.join(""))];
    } catch (err) {
    }
    if (components.length === 1) {
      return components;
    }
    split = split || 1;
    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
  }
  function decode2(input) {
    try {
      return decodeURIComponent(input);
    } catch (err) {
      var tokens = input.match(singleMatcher) || [];
      for (var i2 = 1; i2 < tokens.length; i2++) {
        input = decodeComponents(tokens, i2).join("");
        tokens = input.match(singleMatcher) || [];
      }
      return input;
    }
  }
  function customDecodeURIComponent(input) {
    var replaceMap = {
      "%FE%FF": "",
      "%FF%FE": ""
    };
    var match = multiMatcher.exec(input);
    while (match) {
      try {
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch (err) {
        var result = decode2(match[0]);
        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }
      match = multiMatcher.exec(input);
    }
    replaceMap["%C2"] = "";
    var entries = Object.keys(replaceMap);
    for (var i2 = 0; i2 < entries.length; i2++) {
      var key = entries[i2];
      input = input.replace(new RegExp(key, "g"), replaceMap[key]);
    }
    return input;
  }
  decodeUriComponent = function(encodedURI) {
    if (typeof encodedURI !== "string") {
      throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
    }
    try {
      encodedURI = encodedURI.replace(/\+/g, " ");
      return decodeURIComponent(encodedURI);
    } catch (err) {
      return customDecodeURIComponent(encodedURI);
    }
  };
  return decodeUriComponent;
}
var splitOnFirst;
var hasRequiredSplitOnFirst;
function requireSplitOnFirst() {
  if (hasRequiredSplitOnFirst) return splitOnFirst;
  hasRequiredSplitOnFirst = 1;
  splitOnFirst = (string2, separator) => {
    if (!(typeof string2 === "string" && typeof separator === "string")) {
      throw new TypeError("Expected the arguments to be of type `string`");
    }
    if (separator === "") {
      return [string2];
    }
    const separatorIndex = string2.indexOf(separator);
    if (separatorIndex === -1) {
      return [string2];
    }
    return [
      string2.slice(0, separatorIndex),
      string2.slice(separatorIndex + separator.length)
    ];
  };
  return splitOnFirst;
}
var hasRequiredQueryString;
function requireQueryString() {
  if (hasRequiredQueryString) return queryString;
  hasRequiredQueryString = 1;
  (function(exports) {
    const strictUriEncode2 = requireStrictUriEncode();
    const decodeComponent = requireDecodeUriComponent();
    const splitOnFirst2 = requireSplitOnFirst();
    const isNullOrUndefined = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key, options), "[", encode2(index, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[]"].join("")];
            }
            return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode2(key, options), "=", encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key, options)];
            }
            return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode2(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode2(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a2, b2) => Number(a2) - Number(b2)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash2 = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash2 = url.slice(hashStart);
      }
      return hash2;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse2(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key, value] = splitOnFirst2(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode2(value, options);
        formatter(decode2(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k2 of Object.keys(value)) {
            value[k2] = parseValue(value[k2], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse2;
    exports.stringify = (object2, options) => {
      if (!object2) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object2[key]) || options.skipEmptyString && object2[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object2)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object2[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object2[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode2(key, options) + "=" + encode2(value, options);
      }).filter((x2) => x2.length > 0).join("&");
    };
    exports.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash2] = splitOnFirst2(input, "#");
      return Object.assign(
        {
          url: url.split("?")[0] || "",
          query: parse2(extract(input), options)
        },
        options && options.parseFragmentIdentifier && hash2 ? { fragmentIdentifier: decode2(hash2, options) } : {}
      );
    };
    exports.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(input.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString2 = exports.stringify(query, options);
      if (queryString2) {
        queryString2 = `?${queryString2}`;
      }
      let hash2 = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash2 = `#${encode2(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString2}${hash2}`;
    };
  })(queryString);
  return queryString;
}
var queryStringExports = requireQueryString();
function getQueryString(url) {
  const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
  const queryString2 = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
  return queryString2;
}
function appendToQueryString(queryString2, newQueryParams) {
  let queryParams = parseQueryString(queryString2);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString2 = formatQueryString(queryParams);
  return queryString2;
}
function parseQueryString(queryString2) {
  return queryStringExports.parse(queryString2);
}
function formatQueryString(queryParams) {
  return queryStringExports.stringify(queryParams);
}
function isWalletConnectSession(object2) {
  return typeof object2.bridge !== "undefined";
}
function parseWalletConnectUri(str) {
  const pathStart = str.indexOf(":");
  const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
  const protocol = str.substring(0, pathStart);
  const path2 = str.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path3) {
    const separator = "@";
    const values = path3.split(separator);
    const requiredParams2 = {
      handshakeTopic: values[0],
      version: parseInt(values[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path2);
  const queryString2 = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
  function parseQueryParams(queryString3) {
    const result2 = parseQueryString(queryString3);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString2);
  const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
  return result;
}
class NetworkMonitor {
  constructor() {
    this._eventEmitters = [];
    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
      window.addEventListener("online", () => this.trigger("online"));
      window.addEventListener("offline", () => this.trigger("offline"));
    }
  }
  on(event, callback) {
    this._eventEmitters.push({
      event,
      callback
    });
  }
  trigger(event) {
    let eventEmitters = [];
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    eventEmitters.forEach((eventEmitter) => {
      eventEmitter.callback();
    });
  }
}
const WS = typeof globalThis.WebSocket !== "undefined" ? globalThis.WebSocket : require("ws");
class SocketTransport {
  constructor(opts) {
    this.opts = opts;
    this._queue = [];
    this._events = [];
    this._subscriptions = [];
    this._protocol = opts.protocol;
    this._version = opts.version;
    this._url = "";
    this._netMonitor = null;
    this._socket = null;
    this._nextSocket = null;
    this._subscriptions = opts.subscriptions || [];
    this._netMonitor = opts.netMonitor || new NetworkMonitor();
    if (!opts.url || typeof opts.url !== "string") {
      throw new Error("Missing or invalid WebSocket url");
    }
    this._url = opts.url;
    this._netMonitor.on("online", () => this._socketCreate());
  }
  set readyState(value) {
  }
  get readyState() {
    return this._socket ? this._socket.readyState : -1;
  }
  set connecting(value) {
  }
  get connecting() {
    return this.readyState === 0;
  }
  set connected(value) {
  }
  get connected() {
    return this.readyState === 1;
  }
  set closing(value) {
  }
  get closing() {
    return this.readyState === 2;
  }
  set closed(value) {
  }
  get closed() {
    return this.readyState === 3;
  }
  open() {
    this._socketCreate();
  }
  close() {
    this._socketClose();
  }
  send(message, topic, silent) {
    if (!topic || typeof topic !== "string") {
      throw new Error("Missing or invalid topic field");
    }
    this._socketSend({
      topic,
      type: "pub",
      payload: message,
      silent: !!silent
    });
  }
  subscribe(topic) {
    this._socketSend({
      topic,
      type: "sub",
      payload: "",
      silent: true
    });
  }
  on(event, callback) {
    this._events.push({ event, callback });
  }
  _socketCreate() {
    if (this._nextSocket) {
      return;
    }
    const url = getWebSocketUrl(this._url, this._protocol, this._version);
    this._nextSocket = new WS(url);
    if (!this._nextSocket) {
      throw new Error("Failed to create socket");
    }
    this._nextSocket.onmessage = (event) => this._socketReceive(event);
    this._nextSocket.onopen = () => this._socketOpen();
    this._nextSocket.onerror = (event) => this._socketError(event);
    this._nextSocket.onclose = () => {
      setTimeout(() => {
        this._nextSocket = null;
        this._socketCreate();
      }, 1e3);
    };
  }
  _socketOpen() {
    this._socketClose();
    this._socket = this._nextSocket;
    this._nextSocket = null;
    this._queueSubscriptions();
    this._pushQueue();
  }
  _socketClose() {
    if (this._socket) {
      this._socket.onclose = () => {
      };
      this._socket.close();
    }
  }
  _socketSend(socketMessage) {
    const message = JSON.stringify(socketMessage);
    if (this._socket && this._socket.readyState === 1) {
      this._socket.send(message);
    } else {
      this._setToQueue(socketMessage);
      this._socketCreate();
    }
  }
  async _socketReceive(event) {
    let socketMessage;
    try {
      socketMessage = JSON.parse(event.data);
    } catch (error) {
      return;
    }
    this._socketSend({
      topic: socketMessage.topic,
      type: "ack",
      payload: "",
      silent: true
    });
    if (this._socket && this._socket.readyState === 1) {
      const events = this._events.filter((event2) => event2.event === "message");
      if (events && events.length) {
        events.forEach((event2) => event2.callback(socketMessage));
      }
    }
  }
  _socketError(e3) {
    const events = this._events.filter((event) => event.event === "error");
    if (events && events.length) {
      events.forEach((event) => event.callback(e3));
    }
  }
  _queueSubscriptions() {
    const subscriptions = this._subscriptions;
    subscriptions.forEach((topic) => this._queue.push({
      topic,
      type: "sub",
      payload: "",
      silent: true
    }));
    this._subscriptions = this.opts.subscriptions || [];
  }
  _setToQueue(socketMessage) {
    this._queue.push(socketMessage);
  }
  _pushQueue() {
    const queue = this._queue;
    queue.forEach((socketMessage) => this._socketSend(socketMessage));
    this._queue = [];
  }
}
function getWebSocketUrl(_url, protocol, version2) {
  var _a, _b;
  const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url.split("?");
  const params = isBrowser() ? {
    protocol,
    version: version2,
    env: "browser",
    host: ((_a = getLocation()) === null || _a === void 0 ? void 0 : _a.host) || ""
  } : {
    protocol,
    version: version2,
    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
  };
  const queryString2 = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString2;
}
const ERROR_SESSION_CONNECTED = "Session currently connected";
const ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
const ERROR_SESSION_REJECTED = "Session Rejected";
const ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
const ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
const ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
const ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
const ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
const ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
const ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
const ERROR_INVALID_URI = "URI format is invalid";
const ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
const ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";
class EventManager {
  constructor() {
    this._eventEmitters = [];
  }
  subscribe(eventEmitter) {
    this._eventEmitters.push(eventEmitter);
  }
  unsubscribe(event) {
    this._eventEmitters = this._eventEmitters.filter((x2) => x2.event !== event);
  }
  trigger(payload) {
    let eventEmitters = [];
    let event;
    if (isJsonRpcRequest(payload)) {
      event = payload.method;
    } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
      event = `response:${payload.id}`;
    } else if (isInternalEvent(payload)) {
      event = payload.event;
    } else {
      event = "";
    }
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
    }
    eventEmitters.forEach((eventEmitter) => {
      if (isJsonRpcResponseError(payload)) {
        const error = new Error(payload.error.message);
        eventEmitter.callback(error, null);
      } else {
        eventEmitter.callback(null, payload);
      }
    });
  }
}
class SessionStorage {
  constructor(storageId = "walletconnect") {
    this.storageId = storageId;
  }
  getSession() {
    let session = null;
    const json = getLocal(this.storageId);
    if (json && isWalletConnectSession(json)) {
      session = json;
    }
    return session;
  }
  setSession(session) {
    setLocal(this.storageId, session);
    return session;
  }
  removeSession() {
    removeLocal(this.storageId);
  }
}
const domain = "walletconnect.org";
const alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
const bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
function extractHostname(url) {
  let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
  hostname = hostname.split(":")[0];
  hostname = hostname.split("?")[0];
  return hostname;
}
function extractRootDomain(url) {
  return extractHostname(url).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url) {
  return extractRootDomain(url) === domain;
}
function getBridgeUrl(url) {
  if (shouldSelectRandomly(url)) {
    return selectRandomBridgeUrl();
  }
  return url;
}
class Connector2 {
  constructor(opts) {
    this.protocol = "wc";
    this.version = 1;
    this._bridge = "";
    this._key = null;
    this._clientId = "";
    this._clientMeta = null;
    this._peerId = "";
    this._peerMeta = null;
    this._handshakeId = 0;
    this._handshakeTopic = "";
    this._connected = false;
    this._accounts = [];
    this._chainId = 0;
    this._networkId = 0;
    this._rpcUrl = "";
    this._eventManager = new EventManager();
    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
    this._cryptoLib = opts.cryptoLib;
    this._sessionStorage = opts.sessionStorage || new SessionStorage(opts.connectorOpts.storageId);
    this._qrcodeModal = opts.connectorOpts.qrcodeModal;
    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
    this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
      throw new Error(ERROR_MISSING_REQUIRED);
    }
    if (opts.connectorOpts.bridge) {
      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
    }
    if (opts.connectorOpts.uri) {
      this.uri = opts.connectorOpts.uri;
    }
    const session = opts.connectorOpts.session || this._getStorageSession();
    if (session) {
      this.session = session;
    }
    if (this.handshakeId) {
      this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
    }
    this._transport = opts.transport || new SocketTransport({
      protocol: this.protocol,
      version: this.version,
      url: this.bridge,
      subscriptions: [this.clientId]
    });
    this._subscribeToInternalEvents();
    this._initTransport();
    if (opts.connectorOpts.uri) {
      this._subscribeToSessionRequest();
    }
    if (opts.pushServerOpts) {
      this._registerPushServer(opts.pushServerOpts);
    }
  }
  set bridge(value) {
    if (!value) {
      return;
    }
    this._bridge = value;
  }
  get bridge() {
    return this._bridge;
  }
  set key(value) {
    if (!value) {
      return;
    }
    const key = convertHexToArrayBuffer(value);
    this._key = key;
  }
  get key() {
    if (this._key) {
      const key = convertArrayBufferToHex(this._key);
      return key;
    }
    return "";
  }
  set clientId(value) {
    if (!value) {
      return;
    }
    this._clientId = value;
  }
  get clientId() {
    let clientId = this._clientId;
    if (!clientId) {
      clientId = this._clientId = uuid();
    }
    return this._clientId;
  }
  set peerId(value) {
    if (!value) {
      return;
    }
    this._peerId = value;
  }
  get peerId() {
    return this._peerId;
  }
  set clientMeta(value) {
  }
  get clientMeta() {
    let clientMeta = this._clientMeta;
    if (!clientMeta) {
      clientMeta = this._clientMeta = getClientMeta();
    }
    return clientMeta;
  }
  set peerMeta(value) {
    this._peerMeta = value;
  }
  get peerMeta() {
    const peerMeta = this._peerMeta;
    return peerMeta;
  }
  set handshakeTopic(value) {
    if (!value) {
      return;
    }
    this._handshakeTopic = value;
  }
  get handshakeTopic() {
    return this._handshakeTopic;
  }
  set handshakeId(value) {
    if (!value) {
      return;
    }
    this._handshakeId = value;
  }
  get handshakeId() {
    return this._handshakeId;
  }
  get uri() {
    const _uri = this._formatUri();
    return _uri;
  }
  set uri(value) {
    if (!value) {
      return;
    }
    const { handshakeTopic, bridge, key } = this._parseUri(value);
    this.handshakeTopic = handshakeTopic;
    this.bridge = bridge;
    this.key = key;
  }
  set chainId(value) {
    this._chainId = value;
  }
  get chainId() {
    const chainId = this._chainId;
    return chainId;
  }
  set networkId(value) {
    this._networkId = value;
  }
  get networkId() {
    const networkId = this._networkId;
    return networkId;
  }
  set accounts(value) {
    this._accounts = value;
  }
  get accounts() {
    const accounts = this._accounts;
    return accounts;
  }
  set rpcUrl(value) {
    this._rpcUrl = value;
  }
  get rpcUrl() {
    const rpcUrl = this._rpcUrl;
    return rpcUrl;
  }
  set connected(value) {
  }
  get connected() {
    return this._connected;
  }
  set pending(value) {
  }
  get pending() {
    return !!this._handshakeTopic;
  }
  get session() {
    return {
      connected: this.connected,
      accounts: this.accounts,
      chainId: this.chainId,
      bridge: this.bridge,
      key: this.key,
      clientId: this.clientId,
      clientMeta: this.clientMeta,
      peerId: this.peerId,
      peerMeta: this.peerMeta,
      handshakeId: this.handshakeId,
      handshakeTopic: this.handshakeTopic
    };
  }
  set session(value) {
    if (!value) {
      return;
    }
    this._connected = value.connected;
    this.accounts = value.accounts;
    this.chainId = value.chainId;
    this.bridge = value.bridge;
    this.key = value.key;
    this.clientId = value.clientId;
    this.clientMeta = value.clientMeta;
    this.peerId = value.peerId;
    this.peerMeta = value.peerMeta;
    this.handshakeId = value.handshakeId;
    this.handshakeTopic = value.handshakeTopic;
  }
  on(event, callback) {
    const eventEmitter = {
      event,
      callback
    };
    this._eventManager.subscribe(eventEmitter);
  }
  off(event) {
    this._eventManager.unsubscribe(event);
  }
  async createInstantRequest(instantRequest) {
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_instantRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          request: this._formatRequest(instantRequest)
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
    this.on("modal_closed", () => {
      throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
    });
    const endInstantRequest = () => {
      this.killSession();
    };
    try {
      const result = await this._sendCallRequest(request);
      if (result) {
        endInstantRequest();
      }
      return result;
    } catch (error) {
      endInstantRequest();
      throw error;
    }
  }
  async connect(opts) {
    if (!this._qrcodeModal) {
      throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
    }
    if (this.connected) {
      return {
        chainId: this.chainId,
        accounts: this.accounts
      };
    }
    await this.createSession(opts);
    return new Promise(async (resolve, reject) => {
      this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
      this.on("connect", (error, payload) => {
        if (error) {
          return reject(error);
        }
        resolve(payload.params[0]);
      });
    });
  }
  async createSession(opts) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    if (this.pending) {
      return;
    }
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_sessionRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          chainId: opts && opts.chainId ? opts.chainId : null
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._sendSessionRequest(request, "Session update rejected", {
      topic: this.handshakeTopic
    });
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
  }
  approveSession(sessionStatus) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl,
      peerId: this.clientId,
      peerMeta: this.clientMeta
    };
    const response = {
      id: this.handshakeId,
      jsonrpc: "2.0",
      result: sessionParams
    };
    this._sendResponse(response);
    this._connected = true;
    this._setStorageSession();
    this._eventManager.trigger({
      event: "connect",
      params: [
        {
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
  }
  rejectSession(sessionError) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
    const response = this._formatResponse({
      id: this.handshakeId,
      error: { message }
    });
    this._sendResponse(response);
    this._connected = false;
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
  }
  updateSession(sessionStatus) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    this._sendSessionRequest(request, "Session update rejected");
    this._eventManager.trigger({
      event: "session_update",
      params: [
        {
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
    this._manageStorageSession();
  }
  async killSession(sessionError) {
    const message = sessionError ? sessionError.message : "Session Disconnected";
    const sessionParams = {
      approved: false,
      chainId: null,
      networkId: null,
      accounts: null
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    await this._sendRequest(request);
    this._handleSessionDisconnect(message);
  }
  async sendTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_sendTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_signTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signPersonalMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    params = parsePersonalSign(params);
    const request = this._formatRequest({
      method: "personal_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTypedData(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_signTypedData",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async updateChain(chainParams) {
    if (!this._connected) {
      throw new Error("Session currently disconnected");
    }
    const request = this._formatRequest({
      method: "wallet_updateChain",
      params: [chainParams]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  unsafeSend(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(request.id, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (!payload) {
          throw new Error(ERROR_MISSING_JSON_RPC);
        }
        resolve(payload);
      });
    });
  }
  async sendCustomRequest(request, options) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    switch (request.method) {
      case "eth_accounts":
        return this.accounts;
      case "eth_chainId":
        return convertNumberToHex(this.chainId);
      case "eth_sendTransaction":
      case "eth_signTransaction":
        if (request.params) {
          request.params[0] = parseTransactionData(request.params[0]);
        }
        break;
      case "personal_sign":
        if (request.params) {
          request.params = parsePersonalSign(request.params);
        }
        break;
    }
    const formattedRequest = this._formatRequest(request);
    const result = await this._sendCallRequest(formattedRequest, options);
    return result;
  }
  approveRequest(response) {
    if (isJsonRpcResponseSuccess(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_RESULT);
    }
  }
  rejectRequest(response) {
    if (isJsonRpcResponseError(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_ERROR);
    }
  }
  transportClose() {
    this._transport.close();
  }
  async _sendRequest(request, options) {
    const callRequest = this._formatRequest(request);
    const encryptionPayload = await this._encrypt(callRequest);
    const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
    this._transport.send(payload, topic, silent);
  }
  async _sendResponse(response) {
    const encryptionPayload = await this._encrypt(response);
    const topic = this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = true;
    this._transport.send(payload, topic, silent);
  }
  async _sendSessionRequest(request, errorMsg, options) {
    this._sendRequest(request, options);
    this._subscribeToSessionResponse(request.id, errorMsg);
  }
  _sendCallRequest(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return this._subscribeToCallResponse(request.id);
  }
  _formatRequest(request) {
    if (typeof request.method === "undefined") {
      throw new Error(ERROR_MISSING_METHOD);
    }
    const formattedRequest = {
      id: typeof request.id === "undefined" ? payloadId() : request.id,
      jsonrpc: "2.0",
      method: request.method,
      params: typeof request.params === "undefined" ? [] : request.params
    };
    return formattedRequest;
  }
  _formatResponse(response) {
    if (typeof response.id === "undefined") {
      throw new Error(ERROR_MISSING_ID);
    }
    const baseResponse = { id: response.id, jsonrpc: "2.0" };
    if (isJsonRpcResponseError(response)) {
      const error = formatRpcError(response.error);
      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
      return errorResponse;
    } else if (isJsonRpcResponseSuccess(response)) {
      const successResponse = Object.assign(Object.assign({}, baseResponse), response);
      return successResponse;
    }
    throw new Error(ERROR_INVALID_RESPONSE);
  }
  _handleSessionDisconnect(errorMsg) {
    const message = errorMsg || "Session Disconnected";
    if (!this._connected) {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
      removeLocal(mobileLinkChoiceKey);
    }
    if (this._connected) {
      this._connected = false;
    }
    if (this._handshakeId) {
      this._handshakeId = 0;
    }
    if (this._handshakeTopic) {
      this._handshakeTopic = "";
    }
    if (this._peerId) {
      this._peerId = "";
    }
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
    this.transportClose();
  }
  _handleSessionResponse(errorMsg, sessionParams) {
    if (sessionParams) {
      if (sessionParams.approved) {
        if (!this._connected) {
          this._connected = true;
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          if (sessionParams.peerId && !this.peerId) {
            this.peerId = sessionParams.peerId;
          }
          if (sessionParams.peerMeta && !this.peerMeta) {
            this.peerMeta = sessionParams.peerMeta;
          }
          this._eventManager.trigger({
            event: "connect",
            params: [
              {
                peerId: this.peerId,
                peerMeta: this.peerMeta,
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        } else {
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          this._eventManager.trigger({
            event: "session_update",
            params: [
              {
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        }
        this._manageStorageSession();
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    } else {
      this._handleSessionDisconnect(errorMsg);
    }
  }
  async _handleIncomingMessages(socketMessage) {
    const activeTopics = [this.clientId, this.handshakeTopic];
    if (!activeTopics.includes(socketMessage.topic)) {
      return;
    }
    let encryptionPayload;
    try {
      encryptionPayload = JSON.parse(socketMessage.payload);
    } catch (error) {
      return;
    }
    const payload = await this._decrypt(encryptionPayload);
    if (payload) {
      this._eventManager.trigger(payload);
    }
  }
  _subscribeToSessionRequest() {
    this._transport.subscribe(this.handshakeTopic);
  }
  _subscribeToResponse(id, callback) {
    this.on(`response:${id}`, callback);
  }
  _subscribeToSessionResponse(id, errorMsg) {
    this._subscribeToResponse(id, (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
        return;
      }
      if (isJsonRpcResponseSuccess(payload)) {
        this._handleSessionResponse(errorMsg, payload.result);
      } else if (payload.error && payload.error.message) {
        this._handleSessionResponse(payload.error.message);
      } else {
        this._handleSessionResponse(errorMsg);
      }
    });
  }
  _subscribeToCallResponse(id) {
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(id, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (isJsonRpcResponseSuccess(payload)) {
          resolve(payload.result);
        } else if (payload.error && payload.error.message) {
          reject(payload.error);
        } else {
          reject(new Error(ERROR_INVALID_RESPONSE));
        }
      });
    });
  }
  _subscribeToInternalEvents() {
    this.on("display_uri", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.open(this.uri, () => {
          this._eventManager.trigger({
            event: "modal_closed",
            params: []
          });
        }, this._qrcodeModalOptions);
      }
    });
    this.on("connect", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
    });
    this.on("call_request_sent", (error, payload) => {
      const { request } = payload.params[0];
      if (isMobile() && this._signingMethods.includes(request.method)) {
        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
        if (mobileLinkUrl) {
          window.location.href = mobileLinkUrl.href;
        }
      }
    });
    this.on("wc_sessionRequest", (error, payload) => {
      if (error) {
        this._eventManager.trigger({
          event: "error",
          params: [
            {
              code: "SESSION_REQUEST_ERROR",
              message: error.toString()
            }
          ]
        });
      }
      this.handshakeId = payload.id;
      this.peerId = payload.params[0].peerId;
      this.peerMeta = payload.params[0].peerMeta;
      const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
      this._eventManager.trigger(internalPayload);
    });
    this.on("wc_sessionUpdate", (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
      }
      this._handleSessionResponse("Session disconnected", payload.params[0]);
    });
  }
  _initTransport() {
    this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
    this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
    this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
    this._transport.on("error", () => this._eventManager.trigger({
      event: "transport_error",
      params: ["Websocket connection failed"]
    }));
    this._transport.open();
  }
  _formatUri() {
    const protocol = this.protocol;
    const handshakeTopic = this.handshakeTopic;
    const version2 = this.version;
    const bridge = encodeURIComponent(this.bridge);
    const key = this.key;
    const uri = `${protocol}:${handshakeTopic}@${version2}?bridge=${bridge}&key=${key}`;
    return uri;
  }
  _parseUri(uri) {
    const result = parseWalletConnectUri(uri);
    if (result.protocol === this.protocol) {
      if (!result.handshakeTopic) {
        throw Error("Invalid or missing handshakeTopic parameter value");
      }
      const handshakeTopic = result.handshakeTopic;
      if (!result.bridge) {
        throw Error("Invalid or missing bridge url parameter value");
      }
      const bridge = decodeURIComponent(result.bridge);
      if (!result.key) {
        throw Error("Invalid or missing key parameter value");
      }
      const key = result.key;
      return { handshakeTopic, bridge, key };
    } else {
      throw new Error(ERROR_INVALID_URI);
    }
  }
  async _generateKey() {
    if (this._cryptoLib) {
      const result = await this._cryptoLib.generateKey();
      return result;
    }
    return null;
  }
  async _encrypt(data) {
    const key = this._key;
    if (this._cryptoLib && key) {
      const result = await this._cryptoLib.encrypt(data, key);
      return result;
    }
    return null;
  }
  async _decrypt(payload) {
    const key = this._key;
    if (this._cryptoLib && key) {
      const result = await this._cryptoLib.decrypt(payload, key);
      return result;
    }
    return null;
  }
  _getStorageSession() {
    let result = null;
    if (this._sessionStorage) {
      result = this._sessionStorage.getSession();
    }
    return result;
  }
  _setStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.setSession(this.session);
    }
  }
  _removeStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.removeSession();
    }
  }
  _manageStorageSession() {
    if (this._connected) {
      this._setStorageSession();
    } else {
      this._removeStorageSession();
    }
  }
  _registerPushServer(pushServerOpts) {
    if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
      throw Error("Invalid or missing pushServerOpts.url parameter value");
    }
    if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
      throw Error("Invalid or missing pushServerOpts.type parameter value");
    }
    if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
      throw Error("Invalid or missing pushServerOpts.token parameter value");
    }
    const pushSubscription = {
      bridge: this.bridge,
      topic: this.clientId,
      type: pushServerOpts.type,
      token: pushServerOpts.token,
      peerName: "",
      language: pushServerOpts.language || ""
    };
    this.on("connect", async (error, payload) => {
      if (error) {
        throw error;
      }
      if (pushServerOpts.peerMeta) {
        const peerName = payload.params[0].peerMeta.name;
        pushSubscription.peerName = peerName;
      }
      try {
        const response = await fetch(`${pushServerOpts.url}/new`, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(pushSubscription)
        });
        const json = await response.json();
        if (!json.success) {
          throw Error("Failed to register in Push Server");
        }
      } catch (error2) {
        throw Error("Failed to register in Push Server");
      }
    });
  }
}
function randomBytes(length) {
  const browserCrypto = cjsExports$1.getBrowerCrypto();
  return browserCrypto.getRandomValues(new Uint8Array(length));
}
const LENGTH_256 = 256;
const AES_LENGTH = LENGTH_256;
const HMAC_LENGTH = LENGTH_256;
const AES_BROWSER_ALGO = "AES-CBC";
const HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
const HMAC_BROWSER = "HMAC";
const ENCRYPT_OP = "encrypt";
const DECRYPT_OP = "decrypt";
const SIGN_OP = "sign";
const VERIFY_OP = "verify";
function getAlgo(type) {
  return type === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
    hash: { name: HMAC_BROWSER_ALGO },
    name: HMAC_BROWSER
  };
}
function getOps(type) {
  return type === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
}
async function browserImportKey(buffer2, type = AES_BROWSER_ALGO) {
  return cjsExports$1.getSubtleCrypto().importKey("raw", buffer2, getAlgo(type), true, getOps(type));
}
async function browserAesEncrypt(iv, key, data) {
  const subtle = cjsExports$1.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.encrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserAesDecrypt(iv, key, data) {
  const subtle = cjsExports$1.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.decrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserHmacSha256Sign(key, data) {
  const subtle = cjsExports$1.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: HMAC_LENGTH,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature);
}
function aesCbcEncrypt(iv, key, data) {
  return browserAesEncrypt(iv, key, data);
}
function aesCbcDecrypt(iv, key, data) {
  return browserAesDecrypt(iv, key, data);
}
async function hmacSha256Sign(key, msg) {
  const result = await browserHmacSha256Sign(key, msg);
  return result;
}
async function generateKey(length) {
  const _length = (length || 256) / 8;
  const bytes = randomBytes(_length);
  const result = convertBufferToArrayBuffer(arrayToBuffer(bytes));
  return result;
}
async function verifyHmac(payload, key) {
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const hmac = hexToArray(payload.hmac);
  const hmacHex = arrayToHex(hmac, false);
  const unsigned = concatArrays$1(cipherText, iv);
  const chmac = await hmacSha256Sign(key, unsigned);
  const chmacHex = arrayToHex(chmac, false);
  if (removeHexPrefix(hmacHex) === removeHexPrefix(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt(data, key, providedIv) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = arrayToHex(iv, false);
  const contentString = JSON.stringify(data);
  const content = utf8ToArray(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content);
  const cipherTextHex = arrayToHex(cipherText, false);
  const unsigned = concatArrays$1(cipherText, iv);
  const hmac = await hmacSha256Sign(_key, unsigned);
  const hmacHex = arrayToHex(hmac, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt(payload, key) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const buffer2 = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = arrayToUtf8(buffer2);
  let data;
  try {
    data = JSON.parse(utf8);
  } catch (error) {
    return null;
  }
  return data;
}
const cryptoLib = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decrypt,
  encrypt,
  generateKey,
  verifyHmac
}, Symbol.toStringTag, { value: "Module" }));
class WalletConnect extends Connector2 {
  constructor(connectorOpts, pushServerOpts) {
    super({
      cryptoLib,
      connectorOpts,
      pushServerOpts
    });
  }
}
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(esm);
var browser = {};
var canPromise;
var hasRequiredCanPromise;
function requireCanPromise() {
  if (hasRequiredCanPromise) return canPromise;
  hasRequiredCanPromise = 1;
  canPromise = function() {
    return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
  };
  return canPromise;
}
var qrcode = {};
var typedarrayBuffer = {};
var isarray;
var hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var toString2 = {}.toString;
  isarray = Array.isArray || function(arr) {
    return toString2.call(arr) == "[object Array]";
  };
  return isarray;
}
var hasRequiredTypedarrayBuffer;
function requireTypedarrayBuffer() {
  if (hasRequiredTypedarrayBuffer) return typedarrayBuffer;
  hasRequiredTypedarrayBuffer = 1;
  var isArray = requireIsarray();
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
        return 42;
      } };
      return arr.foo() === 42;
    } catch (e3) {
      return false;
    }
  }
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  var K_MAX_LENGTH = Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  function Buffer2(arg, offset, length) {
    if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
      return new Buffer2(arg, offset, length);
    }
    if (typeof arg === "number") {
      return allocUnsafe(this, arg);
    }
    return from2(this, arg, offset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    Buffer2.prototype.__proto__ = Uint8Array.prototype;
    Buffer2.__proto__ = Uint8Array;
    if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
      Object.defineProperty(Buffer2, Symbol.species, {
        value: null,
        configurable: true,
        enumerable: false,
        writable: false
      });
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function isnan(val) {
    return val !== val;
  }
  function createBuffer(that, length) {
    var buf;
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      buf = new Uint8Array(length);
      buf.__proto__ = Buffer2.prototype;
    } else {
      buf = that;
      if (buf === null) {
        buf = new Buffer2(length);
      }
      buf.length = length;
    }
    return buf;
  }
  function allocUnsafe(that, size) {
    var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer2.TYPED_ARRAY_SUPPORT) {
      for (var i2 = 0; i2 < size; ++i2) {
        buf[i2] = 0;
      }
    }
    return buf;
  }
  function fromString(that, string2) {
    var length = byteLength(string2) | 0;
    var buf = createBuffer(that, length);
    var actual = buf.write(string2);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(that, array2) {
    var length = array2.length < 0 ? 0 : checked(array2.length) | 0;
    var buf = createBuffer(that, length);
    for (var i2 = 0; i2 < length; i2 += 1) {
      buf[i2] = array2[i2] & 255;
    }
    return buf;
  }
  function fromArrayBuffer(that, array2, byteOffset, length) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array2.byteLength < byteOffset + (length || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    var buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array2);
    } else if (length === void 0) {
      buf = new Uint8Array(array2, byteOffset);
    } else {
      buf = new Uint8Array(array2, byteOffset, length);
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      buf.__proto__ = Buffer2.prototype;
    } else {
      buf = fromArrayLike(that, buf);
    }
    return buf;
  }
  function fromObject(that, obj) {
    if (Buffer2.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer(that, len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike(that, obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }
  function utf8ToBytes(string2, units) {
    units = units || Infinity;
    var codePoint;
    var length = string2.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i2 = 0; i2 < length; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function byteLength(string2) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string2) || string2 instanceof ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      string2 = "" + string2;
    }
    var len = string2.length;
    if (len === 0) return 0;
    return utf8ToBytes(string2).length;
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src.length) break;
      dst[i2 + offset] = src[i2];
    }
    return i2;
  }
  function utf8Write(buf, string2, offset, length) {
    return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
  }
  function from2(that, value, offset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, offset, length);
    }
    if (typeof value === "string") {
      return fromString(that, value);
    }
    return fromObject(that, value);
  }
  Buffer2.prototype.write = function write(string2, offset, length) {
    if (offset === void 0) {
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
      } else {
        length = void 0;
      }
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    return utf8Write(this, string2, offset, length);
  };
  Buffer2.prototype.slice = function slice2(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    var newBuf;
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer2.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer2(sliceLen, void 0);
      for (var i2 = 0; i2 < sliceLen; ++i2) {
        newBuf[i2] = this[i2 + start];
      }
    }
    return newBuf;
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    var i2;
    if (this === target && start < targetStart && targetStart < end) {
      for (i2 = len - 1; i2 >= 0; --i2) {
        target[i2 + targetStart] = this[i2 + start];
      }
    } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
      for (i2 = 0; i2 < len; ++i2) {
        target[i2 + targetStart] = this[i2 + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    var i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      var bytes = Buffer2.isBuffer(val) ? val : new Buffer2(val);
      var len = bytes.length;
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes[i2 % len];
      }
    }
    return this;
  };
  Buffer2.concat = function concat(list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return createBuffer(null, 0);
    }
    var i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length += list[i2].length;
      }
    }
    var buffer2 = allocUnsafe(null, length);
    var pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      var buf = list[i2];
      if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      buf.copy(buffer2, pos);
      pos += buf.length;
    }
    return buffer2;
  };
  Buffer2.byteLength = byteLength;
  Buffer2.prototype._isBuffer = true;
  Buffer2.isBuffer = function isBuffer(b2) {
    return !!(b2 != null && b2._isBuffer);
  };
  typedarrayBuffer.alloc = function(size) {
    var buffer2 = new Buffer2(size);
    buffer2.fill(0);
    return buffer2;
  };
  typedarrayBuffer.from = function(data) {
    return new Buffer2(data);
  };
  return typedarrayBuffer;
}
var utils$1 = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  var toSJISFunction;
  var CODEWORDS_COUNT = [
    0,
    // Not used
    26,
    44,
    70,
    100,
    134,
    172,
    196,
    242,
    292,
    346,
    404,
    466,
    532,
    581,
    655,
    733,
    815,
    901,
    991,
    1085,
    1156,
    1258,
    1364,
    1474,
    1588,
    1706,
    1828,
    1921,
    2051,
    2185,
    2323,
    2465,
    2611,
    2761,
    2876,
    3034,
    3196,
    3362,
    3532,
    3706
  ];
  utils$1.getSymbolSize = function getSymbolSize(version2) {
    if (!version2) throw new Error('"version" cannot be null or undefined');
    if (version2 < 1 || version2 > 40) throw new Error('"version" should be in range from 1 to 40');
    return version2 * 4 + 17;
  };
  utils$1.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
    return CODEWORDS_COUNT[version2];
  };
  utils$1.getBCHDigit = function(data) {
    var digit = 0;
    while (data !== 0) {
      digit++;
      data >>>= 1;
    }
    return digit;
  };
  utils$1.setToSJISFunction = function setToSJISFunction(f2) {
    if (typeof f2 !== "function") {
      throw new Error('"toSJISFunc" is not a valid function.');
    }
    toSJISFunction = f2;
  };
  utils$1.isKanjiModeEnabled = function() {
    return typeof toSJISFunction !== "undefined";
  };
  utils$1.toSJIS = function toSJIS(kanji) {
    return toSJISFunction(kanji);
  };
  return utils$1;
}
var errorCorrectionLevel = {};
var hasRequiredErrorCorrectionLevel;
function requireErrorCorrectionLevel() {
  if (hasRequiredErrorCorrectionLevel) return errorCorrectionLevel;
  hasRequiredErrorCorrectionLevel = 1;
  (function(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string2.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string2);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from2(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e3) {
        return defaultValue;
      }
    };
  })(errorCorrectionLevel);
  return errorCorrectionLevel;
}
var bitBuffer;
var hasRequiredBitBuffer;
function requireBitBuffer() {
  if (hasRequiredBitBuffer) return bitBuffer;
  hasRequiredBitBuffer = 1;
  function BitBuffer() {
    this.buffer = [];
    this.length = 0;
  }
  BitBuffer.prototype = {
    get: function(index) {
      var bufIndex = Math.floor(index / 8);
      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
    },
    put: function(num, length) {
      for (var i2 = 0; i2 < length; i2++) {
        this.putBit((num >>> length - i2 - 1 & 1) === 1);
      }
    },
    getLengthInBits: function() {
      return this.length;
    },
    putBit: function(bit) {
      var bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    }
  };
  bitBuffer = BitBuffer;
  return bitBuffer;
}
var bitMatrix;
var hasRequiredBitMatrix;
function requireBitMatrix() {
  if (hasRequiredBitMatrix) return bitMatrix;
  hasRequiredBitMatrix = 1;
  var BufferUtil = requireTypedarrayBuffer();
  function BitMatrix(size) {
    if (!size || size < 1) {
      throw new Error("BitMatrix size must be defined and greater than 0");
    }
    this.size = size;
    this.data = BufferUtil.alloc(size * size);
    this.reservedBit = BufferUtil.alloc(size * size);
  }
  BitMatrix.prototype.set = function(row, col, value, reserved) {
    var index = row * this.size + col;
    this.data[index] = value;
    if (reserved) this.reservedBit[index] = true;
  };
  BitMatrix.prototype.get = function(row, col) {
    return this.data[row * this.size + col];
  };
  BitMatrix.prototype.xor = function(row, col, value) {
    this.data[row * this.size + col] ^= value;
  };
  BitMatrix.prototype.isReserved = function(row, col) {
    return this.reservedBit[row * this.size + col];
  };
  bitMatrix = BitMatrix;
  return bitMatrix;
}
var alignmentPattern = {};
var hasRequiredAlignmentPattern;
function requireAlignmentPattern() {
  if (hasRequiredAlignmentPattern) return alignmentPattern;
  hasRequiredAlignmentPattern = 1;
  (function(exports) {
    var getSymbolSize = requireUtils$1().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version2) {
      if (version2 === 1) return [];
      var posCount = Math.floor(version2 / 7) + 2;
      var size = getSymbolSize(version2);
      var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      var positions = [size - 7];
      for (var i2 = 1; i2 < posCount - 1; i2++) {
        positions[i2] = positions[i2 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version2) {
      var coords = [];
      var pos = exports.getRowColCoords(version2);
      var posLength = pos.length;
      for (var i2 = 0; i2 < posLength; i2++) {
        for (var j2 = 0; j2 < posLength; j2++) {
          if (i2 === 0 && j2 === 0 || // top-left
          i2 === 0 && j2 === posLength - 1 || // bottom-left
          i2 === posLength - 1 && j2 === 0) {
            continue;
          }
          coords.push([pos[i2], pos[j2]]);
        }
      }
      return coords;
    };
  })(alignmentPattern);
  return alignmentPattern;
}
var finderPattern = {};
var hasRequiredFinderPattern;
function requireFinderPattern() {
  if (hasRequiredFinderPattern) return finderPattern;
  hasRequiredFinderPattern = 1;
  var getSymbolSize = requireUtils$1().getSymbolSize;
  var FINDER_PATTERN_SIZE = 7;
  finderPattern.getPositions = function getPositions(version2) {
    var size = getSymbolSize(version2);
    return [
      // top-left
      [0, 0],
      // top-right
      [size - FINDER_PATTERN_SIZE, 0],
      // bottom-left
      [0, size - FINDER_PATTERN_SIZE]
    ];
  };
  return finderPattern;
}
var maskPattern = {};
var hasRequiredMaskPattern;
function requireMaskPattern() {
  if (hasRequiredMaskPattern) return maskPattern;
  hasRequiredMaskPattern = 1;
  (function(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from2(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      var size = data.size;
      var points = 0;
      var sameCountCol = 0;
      var sameCountRow = 0;
      var lastCol = null;
      var lastRow = null;
      for (var row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (var col = 0; col < size; col++) {
          var module = data.get(row, col);
          if (module === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module;
            sameCountCol = 1;
          }
          module = data.get(col, row);
          if (module === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      var size = data.size;
      var points = 0;
      for (var row = 0; row < size - 1; row++) {
        for (var col = 0; col < size - 1; col++) {
          var last2 = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last2 === 4 || last2 === 0) points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      var size = data.size;
      var points = 0;
      var bitsCol = 0;
      var bitsRow = 0;
      for (var row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (var col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      var darkCount = 0;
      var modulesCount = data.data.length;
      for (var i2 = 0; i2 < modulesCount; i2++) darkCount += data.data[i2];
      var k2 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k2 * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern2, i2, j2) {
      switch (maskPattern2) {
        case exports.Patterns.PATTERN000:
          return (i2 + j2) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i2 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j2 % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i2 + j2) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i2 / 2) + Math.floor(j2 / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i2 * j2 % 2 + i2 * j2 % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i2 * j2 % 2 + i2 * j2 % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i2 * j2 % 3 + (i2 + j2) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern2);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      var size = data.size;
      for (var col = 0; col < size; col++) {
        for (var row = 0; row < size; row++) {
          if (data.isReserved(row, col)) continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      var numPatterns = Object.keys(exports.Patterns).length;
      var bestPattern = 0;
      var lowerPenalty = Infinity;
      for (var p2 = 0; p2 < numPatterns; p2++) {
        setupFormatFunc(p2);
        exports.applyMask(p2, data);
        var penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p2, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p2;
        }
      }
      return bestPattern;
    };
  })(maskPattern);
  return maskPattern;
}
var errorCorrectionCode = {};
var hasRequiredErrorCorrectionCode;
function requireErrorCorrectionCode() {
  if (hasRequiredErrorCorrectionCode) return errorCorrectionCode;
  hasRequiredErrorCorrectionCode = 1;
  var ECLevel = requireErrorCorrectionLevel();
  var EC_BLOCKS_TABLE = [
    // L  M  Q  H
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    1,
    2,
    2,
    4,
    1,
    2,
    4,
    4,
    2,
    4,
    4,
    4,
    2,
    4,
    6,
    5,
    2,
    4,
    6,
    6,
    2,
    5,
    8,
    8,
    4,
    5,
    8,
    8,
    4,
    5,
    8,
    11,
    4,
    8,
    10,
    11,
    4,
    9,
    12,
    16,
    4,
    9,
    16,
    16,
    6,
    10,
    12,
    18,
    6,
    10,
    17,
    16,
    6,
    11,
    16,
    19,
    6,
    13,
    18,
    21,
    7,
    14,
    21,
    25,
    8,
    16,
    20,
    25,
    8,
    17,
    23,
    25,
    9,
    17,
    23,
    34,
    9,
    18,
    25,
    30,
    10,
    20,
    27,
    32,
    12,
    21,
    29,
    35,
    12,
    23,
    34,
    37,
    12,
    25,
    34,
    40,
    13,
    26,
    35,
    42,
    14,
    28,
    38,
    45,
    15,
    29,
    40,
    48,
    16,
    31,
    43,
    51,
    17,
    33,
    45,
    54,
    18,
    35,
    48,
    57,
    19,
    37,
    51,
    60,
    19,
    38,
    53,
    63,
    20,
    40,
    56,
    66,
    21,
    43,
    59,
    70,
    22,
    45,
    62,
    74,
    24,
    47,
    65,
    77,
    25,
    49,
    68,
    81
  ];
  var EC_CODEWORDS_TABLE = [
    // L  M  Q  H
    7,
    10,
    13,
    17,
    10,
    16,
    22,
    28,
    15,
    26,
    36,
    44,
    20,
    36,
    52,
    64,
    26,
    48,
    72,
    88,
    36,
    64,
    96,
    112,
    40,
    72,
    108,
    130,
    48,
    88,
    132,
    156,
    60,
    110,
    160,
    192,
    72,
    130,
    192,
    224,
    80,
    150,
    224,
    264,
    96,
    176,
    260,
    308,
    104,
    198,
    288,
    352,
    120,
    216,
    320,
    384,
    132,
    240,
    360,
    432,
    144,
    280,
    408,
    480,
    168,
    308,
    448,
    532,
    180,
    338,
    504,
    588,
    196,
    364,
    546,
    650,
    224,
    416,
    600,
    700,
    224,
    442,
    644,
    750,
    252,
    476,
    690,
    816,
    270,
    504,
    750,
    900,
    300,
    560,
    810,
    960,
    312,
    588,
    870,
    1050,
    336,
    644,
    952,
    1110,
    360,
    700,
    1020,
    1200,
    390,
    728,
    1050,
    1260,
    420,
    784,
    1140,
    1350,
    450,
    812,
    1200,
    1440,
    480,
    868,
    1290,
    1530,
    510,
    924,
    1350,
    1620,
    540,
    980,
    1440,
    1710,
    570,
    1036,
    1530,
    1800,
    570,
    1064,
    1590,
    1890,
    600,
    1120,
    1680,
    1980,
    630,
    1204,
    1770,
    2100,
    660,
    1260,
    1860,
    2220,
    720,
    1316,
    1950,
    2310,
    750,
    1372,
    2040,
    2430
  ];
  errorCorrectionCode.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
    switch (errorCorrectionLevel2) {
      case ECLevel.L:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
      case ECLevel.M:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
      case ECLevel.Q:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
      case ECLevel.H:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
      default:
        return void 0;
    }
  };
  errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
    switch (errorCorrectionLevel2) {
      case ECLevel.L:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
      case ECLevel.M:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
      case ECLevel.Q:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
      case ECLevel.H:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
      default:
        return void 0;
    }
  };
  return errorCorrectionCode;
}
var polynomial = {};
var galoisField = {};
var hasRequiredGaloisField;
function requireGaloisField() {
  if (hasRequiredGaloisField) return galoisField;
  hasRequiredGaloisField = 1;
  var BufferUtil = requireTypedarrayBuffer();
  var EXP_TABLE = BufferUtil.alloc(512);
  var LOG_TABLE = BufferUtil.alloc(256);
  (function initTables() {
    var x2 = 1;
    for (var i2 = 0; i2 < 255; i2++) {
      EXP_TABLE[i2] = x2;
      LOG_TABLE[x2] = i2;
      x2 <<= 1;
      if (x2 & 256) {
        x2 ^= 285;
      }
    }
    for (i2 = 255; i2 < 512; i2++) {
      EXP_TABLE[i2] = EXP_TABLE[i2 - 255];
    }
  })();
  galoisField.log = function log2(n2) {
    if (n2 < 1) throw new Error("log(" + n2 + ")");
    return LOG_TABLE[n2];
  };
  galoisField.exp = function exp2(n2) {
    return EXP_TABLE[n2];
  };
  galoisField.mul = function mul(x2, y2) {
    if (x2 === 0 || y2 === 0) return 0;
    return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y2]];
  };
  return galoisField;
}
var hasRequiredPolynomial;
function requirePolynomial() {
  if (hasRequiredPolynomial) return polynomial;
  hasRequiredPolynomial = 1;
  (function(exports) {
    var BufferUtil = requireTypedarrayBuffer();
    var GF = requireGaloisField();
    exports.mul = function mul(p1, p2) {
      var coeff = BufferUtil.alloc(p1.length + p2.length - 1);
      for (var i2 = 0; i2 < p1.length; i2++) {
        for (var j2 = 0; j2 < p2.length; j2++) {
          coeff[i2 + j2] ^= GF.mul(p1[i2], p2[j2]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      var result = BufferUtil.from(divident);
      while (result.length - divisor.length >= 0) {
        var coeff = result[0];
        for (var i2 = 0; i2 < divisor.length; i2++) {
          result[i2] ^= GF.mul(divisor[i2], coeff);
        }
        var offset = 0;
        while (offset < result.length && result[offset] === 0) offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      var poly = BufferUtil.from([1]);
      for (var i2 = 0; i2 < degree; i2++) {
        poly = exports.mul(poly, [1, GF.exp(i2)]);
      }
      return poly;
    };
  })(polynomial);
  return polynomial;
}
var buffer$1 = {};
var base64Js = {};
var hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1;
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code.length; i2 < len; ++i2) {
    lookup[i2] = code[i2];
    revLookup[code.charCodeAt(i2)] = i2;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i3;
    for (i3 = 0; i3 < len2; i3 += 4) {
      tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i3 = start; i3 < end; i3 += 3) {
      tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  return base64Js;
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredIeee754;
function requireIeee754() {
  if (hasRequiredIeee754) return ieee754;
  hasRequiredIeee754 = 1;
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e3, m2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d2 = isLE ? -1 : 1;
    var s2 = buffer2[offset + i2];
    i2 += d2;
    e3 = s2 & (1 << -nBits) - 1;
    s2 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e3 = e3 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
    }
    m2 = e3 & (1 << -nBits) - 1;
    e3 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
    }
    if (e3 === 0) {
      e3 = 1 - eBias;
    } else if (e3 === eMax) {
      return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
    } else {
      m2 = m2 + Math.pow(2, mLen);
      e3 = e3 - eBias;
    }
    return (s2 ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e3, m2, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d2 = isLE ? 1 : -1;
    var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m2 = isNaN(value) ? 1 : 0;
      e3 = eMax;
    } else {
      e3 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e3)) < 1) {
        e3--;
        c2 *= 2;
      }
      if (e3 + eBias >= 1) {
        value += rt / c2;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c2 >= 2) {
        e3++;
        c2 /= 2;
      }
      if (e3 + eBias >= eMax) {
        m2 = 0;
        e3 = eMax;
      } else if (e3 + eBias >= 1) {
        m2 = (value * c2 - 1) * Math.pow(2, mLen);
        e3 = e3 + eBias;
      } else {
        m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e3 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
    }
    e3 = e3 << mLen | m2;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i2] = e3 & 255, i2 += d2, e3 /= 256, eLen -= 8) {
    }
    buffer2[offset + i2 - d2] |= s2 * 128;
  };
  return ieee754;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var hasRequiredBuffer$1;
function requireBuffer$1() {
  if (hasRequiredBuffer$1) return buffer$1;
  hasRequiredBuffer$1 = 1;
  (function(exports) {
    var base64 = requireBase64Js();
    var ieee7542 = requireIeee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e3) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from2(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from2(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b2 = fromObject(value);
      if (b2) return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from2(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string2, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string2, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string2, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array2) {
      var length = array2.length < 0 ? 0 : checked(array2.length) | 0;
      var buf = createBuffer(length);
      for (var i2 = 0; i2 < length; i2 += 1) {
        buf[i2] = array2[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy2 = new Uint8Array(arrayView);
        return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array2, byteOffset, length) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array2.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array2);
      } else if (length === void 0) {
        buf = new Uint8Array(array2, byteOffset);
      } else {
        buf = new Uint8Array(array2, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a2, b2) {
      if (isInstance(a2, Uint8Array)) a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b2, Uint8Array)) b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
      if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a2 === b2) return 0;
      var x2 = a2.length;
      var y2 = b2.length;
      for (var i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
        if (a2[i2] !== b2[i2]) {
          x2 = a2[i2];
          y2 = b2[i2];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i2;
      if (length === void 0) {
        length = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length += list[i2].length;
        }
      }
      var buffer2 = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        var buf = list[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            Buffer2.from(buf).copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string2, encoding) {
      if (Buffer2.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      var len = string2.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes2(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string2).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap2(b2, n2, m2) {
      var i2 = b2[n2];
      b2[n2] = b2[m2];
      b2[m2] = i2;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 2) {
        swap2(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 4) {
        swap2(this, i2, i2 + 3);
        swap2(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 8) {
        swap2(this, i2, i2 + 7);
        swap2(this, i2 + 1, i2 + 6);
        swap2(this, i2 + 2, i2 + 5);
        swap2(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      var length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b2) {
      if (!Buffer2.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
      if (this === b2) return true;
      return Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max2 = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x2 = thisEnd - thisStart;
      var y2 = end - start;
      var len = Math.min(x2, y2);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x2 = thisCopy[i2];
          y2 = targetCopy[i2];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      var i2;
      if (dir) {
        var foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          var found = true;
          for (var j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i2 + j2) !== read(val, j2)) {
              found = false;
              break;
            }
          }
          if (found) return i2;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string2, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string2.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i2 = 0; i2 < length; ++i2) {
        var parsed = parseInt(string2.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string2, offset, length) {
      return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string2, offset, length) {
      return blitBuffer(asciiToBytes(string2), buf, offset, length);
    }
    function base64Write(buf, string2, offset, length) {
      return blitBuffer(base64ToBytes2(string2), buf, offset, length);
    }
    function ucs2Write(buf, string2, offset, length) {
      return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string2, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset, length);
          case "base64":
            return base64Write(this, string2, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i2 = start;
      while (i2 < end) {
        var firstByte = buf[i2];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i2 = 0;
      while (i2 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = "";
      for (var i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice2(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var i2 = byteLength2;
      var mul = 1;
      var val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max2, min2) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i2 = byteLength2 - 1;
      var mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i2 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i2 = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max2, min2) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee7542.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee7542.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      var i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string2, units) {
      units = units || Infinity;
      var codePoint;
      var length = string2.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i2 = 0; i2 < length; ++i2) {
        codePoint = string2.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c2, hi, lo;
      var byteArray = [];
      for (var i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0) break;
        c2 = str.charCodeAt(i2);
        hi = c2 >> 8;
        lo = c2 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes2(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i2 = 0; i2 < length; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src.length) break;
        dst[i2 + offset] = src[i2];
      }
      return i2;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = (function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i2 = 0; i2 < 16; ++i2) {
        var i16 = i2 * 16;
        for (var j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet[i2] + alphabet[j2];
        }
      }
      return table;
    })();
  })(buffer$1);
  return buffer$1;
}
var reedSolomonEncoder;
var hasRequiredReedSolomonEncoder;
function requireReedSolomonEncoder() {
  if (hasRequiredReedSolomonEncoder) return reedSolomonEncoder;
  hasRequiredReedSolomonEncoder = 1;
  var BufferUtil = requireTypedarrayBuffer();
  var Polynomial = requirePolynomial();
  var Buffer2 = requireBuffer$1().Buffer;
  function ReedSolomonEncoder(degree) {
    this.genPoly = void 0;
    this.degree = degree;
    if (this.degree) this.initialize(this.degree);
  }
  ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
    this.degree = degree;
    this.genPoly = Polynomial.generateECPolynomial(this.degree);
  };
  ReedSolomonEncoder.prototype.encode = function encode2(data) {
    if (!this.genPoly) {
      throw new Error("Encoder not initialized");
    }
    var pad2 = BufferUtil.alloc(this.degree);
    var paddedData = Buffer2.concat([data, pad2], data.length + this.degree);
    var remainder = Polynomial.mod(paddedData, this.genPoly);
    var start = this.degree - remainder.length;
    if (start > 0) {
      var buff = BufferUtil.alloc(this.degree);
      remainder.copy(buff, start);
      return buff;
    }
    return remainder;
  };
  reedSolomonEncoder = ReedSolomonEncoder;
  return reedSolomonEncoder;
}
var version = {};
var mode = {};
var versionCheck = {};
var hasRequiredVersionCheck;
function requireVersionCheck() {
  if (hasRequiredVersionCheck) return versionCheck;
  hasRequiredVersionCheck = 1;
  versionCheck.isValid = function isValid(version2) {
    return !isNaN(version2) && version2 >= 1 && version2 <= 40;
  };
  return versionCheck;
}
var regex = {};
var hasRequiredRegex;
function requireRegex() {
  if (hasRequiredRegex) return regex;
  hasRequiredRegex = 1;
  var numeric = "[0-9]+";
  var alphanumeric = "[A-Z $%*+\\-./:]+";
  var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
  kanji = kanji.replace(/u/g, "\\u");
  var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
  regex.KANJI = new RegExp(kanji, "g");
  regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
  regex.BYTE = new RegExp(byte, "g");
  regex.NUMERIC = new RegExp(numeric, "g");
  regex.ALPHANUMERIC = new RegExp(alphanumeric, "g");
  var TEST_KANJI = new RegExp("^" + kanji + "$");
  var TEST_NUMERIC = new RegExp("^" + numeric + "$");
  var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
  regex.testKanji = function testKanji(str) {
    return TEST_KANJI.test(str);
  };
  regex.testNumeric = function testNumeric(str) {
    return TEST_NUMERIC.test(str);
  };
  regex.testAlphanumeric = function testAlphanumeric(str) {
    return TEST_ALPHANUMERIC.test(str);
  };
  return regex;
}
var hasRequiredMode;
function requireMode() {
  if (hasRequiredMode) return mode;
  hasRequiredMode = 1;
  (function(exports) {
    var VersionCheck = requireVersionCheck();
    var Regex = requireRegex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
      if (!mode2.ccBits) throw new Error("Invalid mode: " + mode2);
      if (!VersionCheck.isValid(version2)) {
        throw new Error("Invalid version: " + version2);
      }
      if (version2 >= 1 && version2 < 10) return mode2.ccBits[0];
      else if (version2 < 27) return mode2.ccBits[1];
      return mode2.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr)) return exports.KANJI;
      else return exports.BYTE;
    };
    exports.toString = function toString2(mode2) {
      if (mode2 && mode2.id) return mode2.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode2) {
      return mode2 && mode2.bit && mode2.ccBits;
    };
    function fromString(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string2.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string2);
      }
    }
    exports.from = function from2(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e3) {
        return defaultValue;
      }
    };
  })(mode);
  return mode;
}
var hasRequiredVersion;
function requireVersion() {
  if (hasRequiredVersion) return version;
  hasRequiredVersion = 1;
  (function(exports) {
    var Utils = requireUtils$1();
    var ECCode = requireErrorCorrectionCode();
    var ECLevel = requireErrorCorrectionLevel();
    var Mode = requireMode();
    var VersionCheck = requireVersionCheck();
    var isArray = requireIsarray();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode2, length, errorCorrectionLevel2) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode2, version2) {
      return Mode.getCharCountIndicator(mode2, version2) + 4;
    }
    function getTotalBitsFromDataArray(segments2, version2) {
      var totalBits = 0;
      segments2.forEach(function(data) {
        var reservedBits = getReservedBitsCount(data.mode, version2);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        var length = getTotalBitsFromDataArray(segments2, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel2, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from2(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
      if (!VersionCheck.isValid(version2)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode2 === "undefined") mode2 = Mode.BYTE;
      var totalCodewords = Utils.getSymbolTotalCodewords(version2);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode2 === Mode.MIXED) return dataTotalCodewordsBits;
      var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
      switch (mode2) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel2) {
      var seg;
      var ecl = ECLevel.from(errorCorrectionLevel2, ECLevel.M);
      if (isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version2) {
      if (!VersionCheck.isValid(version2) || version2 < 7) {
        throw new Error("Invalid QR Code version");
      }
      var d2 = version2 << 12;
      while (Utils.getBCHDigit(d2) - G18_BCH >= 0) {
        d2 ^= G18 << Utils.getBCHDigit(d2) - G18_BCH;
      }
      return version2 << 12 | d2;
    };
  })(version);
  return version;
}
var formatInfo = {};
var hasRequiredFormatInfo;
function requireFormatInfo() {
  if (hasRequiredFormatInfo) return formatInfo;
  hasRequiredFormatInfo = 1;
  var Utils = requireUtils$1();
  var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
  var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
  var G15_BCH = Utils.getBCHDigit(G15);
  formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask) {
    var data = errorCorrectionLevel2.bit << 3 | mask;
    var d2 = data << 10;
    while (Utils.getBCHDigit(d2) - G15_BCH >= 0) {
      d2 ^= G15 << Utils.getBCHDigit(d2) - G15_BCH;
    }
    return (data << 10 | d2) ^ G15_MASK;
  };
  return formatInfo;
}
var segments = {};
var numericData;
var hasRequiredNumericData;
function requireNumericData() {
  if (hasRequiredNumericData) return numericData;
  hasRequiredNumericData = 1;
  var Mode = requireMode();
  function NumericData(data) {
    this.mode = Mode.NUMERIC;
    this.data = data.toString();
  }
  NumericData.getBitsLength = function getBitsLength(length) {
    return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
  };
  NumericData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  NumericData.prototype.getBitsLength = function getBitsLength() {
    return NumericData.getBitsLength(this.data.length);
  };
  NumericData.prototype.write = function write(bitBuffer2) {
    var i2, group, value;
    for (i2 = 0; i2 + 3 <= this.data.length; i2 += 3) {
      group = this.data.substr(i2, 3);
      value = parseInt(group, 10);
      bitBuffer2.put(value, 10);
    }
    var remainingNum = this.data.length - i2;
    if (remainingNum > 0) {
      group = this.data.substr(i2);
      value = parseInt(group, 10);
      bitBuffer2.put(value, remainingNum * 3 + 1);
    }
  };
  numericData = NumericData;
  return numericData;
}
var alphanumericData;
var hasRequiredAlphanumericData;
function requireAlphanumericData() {
  if (hasRequiredAlphanumericData) return alphanumericData;
  hasRequiredAlphanumericData = 1;
  var Mode = requireMode();
  var ALPHA_NUM_CHARS = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    " ",
    "$",
    "%",
    "*",
    "+",
    "-",
    ".",
    "/",
    ":"
  ];
  function AlphanumericData(data) {
    this.mode = Mode.ALPHANUMERIC;
    this.data = data;
  }
  AlphanumericData.getBitsLength = function getBitsLength(length) {
    return 11 * Math.floor(length / 2) + 6 * (length % 2);
  };
  AlphanumericData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  AlphanumericData.prototype.getBitsLength = function getBitsLength() {
    return AlphanumericData.getBitsLength(this.data.length);
  };
  AlphanumericData.prototype.write = function write(bitBuffer2) {
    var i2;
    for (i2 = 0; i2 + 2 <= this.data.length; i2 += 2) {
      var value = ALPHA_NUM_CHARS.indexOf(this.data[i2]) * 45;
      value += ALPHA_NUM_CHARS.indexOf(this.data[i2 + 1]);
      bitBuffer2.put(value, 11);
    }
    if (this.data.length % 2) {
      bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i2]), 6);
    }
  };
  alphanumericData = AlphanumericData;
  return alphanumericData;
}
var byteData;
var hasRequiredByteData;
function requireByteData() {
  if (hasRequiredByteData) return byteData;
  hasRequiredByteData = 1;
  var BufferUtil = requireTypedarrayBuffer();
  var Mode = requireMode();
  function ByteData(data) {
    this.mode = Mode.BYTE;
    this.data = BufferUtil.from(data);
  }
  ByteData.getBitsLength = function getBitsLength(length) {
    return length * 8;
  };
  ByteData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  ByteData.prototype.getBitsLength = function getBitsLength() {
    return ByteData.getBitsLength(this.data.length);
  };
  ByteData.prototype.write = function(bitBuffer2) {
    for (var i2 = 0, l2 = this.data.length; i2 < l2; i2++) {
      bitBuffer2.put(this.data[i2], 8);
    }
  };
  byteData = ByteData;
  return byteData;
}
var kanjiData;
var hasRequiredKanjiData;
function requireKanjiData() {
  if (hasRequiredKanjiData) return kanjiData;
  hasRequiredKanjiData = 1;
  var Mode = requireMode();
  var Utils = requireUtils$1();
  function KanjiData(data) {
    this.mode = Mode.KANJI;
    this.data = data;
  }
  KanjiData.getBitsLength = function getBitsLength(length) {
    return length * 13;
  };
  KanjiData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  KanjiData.prototype.getBitsLength = function getBitsLength() {
    return KanjiData.getBitsLength(this.data.length);
  };
  KanjiData.prototype.write = function(bitBuffer2) {
    var i2;
    for (i2 = 0; i2 < this.data.length; i2++) {
      var value = Utils.toSJIS(this.data[i2]);
      if (value >= 33088 && value <= 40956) {
        value -= 33088;
      } else if (value >= 57408 && value <= 60351) {
        value -= 49472;
      } else {
        throw new Error(
          "Invalid SJIS character: " + this.data[i2] + "\nMake sure your charset is UTF-8"
        );
      }
      value = (value >>> 8 & 255) * 192 + (value & 255);
      bitBuffer2.put(value, 13);
    }
  };
  kanjiData = KanjiData;
  return kanjiData;
}
var dijkstra = { exports: {} };
var hasRequiredDijkstra;
function requireDijkstra() {
  if (hasRequiredDijkstra) return dijkstra.exports;
  hasRequiredDijkstra = 1;
  (function(module) {
    var dijkstra2 = {
      single_source_shortest_paths: function(graph, s2, d2) {
        var predecessors = {};
        var costs = {};
        costs[s2] = 0;
        var open = dijkstra2.PriorityQueue.make();
        open.push(s2, 0);
        var closest, u2, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u2 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u2] || {};
          for (v2 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v2)) {
              cost_of_e = adjacent_nodes[v2];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v2];
              first_visit = typeof costs[v2] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v2] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v2, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v2] = u2;
              }
            }
          }
        }
        if (typeof d2 !== "undefined" && typeof costs[d2] === "undefined") {
          var msg = ["Could not find a path from ", s2, " to ", d2, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d2) {
        var nodes = [];
        var u2 = d2;
        while (u2) {
          nodes.push(u2);
          predecessors[u2];
          u2 = predecessors[u2];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s2, d2) {
        var predecessors = dijkstra2.single_source_shortest_paths(graph, s2, d2);
        return dijkstra2.extract_shortest_path_from_predecessor_list(
          predecessors,
          d2
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(opts) {
          var T2 = dijkstra2.PriorityQueue, t2 = {}, key;
          opts = opts || {};
          for (key in T2) {
            if (T2.hasOwnProperty(key)) {
              t2[key] = T2[key];
            }
          }
          t2.queue = [];
          t2.sorter = opts.sorter || T2.default_sorter;
          return t2;
        },
        default_sorter: function(a2, b2) {
          return a2.cost - b2.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    {
      module.exports = dijkstra2;
    }
  })(dijkstra);
  return dijkstra.exports;
}
var hasRequiredSegments;
function requireSegments() {
  if (hasRequiredSegments) return segments;
  hasRequiredSegments = 1;
  (function(exports) {
    var Mode = requireMode();
    var NumericData = requireNumericData();
    var AlphanumericData = requireAlphanumericData();
    var ByteData = requireByteData();
    var KanjiData = requireKanjiData();
    var Regex = requireRegex();
    var Utils = requireUtils$1();
    var dijkstra2 = requireDijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex2, mode2, str) {
      var segments2 = [];
      var result;
      while ((result = regex2.exec(str)) !== null) {
        segments2.push({
          data: result[0],
          index: result.index,
          mode: mode2,
          length: result[0].length
        });
      }
      return segments2;
    }
    function getSegmentsFromString(dataStr) {
      var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      var byteSegs;
      var kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode2) {
      switch (mode2) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      var nodes = [];
      for (var i2 = 0; i2 < segs.length; i2++) {
        var seg = segs[i2];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version2) {
      var table = {};
      var graph = { "start": {} };
      var prevNodeIds = ["start"];
      for (var i2 = 0; i2 < nodes.length; i2++) {
        var nodeGroup = nodes[i2];
        var currentNodeIds = [];
        for (var j2 = 0; j2 < nodeGroup.length; j2++) {
          var node = nodeGroup[j2];
          var key = "" + i2 + j2;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (var n2 = 0; n2 < prevNodeIds.length; n2++) {
            var prevNodeId = prevNodeIds[n2];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version2);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (n2 = 0; n2 < prevNodeIds.length; n2++) {
        graph[prevNodeIds[n2]]["end"] = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      var mode2;
      var bestMode = Mode.getBestModeForData(data);
      mode2 = Mode.from(modesHint, bestMode);
      if (mode2 !== Mode.BYTE && mode2.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode2) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode2 === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode2 = Mode.BYTE;
      }
      switch (mode2) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray(array2) {
      return array2.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString(data, version2) {
      var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      var nodes = buildNodes(segs);
      var graph = buildGraph(nodes, version2);
      var path2 = dijkstra2.find_path(graph.map, "start", "end");
      var optimizedSegs = [];
      for (var i2 = 1; i2 < path2.length - 1; i2++) {
        optimizedSegs.push(graph.table[path2[i2]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  })(segments);
  return segments;
}
var hasRequiredQrcode;
function requireQrcode() {
  if (hasRequiredQrcode) return qrcode;
  hasRequiredQrcode = 1;
  var BufferUtil = requireTypedarrayBuffer();
  var Utils = requireUtils$1();
  var ECLevel = requireErrorCorrectionLevel();
  var BitBuffer = requireBitBuffer();
  var BitMatrix = requireBitMatrix();
  var AlignmentPattern = requireAlignmentPattern();
  var FinderPattern = requireFinderPattern();
  var MaskPattern = requireMaskPattern();
  var ECCode = requireErrorCorrectionCode();
  var ReedSolomonEncoder = requireReedSolomonEncoder();
  var Version = requireVersion();
  var FormatInfo = requireFormatInfo();
  var Mode = requireMode();
  var Segments = requireSegments();
  var isArray = requireIsarray();
  function setupFinderPattern(matrix, version2) {
    var size = matrix.size;
    var pos = FinderPattern.getPositions(version2);
    for (var i2 = 0; i2 < pos.length; i2++) {
      var row = pos[i2][0];
      var col = pos[i2][1];
      for (var r2 = -1; r2 <= 7; r2++) {
        if (row + r2 <= -1 || size <= row + r2) continue;
        for (var c2 = -1; c2 <= 7; c2++) {
          if (col + c2 <= -1 || size <= col + c2) continue;
          if (r2 >= 0 && r2 <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c2 >= 2 && c2 <= 4) {
            matrix.set(row + r2, col + c2, true, true);
          } else {
            matrix.set(row + r2, col + c2, false, true);
          }
        }
      }
    }
  }
  function setupTimingPattern(matrix) {
    var size = matrix.size;
    for (var r2 = 8; r2 < size - 8; r2++) {
      var value = r2 % 2 === 0;
      matrix.set(r2, 6, value, true);
      matrix.set(6, r2, value, true);
    }
  }
  function setupAlignmentPattern(matrix, version2) {
    var pos = AlignmentPattern.getPositions(version2);
    for (var i2 = 0; i2 < pos.length; i2++) {
      var row = pos[i2][0];
      var col = pos[i2][1];
      for (var r2 = -2; r2 <= 2; r2++) {
        for (var c2 = -2; c2 <= 2; c2++) {
          if (r2 === -2 || r2 === 2 || c2 === -2 || c2 === 2 || r2 === 0 && c2 === 0) {
            matrix.set(row + r2, col + c2, true, true);
          } else {
            matrix.set(row + r2, col + c2, false, true);
          }
        }
      }
    }
  }
  function setupVersionInfo(matrix, version2) {
    var size = matrix.size;
    var bits = Version.getEncodedBits(version2);
    var row, col, mod;
    for (var i2 = 0; i2 < 18; i2++) {
      row = Math.floor(i2 / 3);
      col = i2 % 3 + size - 8 - 3;
      mod = (bits >> i2 & 1) === 1;
      matrix.set(row, col, mod, true);
      matrix.set(col, row, mod, true);
    }
  }
  function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
    var size = matrix.size;
    var bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
    var i2, mod;
    for (i2 = 0; i2 < 15; i2++) {
      mod = (bits >> i2 & 1) === 1;
      if (i2 < 6) {
        matrix.set(i2, 8, mod, true);
      } else if (i2 < 8) {
        matrix.set(i2 + 1, 8, mod, true);
      } else {
        matrix.set(size - 15 + i2, 8, mod, true);
      }
      if (i2 < 8) {
        matrix.set(8, size - i2 - 1, mod, true);
      } else if (i2 < 9) {
        matrix.set(8, 15 - i2 - 1 + 1, mod, true);
      } else {
        matrix.set(8, 15 - i2 - 1, mod, true);
      }
    }
    matrix.set(size - 8, 8, 1, true);
  }
  function setupData(matrix, data) {
    var size = matrix.size;
    var inc = -1;
    var row = size - 1;
    var bitIndex = 7;
    var byteIndex = 0;
    for (var col = size - 1; col > 0; col -= 2) {
      if (col === 6) col--;
      while (true) {
        for (var c2 = 0; c2 < 2; c2++) {
          if (!matrix.isReserved(row, col - c2)) {
            var dark = false;
            if (byteIndex < data.length) {
              dark = (data[byteIndex] >>> bitIndex & 1) === 1;
            }
            matrix.set(row, col - c2, dark);
            bitIndex--;
            if (bitIndex === -1) {
              byteIndex++;
              bitIndex = 7;
            }
          }
        }
        row += inc;
        if (row < 0 || size <= row) {
          row -= inc;
          inc = -inc;
          break;
        }
      }
    }
  }
  function createData(version2, errorCorrectionLevel2, segments2) {
    var buffer2 = new BitBuffer();
    segments2.forEach(function(data) {
      buffer2.put(data.mode.bit, 4);
      buffer2.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version2));
      data.write(buffer2);
    });
    var totalCodewords = Utils.getSymbolTotalCodewords(version2);
    var ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
      buffer2.put(0, 4);
    }
    while (buffer2.getLengthInBits() % 8 !== 0) {
      buffer2.putBit(0);
    }
    var remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
    for (var i2 = 0; i2 < remainingByte; i2++) {
      buffer2.put(i2 % 2 ? 17 : 236, 8);
    }
    return createCodewords(buffer2, version2, errorCorrectionLevel2);
  }
  function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
    var totalCodewords = Utils.getSymbolTotalCodewords(version2);
    var ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    var dataTotalCodewords = totalCodewords - ecTotalCodewords;
    var ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
    var blocksInGroup2 = totalCodewords % ecTotalBlocks;
    var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
    var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
    var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
    var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
    var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
    var rs = new ReedSolomonEncoder(ecCount);
    var offset = 0;
    var dcData = new Array(ecTotalBlocks);
    var ecData = new Array(ecTotalBlocks);
    var maxDataSize = 0;
    var buffer2 = BufferUtil.from(bitBuffer2.buffer);
    for (var b2 = 0; b2 < ecTotalBlocks; b2++) {
      var dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
      dcData[b2] = buffer2.slice(offset, offset + dataSize);
      ecData[b2] = rs.encode(dcData[b2]);
      offset += dataSize;
      maxDataSize = Math.max(maxDataSize, dataSize);
    }
    var data = BufferUtil.alloc(totalCodewords);
    var index = 0;
    var i2, r2;
    for (i2 = 0; i2 < maxDataSize; i2++) {
      for (r2 = 0; r2 < ecTotalBlocks; r2++) {
        if (i2 < dcData[r2].length) {
          data[index++] = dcData[r2][i2];
        }
      }
    }
    for (i2 = 0; i2 < ecCount; i2++) {
      for (r2 = 0; r2 < ecTotalBlocks; r2++) {
        data[index++] = ecData[r2][i2];
      }
    }
    return data;
  }
  function createSymbol(data, version2, errorCorrectionLevel2, maskPattern2) {
    var segments2;
    if (isArray(data)) {
      segments2 = Segments.fromArray(data);
    } else if (typeof data === "string") {
      var estimatedVersion = version2;
      if (!estimatedVersion) {
        var rawSegments = Segments.rawSplit(data);
        estimatedVersion = Version.getBestVersionForData(
          rawSegments,
          errorCorrectionLevel2
        );
      }
      segments2 = Segments.fromString(data, estimatedVersion || 40);
    } else {
      throw new Error("Invalid data");
    }
    var bestVersion = Version.getBestVersionForData(
      segments2,
      errorCorrectionLevel2
    );
    if (!bestVersion) {
      throw new Error("The amount of data is too big to be stored in a QR Code");
    }
    if (!version2) {
      version2 = bestVersion;
    } else if (version2 < bestVersion) {
      throw new Error(
        "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
      );
    }
    var dataBits = createData(version2, errorCorrectionLevel2, segments2);
    var moduleCount = Utils.getSymbolSize(version2);
    var modules = new BitMatrix(moduleCount);
    setupFinderPattern(modules, version2);
    setupTimingPattern(modules);
    setupAlignmentPattern(modules, version2);
    setupFormatInfo(modules, errorCorrectionLevel2, 0);
    if (version2 >= 7) {
      setupVersionInfo(modules, version2);
    }
    setupData(modules, dataBits);
    if (isNaN(maskPattern2)) {
      maskPattern2 = MaskPattern.getBestMask(
        modules,
        setupFormatInfo.bind(null, modules, errorCorrectionLevel2)
      );
    }
    MaskPattern.applyMask(maskPattern2, modules);
    setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
    return {
      modules,
      version: version2,
      errorCorrectionLevel: errorCorrectionLevel2,
      maskPattern: maskPattern2,
      segments: segments2
    };
  }
  qrcode.create = function create(data, options) {
    if (typeof data === "undefined" || data === "") {
      throw new Error("No input text");
    }
    var errorCorrectionLevel2 = ECLevel.M;
    var version2;
    var mask;
    if (typeof options !== "undefined") {
      errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
      version2 = Version.from(options.version);
      mask = MaskPattern.from(options.maskPattern);
      if (options.toSJISFunc) {
        Utils.setToSJISFunction(options.toSJISFunc);
      }
    }
    return createSymbol(data, version2, errorCorrectionLevel2, mask);
  };
  return qrcode;
}
var canvas = {};
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  (function(exports) {
    function hex2rgba(hex2) {
      if (typeof hex2 === "number") {
        hex2 = hex2.toString();
      }
      if (typeof hex2 !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      var hexCode = hex2.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex2);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c2) {
          return [c2, c2];
        }));
      }
      if (hexCode.length === 6) hexCode.push("F", "F");
      var hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options) options = {};
      if (!options.color) options.color = {};
      var margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      var width = options.width && options.width >= 21 ? options.width : void 0;
      var scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      var scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      var size = qr.modules.size;
      var data = qr.modules.data;
      var scale = exports.getScale(size, opts);
      var symbolSize = Math.floor((size + opts.margin * 2) * scale);
      var scaledMargin = opts.margin * scale;
      var palette = [opts.color.light, opts.color.dark];
      for (var i2 = 0; i2 < symbolSize; i2++) {
        for (var j2 = 0; j2 < symbolSize; j2++) {
          var posDst = (i2 * symbolSize + j2) * 4;
          var pxColor = opts.color.light;
          if (i2 >= scaledMargin && j2 >= scaledMargin && i2 < symbolSize - scaledMargin && j2 < symbolSize - scaledMargin) {
            var iSrc = Math.floor((i2 - scaledMargin) / scale);
            var jSrc = Math.floor((j2 - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  })(utils);
  return utils;
}
var hasRequiredCanvas;
function requireCanvas() {
  if (hasRequiredCanvas) return canvas;
  hasRequiredCanvas = 1;
  (function(exports) {
    var Utils = requireUtils();
    function clearCanvas(ctx, canvas2, size) {
      ctx.clearRect(0, 0, canvas2.width, canvas2.height);
      if (!canvas2.style) canvas2.style = {};
      canvas2.height = size;
      canvas2.width = size;
      canvas2.style.height = size + "px";
      canvas2.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e3) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas2, options) {
      var opts = options;
      var canvasEl = canvas2;
      if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
        opts = canvas2;
        canvas2 = void 0;
      }
      if (!canvas2) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      var size = Utils.getImageWidth(qrData.modules.size, opts);
      var ctx = canvasEl.getContext("2d");
      var image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
      var opts = options;
      if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
        opts = canvas2;
        canvas2 = void 0;
      }
      if (!opts) opts = {};
      var canvasEl = exports.render(qrData, canvas2, opts);
      var type = opts.type || "image/png";
      var rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  })(canvas);
  return canvas;
}
var svgTag = {};
var hasRequiredSvgTag;
function requireSvgTag() {
  if (hasRequiredSvgTag) return svgTag;
  hasRequiredSvgTag = 1;
  var Utils = requireUtils();
  function getColorAttrib(color2, attrib) {
    var alpha2 = color2.a / 255;
    var str = attrib + '="' + color2.hex + '"';
    return alpha2 < 1 ? str + " " + attrib + '-opacity="' + alpha2.toFixed(2).slice(1) + '"' : str;
  }
  function svgCmd(cmd, x2, y2) {
    var str = cmd + x2;
    if (typeof y2 !== "undefined") str += " " + y2;
    return str;
  }
  function qrToPath(data, size, margin) {
    var path2 = "";
    var moveBy = 0;
    var newRow = false;
    var lineLength = 0;
    for (var i2 = 0; i2 < data.length; i2++) {
      var col = Math.floor(i2 % size);
      var row = Math.floor(i2 / size);
      if (!col && !newRow) newRow = true;
      if (data[i2]) {
        lineLength++;
        if (!(i2 > 0 && col > 0 && data[i2 - 1])) {
          path2 += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
          moveBy = 0;
          newRow = false;
        }
        if (!(col + 1 < size && data[i2 + 1])) {
          path2 += svgCmd("h", lineLength);
          lineLength = 0;
        }
      } else {
        moveBy++;
      }
    }
    return path2;
  }
  svgTag.render = function render(qrData, options, cb) {
    var opts = Utils.getOptions(options);
    var size = qrData.modules.size;
    var data = qrData.modules.data;
    var qrcodesize = size + opts.margin * 2;
    var bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
    var path2 = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
    var viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
    var width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
    var svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path2 + "</svg>\n";
    if (typeof cb === "function") {
      cb(null, svgTag2);
    }
    return svgTag2;
  };
  return svgTag;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  var canPromise2 = requireCanPromise();
  var QRCode = requireQrcode();
  var CanvasRenderer = requireCanvas();
  var SvgRenderer = requireSvgTag();
  function renderCanvas(renderFunc, canvas2, text, opts, cb) {
    var args = [].slice.call(arguments, 1);
    var argsNum = args.length;
    var isLastArgCb = typeof args[argsNum - 1] === "function";
    if (!isLastArgCb && !canPromise2()) {
      throw new Error("Callback required as last argument");
    }
    if (isLastArgCb) {
      if (argsNum < 2) {
        throw new Error("Too few arguments provided");
      }
      if (argsNum === 2) {
        cb = text;
        text = canvas2;
        canvas2 = opts = void 0;
      } else if (argsNum === 3) {
        if (canvas2.getContext && typeof cb === "undefined") {
          cb = opts;
          opts = void 0;
        } else {
          cb = opts;
          opts = text;
          text = canvas2;
          canvas2 = void 0;
        }
      }
    } else {
      if (argsNum < 1) {
        throw new Error("Too few arguments provided");
      }
      if (argsNum === 1) {
        text = canvas2;
        canvas2 = opts = void 0;
      } else if (argsNum === 2 && !canvas2.getContext) {
        opts = text;
        text = canvas2;
        canvas2 = void 0;
      }
      return new Promise(function(resolve, reject) {
        try {
          var data2 = QRCode.create(text, opts);
          resolve(renderFunc(data2, canvas2, opts));
        } catch (e3) {
          reject(e3);
        }
      });
    }
    try {
      var data = QRCode.create(text, opts);
      cb(null, renderFunc(data, canvas2, opts));
    } catch (e3) {
      cb(e3);
    }
  }
  browser.create = QRCode.create;
  browser.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
  browser.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
  browser.toString = renderCanvas.bind(null, function(data, _2, opts) {
    return SvgRenderer.render(data, opts);
  });
  return browser;
}
var toggleSelection;
var hasRequiredToggleSelection;
function requireToggleSelection() {
  if (hasRequiredToggleSelection) return toggleSelection;
  hasRequiredToggleSelection = 1;
  toggleSelection = function() {
    var selection = document.getSelection();
    if (!selection.rangeCount) {
      return function() {
      };
    }
    var active = document.activeElement;
    var ranges = [];
    for (var i2 = 0; i2 < selection.rangeCount; i2++) {
      ranges.push(selection.getRangeAt(i2));
    }
    switch (active.tagName.toUpperCase()) {
      // .toUpperCase handles XHTML
      case "INPUT":
      case "TEXTAREA":
        active.blur();
        break;
      default:
        active = null;
        break;
    }
    selection.removeAllRanges();
    return function() {
      selection.type === "Caret" && selection.removeAllRanges();
      if (!selection.rangeCount) {
        ranges.forEach(function(range2) {
          selection.addRange(range2);
        });
      }
      active && active.focus();
    };
  };
  return toggleSelection;
}
var copyToClipboard;
var hasRequiredCopyToClipboard;
function requireCopyToClipboard() {
  if (hasRequiredCopyToClipboard) return copyToClipboard;
  hasRequiredCopyToClipboard = 1;
  var deselectCurrent = requireToggleSelection();
  var clipboardToIE11Formatting = {
    "text/plain": "Text",
    "text/html": "Url",
    "default": "Text"
  };
  var defaultMessage = "Copy to clipboard: #{key}, Enter";
  function format2(message) {
    var copyKey = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
    return message.replace(/#{\s*key\s*}/g, copyKey);
  }
  function copy2(text, options) {
    var debug, message, reselectPrevious, range2, selection, mark, success = false;
    if (!options) {
      options = {};
    }
    debug = options.debug || false;
    try {
      reselectPrevious = deselectCurrent();
      range2 = document.createRange();
      selection = document.getSelection();
      mark = document.createElement("span");
      mark.textContent = text;
      mark.ariaHidden = "true";
      mark.style.all = "unset";
      mark.style.position = "fixed";
      mark.style.top = 0;
      mark.style.clip = "rect(0, 0, 0, 0)";
      mark.style.whiteSpace = "pre";
      mark.style.webkitUserSelect = "text";
      mark.style.MozUserSelect = "text";
      mark.style.msUserSelect = "text";
      mark.style.userSelect = "text";
      mark.addEventListener("copy", function(e3) {
        e3.stopPropagation();
        if (options.format) {
          e3.preventDefault();
          if (typeof e3.clipboardData === "undefined") {
            debug && console.warn("unable to use e.clipboardData");
            debug && console.warn("trying IE specific stuff");
            window.clipboardData.clearData();
            var format3 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
            window.clipboardData.setData(format3, text);
          } else {
            e3.clipboardData.clearData();
            e3.clipboardData.setData(options.format, text);
          }
        }
        if (options.onCopy) {
          e3.preventDefault();
          options.onCopy(e3.clipboardData);
        }
      });
      document.body.appendChild(mark);
      range2.selectNodeContents(mark);
      selection.addRange(range2);
      var successful = document.execCommand("copy");
      if (!successful) {
        throw new Error("copy command was unsuccessful");
      }
      success = true;
    } catch (err) {
      debug && console.error("unable to copy using execCommand: ", err);
      debug && console.warn("trying IE specific stuff");
      try {
        window.clipboardData.setData(options.format || "text", text);
        options.onCopy && options.onCopy(window.clipboardData);
        success = true;
      } catch (err2) {
        debug && console.error("unable to copy using clipboardData: ", err2);
        debug && console.error("falling back to prompt");
        message = format2("message" in options ? options.message : defaultMessage);
        window.prompt(message, text);
      }
    } finally {
      if (selection) {
        if (typeof selection.removeRange == "function") {
          selection.removeRange(range2);
        } else {
          selection.removeAllRanges();
        }
      }
      if (mark) {
        document.body.removeChild(mark);
      }
      reselectPrevious();
    }
    return success;
  }
  copyToClipboard = copy2;
  return copyToClipboard;
}
var n, u$1, i$1, t$1, r$1, o$1, f$1, e$1 = {}, c$1 = [], s$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function a$1(n2, l2) {
  for (var u2 in l2) n2[u2] = l2[u2];
  return n2;
}
function v$1(n2) {
  var l2 = n2.parentNode;
  l2 && l2.removeChild(n2);
}
function h$1(n2, l2, u2) {
  var i2, t2 = arguments, r2 = {};
  for (i2 in l2) "key" !== i2 && "ref" !== i2 && (r2[i2] = l2[i2]);
  if (arguments.length > 3) for (u2 = [u2], i2 = 3; i2 < arguments.length; i2++) u2.push(t2[i2]);
  if (null != u2 && (r2.children = u2), "function" == typeof n2 && null != n2.defaultProps) for (i2 in n2.defaultProps) void 0 === r2[i2] && (r2[i2] = n2.defaultProps[i2]);
  return p$1(n2, r2, l2 && l2.key, l2 && l2.ref, null);
}
function p$1(l2, u2, i2, t2, r2) {
  var o2 = { type: l2, props: u2, key: i2, ref: t2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: r2 };
  return null == r2 && (o2.__v = o2), n.vnode && n.vnode(o2), o2;
}
function y$1() {
  return {};
}
function d$1(n2) {
  return n2.children;
}
function m$1(n2, l2) {
  this.props = n2, this.context = l2;
}
function w$2(n2, l2) {
  if (null == l2) return n2.__ ? w$2(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u2; l2 < n2.__k.length; l2++) if (null != (u2 = n2.__k[l2]) && null != u2.__e) return u2.__e;
  return "function" == typeof n2.type ? w$2(n2) : null;
}
function k$1(n2) {
  var l2, u2;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++) if (null != (u2 = n2.__k[l2]) && null != u2.__e) {
      n2.__e = n2.__c.base = u2.__e;
      break;
    }
    return k$1(n2);
  }
}
function g$1(l2) {
  (!l2.__d && (l2.__d = true) && u$1.push(l2) && !i$1++ || r$1 !== n.debounceRendering) && ((r$1 = n.debounceRendering) || t$1)(_$2);
}
function _$2() {
  for (var n2; i$1 = u$1.length; ) n2 = u$1.sort(function(n3, l2) {
    return n3.__v.__b - l2.__v.__b;
  }), u$1 = [], n2.some(function(n3) {
    var l2, u2, i2, t2, r2, o2, f2;
    n3.__d && (o2 = (r2 = (l2 = n3).__v).__e, (f2 = l2.__P) && (u2 = [], (i2 = a$1({}, r2)).__v = i2, t2 = A$2(f2, r2, i2, l2.__n, void 0 !== f2.ownerSVGElement, null, u2, null == o2 ? w$2(r2) : o2), T$2(u2, r2), t2 != o2 && k$1(r2)));
  });
}
function b(n2, l2, u2, i2, t2, r2, o2, f2, s2) {
  var a2, h2, p2, y2, d2, m2, k2, g2 = u2 && u2.__k || c$1, _2 = g2.length;
  if (f2 == e$1 && (f2 = null != r2 ? r2[0] : _2 ? w$2(u2, 0) : null), a2 = 0, l2.__k = x$1(l2.__k, function(u3) {
    if (null != u3) {
      if (u3.__ = l2, u3.__b = l2.__b + 1, null === (p2 = g2[a2]) || p2 && u3.key == p2.key && u3.type === p2.type) g2[a2] = void 0;
      else for (h2 = 0; h2 < _2; h2++) {
        if ((p2 = g2[h2]) && u3.key == p2.key && u3.type === p2.type) {
          g2[h2] = void 0;
          break;
        }
        p2 = null;
      }
      if (y2 = A$2(n2, u3, p2 = p2 || e$1, i2, t2, r2, o2, f2, s2), (h2 = u3.ref) && p2.ref != h2 && (k2 || (k2 = []), p2.ref && k2.push(p2.ref, null, u3), k2.push(h2, u3.__c || y2, u3)), null != y2) {
        var c2;
        if (null == m2 && (m2 = y2), void 0 !== u3.__d) c2 = u3.__d, u3.__d = void 0;
        else if (r2 == p2 || y2 != f2 || null == y2.parentNode) {
          n: if (null == f2 || f2.parentNode !== n2) n2.appendChild(y2), c2 = null;
          else {
            for (d2 = f2, h2 = 0; (d2 = d2.nextSibling) && h2 < _2; h2 += 2) if (d2 == y2) break n;
            n2.insertBefore(y2, f2), c2 = f2;
          }
          "option" == l2.type && (n2.value = "");
        }
        f2 = void 0 !== c2 ? c2 : y2.nextSibling, "function" == typeof l2.type && (l2.__d = f2);
      } else f2 && p2.__e == f2 && f2.parentNode != n2 && (f2 = w$2(p2));
    }
    return a2++, u3;
  }), l2.__e = m2, null != r2 && "function" != typeof l2.type) for (a2 = r2.length; a2--; ) null != r2[a2] && v$1(r2[a2]);
  for (a2 = _2; a2--; ) null != g2[a2] && D$1(g2[a2], g2[a2]);
  if (k2) for (a2 = 0; a2 < k2.length; a2++) j$1(k2[a2], k2[++a2], k2[++a2]);
}
function x$1(n2, l2, u2) {
  if (null == u2 && (u2 = []), null == n2 || "boolean" == typeof n2) l2 && u2.push(l2(null));
  else if (Array.isArray(n2)) for (var i2 = 0; i2 < n2.length; i2++) x$1(n2[i2], l2, u2);
  else u2.push(l2 ? l2("string" == typeof n2 || "number" == typeof n2 ? p$1(null, n2, null, null, n2) : null != n2.__e || null != n2.__c ? p$1(n2.type, n2.props, n2.key, null, n2.__v) : n2) : n2);
  return u2;
}
function P$1(n2, l2, u2, i2, t2) {
  var r2;
  for (r2 in u2) "children" === r2 || "key" === r2 || r2 in l2 || N$1(n2, r2, null, u2[r2], i2);
  for (r2 in l2) t2 && "function" != typeof l2[r2] || "children" === r2 || "key" === r2 || "value" === r2 || "checked" === r2 || u2[r2] === l2[r2] || N$1(n2, r2, l2[r2], u2[r2], i2);
}
function C$1(n2, l2, u2) {
  "-" === l2[0] ? n2.setProperty(l2, u2) : n2[l2] = "number" == typeof u2 && false === s$1.test(l2) ? u2 + "px" : null == u2 ? "" : u2;
}
function N$1(n2, l2, u2, i2, t2) {
  var r2, o2, f2, e3, c2;
  if (t2 ? "className" === l2 && (l2 = "class") : "class" === l2 && (l2 = "className"), "style" === l2) if (r2 = n2.style, "string" == typeof u2) r2.cssText = u2;
  else {
    if ("string" == typeof i2 && (r2.cssText = "", i2 = null), i2) for (e3 in i2) u2 && e3 in u2 || C$1(r2, e3, "");
    if (u2) for (c2 in u2) i2 && u2[c2] === i2[c2] || C$1(r2, c2, u2[c2]);
  }
  else "o" === l2[0] && "n" === l2[1] ? (o2 = l2 !== (l2 = l2.replace(/Capture$/, "")), f2 = l2.toLowerCase(), l2 = (f2 in n2 ? f2 : l2).slice(2), u2 ? (i2 || n2.addEventListener(l2, z$1, o2), (n2.l || (n2.l = {}))[l2] = u2) : n2.removeEventListener(l2, z$1, o2)) : "list" !== l2 && "tagName" !== l2 && "form" !== l2 && "type" !== l2 && "size" !== l2 && !t2 && l2 in n2 ? n2[l2] = null == u2 ? "" : u2 : "function" != typeof u2 && "dangerouslySetInnerHTML" !== l2 && (l2 !== (l2 = l2.replace(/^xlink:?/, "")) ? null == u2 || false === u2 ? n2.removeAttributeNS("http://www.w3.org/1999/xlink", l2.toLowerCase()) : n2.setAttributeNS("http://www.w3.org/1999/xlink", l2.toLowerCase(), u2) : null == u2 || false === u2 && !/^ar/.test(l2) ? n2.removeAttribute(l2) : n2.setAttribute(l2, u2));
}
function z$1(l2) {
  this.l[l2.type](n.event ? n.event(l2) : l2);
}
function A$2(l2, u2, i2, t2, r2, o2, f2, e3, c2) {
  var s2, v2, h2, p2, y2, w2, k2, g2, _2, x2, P2 = u2.type;
  if (void 0 !== u2.constructor) return null;
  (s2 = n.__b) && s2(u2);
  try {
    n: if ("function" == typeof P2) {
      if (g2 = u2.props, _2 = (s2 = P2.contextType) && t2[s2.__c], x2 = s2 ? _2 ? _2.props.value : s2.__ : t2, i2.__c ? k2 = (v2 = u2.__c = i2.__c).__ = v2.__E : ("prototype" in P2 && P2.prototype.render ? u2.__c = v2 = new P2(g2, x2) : (u2.__c = v2 = new m$1(g2, x2), v2.constructor = P2, v2.render = E$2), _2 && _2.sub(v2), v2.props = g2, v2.state || (v2.state = {}), v2.context = x2, v2.__n = t2, h2 = v2.__d = true, v2.__h = []), null == v2.__s && (v2.__s = v2.state), null != P2.getDerivedStateFromProps && (v2.__s == v2.state && (v2.__s = a$1({}, v2.__s)), a$1(v2.__s, P2.getDerivedStateFromProps(g2, v2.__s))), p2 = v2.props, y2 = v2.state, h2) null == P2.getDerivedStateFromProps && null != v2.componentWillMount && v2.componentWillMount(), null != v2.componentDidMount && v2.__h.push(v2.componentDidMount);
      else {
        if (null == P2.getDerivedStateFromProps && g2 !== p2 && null != v2.componentWillReceiveProps && v2.componentWillReceiveProps(g2, x2), !v2.__e && null != v2.shouldComponentUpdate && false === v2.shouldComponentUpdate(g2, v2.__s, x2) || u2.__v === i2.__v && !v2.__) {
          for (v2.props = g2, v2.state = v2.__s, u2.__v !== i2.__v && (v2.__d = false), v2.__v = u2, u2.__e = i2.__e, u2.__k = i2.__k, v2.__h.length && f2.push(v2), s2 = 0; s2 < u2.__k.length; s2++) u2.__k[s2] && (u2.__k[s2].__ = u2);
          break n;
        }
        null != v2.componentWillUpdate && v2.componentWillUpdate(g2, v2.__s, x2), null != v2.componentDidUpdate && v2.__h.push(function() {
          v2.componentDidUpdate(p2, y2, w2);
        });
      }
      v2.context = x2, v2.props = g2, v2.state = v2.__s, (s2 = n.__r) && s2(u2), v2.__d = false, v2.__v = u2, v2.__P = l2, s2 = v2.render(v2.props, v2.state, v2.context), u2.__k = null != s2 && s2.type == d$1 && null == s2.key ? s2.props.children : Array.isArray(s2) ? s2 : [s2], null != v2.getChildContext && (t2 = a$1(a$1({}, t2), v2.getChildContext())), h2 || null == v2.getSnapshotBeforeUpdate || (w2 = v2.getSnapshotBeforeUpdate(p2, y2)), b(l2, u2, i2, t2, r2, o2, f2, e3, c2), v2.base = u2.__e, v2.__h.length && f2.push(v2), k2 && (v2.__E = v2.__ = null), v2.__e = false;
    } else null == o2 && u2.__v === i2.__v ? (u2.__k = i2.__k, u2.__e = i2.__e) : u2.__e = $$1(i2.__e, u2, i2, t2, r2, o2, f2, c2);
    (s2 = n.diffed) && s2(u2);
  } catch (l3) {
    u2.__v = null, n.__e(l3, u2, i2);
  }
  return u2.__e;
}
function T$2(l2, u2) {
  n.__c && n.__c(u2, l2), l2.some(function(u3) {
    try {
      l2 = u3.__h, u3.__h = [], l2.some(function(n2) {
        n2.call(u3);
      });
    } catch (l3) {
      n.__e(l3, u3.__v);
    }
  });
}
function $$1(n2, l2, u2, i2, t2, r2, o2, f2) {
  var s2, a2, v2, h2, p2, y2 = u2.props, d2 = l2.props;
  if (t2 = "svg" === l2.type || t2, null != r2) {
    for (s2 = 0; s2 < r2.length; s2++) if (null != (a2 = r2[s2]) && ((null === l2.type ? 3 === a2.nodeType : a2.localName === l2.type) || n2 == a2)) {
      n2 = a2, r2[s2] = null;
      break;
    }
  }
  if (null == n2) {
    if (null === l2.type) return document.createTextNode(d2);
    n2 = t2 ? document.createElementNS("http://www.w3.org/2000/svg", l2.type) : document.createElement(l2.type, d2.is && { is: d2.is }), r2 = null, f2 = false;
  }
  if (null === l2.type) y2 !== d2 && n2.data != d2 && (n2.data = d2);
  else {
    if (null != r2 && (r2 = c$1.slice.call(n2.childNodes)), v2 = (y2 = u2.props || e$1).dangerouslySetInnerHTML, h2 = d2.dangerouslySetInnerHTML, !f2) {
      if (y2 === e$1) for (y2 = {}, p2 = 0; p2 < n2.attributes.length; p2++) y2[n2.attributes[p2].name] = n2.attributes[p2].value;
      (h2 || v2) && (h2 && v2 && h2.__html == v2.__html || (n2.innerHTML = h2 && h2.__html || ""));
    }
    P$1(n2, d2, y2, t2, f2), h2 ? l2.__k = [] : (l2.__k = l2.props.children, b(n2, l2, u2, i2, "foreignObject" !== l2.type && t2, r2, o2, e$1, f2)), f2 || ("value" in d2 && void 0 !== (s2 = d2.value) && s2 !== n2.value && N$1(n2, "value", s2, y2.value, false), "checked" in d2 && void 0 !== (s2 = d2.checked) && s2 !== n2.checked && N$1(n2, "checked", s2, y2.checked, false));
  }
  return n2;
}
function j$1(l2, u2, i2) {
  try {
    "function" == typeof l2 ? l2(u2) : l2.current = u2;
  } catch (l3) {
    n.__e(l3, i2);
  }
}
function D$1(l2, u2, i2) {
  var t2, r2, o2;
  if (n.unmount && n.unmount(l2), (t2 = l2.ref) && (t2.current && t2.current !== l2.__e || j$1(t2, null, u2)), i2 || "function" == typeof l2.type || (i2 = null != (r2 = l2.__e)), l2.__e = l2.__d = void 0, null != (t2 = l2.__c)) {
    if (t2.componentWillUnmount) try {
      t2.componentWillUnmount();
    } catch (l3) {
      n.__e(l3, u2);
    }
    t2.base = t2.__P = null;
  }
  if (t2 = l2.__k) for (o2 = 0; o2 < t2.length; o2++) t2[o2] && D$1(t2[o2], u2, i2);
  null != r2 && v$1(r2);
}
function E$2(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function H$1(l2, u2, i2) {
  var t2, r2, f2;
  n.__ && n.__(l2, u2), r2 = (t2 = i2 === o$1) ? null : i2 && i2.__k || u2.__k, l2 = h$1(d$1, null, [l2]), f2 = [], A$2(u2, (t2 ? u2 : i2 || u2).__k = l2, r2 || e$1, e$1, void 0 !== u2.ownerSVGElement, i2 && !t2 ? [i2] : r2 ? null : c$1.slice.call(u2.childNodes), f2, i2 || e$1, t2), T$2(f2, l2);
}
function I$1(n2, l2) {
  H$1(n2, l2, o$1);
}
function L$2(n2, l2) {
  var u2, i2;
  for (i2 in l2 = a$1(a$1({}, n2.props), l2), arguments.length > 2 && (l2.children = c$1.slice.call(arguments, 2)), u2 = {}, l2) "key" !== i2 && "ref" !== i2 && (u2[i2] = l2[i2]);
  return p$1(n2.type, u2, l2.key || n2.key, l2.ref || n2.ref, null);
}
function M$1(n2) {
  var l2 = {}, u2 = { __c: "__cC" + f$1++, __: n2, Consumer: function(n3, l3) {
    return n3.children(l3);
  }, Provider: function(n3) {
    var i2, t2 = this;
    return this.getChildContext || (i2 = [], this.getChildContext = function() {
      return l2[u2.__c] = t2, l2;
    }, this.shouldComponentUpdate = function(n4) {
      t2.props.value !== n4.value && i2.some(function(l3) {
        l3.context = n4.value, g$1(l3);
      });
    }, this.sub = function(n4) {
      i2.push(n4);
      var l3 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        i2.splice(i2.indexOf(n4), 1), l3 && l3.call(n4);
      };
    }), n3.children;
  } };
  return u2.Consumer.contextType = u2, u2.Provider.__ = u2, u2;
}
n = { __e: function(n2, l2) {
  for (var u2, i2; l2 = l2.__; ) if ((u2 = l2.__c) && !u2.__) try {
    if (u2.constructor && null != u2.constructor.getDerivedStateFromError && (i2 = true, u2.setState(u2.constructor.getDerivedStateFromError(n2))), null != u2.componentDidCatch && (i2 = true, u2.componentDidCatch(n2)), i2) return g$1(u2.__E = u2);
  } catch (l3) {
    n2 = l3;
  }
  throw n2;
} }, m$1.prototype.setState = function(n2, l2) {
  var u2;
  u2 = this.__s !== this.state ? this.__s : this.__s = a$1({}, this.state), "function" == typeof n2 && (n2 = n2(u2, this.props)), n2 && a$1(u2, n2), null != n2 && this.__v && (l2 && this.__h.push(l2), g$1(this));
}, m$1.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), g$1(this));
}, m$1.prototype.render = d$1, u$1 = [], i$1 = 0, t$1 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o$1 = e$1, f$1 = 0;
var t, u, r, i = 0, o = [], c = n.__r, f = n.diffed, e = n.__c, a = n.unmount;
function v(t2, r2) {
  n.__h && n.__h(u, t2, i || r2), i = 0;
  var o2 = u.__H || (u.__H = { __: [], __h: [] });
  return t2 >= o2.__.length && o2.__.push({}), o2.__[t2];
}
function m(n2) {
  return i = 1, p(E$1, n2);
}
function p(n2, r2, i2) {
  var o2 = v(t++, 2);
  return o2.__c || (o2.__c = u, o2.__ = [i2 ? i2(r2) : E$1(void 0, r2), function(t2) {
    var u2 = n2(o2.__[0], t2);
    o2.__[0] !== u2 && (o2.__[0] = u2, o2.__c.setState({}));
  }]), o2.__;
}
function l(r2, i2) {
  var o2 = v(t++, 3);
  !n.__s && x(o2.__H, i2) && (o2.__ = r2, o2.__H = i2, u.__H.__h.push(o2));
}
function y(r2, i2) {
  var o2 = v(t++, 4);
  !n.__s && x(o2.__H, i2) && (o2.__ = r2, o2.__H = i2, u.__h.push(o2));
}
function d(n2) {
  return i = 5, h(function() {
    return { current: n2 };
  }, []);
}
function s(n2, t2, u2) {
  i = 6, y(function() {
    "function" == typeof n2 ? n2(t2()) : n2 && (n2.current = t2());
  }, null == u2 ? u2 : u2.concat(n2));
}
function h(n2, u2) {
  var r2 = v(t++, 7);
  return x(r2.__H, u2) ? (r2.__H = u2, r2.__h = n2, r2.__ = n2()) : r2.__;
}
function T$1(n2, t2) {
  return i = 8, h(function() {
    return n2;
  }, t2);
}
function w$1(n2) {
  var r2 = u.context[n2.__c], i2 = v(t++, 9);
  return i2.__c = n2, r2 ? (null == i2.__ && (i2.__ = true, r2.sub(u)), r2.props.value) : n2.__;
}
function A$1(t2, u2) {
  n.useDebugValue && n.useDebugValue(u2 ? u2(t2) : t2);
}
function F$1(n2) {
  var r2 = v(t++, 10), i2 = m();
  return r2.__ = n2, u.componentDidCatch || (u.componentDidCatch = function(n3) {
    r2.__ && r2.__(n3), i2[1](n3);
  }), [i2[0], function() {
    i2[1](void 0);
  }];
}
function _$1() {
  o.some(function(t2) {
    if (t2.__P) try {
      t2.__H.__h.forEach(g), t2.__H.__h.forEach(q$1), t2.__H.__h = [];
    } catch (u2) {
      return t2.__H.__h = [], n.__e(u2, t2.__v), true;
    }
  }), o = [];
}
function g(n2) {
  n2.t && n2.t();
}
function q$1(n2) {
  var t2 = n2.__();
  "function" == typeof t2 && (n2.t = t2);
}
function x(n2, t2) {
  return !n2 || t2.some(function(t3, u2) {
    return t3 !== n2[u2];
  });
}
function E$1(n2, t2) {
  return "function" == typeof t2 ? t2(n2) : t2;
}
n.__r = function(n2) {
  c && c(n2), t = 0, (u = n2.__c).__H && (u.__H.__h.forEach(g), u.__H.__h.forEach(q$1), u.__H.__h = []);
}, n.diffed = function(t2) {
  f && f(t2);
  var u2 = t2.__c;
  if (u2) {
    var i2 = u2.__H;
    i2 && i2.__h.length && (1 !== o.push(u2) && r === n.requestAnimationFrame || ((r = n.requestAnimationFrame) || function(n2) {
      var t3, u3 = function() {
        clearTimeout(r2), cancelAnimationFrame(t3), setTimeout(n2);
      }, r2 = setTimeout(u3, 100);
      "undefined" != typeof window && (t3 = requestAnimationFrame(u3));
    })(_$1));
  }
}, n.__c = function(t2, u2) {
  u2.some(function(t3) {
    try {
      t3.__h.forEach(g), t3.__h = t3.__h.filter(function(n2) {
        return !n2.__ || q$1(n2);
      });
    } catch (r2) {
      u2.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), u2 = [], n.__e(r2, t3.__v);
    }
  }), e && e(t2, u2);
}, n.unmount = function(t2) {
  a && a(t2);
  var u2 = t2.__c;
  if (u2) {
    var r2 = u2.__H;
    if (r2) try {
      r2.__.forEach(function(n2) {
        return n2.t && n2.t();
      });
    } catch (t3) {
      n.__e(t3, u2.__v);
    }
  }
};
function E(n2, t2) {
  for (var e3 in t2) n2[e3] = t2[e3];
  return n2;
}
function w(n2, t2) {
  for (var e3 in n2) if ("__source" !== e3 && !(e3 in t2)) return true;
  for (var r2 in t2) if ("__source" !== r2 && n2[r2] !== t2[r2]) return true;
  return false;
}
var C = (function(n2) {
  var t2, e3;
  function r2(t3) {
    var e4;
    return (e4 = n2.call(this, t3) || this).isPureReactComponent = true, e4;
  }
  return e3 = n2, (t2 = r2).prototype = Object.create(e3.prototype), t2.prototype.constructor = t2, t2.__proto__ = e3, r2.prototype.shouldComponentUpdate = function(n3, t3) {
    return w(this.props, n3) || w(this.state, t3);
  }, r2;
})(m$1);
function _(n2, t2) {
  function e3(n3) {
    var e4 = this.props.ref, r3 = e4 == n3.ref;
    return !r3 && e4 && (e4.call ? e4(null) : e4.current = null), t2 ? !t2(this.props, n3) || !r3 : w(this.props, n3);
  }
  function r2(t3) {
    return this.shouldComponentUpdate = e3, h$1(n2, E({}, t3));
  }
  return r2.prototype.isReactComponent = true, r2.displayName = "Memo(" + (n2.displayName || n2.name) + ")", r2.t = true, r2;
}
var A = n.__b;
function S(n2) {
  function t2(t3) {
    var e3 = E({}, t3);
    return delete e3.ref, n2(e3, t3.ref);
  }
  return t2.prototype.isReactComponent = t2.t = true, t2.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t2;
}
n.__b = function(n2) {
  n2.type && n2.type.t && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), A && A(n2);
};
var k = function(n2, t2) {
  return n2 ? x$1(n2).reduce(function(n3, e3, r2) {
    return n3.concat(t2(e3, r2));
  }, []) : null;
}, R = { map: k, forEach: k, count: function(n2) {
  return n2 ? x$1(n2).length : 0;
}, only: function(n2) {
  if (1 !== (n2 = x$1(n2)).length) throw new Error("Children.only() expects only one child.");
  return n2[0];
}, toArray: x$1 }, F = n.__e;
function N(n2) {
  return n2 && ((n2 = E({}, n2)).__c = null, n2.__k = n2.__k && n2.__k.map(N)), n2;
}
function U() {
  this.__u = 0, this.o = null, this.__b = null;
}
function M(n2) {
  var t2 = n2.__.__c;
  return t2 && t2.u && t2.u(n2);
}
function L$1(n2) {
  var t2, e3, r2;
  function o2(o3) {
    if (t2 || (t2 = n2()).then(function(n3) {
      e3 = n3.default || n3;
    }, function(n3) {
      r2 = n3;
    }), r2) throw r2;
    if (!e3) throw t2;
    return h$1(e3, o3);
  }
  return o2.displayName = "Lazy", o2.t = true, o2;
}
function O() {
  this.i = null, this.l = null;
}
n.__e = function(n2, t2, e3) {
  if (n2.then) {
    for (var r2, o2 = t2; o2 = o2.__; ) if ((r2 = o2.__c) && r2.__c) return r2.__c(n2, t2.__c);
  }
  F(n2, t2, e3);
}, (U.prototype = new m$1()).__c = function(n2, t2) {
  var e3 = this;
  null == e3.o && (e3.o = []), e3.o.push(t2);
  var r2 = M(e3.__v), o2 = false, u2 = function() {
    o2 || (o2 = true, r2 ? r2(i2) : i2());
  };
  t2.__c = t2.componentWillUnmount, t2.componentWillUnmount = function() {
    u2(), t2.__c && t2.__c();
  };
  var i2 = function() {
    var n3;
    if (!--e3.__u) for (e3.__v.__k[0] = e3.state.u, e3.setState({ u: e3.__b = null }); n3 = e3.o.pop(); ) n3.forceUpdate();
  };
  e3.__u++ || e3.setState({ u: e3.__b = e3.__v.__k[0] }), n2.then(u2, u2);
}, U.prototype.render = function(n2, t2) {
  return this.__b && (this.__v.__k[0] = N(this.__b), this.__b = null), [h$1(m$1, null, t2.u ? null : n2.children), t2.u && n2.fallback];
};
var P = function(n2, t2, e3) {
  if (++e3[1] === e3[0] && n2.l.delete(t2), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.l.size)) for (e3 = n2.i; e3; ) {
    for (; e3.length > 3; ) e3.pop()();
    if (e3[1] < e3[0]) break;
    n2.i = e3 = e3[2];
  }
};
(O.prototype = new m$1()).u = function(n2) {
  var t2 = this, e3 = M(t2.__v), r2 = t2.l.get(n2);
  return r2[0]++, function(o2) {
    var u2 = function() {
      t2.props.revealOrder ? (r2.push(o2), P(t2, n2, r2)) : o2();
    };
    e3 ? e3(u2) : u2();
  };
}, O.prototype.render = function(n2) {
  this.i = null, this.l = /* @__PURE__ */ new Map();
  var t2 = x$1(n2.children);
  n2.revealOrder && "b" === n2.revealOrder[0] && t2.reverse();
  for (var e3 = t2.length; e3--; ) this.l.set(t2[e3], this.i = [1, 0, this.i]);
  return n2.children;
}, O.prototype.componentDidUpdate = O.prototype.componentDidMount = function() {
  var n2 = this;
  n2.l.forEach(function(t2, e3) {
    P(n2, e3, t2);
  });
};
var W = (function() {
  function n2() {
  }
  var t2 = n2.prototype;
  return t2.getChildContext = function() {
    return this.props.context;
  }, t2.render = function(n3) {
    return n3.children;
  }, n2;
})();
function j(n2) {
  var t2 = this, e3 = n2.container, r2 = h$1(W, { context: t2.context }, n2.vnode);
  return t2.s && t2.s !== e3 && (t2.v.parentNode && t2.s.removeChild(t2.v), D$1(t2.h), t2.p = false), n2.vnode ? t2.p ? (e3.__k = t2.__k, H$1(r2, e3), t2.__k = e3.__k) : (t2.v = document.createTextNode(""), I$1("", e3), e3.appendChild(t2.v), t2.p = true, t2.s = e3, H$1(r2, e3, t2.v), t2.__k = t2.v.__k) : t2.p && (t2.v.parentNode && t2.s.removeChild(t2.v), D$1(t2.h)), t2.h = r2, t2.componentWillUnmount = function() {
    t2.v.parentNode && t2.s.removeChild(t2.v), D$1(t2.h);
  }, null;
}
function z(n2, t2) {
  return h$1(j, { vnode: n2, container: t2 });
}
var D = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
m$1.prototype.isReactComponent = {};
var H = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
function T(n2, t2, e3) {
  if (null == t2.__k) for (; t2.firstChild; ) t2.removeChild(t2.firstChild);
  return H$1(n2, t2), "function" == typeof e3 && e3(), n2 ? n2.__c : null;
}
function V(n2, t2, e3) {
  return I$1(n2, t2), "function" == typeof e3 && e3(), n2 ? n2.__c : null;
}
var Z = n.event;
function I(n2, t2) {
  n2["UNSAFE_" + t2] && !n2[t2] && Object.defineProperty(n2, t2, { configurable: false, get: function() {
    return this["UNSAFE_" + t2];
  }, set: function(n3) {
    this["UNSAFE_" + t2] = n3;
  } });
}
n.event = function(n2) {
  Z && (n2 = Z(n2)), n2.persist = function() {
  };
  var t2 = false, e3 = false, r2 = n2.stopPropagation;
  n2.stopPropagation = function() {
    r2.call(n2), t2 = true;
  };
  var o2 = n2.preventDefault;
  return n2.preventDefault = function() {
    o2.call(n2), e3 = true;
  }, n2.isPropagationStopped = function() {
    return t2;
  }, n2.isDefaultPrevented = function() {
    return e3;
  }, n2.nativeEvent = n2;
};
var $ = { configurable: true, get: function() {
  return this.class;
} }, q = n.vnode;
n.vnode = function(n2) {
  n2.$$typeof = H;
  var t2 = n2.type, e3 = n2.props;
  if (t2) {
    if (e3.class != e3.className && ($.enumerable = "className" in e3, null != e3.className && (e3.class = e3.className), Object.defineProperty(e3, "className", $)), "function" != typeof t2) {
      var r2, o2, u2;
      for (u2 in e3.defaultValue && void 0 !== e3.value && (e3.value || 0 === e3.value || (e3.value = e3.defaultValue), delete e3.defaultValue), Array.isArray(e3.value) && e3.multiple && "select" === t2 && (x$1(e3.children).forEach(function(n3) {
        -1 != e3.value.indexOf(n3.props.value) && (n3.props.selected = true);
      }), delete e3.value), e3) if (r2 = D.test(u2)) break;
      if (r2) for (u2 in o2 = n2.props = {}, e3) o2[D.test(u2) ? u2.replace(/[A-Z0-9]/, "-$&").toLowerCase() : u2] = e3[u2];
    }
    !(function(t3) {
      var e4 = n2.type, r3 = n2.props;
      if (r3 && "string" == typeof e4) {
        var o3 = {};
        for (var u3 in r3) /^on(Ani|Tra|Tou)/.test(u3) && (r3[u3.toLowerCase()] = r3[u3], delete r3[u3]), o3[u3.toLowerCase()] = u3;
        if (o3.ondoubleclick && (r3.ondblclick = r3[o3.ondoubleclick], delete r3[o3.ondoubleclick]), o3.onbeforeinput && (r3.onbeforeinput = r3[o3.onbeforeinput], delete r3[o3.onbeforeinput]), o3.onchange && ("textarea" === e4 || "input" === e4.toLowerCase() && !/^fil|che|ra/i.test(r3.type))) {
          var i2 = o3.oninput || "oninput";
          r3[i2] || (r3[i2] = r3[o3.onchange], delete r3[o3.onchange]);
        }
      }
    })(), "function" == typeof t2 && !t2.m && t2.prototype && (I(t2.prototype, "componentWillMount"), I(t2.prototype, "componentWillReceiveProps"), I(t2.prototype, "componentWillUpdate"), t2.m = true);
  }
  q && q(n2);
};
var B = "16.8.0";
function G(n2) {
  return h$1.bind(null, n2);
}
function J(n2) {
  return !!n2 && n2.$$typeof === H;
}
function K(n2) {
  return J(n2) ? L$2.apply(null, arguments) : n2;
}
function Q(n2) {
  return !!n2.__k && (H$1(null, n2), true);
}
function X(n2) {
  return n2 && (n2.base || 1 === n2.nodeType && n2) || null;
}
var Y = function(n2, t2) {
  return n2(t2);
};
const compat_module = { useState: m, useReducer: p, useEffect: l, useLayoutEffect: y, useRef: d, useImperativeHandle: s, useMemo: h, useCallback: T$1, useContext: w$1, useDebugValue: A$1, version: "16.8.0", Children: R, render: T, hydrate: T, unmountComponentAtNode: Q, createPortal: z, createElement: h$1, createContext: M$1, createFactory: G, cloneElement: K, createRef: y$1, Fragment: d$1, isValidElement: J, findDOMNode: X, Component: m$1, PureComponent: C, memo: _, forwardRef: S, unstable_batchedUpdates: Y, Suspense: U, SuspenseList: O, lazy: L$1 };
const compat_module$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Children: R,
  Component: m$1,
  Fragment: d$1,
  PureComponent: C,
  Suspense: U,
  SuspenseList: O,
  cloneElement: K,
  createContext: M$1,
  createElement: h$1,
  createFactory: G,
  createPortal: z,
  createRef: y$1,
  default: compat_module,
  findDOMNode: X,
  forwardRef: S,
  hydrate: V,
  isValidElement: J,
  lazy: L$1,
  memo: _,
  render: T,
  unmountComponentAtNode: Q,
  unstable_batchedUpdates: Y,
  useCallback: T$1,
  useContext: w$1,
  useDebugValue: A$1,
  useEffect: l,
  useErrorBoundary: F$1,
  useImperativeHandle: s,
  useLayoutEffect: y,
  useMemo: h,
  useReducer: p,
  useRef: d,
  useState: m,
  version: B
}, Symbol.toStringTag, { value: "Module" }));
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(compat_module$1);
var cjs;
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var browserUtils = require$$0;
  var QRCode = _interopDefault(requireBrowser());
  var copy2 = _interopDefault(requireCopyToClipboard());
  var React2 = require$$3;
  function open(uri) {
    QRCode.toString(uri, {
      type: "terminal"
    }).then(console.log);
  }
  var WALLETCONNECT_STYLE_SHEET = ':root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,\n    "Open Sans", "Helvetica Neue", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url("images/wc-logo.svg") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n';
  typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
  typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
  function _catch(body, recover) {
    try {
      var result = body();
    } catch (e3) {
      return recover(e3);
    }
    if (result && result.then) {
      return result.then(void 0, recover);
    }
    return result;
  }
  var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3Csvg height='185' viewBox='0 0 300 185' width='300' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z' fill='%233b99fc'/%3E%3C/svg%3E";
  var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
  var ANIMATION_DURATION = 300;
  var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
  var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
  var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
  var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
  var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
  var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
  var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";
  function Header(props) {
    return React2.createElement("div", {
      className: "walletconnect-modal__header"
    }, React2.createElement("img", {
      src: WALLETCONNECT_LOGO_SVG_URL,
      className: "walletconnect-modal__headerLogo"
    }), React2.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React2.createElement("div", {
      className: "walletconnect-modal__close__wrapper",
      onClick: props.onClose
    }, React2.createElement("div", {
      id: WALLETCONNECT_CLOSE_BUTTON_ID,
      className: "walletconnect-modal__close__icon"
    }, React2.createElement("div", {
      className: "walletconnect-modal__close__line1"
    }), React2.createElement("div", {
      className: "walletconnect-modal__close__line2"
    }))));
  }
  function ConnectButton(props) {
    return React2.createElement("a", {
      className: "walletconnect-connect__button",
      href: props.href,
      id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + props.name,
      onClick: props.onClick,
      rel: "noopener noreferrer",
      style: {
        backgroundColor: props.color
      },
      target: "_blank"
    }, props.name);
  }
  var CARET_SVG_URL = "data:image/svg+xml,%3Csvg fill='none' height='18' viewBox='0 0 8 18' width='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath clip-rule='evenodd' d='m.586301.213898c-.435947.33907-.5144813.967342-.175411 1.403292l4.87831 6.27212c.28087.36111.28087.86677 0 1.22788l-4.878311 6.27211c-.33907.436-.260536 1.0642.175412 1.4033.435949.3391 1.064219.2605 1.403289-.1754l4.87832-6.2721c.84259-1.08336.84259-2.60034 0-3.68367l-4.87832-6.27212c-.33907-.4359474-.96734-.514482-1.403289-.175412z' fill='%233c4252' fill-rule='evenodd'/%3E%3C/svg%3E";
  function WalletButton(props) {
    var color2 = props.color;
    var href = props.href;
    var name = props.name;
    var logo = props.logo;
    var onClick = props.onClick;
    return React2.createElement("a", {
      className: "walletconnect-modal__base__row",
      href,
      onClick,
      rel: "noopener noreferrer",
      target: "_blank"
    }, React2.createElement("h3", {
      className: "walletconnect-modal__base__row__h3"
    }, name), React2.createElement("div", {
      className: "walletconnect-modal__base__row__right"
    }, React2.createElement("div", {
      className: "walletconnect-modal__base__row__right__app-icon",
      style: {
        background: "url('" + logo + "') " + color2,
        backgroundSize: "100%"
      }
    }), React2.createElement("img", {
      src: CARET_SVG_URL,
      className: "walletconnect-modal__base__row__right__caret"
    })));
  }
  function WalletIcon(props) {
    var color2 = props.color;
    var href = props.href;
    var name = props.name;
    var logo = props.logo;
    var onClick = props.onClick;
    var fontSize = window.innerWidth < 768 ? (name.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
    return React2.createElement("a", {
      className: "walletconnect-connect__button__icon_anchor",
      href,
      onClick,
      rel: "noopener noreferrer",
      target: "_blank"
    }, React2.createElement("div", {
      className: "walletconnect-connect__button__icon",
      style: {
        background: "url('" + logo + "') " + color2,
        backgroundSize: "100%"
      }
    }), React2.createElement("div", {
      style: {
        fontSize
      },
      className: "walletconnect-connect__button__text"
    }, name));
  }
  var GRID_MIN_COUNT = 5;
  var LINKS_PER_PAGE = 12;
  function LinkDisplay(props) {
    var android = browserUtils.isAndroid();
    var ref = React2.useState("");
    var input = ref[0];
    var setInput = ref[1];
    var ref$1 = React2.useState("");
    var filter = ref$1[0];
    var setFilter = ref$1[1];
    var ref$2 = React2.useState(1);
    var page = ref$2[0];
    var setPage = ref$2[1];
    var links = filter ? props.links.filter(function(link) {
      return link.name.toLowerCase().includes(filter.toLowerCase());
    }) : props.links;
    var errorMessage = props.errorMessage;
    var grid = filter || links.length > GRID_MIN_COUNT;
    var pages = Math.ceil(links.length / LINKS_PER_PAGE);
    var range2 = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
    var pageLinks = links.length ? links.filter(function(_2, index2) {
      return index2 + 1 >= range2[0] && index2 + 1 <= range2[1];
    }) : [];
    var hasPaging = !!(!android && pages > 1);
    var filterTimeout = void 0;
    function handleInput(e3) {
      setInput(e3.target.value);
      clearTimeout(filterTimeout);
      if (e3.target.value) {
        filterTimeout = setTimeout(function() {
          setFilter(e3.target.value);
          setPage(1);
        }, 1e3);
      } else {
        setInput("");
        setFilter("");
        setPage(1);
      }
    }
    return React2.createElement("div", null, React2.createElement("p", {
      id: WALLETCONNECT_CTA_TEXT_ID,
      className: "walletconnect-qrcode__text"
    }, android ? props.text.connect_mobile_wallet : props.text.choose_preferred_wallet), !android && React2.createElement("input", {
      className: "walletconnect-search__input",
      placeholder: "Search",
      value: input,
      onChange: handleInput
    }), React2.createElement("div", {
      className: "walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : "")
    }, !android ? pageLinks.length ? pageLinks.map(function(entry) {
      var color2 = entry.color;
      var name = entry.name;
      var shortName = entry.shortName;
      var logo = entry.logo;
      var href = browserUtils.formatIOSMobile(props.uri, entry);
      var handleClickIOS = React2.useCallback(function() {
        browserUtils.saveMobileLinkInfo({
          name,
          href
        });
      }, [pageLinks]);
      return !grid ? React2.createElement(WalletButton, {
        color: color2,
        href,
        name,
        logo,
        onClick: handleClickIOS
      }) : React2.createElement(WalletIcon, {
        color: color2,
        href,
        name: shortName || name,
        logo,
        onClick: handleClickIOS
      });
    }) : React2.createElement(React2.Fragment, null, React2.createElement("p", null, errorMessage.length ? props.errorMessage : !!props.links.length && !links.length ? props.text.no_wallets_found : props.text.loading)) : React2.createElement(ConnectButton, {
      name: props.text.connect,
      color: DEFAULT_BUTTON_COLOR,
      href: props.uri,
      onClick: React2.useCallback(function() {
        browserUtils.saveMobileLinkInfo({
          name: "Unknown",
          href: props.uri
        });
      }, [])
    })), hasPaging && React2.createElement("div", {
      className: "walletconnect-modal__footer"
    }, Array(pages).fill(0).map(function(_2, index2) {
      var pageNumber = index2 + 1;
      var selected = page === pageNumber;
      return React2.createElement("a", {
        style: {
          margin: "auto 10px",
          fontWeight: selected ? "bold" : "normal"
        },
        onClick: function() {
          return setPage(pageNumber);
        }
      }, pageNumber);
    })));
  }
  function Notification(props) {
    var show = !!props.message.trim();
    return React2.createElement("div", {
      className: "walletconnect-qrcode__notification" + (show ? " notification__show" : "")
    }, props.message);
  }
  var formatQRCodeImage = function(data) {
    try {
      var result = "";
      return Promise.resolve(QRCode.toString(data, {
        margin: 0,
        type: "svg"
      })).then(function(dataString) {
        if (typeof dataString === "string") {
          result = dataString.replace("<svg", '<svg class="walletconnect-qrcode__image"');
        }
        return result;
      });
    } catch (e3) {
      return Promise.reject(e3);
    }
  };
  function QRCodeDisplay(props) {
    var ref = React2.useState("");
    var notification = ref[0];
    var setNotification = ref[1];
    var ref$1 = React2.useState("");
    var svg = ref$1[0];
    var setSvg = ref$1[1];
    React2.useEffect(function() {
      try {
        return Promise.resolve(formatQRCodeImage(props.uri)).then(function(_formatQRCodeImage) {
          setSvg(_formatQRCodeImage);
        });
      } catch (e3) {
        Promise.reject(e3);
      }
    }, []);
    var copyToClipboard2 = function() {
      var success = copy2(props.uri);
      if (success) {
        setNotification(props.text.copied_to_clipboard);
        setInterval(function() {
          return setNotification("");
        }, 1200);
      } else {
        setNotification("Error");
        setInterval(function() {
          return setNotification("");
        }, 1200);
      }
    };
    return React2.createElement("div", null, React2.createElement("p", {
      id: WALLETCONNECT_CTA_TEXT_ID,
      className: "walletconnect-qrcode__text"
    }, props.text.scan_qrcode_with_wallet), React2.createElement("div", {
      dangerouslySetInnerHTML: {
        __html: svg
      }
    }), React2.createElement("div", {
      className: "walletconnect-modal__footer"
    }, React2.createElement("a", {
      onClick: copyToClipboard2
    }, props.text.copy_to_clipboard)), React2.createElement(Notification, {
      message: notification
    }));
  }
  function Modal(props) {
    var android = browserUtils.isAndroid();
    var mobile = browserUtils.isMobile();
    var whitelist = mobile ? props.qrcodeModalOptions && props.qrcodeModalOptions.mobileLinks ? props.qrcodeModalOptions.mobileLinks : void 0 : props.qrcodeModalOptions && props.qrcodeModalOptions.desktopLinks ? props.qrcodeModalOptions.desktopLinks : void 0;
    var ref = React2.useState(false);
    var loading = ref[0];
    var setLoading = ref[1];
    var ref$1 = React2.useState(false);
    var fetched = ref$1[0];
    var setFetched = ref$1[1];
    var ref$2 = React2.useState(!mobile);
    var displayQRCode = ref$2[0];
    var setDisplayQRCode = ref$2[1];
    var displayProps = {
      mobile,
      text: props.text,
      uri: props.uri,
      qrcodeModalOptions: props.qrcodeModalOptions
    };
    var ref$3 = React2.useState("");
    var singleLinkHref = ref$3[0];
    var setSingleLinkHref = ref$3[1];
    var ref$4 = React2.useState(false);
    var hasSingleLink = ref$4[0];
    var setHasSingleLink = ref$4[1];
    var ref$5 = React2.useState([]);
    var links = ref$5[0];
    var setLinks = ref$5[1];
    var ref$6 = React2.useState("");
    var errorMessage = ref$6[0];
    var setErrorMessage = ref$6[1];
    var getLinksIfNeeded = function() {
      if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
        return;
      }
      React2.useEffect(function() {
        var initLinks = function() {
          try {
            if (android) {
              return Promise.resolve();
            }
            setLoading(true);
            var _temp = _catch(function() {
              var url = props.qrcodeModalOptions && props.qrcodeModalOptions.registryUrl ? props.qrcodeModalOptions.registryUrl : browserUtils.getWalletRegistryUrl();
              return Promise.resolve(fetch(url)).then(function(registryResponse) {
                return Promise.resolve(registryResponse.json()).then(function(_registryResponse$jso) {
                  var registry = _registryResponse$jso.listings;
                  var platform = mobile ? "mobile" : "desktop";
                  var _links = browserUtils.getMobileLinkRegistry(browserUtils.formatMobileRegistry(registry, platform), whitelist);
                  setLoading(false);
                  setFetched(true);
                  setErrorMessage(!_links.length ? props.text.no_supported_wallets : "");
                  setLinks(_links);
                  var hasSingleLink2 = _links.length === 1;
                  if (hasSingleLink2) {
                    setSingleLinkHref(browserUtils.formatIOSMobile(props.uri, _links[0]));
                    setDisplayQRCode(true);
                  }
                  setHasSingleLink(hasSingleLink2);
                });
              });
            }, function(e3) {
              setLoading(false);
              setFetched(true);
              setErrorMessage(props.text.something_went_wrong);
              console.error(e3);
            });
            return Promise.resolve(_temp && _temp.then ? _temp.then(function() {
            }) : void 0);
          } catch (e3) {
            return Promise.reject(e3);
          }
        };
        initLinks();
      });
    };
    getLinksIfNeeded();
    var rightSelected = mobile ? displayQRCode : !displayQRCode;
    return React2.createElement("div", {
      id: WALLETCONNECT_MODAL_ID,
      className: "walletconnect-qrcode__base animated fadeIn"
    }, React2.createElement("div", {
      className: "walletconnect-modal__base"
    }, React2.createElement(Header, {
      onClose: props.onClose
    }), hasSingleLink && displayQRCode ? React2.createElement("div", {
      className: "walletconnect-modal__single_wallet"
    }, React2.createElement("a", {
      onClick: function() {
        return browserUtils.saveMobileLinkInfo({
          name: links[0].name,
          href: singleLinkHref
        });
      },
      href: singleLinkHref,
      rel: "noopener noreferrer",
      target: "_blank"
    }, props.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " ")) : android || loading || !loading && links.length ? React2.createElement("div", {
      className: "walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : "")
    }, React2.createElement("div", {
      className: "walletconnect-modal__mobile__toggle_selector"
    }), mobile ? React2.createElement(React2.Fragment, null, React2.createElement("a", {
      onClick: function() {
        return setDisplayQRCode(false), getLinksIfNeeded();
      }
    }, props.text.mobile), React2.createElement("a", {
      onClick: function() {
        return setDisplayQRCode(true);
      }
    }, props.text.qrcode)) : React2.createElement(React2.Fragment, null, React2.createElement("a", {
      onClick: function() {
        return setDisplayQRCode(true);
      }
    }, props.text.qrcode), React2.createElement("a", {
      onClick: function() {
        return setDisplayQRCode(false), getLinksIfNeeded();
      }
    }, props.text.desktop))) : null, React2.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React2.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React2.createElement(LinkDisplay, Object.assign(
      {},
      displayProps,
      {
        links,
        errorMessage
      }
    )))));
  }
  var de = {
    choose_preferred_wallet: "Whle bevorzugte Wallet",
    connect_mobile_wallet: "Verbinde mit Mobile Wallet",
    scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
    connect: "Verbinden",
    qrcode: "QR-Code",
    mobile: "Mobile",
    desktop: "Desktop",
    copy_to_clipboard: "In die Zwischenablage kopieren",
    copied_to_clipboard: "In die Zwischenablage kopiert!",
    connect_with: "Verbinden mit Hilfe von",
    loading: "Laden...",
    something_went_wrong: "Etwas ist schief gelaufen",
    no_supported_wallets: "Es gibt noch keine untersttzten Wallet",
    no_wallets_found: "keine Wallet gefunden"
  };
  var en = {
    choose_preferred_wallet: "Choose your preferred wallet",
    connect_mobile_wallet: "Connect to Mobile Wallet",
    scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
    connect: "Connect",
    qrcode: "QR Code",
    mobile: "Mobile",
    desktop: "Desktop",
    copy_to_clipboard: "Copy to clipboard",
    copied_to_clipboard: "Copied to clipboard!",
    connect_with: "Connect with",
    loading: "Loading...",
    something_went_wrong: "Something went wrong",
    no_supported_wallets: "There are no supported wallets yet",
    no_wallets_found: "No wallets found"
  };
  var es = {
    choose_preferred_wallet: "Elige tu billetera preferida",
    connect_mobile_wallet: "Conectar a billetera mvil",
    scan_qrcode_with_wallet: "Escanea el cdigo QR con una billetera compatible con WalletConnect",
    connect: "Conectar",
    qrcode: "Cdigo QR",
    mobile: "Mvil",
    desktop: "Desktop",
    copy_to_clipboard: "Copiar",
    copied_to_clipboard: "Copiado!",
    connect_with: "Conectar mediante",
    loading: "Cargando...",
    something_went_wrong: "Algo sali mal",
    no_supported_wallets: "Todava no hay billeteras compatibles",
    no_wallets_found: "No se encontraron billeteras"
  };
  var fr = {
    choose_preferred_wallet: "Choisissez votre portefeuille prfr",
    connect_mobile_wallet: "Se connecter au portefeuille mobile",
    scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
    connect: "Se connecter",
    qrcode: "QR Code",
    mobile: "Mobile",
    desktop: "Desktop",
    copy_to_clipboard: "Copier",
    copied_to_clipboard: "Copi!",
    connect_with: "Connectez-vous  l'aide de",
    loading: "Chargement...",
    something_went_wrong: "Quelque chose a mal tourn",
    no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
    no_wallets_found: "Aucun portefeuille trouv"
  };
  var ko = {
    choose_preferred_wallet: "  ",
    connect_mobile_wallet: "  ",
    scan_qrcode_with_wallet: "WalletConnect   QR ",
    connect: "",
    qrcode: "QR ",
    mobile: "",
    desktop: "",
    copy_to_clipboard: " ",
    copied_to_clipboard: " !",
    connect_with: " ",
    loading: " ...",
    something_went_wrong: " .",
    no_supported_wallets: "   ",
    no_wallets_found: "   "
  };
  var pt = {
    choose_preferred_wallet: "Escolha sua carteira preferida",
    connect_mobile_wallet: "Conectar-se  carteira mvel",
    scan_qrcode_with_wallet: "Ler o cdigo QR com uma carteira compatvel com WalletConnect",
    connect: "Conectar",
    qrcode: "Cdigo QR",
    mobile: "Mvel",
    desktop: "Desktop",
    copy_to_clipboard: "Copiar",
    copied_to_clipboard: "Copiado!",
    connect_with: "Ligar por meio de",
    loading: "Carregamento...",
    something_went_wrong: "Algo correu mal",
    no_supported_wallets: "Ainda no h carteiras suportadas",
    no_wallets_found: "Nenhuma carteira encontrada"
  };
  var zh = {
    choose_preferred_wallet: "",
    connect_mobile_wallet: "",
    scan_qrcode_with_wallet: " WalletConnect ",
    connect: "",
    qrcode: "",
    mobile: "",
    desktop: "",
    copy_to_clipboard: "",
    copied_to_clipboard: "",
    connect_with: "",
    loading: "...",
    something_went_wrong: "",
    no_supported_wallets: "",
    no_wallets_found: ""
  };
  var fa = {
    choose_preferred_wallet: "       ",
    connect_mobile_wallet: "     ",
    scan_qrcode_with_wallet: " QR        WalletConnect  ",
    connect: "",
    qrcode: " QR",
    mobile: "",
    desktop: "",
    copy_to_clipboard: "   ",
    copied_to_clipboard: "    !",
    connect_with: " ",
    loading: "...",
    something_went_wrong: "  ",
    no_supported_wallets: "        ",
    no_wallets_found: "    "
  };
  var languages = {
    de,
    en,
    es,
    fr,
    ko,
    pt,
    zh,
    fa
  };
  function injectStyleSheet() {
    var doc = browserUtils.getDocumentOrThrow();
    var prev = doc.getElementById(WALLETCONNECT_STYLE_ID);
    if (prev) {
      doc.head.removeChild(prev);
    }
    var style = doc.createElement("style");
    style.setAttribute("id", WALLETCONNECT_STYLE_ID);
    style.innerText = WALLETCONNECT_STYLE_SHEET;
    doc.head.appendChild(style);
  }
  function renderWrapper() {
    var doc = browserUtils.getDocumentOrThrow();
    var wrapper = doc.createElement("div");
    wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
    doc.body.appendChild(wrapper);
    return wrapper;
  }
  function triggerCloseAnimation() {
    var doc = browserUtils.getDocumentOrThrow();
    var modal = doc.getElementById(WALLETCONNECT_MODAL_ID);
    if (modal) {
      modal.className = modal.className.replace("fadeIn", "fadeOut");
      setTimeout(function() {
        var wrapper = doc.getElementById(WALLETCONNECT_WRAPPER_ID);
        if (wrapper) {
          doc.body.removeChild(wrapper);
        }
      }, ANIMATION_DURATION);
    }
  }
  function getWrappedCallback(cb) {
    return function() {
      triggerCloseAnimation();
      if (cb) {
        cb();
      }
    };
  }
  function getText() {
    var lang = browserUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
    return languages[lang] || languages["en"];
  }
  function open$1(uri, cb, qrcodeModalOptions) {
    injectStyleSheet();
    var wrapper = renderWrapper();
    React2.render(React2.createElement(Modal, {
      text: getText(),
      uri,
      onClose: getWrappedCallback(cb),
      qrcodeModalOptions
    }), wrapper);
  }
  function close$1() {
    triggerCloseAnimation();
  }
  var isNode2 = function() {
    return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
  };
  function open$2(uri, cb, qrcodeModalOptions) {
    console.log(uri);
    if (isNode2()) {
      open(uri);
    } else {
      open$1(uri, cb, qrcodeModalOptions);
    }
  }
  function close$2() {
    if (isNode2()) ;
    else {
      close$1();
    }
  }
  var index = {
    open: open$2,
    close: close$2
  };
  cjs = index;
  return cjs;
}
var cjsExports = requireCjs();
const QRCodeModal = /* @__PURE__ */ getDefaultExportFromCjs(cjsExports);
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
var hasRequiredNaclFast;
function requireNaclFast() {
  if (hasRequiredNaclFast) return naclFast.exports;
  hasRequiredNaclFast = 1;
  (function(module) {
    (function(nacl2) {
      var gf = function(init) {
        var i2, r2 = new Float64Array(16);
        if (init) for (i2 = 0; i2 < init.length; i2++) r2[i2] = init[i2];
        return r2;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D2 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y2 = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x2, i2, h2, l2) {
        x2[i2] = h2 >> 24 & 255;
        x2[i2 + 1] = h2 >> 16 & 255;
        x2[i2 + 2] = h2 >> 8 & 255;
        x2[i2 + 3] = h2 & 255;
        x2[i2 + 4] = l2 >> 24 & 255;
        x2[i2 + 5] = l2 >> 16 & 255;
        x2[i2 + 6] = l2 >> 8 & 255;
        x2[i2 + 7] = l2 & 255;
      }
      function vn(x2, xi, y2, yi, n2) {
        var i2, d2 = 0;
        for (i2 = 0; i2 < n2; i2++) d2 |= x2[xi + i2] ^ y2[yi + i2];
        return (1 & d2 - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x2, xi, y2, yi) {
        return vn(x2, xi, y2, yi, 16);
      }
      function crypto_verify_32(x2, xi, y2, yi) {
        return vn(x2, xi, y2, yi, 32);
      }
      function core_salsa20(o2, p2, k2, c2) {
        var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x2 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x1 | 0;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x2 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o2[0] = x0 >>> 0 & 255;
        o2[1] = x0 >>> 8 & 255;
        o2[2] = x0 >>> 16 & 255;
        o2[3] = x0 >>> 24 & 255;
        o2[4] = x1 >>> 0 & 255;
        o2[5] = x1 >>> 8 & 255;
        o2[6] = x1 >>> 16 & 255;
        o2[7] = x1 >>> 24 & 255;
        o2[8] = x2 >>> 0 & 255;
        o2[9] = x2 >>> 8 & 255;
        o2[10] = x2 >>> 16 & 255;
        o2[11] = x2 >>> 24 & 255;
        o2[12] = x3 >>> 0 & 255;
        o2[13] = x3 >>> 8 & 255;
        o2[14] = x3 >>> 16 & 255;
        o2[15] = x3 >>> 24 & 255;
        o2[16] = x4 >>> 0 & 255;
        o2[17] = x4 >>> 8 & 255;
        o2[18] = x4 >>> 16 & 255;
        o2[19] = x4 >>> 24 & 255;
        o2[20] = x5 >>> 0 & 255;
        o2[21] = x5 >>> 8 & 255;
        o2[22] = x5 >>> 16 & 255;
        o2[23] = x5 >>> 24 & 255;
        o2[24] = x6 >>> 0 & 255;
        o2[25] = x6 >>> 8 & 255;
        o2[26] = x6 >>> 16 & 255;
        o2[27] = x6 >>> 24 & 255;
        o2[28] = x7 >>> 0 & 255;
        o2[29] = x7 >>> 8 & 255;
        o2[30] = x7 >>> 16 & 255;
        o2[31] = x7 >>> 24 & 255;
        o2[32] = x8 >>> 0 & 255;
        o2[33] = x8 >>> 8 & 255;
        o2[34] = x8 >>> 16 & 255;
        o2[35] = x8 >>> 24 & 255;
        o2[36] = x9 >>> 0 & 255;
        o2[37] = x9 >>> 8 & 255;
        o2[38] = x9 >>> 16 & 255;
        o2[39] = x9 >>> 24 & 255;
        o2[40] = x10 >>> 0 & 255;
        o2[41] = x10 >>> 8 & 255;
        o2[42] = x10 >>> 16 & 255;
        o2[43] = x10 >>> 24 & 255;
        o2[44] = x11 >>> 0 & 255;
        o2[45] = x11 >>> 8 & 255;
        o2[46] = x11 >>> 16 & 255;
        o2[47] = x11 >>> 24 & 255;
        o2[48] = x12 >>> 0 & 255;
        o2[49] = x12 >>> 8 & 255;
        o2[50] = x12 >>> 16 & 255;
        o2[51] = x12 >>> 24 & 255;
        o2[52] = x13 >>> 0 & 255;
        o2[53] = x13 >>> 8 & 255;
        o2[54] = x13 >>> 16 & 255;
        o2[55] = x13 >>> 24 & 255;
        o2[56] = x14 >>> 0 & 255;
        o2[57] = x14 >>> 8 & 255;
        o2[58] = x14 >>> 16 & 255;
        o2[59] = x14 >>> 24 & 255;
        o2[60] = x15 >>> 0 & 255;
        o2[61] = x15 >>> 8 & 255;
        o2[62] = x15 >>> 16 & 255;
        o2[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o2, p2, k2, c2) {
        var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x2 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x1 | 0;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x2 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        o2[0] = x0 >>> 0 & 255;
        o2[1] = x0 >>> 8 & 255;
        o2[2] = x0 >>> 16 & 255;
        o2[3] = x0 >>> 24 & 255;
        o2[4] = x5 >>> 0 & 255;
        o2[5] = x5 >>> 8 & 255;
        o2[6] = x5 >>> 16 & 255;
        o2[7] = x5 >>> 24 & 255;
        o2[8] = x10 >>> 0 & 255;
        o2[9] = x10 >>> 8 & 255;
        o2[10] = x10 >>> 16 & 255;
        o2[11] = x10 >>> 24 & 255;
        o2[12] = x15 >>> 0 & 255;
        o2[13] = x15 >>> 8 & 255;
        o2[14] = x15 >>> 16 & 255;
        o2[15] = x15 >>> 24 & 255;
        o2[16] = x6 >>> 0 & 255;
        o2[17] = x6 >>> 8 & 255;
        o2[18] = x6 >>> 16 & 255;
        o2[19] = x6 >>> 24 & 255;
        o2[20] = x7 >>> 0 & 255;
        o2[21] = x7 >>> 8 & 255;
        o2[22] = x7 >>> 16 & 255;
        o2[23] = x7 >>> 24 & 255;
        o2[24] = x8 >>> 0 & 255;
        o2[25] = x8 >>> 8 & 255;
        o2[26] = x8 >>> 16 & 255;
        o2[27] = x8 >>> 24 & 255;
        o2[28] = x9 >>> 0 & 255;
        o2[29] = x9 >>> 8 & 255;
        o2[30] = x9 >>> 16 & 255;
        o2[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k2, c2) {
        core_salsa20(out, inp, k2, c2);
      }
      function crypto_core_hsalsa20(out, inp, k2, c2) {
        core_hsalsa20(out, inp, k2, c2);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c2, cpos, m2, mpos, b2, n2, k2) {
        var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
        var u2, i2;
        for (i2 = 0; i2 < 16; i2++) z2[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z2[i2] = n2[i2];
        while (b2 >= 64) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i2 = 0; i2 < 64; i2++) c2[cpos + i2] = m2[mpos + i2] ^ x2[i2];
          u2 = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u2 = u2 + (z2[i2] & 255) | 0;
            z2[i2] = u2 & 255;
            u2 >>>= 8;
          }
          b2 -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b2 > 0) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i2 = 0; i2 < b2; i2++) c2[cpos + i2] = m2[mpos + i2] ^ x2[i2];
        }
        return 0;
      }
      function crypto_stream_salsa20(c2, cpos, b2, n2, k2) {
        var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
        var u2, i2;
        for (i2 = 0; i2 < 16; i2++) z2[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z2[i2] = n2[i2];
        while (b2 >= 64) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i2 = 0; i2 < 64; i2++) c2[cpos + i2] = x2[i2];
          u2 = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u2 = u2 + (z2[i2] & 255) | 0;
            z2[i2] = u2 & 255;
            u2 >>>= 8;
          }
          b2 -= 64;
          cpos += 64;
        }
        if (b2 > 0) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i2 = 0; i2 < b2; i2++) c2[cpos + i2] = x2[i2];
        }
        return 0;
      }
      function crypto_stream(c2, cpos, d2, n2, k2) {
        var s2 = new Uint8Array(32);
        crypto_core_hsalsa20(s2, n2, k2, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn[i2] = n2[i2 + 16];
        return crypto_stream_salsa20(c2, cpos, d2, sn, s2);
      }
      function crypto_stream_xor(c2, cpos, m2, mpos, d2, n2, k2) {
        var s2 = new Uint8Array(32);
        crypto_core_hsalsa20(s2, n2, k2, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn[i2] = n2[i2 + 16];
        return crypto_stream_salsa20_xor(c2, cpos, m2, mpos, d2, sn, s2);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t02, t12, t2, t3, t4, t5, t6, t7;
        t02 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t02 & 8191;
        t12 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t02 >>> 13 | t12 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t12 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m2, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t02, t12, t2, t3, t4, t5, t6, t7, c2;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t02 = m2[mpos + 0] & 255 | (m2[mpos + 1] & 255) << 8;
          h0 += t02 & 8191;
          t12 = m2[mpos + 2] & 255 | (m2[mpos + 3] & 255) << 8;
          h1 += (t02 >>> 13 | t12 << 3) & 8191;
          t2 = m2[mpos + 4] & 255 | (m2[mpos + 5] & 255) << 8;
          h2 += (t12 >>> 10 | t2 << 6) & 8191;
          t3 = m2[mpos + 6] & 255 | (m2[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m2[mpos + 8] & 255 | (m2[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m2[mpos + 10] & 255 | (m2[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m2[mpos + 12] & 255 | (m2[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m2[mpos + 14] & 255 | (m2[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c2 = 0;
          d0 = c2;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c2 = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c2 += d0 >>> 13;
          d0 &= 8191;
          d1 = c2;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c2 = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c2 += d1 >>> 13;
          d1 &= 8191;
          d2 = c2;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c2 = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c2 += d2 >>> 13;
          d2 &= 8191;
          d3 = c2;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c2 = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c2 += d3 >>> 13;
          d3 &= 8191;
          d4 = c2;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c2 = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c2 += d4 >>> 13;
          d4 &= 8191;
          d5 = c2;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c2 = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c2 += d5 >>> 13;
          d5 &= 8191;
          d6 = c2;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c2 = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c2 += d6 >>> 13;
          d6 &= 8191;
          d7 = c2;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c2 = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c2 += d7 >>> 13;
          d7 &= 8191;
          d8 = c2;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c2 = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c2 += d8 >>> 13;
          d8 &= 8191;
          d9 = c2;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c2 = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c2 += d9 >>> 13;
          d9 &= 8191;
          c2 = (c2 << 2) + c2 | 0;
          c2 = c2 + d0 | 0;
          d0 = c2 & 8191;
          c2 = c2 >>> 13;
          d1 += c2;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g2 = new Uint16Array(10);
        var c2, mask, f2, i2;
        if (this.leftover) {
          i2 = this.leftover;
          this.buffer[i2++] = 1;
          for (; i2 < 16; i2++) this.buffer[i2] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c2 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i2 = 2; i2 < 10; i2++) {
          this.h[i2] += c2;
          c2 = this.h[i2] >>> 13;
          this.h[i2] &= 8191;
        }
        this.h[0] += c2 * 5;
        c2 = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c2;
        c2 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c2;
        g2[0] = this.h[0] + 5;
        c2 = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i2 = 1; i2 < 10; i2++) {
          g2[i2] = this.h[i2] + c2;
          c2 = g2[i2] >>> 13;
          g2[i2] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c2 ^ 1) - 1;
        for (i2 = 0; i2 < 10; i2++) g2[i2] &= mask;
        mask = ~mask;
        for (i2 = 0; i2 < 10; i2++) this.h[i2] = this.h[i2] & mask | g2[i2];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f2 = this.h[0] + this.pad[0];
        this.h[0] = f2 & 65535;
        for (i2 = 1; i2 < 8; i2++) {
          f2 = (this.h[i2] + this.pad[i2] | 0) + (f2 >>> 16) | 0;
          this.h[i2] = f2 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m2, mpos, bytes) {
        var i2, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i2 = 0; i2 < want; i2++)
            this.buffer[this.leftover + i2] = m2[mpos + i2];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m2, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i2 = 0; i2 < bytes; i2++)
            this.buffer[this.leftover + i2] = m2[mpos + i2];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m2, mpos, n2, k2) {
        var s2 = new poly1305(k2);
        s2.update(m2, mpos, n2);
        s2.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h2, hpos, m2, mpos, n2, k2) {
        var x2 = new Uint8Array(16);
        crypto_onetimeauth(x2, 0, m2, mpos, n2, k2);
        return crypto_verify_16(h2, hpos, x2, 0);
      }
      function crypto_secretbox(c2, m2, d2, n2, k2) {
        var i2;
        if (d2 < 32) return -1;
        crypto_stream_xor(c2, 0, m2, 0, d2, n2, k2);
        crypto_onetimeauth(c2, 16, c2, 32, d2 - 32, c2);
        for (i2 = 0; i2 < 16; i2++) c2[i2] = 0;
        return 0;
      }
      function crypto_secretbox_open(m2, c2, d2, n2, k2) {
        var i2;
        var x2 = new Uint8Array(32);
        if (d2 < 32) return -1;
        crypto_stream(x2, 0, 32, n2, k2);
        if (crypto_onetimeauth_verify(c2, 16, c2, 32, d2 - 32, x2) !== 0) return -1;
        crypto_stream_xor(m2, 0, c2, 0, d2, n2, k2);
        for (i2 = 0; i2 < 32; i2++) m2[i2] = 0;
        return 0;
      }
      function set25519(r2, a2) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) r2[i2] = a2[i2] | 0;
      }
      function car25519(o2) {
        var i2, v2, c2 = 1;
        for (i2 = 0; i2 < 16; i2++) {
          v2 = o2[i2] + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          o2[i2] = v2 - c2 * 65536;
        }
        o2[0] += c2 - 1 + 37 * (c2 - 1);
      }
      function sel25519(p2, q2, b2) {
        var t2, c2 = ~(b2 - 1);
        for (var i2 = 0; i2 < 16; i2++) {
          t2 = c2 & (p2[i2] ^ q2[i2]);
          p2[i2] ^= t2;
          q2[i2] ^= t2;
        }
      }
      function pack25519(o2, n2) {
        var i2, j2, b2;
        var m2 = gf(), t2 = gf();
        for (i2 = 0; i2 < 16; i2++) t2[i2] = n2[i2];
        car25519(t2);
        car25519(t2);
        car25519(t2);
        for (j2 = 0; j2 < 2; j2++) {
          m2[0] = t2[0] - 65517;
          for (i2 = 1; i2 < 15; i2++) {
            m2[i2] = t2[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
            m2[i2 - 1] &= 65535;
          }
          m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
          b2 = m2[15] >> 16 & 1;
          m2[14] &= 65535;
          sel25519(t2, m2, 1 - b2);
        }
        for (i2 = 0; i2 < 16; i2++) {
          o2[2 * i2] = t2[i2] & 255;
          o2[2 * i2 + 1] = t2[i2] >> 8;
        }
      }
      function neq25519(a2, b2) {
        var c2 = new Uint8Array(32), d2 = new Uint8Array(32);
        pack25519(c2, a2);
        pack25519(d2, b2);
        return crypto_verify_32(c2, 0, d2, 0);
      }
      function par25519(a2) {
        var d2 = new Uint8Array(32);
        pack25519(d2, a2);
        return d2[0] & 1;
      }
      function unpack25519(o2, n2) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) o2[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
        o2[15] &= 32767;
      }
      function A2(o2, a2, b2) {
        for (var i2 = 0; i2 < 16; i2++) o2[i2] = a2[i2] + b2[i2];
      }
      function Z2(o2, a2, b2) {
        for (var i2 = 0; i2 < 16; i2++) o2[i2] = a2[i2] - b2[i2];
      }
      function M2(o2, a2, b2) {
        var v2, c2, t02 = 0, t12 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t122 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
        v2 = a2[0];
        t02 += v2 * b0;
        t12 += v2 * b1;
        t2 += v2 * b22;
        t3 += v2 * b3;
        t4 += v2 * b4;
        t5 += v2 * b5;
        t6 += v2 * b6;
        t7 += v2 * b7;
        t8 += v2 * b8;
        t9 += v2 * b9;
        t10 += v2 * b10;
        t11 += v2 * b11;
        t122 += v2 * b12;
        t13 += v2 * b13;
        t14 += v2 * b14;
        t15 += v2 * b15;
        v2 = a2[1];
        t12 += v2 * b0;
        t2 += v2 * b1;
        t3 += v2 * b22;
        t4 += v2 * b3;
        t5 += v2 * b4;
        t6 += v2 * b5;
        t7 += v2 * b6;
        t8 += v2 * b7;
        t9 += v2 * b8;
        t10 += v2 * b9;
        t11 += v2 * b10;
        t122 += v2 * b11;
        t13 += v2 * b12;
        t14 += v2 * b13;
        t15 += v2 * b14;
        t16 += v2 * b15;
        v2 = a2[2];
        t2 += v2 * b0;
        t3 += v2 * b1;
        t4 += v2 * b22;
        t5 += v2 * b3;
        t6 += v2 * b4;
        t7 += v2 * b5;
        t8 += v2 * b6;
        t9 += v2 * b7;
        t10 += v2 * b8;
        t11 += v2 * b9;
        t122 += v2 * b10;
        t13 += v2 * b11;
        t14 += v2 * b12;
        t15 += v2 * b13;
        t16 += v2 * b14;
        t17 += v2 * b15;
        v2 = a2[3];
        t3 += v2 * b0;
        t4 += v2 * b1;
        t5 += v2 * b22;
        t6 += v2 * b3;
        t7 += v2 * b4;
        t8 += v2 * b5;
        t9 += v2 * b6;
        t10 += v2 * b7;
        t11 += v2 * b8;
        t122 += v2 * b9;
        t13 += v2 * b10;
        t14 += v2 * b11;
        t15 += v2 * b12;
        t16 += v2 * b13;
        t17 += v2 * b14;
        t18 += v2 * b15;
        v2 = a2[4];
        t4 += v2 * b0;
        t5 += v2 * b1;
        t6 += v2 * b22;
        t7 += v2 * b3;
        t8 += v2 * b4;
        t9 += v2 * b5;
        t10 += v2 * b6;
        t11 += v2 * b7;
        t122 += v2 * b8;
        t13 += v2 * b9;
        t14 += v2 * b10;
        t15 += v2 * b11;
        t16 += v2 * b12;
        t17 += v2 * b13;
        t18 += v2 * b14;
        t19 += v2 * b15;
        v2 = a2[5];
        t5 += v2 * b0;
        t6 += v2 * b1;
        t7 += v2 * b22;
        t8 += v2 * b3;
        t9 += v2 * b4;
        t10 += v2 * b5;
        t11 += v2 * b6;
        t122 += v2 * b7;
        t13 += v2 * b8;
        t14 += v2 * b9;
        t15 += v2 * b10;
        t16 += v2 * b11;
        t17 += v2 * b12;
        t18 += v2 * b13;
        t19 += v2 * b14;
        t20 += v2 * b15;
        v2 = a2[6];
        t6 += v2 * b0;
        t7 += v2 * b1;
        t8 += v2 * b22;
        t9 += v2 * b3;
        t10 += v2 * b4;
        t11 += v2 * b5;
        t122 += v2 * b6;
        t13 += v2 * b7;
        t14 += v2 * b8;
        t15 += v2 * b9;
        t16 += v2 * b10;
        t17 += v2 * b11;
        t18 += v2 * b12;
        t19 += v2 * b13;
        t20 += v2 * b14;
        t21 += v2 * b15;
        v2 = a2[7];
        t7 += v2 * b0;
        t8 += v2 * b1;
        t9 += v2 * b22;
        t10 += v2 * b3;
        t11 += v2 * b4;
        t122 += v2 * b5;
        t13 += v2 * b6;
        t14 += v2 * b7;
        t15 += v2 * b8;
        t16 += v2 * b9;
        t17 += v2 * b10;
        t18 += v2 * b11;
        t19 += v2 * b12;
        t20 += v2 * b13;
        t21 += v2 * b14;
        t22 += v2 * b15;
        v2 = a2[8];
        t8 += v2 * b0;
        t9 += v2 * b1;
        t10 += v2 * b22;
        t11 += v2 * b3;
        t122 += v2 * b4;
        t13 += v2 * b5;
        t14 += v2 * b6;
        t15 += v2 * b7;
        t16 += v2 * b8;
        t17 += v2 * b9;
        t18 += v2 * b10;
        t19 += v2 * b11;
        t20 += v2 * b12;
        t21 += v2 * b13;
        t22 += v2 * b14;
        t23 += v2 * b15;
        v2 = a2[9];
        t9 += v2 * b0;
        t10 += v2 * b1;
        t11 += v2 * b22;
        t122 += v2 * b3;
        t13 += v2 * b4;
        t14 += v2 * b5;
        t15 += v2 * b6;
        t16 += v2 * b7;
        t17 += v2 * b8;
        t18 += v2 * b9;
        t19 += v2 * b10;
        t20 += v2 * b11;
        t21 += v2 * b12;
        t22 += v2 * b13;
        t23 += v2 * b14;
        t24 += v2 * b15;
        v2 = a2[10];
        t10 += v2 * b0;
        t11 += v2 * b1;
        t122 += v2 * b22;
        t13 += v2 * b3;
        t14 += v2 * b4;
        t15 += v2 * b5;
        t16 += v2 * b6;
        t17 += v2 * b7;
        t18 += v2 * b8;
        t19 += v2 * b9;
        t20 += v2 * b10;
        t21 += v2 * b11;
        t22 += v2 * b12;
        t23 += v2 * b13;
        t24 += v2 * b14;
        t25 += v2 * b15;
        v2 = a2[11];
        t11 += v2 * b0;
        t122 += v2 * b1;
        t13 += v2 * b22;
        t14 += v2 * b3;
        t15 += v2 * b4;
        t16 += v2 * b5;
        t17 += v2 * b6;
        t18 += v2 * b7;
        t19 += v2 * b8;
        t20 += v2 * b9;
        t21 += v2 * b10;
        t22 += v2 * b11;
        t23 += v2 * b12;
        t24 += v2 * b13;
        t25 += v2 * b14;
        t26 += v2 * b15;
        v2 = a2[12];
        t122 += v2 * b0;
        t13 += v2 * b1;
        t14 += v2 * b22;
        t15 += v2 * b3;
        t16 += v2 * b4;
        t17 += v2 * b5;
        t18 += v2 * b6;
        t19 += v2 * b7;
        t20 += v2 * b8;
        t21 += v2 * b9;
        t22 += v2 * b10;
        t23 += v2 * b11;
        t24 += v2 * b12;
        t25 += v2 * b13;
        t26 += v2 * b14;
        t27 += v2 * b15;
        v2 = a2[13];
        t13 += v2 * b0;
        t14 += v2 * b1;
        t15 += v2 * b22;
        t16 += v2 * b3;
        t17 += v2 * b4;
        t18 += v2 * b5;
        t19 += v2 * b6;
        t20 += v2 * b7;
        t21 += v2 * b8;
        t22 += v2 * b9;
        t23 += v2 * b10;
        t24 += v2 * b11;
        t25 += v2 * b12;
        t26 += v2 * b13;
        t27 += v2 * b14;
        t28 += v2 * b15;
        v2 = a2[14];
        t14 += v2 * b0;
        t15 += v2 * b1;
        t16 += v2 * b22;
        t17 += v2 * b3;
        t18 += v2 * b4;
        t19 += v2 * b5;
        t20 += v2 * b6;
        t21 += v2 * b7;
        t22 += v2 * b8;
        t23 += v2 * b9;
        t24 += v2 * b10;
        t25 += v2 * b11;
        t26 += v2 * b12;
        t27 += v2 * b13;
        t28 += v2 * b14;
        t29 += v2 * b15;
        v2 = a2[15];
        t15 += v2 * b0;
        t16 += v2 * b1;
        t17 += v2 * b22;
        t18 += v2 * b3;
        t19 += v2 * b4;
        t20 += v2 * b5;
        t21 += v2 * b6;
        t22 += v2 * b7;
        t23 += v2 * b8;
        t24 += v2 * b9;
        t25 += v2 * b10;
        t26 += v2 * b11;
        t27 += v2 * b12;
        t28 += v2 * b13;
        t29 += v2 * b14;
        t30 += v2 * b15;
        t02 += 38 * t16;
        t12 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t122 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c2 = 1;
        v2 = t02 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t02 = v2 - c2 * 65536;
        v2 = t12 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t12 = v2 - c2 * 65536;
        v2 = t2 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t2 = v2 - c2 * 65536;
        v2 = t3 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t3 = v2 - c2 * 65536;
        v2 = t4 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t4 = v2 - c2 * 65536;
        v2 = t5 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t5 = v2 - c2 * 65536;
        v2 = t6 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t6 = v2 - c2 * 65536;
        v2 = t7 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t7 = v2 - c2 * 65536;
        v2 = t8 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t8 = v2 - c2 * 65536;
        v2 = t9 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t9 = v2 - c2 * 65536;
        v2 = t10 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t10 = v2 - c2 * 65536;
        v2 = t11 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t11 = v2 - c2 * 65536;
        v2 = t122 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t122 = v2 - c2 * 65536;
        v2 = t13 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t13 = v2 - c2 * 65536;
        v2 = t14 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t14 = v2 - c2 * 65536;
        v2 = t15 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t15 = v2 - c2 * 65536;
        t02 += c2 - 1 + 37 * (c2 - 1);
        c2 = 1;
        v2 = t02 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t02 = v2 - c2 * 65536;
        v2 = t12 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t12 = v2 - c2 * 65536;
        v2 = t2 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t2 = v2 - c2 * 65536;
        v2 = t3 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t3 = v2 - c2 * 65536;
        v2 = t4 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t4 = v2 - c2 * 65536;
        v2 = t5 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t5 = v2 - c2 * 65536;
        v2 = t6 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t6 = v2 - c2 * 65536;
        v2 = t7 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t7 = v2 - c2 * 65536;
        v2 = t8 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t8 = v2 - c2 * 65536;
        v2 = t9 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t9 = v2 - c2 * 65536;
        v2 = t10 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t10 = v2 - c2 * 65536;
        v2 = t11 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t11 = v2 - c2 * 65536;
        v2 = t122 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t122 = v2 - c2 * 65536;
        v2 = t13 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t13 = v2 - c2 * 65536;
        v2 = t14 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t14 = v2 - c2 * 65536;
        v2 = t15 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t15 = v2 - c2 * 65536;
        t02 += c2 - 1 + 37 * (c2 - 1);
        o2[0] = t02;
        o2[1] = t12;
        o2[2] = t2;
        o2[3] = t3;
        o2[4] = t4;
        o2[5] = t5;
        o2[6] = t6;
        o2[7] = t7;
        o2[8] = t8;
        o2[9] = t9;
        o2[10] = t10;
        o2[11] = t11;
        o2[12] = t122;
        o2[13] = t13;
        o2[14] = t14;
        o2[15] = t15;
      }
      function S2(o2, a2) {
        M2(o2, a2, a2);
      }
      function inv25519(o2, i2) {
        var c2 = gf();
        var a2;
        for (a2 = 0; a2 < 16; a2++) c2[a2] = i2[a2];
        for (a2 = 253; a2 >= 0; a2--) {
          S2(c2, c2);
          if (a2 !== 2 && a2 !== 4) M2(c2, c2, i2);
        }
        for (a2 = 0; a2 < 16; a2++) o2[a2] = c2[a2];
      }
      function pow2523(o2, i2) {
        var c2 = gf();
        var a2;
        for (a2 = 0; a2 < 16; a2++) c2[a2] = i2[a2];
        for (a2 = 250; a2 >= 0; a2--) {
          S2(c2, c2);
          if (a2 !== 1) M2(c2, c2, i2);
        }
        for (a2 = 0; a2 < 16; a2++) o2[a2] = c2[a2];
      }
      function crypto_scalarmult(q2, n2, p2) {
        var z2 = new Uint8Array(32);
        var x2 = new Float64Array(80), r2, i2;
        var a2 = gf(), b2 = gf(), c2 = gf(), d2 = gf(), e3 = gf(), f2 = gf();
        for (i2 = 0; i2 < 31; i2++) z2[i2] = n2[i2];
        z2[31] = n2[31] & 127 | 64;
        z2[0] &= 248;
        unpack25519(x2, p2);
        for (i2 = 0; i2 < 16; i2++) {
          b2[i2] = x2[i2];
          d2[i2] = a2[i2] = c2[i2] = 0;
        }
        a2[0] = d2[0] = 1;
        for (i2 = 254; i2 >= 0; --i2) {
          r2 = z2[i2 >>> 3] >>> (i2 & 7) & 1;
          sel25519(a2, b2, r2);
          sel25519(c2, d2, r2);
          A2(e3, a2, c2);
          Z2(a2, a2, c2);
          A2(c2, b2, d2);
          Z2(b2, b2, d2);
          S2(d2, e3);
          S2(f2, a2);
          M2(a2, c2, a2);
          M2(c2, b2, e3);
          A2(e3, a2, c2);
          Z2(a2, a2, c2);
          S2(b2, a2);
          Z2(c2, d2, f2);
          M2(a2, c2, _121665);
          A2(a2, a2, d2);
          M2(c2, c2, a2);
          M2(a2, d2, f2);
          M2(d2, b2, x2);
          S2(b2, e3);
          sel25519(a2, b2, r2);
          sel25519(c2, d2, r2);
        }
        for (i2 = 0; i2 < 16; i2++) {
          x2[i2 + 16] = a2[i2];
          x2[i2 + 32] = c2[i2];
          x2[i2 + 48] = b2[i2];
          x2[i2 + 64] = d2[i2];
        }
        var x32 = x2.subarray(32);
        var x16 = x2.subarray(16);
        inv25519(x32, x32);
        M2(x16, x16, x32);
        pack25519(q2, x16);
        return 0;
      }
      function crypto_scalarmult_base(q2, n2) {
        return crypto_scalarmult(q2, n2, _9);
      }
      function crypto_box_keypair(y2, x2) {
        randombytes(x2, 32);
        return crypto_scalarmult_base(y2, x2);
      }
      function crypto_box_beforenm(k2, y2, x2) {
        var s2 = new Uint8Array(32);
        crypto_scalarmult(s2, x2, y2);
        return crypto_core_hsalsa20(k2, _0, s2, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c2, m2, d2, n2, y2, x2) {
        var k2 = new Uint8Array(32);
        crypto_box_beforenm(k2, y2, x2);
        return crypto_box_afternm(c2, m2, d2, n2, k2);
      }
      function crypto_box_open(m2, c2, d2, n2, y2, x2) {
        var k2 = new Uint8Array(32);
        crypto_box_beforenm(k2, y2, x2);
        return crypto_box_open_afternm(m2, c2, d2, n2, k2);
      }
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m2, n2) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i2, j2, h2, l2, a2, b2, c2, d2;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n2 >= 128) {
          for (i2 = 0; i2 < 16; i2++) {
            j2 = 8 * i2 + pos;
            wh[i2] = m2[j2 + 0] << 24 | m2[j2 + 1] << 16 | m2[j2 + 2] << 8 | m2[j2 + 3];
            wl[i2] = m2[j2 + 4] << 24 | m2[j2 + 5] << 16 | m2[j2 + 6] << 8 | m2[j2 + 7];
          }
          for (i2 = 0; i2 < 80; i2++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h2 = ah7;
            l2 = al7;
            a2 = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            h2 = ah4 & ah5 ^ ~ah4 & ah6;
            l2 = al4 & al5 ^ ~al4 & al6;
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            h2 = K2[i2 * 2];
            l2 = K2[i2 * 2 + 1];
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            h2 = wh[i2 % 16];
            l2 = wl[i2 % 16];
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a2 >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            th = c2 & 65535 | d2 << 16;
            tl = a2 & 65535 | b2 << 16;
            h2 = th;
            l2 = tl;
            a2 = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a2 >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            bh7 = c2 & 65535 | d2 << 16;
            bl7 = a2 & 65535 | b2 << 16;
            h2 = bh3;
            l2 = bl3;
            a2 = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = th;
            l2 = tl;
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a2 >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            bh3 = c2 & 65535 | d2 << 16;
            bl3 = a2 & 65535 | b2 << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i2 % 16 === 15) {
              for (j2 = 0; j2 < 16; j2++) {
                h2 = wh[j2];
                l2 = wl[j2];
                a2 = l2 & 65535;
                b2 = l2 >>> 16;
                c2 = h2 & 65535;
                d2 = h2 >>> 16;
                h2 = wh[(j2 + 9) % 16];
                l2 = wl[(j2 + 9) % 16];
                a2 += l2 & 65535;
                b2 += l2 >>> 16;
                c2 += h2 & 65535;
                d2 += h2 >>> 16;
                th = wh[(j2 + 1) % 16];
                tl = wl[(j2 + 1) % 16];
                h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l2 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a2 += l2 & 65535;
                b2 += l2 >>> 16;
                c2 += h2 & 65535;
                d2 += h2 >>> 16;
                th = wh[(j2 + 14) % 16];
                tl = wl[(j2 + 14) % 16];
                h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l2 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a2 += l2 & 65535;
                b2 += l2 >>> 16;
                c2 += h2 & 65535;
                d2 += h2 >>> 16;
                b2 += a2 >>> 16;
                c2 += b2 >>> 16;
                d2 += c2 >>> 16;
                wh[j2] = c2 & 65535 | d2 << 16;
                wl[j2] = a2 & 65535 | b2 << 16;
              }
            }
          }
          h2 = ah0;
          l2 = al0;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[0];
          l2 = hl[0];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[0] = ah0 = c2 & 65535 | d2 << 16;
          hl[0] = al0 = a2 & 65535 | b2 << 16;
          h2 = ah1;
          l2 = al1;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[1];
          l2 = hl[1];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[1] = ah1 = c2 & 65535 | d2 << 16;
          hl[1] = al1 = a2 & 65535 | b2 << 16;
          h2 = ah2;
          l2 = al2;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[2];
          l2 = hl[2];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[2] = ah2 = c2 & 65535 | d2 << 16;
          hl[2] = al2 = a2 & 65535 | b2 << 16;
          h2 = ah3;
          l2 = al3;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[3];
          l2 = hl[3];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[3] = ah3 = c2 & 65535 | d2 << 16;
          hl[3] = al3 = a2 & 65535 | b2 << 16;
          h2 = ah4;
          l2 = al4;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[4];
          l2 = hl[4];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[4] = ah4 = c2 & 65535 | d2 << 16;
          hl[4] = al4 = a2 & 65535 | b2 << 16;
          h2 = ah5;
          l2 = al5;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[5];
          l2 = hl[5];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[5] = ah5 = c2 & 65535 | d2 << 16;
          hl[5] = al5 = a2 & 65535 | b2 << 16;
          h2 = ah6;
          l2 = al6;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[6];
          l2 = hl[6];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[6] = ah6 = c2 & 65535 | d2 << 16;
          hl[6] = al6 = a2 & 65535 | b2 << 16;
          h2 = ah7;
          l2 = al7;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[7];
          l2 = hl[7];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[7] = ah7 = c2 & 65535 | d2 << 16;
          hl[7] = al7 = a2 & 65535 | b2 << 16;
          pos += 128;
          n2 -= 128;
        }
        return n2;
      }
      function crypto_hash(out, m2, n2) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x2 = new Uint8Array(256), i2, b2 = n2;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m2, n2);
        n2 %= 128;
        for (i2 = 0; i2 < n2; i2++) x2[i2] = m2[b2 - n2 + i2];
        x2[n2] = 128;
        n2 = 256 - 128 * (n2 < 112 ? 1 : 0);
        x2[n2 - 9] = 0;
        ts64(x2, n2 - 8, b2 / 536870912 | 0, b2 << 3);
        crypto_hashblocks_hl(hh, hl, x2, n2);
        for (i2 = 0; i2 < 8; i2++) ts64(out, 8 * i2, hh[i2], hl[i2]);
        return 0;
      }
      function add2(p2, q2) {
        var a2 = gf(), b2 = gf(), c2 = gf(), d2 = gf(), e3 = gf(), f2 = gf(), g2 = gf(), h2 = gf(), t2 = gf();
        Z2(a2, p2[1], p2[0]);
        Z2(t2, q2[1], q2[0]);
        M2(a2, a2, t2);
        A2(b2, p2[0], p2[1]);
        A2(t2, q2[0], q2[1]);
        M2(b2, b2, t2);
        M2(c2, p2[3], q2[3]);
        M2(c2, c2, D22);
        M2(d2, p2[2], q2[2]);
        A2(d2, d2, d2);
        Z2(e3, b2, a2);
        Z2(f2, d2, c2);
        A2(g2, d2, c2);
        A2(h2, b2, a2);
        M2(p2[0], e3, f2);
        M2(p2[1], h2, g2);
        M2(p2[2], g2, f2);
        M2(p2[3], e3, h2);
      }
      function cswap(p2, q2, b2) {
        var i2;
        for (i2 = 0; i2 < 4; i2++) {
          sel25519(p2[i2], q2[i2], b2);
        }
      }
      function pack(r2, p2) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p2[2]);
        M2(tx, p2[0], zi);
        M2(ty, p2[1], zi);
        pack25519(r2, ty);
        r2[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p2, q2, s2) {
        var b2, i2;
        set25519(p2[0], gf0);
        set25519(p2[1], gf1);
        set25519(p2[2], gf1);
        set25519(p2[3], gf0);
        for (i2 = 255; i2 >= 0; --i2) {
          b2 = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
          cswap(p2, q2, b2);
          add2(q2, p2);
          add2(p2, p2);
          cswap(p2, q2, b2);
        }
      }
      function scalarbase(p2, s2) {
        var q2 = [gf(), gf(), gf(), gf()];
        set25519(q2[0], X2);
        set25519(q2[1], Y2);
        set25519(q2[2], gf1);
        M2(q2[3], X2, Y2);
        scalarmult(p2, q2, s2);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d2 = new Uint8Array(64);
        var p2 = [gf(), gf(), gf(), gf()];
        var i2;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d2, sk, 32);
        d2[0] &= 248;
        d2[31] &= 127;
        d2[31] |= 64;
        scalarbase(p2, d2);
        pack(pk, p2);
        for (i2 = 0; i2 < 32; i2++) sk[i2 + 32] = pk[i2];
        return 0;
      }
      var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r2, x2) {
        var carry, i2, j2, k2;
        for (i2 = 63; i2 >= 32; --i2) {
          carry = 0;
          for (j2 = i2 - 32, k2 = i2 - 12; j2 < k2; ++j2) {
            x2[j2] += carry - 16 * x2[i2] * L2[j2 - (i2 - 32)];
            carry = Math.floor((x2[j2] + 128) / 256);
            x2[j2] -= carry * 256;
          }
          x2[j2] += carry;
          x2[i2] = 0;
        }
        carry = 0;
        for (j2 = 0; j2 < 32; j2++) {
          x2[j2] += carry - (x2[31] >> 4) * L2[j2];
          carry = x2[j2] >> 8;
          x2[j2] &= 255;
        }
        for (j2 = 0; j2 < 32; j2++) x2[j2] -= carry * L2[j2];
        for (i2 = 0; i2 < 32; i2++) {
          x2[i2 + 1] += x2[i2] >> 8;
          r2[i2] = x2[i2] & 255;
        }
      }
      function reduce(r2) {
        var x2 = new Float64Array(64), i2;
        for (i2 = 0; i2 < 64; i2++) x2[i2] = r2[i2];
        for (i2 = 0; i2 < 64; i2++) r2[i2] = 0;
        modL(r2, x2);
      }
      function crypto_sign(sm, m2, n2, sk) {
        var d2 = new Uint8Array(64), h2 = new Uint8Array(64), r2 = new Uint8Array(64);
        var i2, j2, x2 = new Float64Array(64);
        var p2 = [gf(), gf(), gf(), gf()];
        crypto_hash(d2, sk, 32);
        d2[0] &= 248;
        d2[31] &= 127;
        d2[31] |= 64;
        var smlen = n2 + 64;
        for (i2 = 0; i2 < n2; i2++) sm[64 + i2] = m2[i2];
        for (i2 = 0; i2 < 32; i2++) sm[32 + i2] = d2[32 + i2];
        crypto_hash(r2, sm.subarray(32), n2 + 32);
        reduce(r2);
        scalarbase(p2, r2);
        pack(sm, p2);
        for (i2 = 32; i2 < 64; i2++) sm[i2] = sk[i2];
        crypto_hash(h2, sm, n2 + 64);
        reduce(h2);
        for (i2 = 0; i2 < 64; i2++) x2[i2] = 0;
        for (i2 = 0; i2 < 32; i2++) x2[i2] = r2[i2];
        for (i2 = 0; i2 < 32; i2++) {
          for (j2 = 0; j2 < 32; j2++) {
            x2[i2 + j2] += h2[i2] * d2[j2];
          }
        }
        modL(sm.subarray(32), x2);
        return smlen;
      }
      function unpackneg(r2, p2) {
        var t2 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r2[2], gf1);
        unpack25519(r2[1], p2);
        S2(num, r2[1]);
        M2(den, num, D2);
        Z2(num, num, r2[2]);
        A2(den, r2[2], den);
        S2(den2, den);
        S2(den4, den2);
        M2(den6, den4, den2);
        M2(t2, den6, num);
        M2(t2, t2, den);
        pow2523(t2, t2);
        M2(t2, t2, num);
        M2(t2, t2, den);
        M2(t2, t2, den);
        M2(r2[0], t2, den);
        S2(chk, r2[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) M2(r2[0], r2[0], I2);
        S2(chk, r2[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r2[0]) === p2[31] >> 7) Z2(r2[0], gf0, r2[0]);
        M2(r2[3], r2[0], r2[1]);
        return 0;
      }
      function crypto_sign_open(m2, sm, n2, pk) {
        var i2;
        var t2 = new Uint8Array(32), h2 = new Uint8Array(64);
        var p2 = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
        if (n2 < 64) return -1;
        if (unpackneg(q2, pk)) return -1;
        for (i2 = 0; i2 < n2; i2++) m2[i2] = sm[i2];
        for (i2 = 0; i2 < 32; i2++) m2[i2 + 32] = pk[i2];
        crypto_hash(h2, m2, n2);
        reduce(h2);
        scalarmult(p2, q2, h2);
        scalarbase(q2, sm.subarray(32));
        add2(p2, q2);
        pack(t2, p2);
        n2 -= 64;
        if (crypto_verify_32(sm, 0, t2, 0)) {
          for (i2 = 0; i2 < n2; i2++) m2[i2] = 0;
          return -1;
        }
        for (i2 = 0; i2 < n2; i2++) m2[i2] = sm[i2 + 64];
        return n2;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl2.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D: D2,
        L: L2,
        pack25519,
        unpack25519,
        M: M2,
        A: A2,
        S: S2,
        Z: Z2,
        pow2523,
        add: add2,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k2, n2) {
        if (k2.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n2.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i2 = 0; i2 < arguments.length; i2++) {
          if (!(arguments[i2] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i2 = 0; i2 < arr.length; i2++) arr[i2] = 0;
      }
      nacl2.randomBytes = function(n2) {
        var b2 = new Uint8Array(n2);
        randombytes(b2, n2);
        return b2;
      };
      nacl2.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m2 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c2 = new Uint8Array(m2.length);
        for (var i2 = 0; i2 < msg.length; i2++) m2[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
        crypto_secretbox(c2, m2, m2.length, nonce, key);
        return c2.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl2.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c2 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m2 = new Uint8Array(c2.length);
        for (var i2 = 0; i2 < box.length; i2++) c2[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
        if (c2.length < 32) return null;
        if (crypto_secretbox_open(m2, c2, c2.length, nonce, key) !== 0) return null;
        return m2.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl2.scalarMult = function(n2, p2) {
        checkArrayTypes(n2, p2);
        if (n2.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p2.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q2, n2, p2);
        return q2;
      };
      nacl2.scalarMult.base = function(n2) {
        checkArrayTypes(n2);
        if (n2.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q2, n2);
        return q2;
      };
      nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl2.box = function(msg, nonce, publicKey, secretKey) {
        var k2 = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox(msg, nonce, k2);
      };
      nacl2.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k2, publicKey, secretKey);
        return k2;
      };
      nacl2.box.after = nacl2.secretbox;
      nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
        var k2 = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox.open(msg, nonce, k2);
      };
      nacl2.box.open.after = nacl2.secretbox.open;
      nacl2.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl2.box.nonceLength = crypto_box_NONCEBYTES;
      nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
      nacl2.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl2.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m2 = new Uint8Array(mlen);
        for (var i2 = 0; i2 < m2.length; i2++) m2[i2] = tmp[i2];
        return m2;
      };
      nacl2.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl2.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i2 = 0; i2 < sig.length; i2++) sig[i2] = signedMsg[i2];
        return sig;
      };
      nacl2.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m2 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i2;
        for (i2 = 0; i2 < crypto_sign_BYTES; i2++) sm[i2] = sig[i2];
        for (i2 = 0; i2 < msg.length; i2++) sm[i2 + crypto_sign_BYTES] = msg[i2];
        return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
      };
      nacl2.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i2 = 0; i2 < pk.length; i2++) pk[i2] = secretKey[32 + i2];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i2 = 0; i2 < 32; i2++) sk[i2] = seed[i2];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl2.sign.signatureLength = crypto_sign_BYTES;
      nacl2.hash = function(msg) {
        checkArrayTypes(msg);
        var h2 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h2, msg, msg.length);
        return h2;
      };
      nacl2.hash.hashLength = crypto_hash_BYTES;
      nacl2.verify = function(x2, y2) {
        checkArrayTypes(x2, y2);
        if (x2.length === 0 || y2.length === 0) return false;
        if (x2.length !== y2.length) return false;
        return vn(x2, 0, y2, 0, x2.length) === 0 ? true : false;
      };
      nacl2.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl2.setPRNG(function(x2, n2) {
            var i2, v2 = new Uint8Array(n2);
            for (i2 = 0; i2 < n2; i2 += QUOTA) {
              crypto2.getRandomValues(v2.subarray(i2, i2 + Math.min(n2 - i2, QUOTA)));
            }
            for (i2 = 0; i2 < n2; i2++) x2[i2] = v2[i2];
            cleanup(v2);
          });
        } else if (typeof commonjsRequire !== "undefined") {
          crypto2 = require$$0$2;
          if (crypto2 && crypto2.randomBytes) {
            nacl2.setPRNG(function(x2, n2) {
              var i2, v2 = crypto2.randomBytes(n2);
              for (i2 = 0; i2 < n2; i2++) x2[i2] = v2[i2];
              cleanup(v2);
            });
          }
        }
      })();
    })(module.exports ? module.exports : self.nacl = self.nacl || {});
  })(naclFast);
  return naclFast.exports;
}
var naclFastExports = requireNaclFast();
const nacl = /* @__PURE__ */ getDefaultExportFromCjs(naclFastExports);
var sha512$1 = { exports: {} };
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1.exports;
  hasRequiredSha512 = 1;
  (function(module) {
    (function() {
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA512_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA512_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = globalThis;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA512_NO_COMMON_JS && true && module.exports;
      var ARRAY_BUFFER = !root.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA512_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, bits) {
        return function(message) {
          return new Sha512(bits, true).update(message)[outputType]();
        };
      };
      var createMethod = function(bits) {
        var method = createOutputMethod("hex", bits);
        method.create = function() {
          return new Sha512(bits);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createOutputMethod(type, bits);
        }
        return method;
      };
      var createHmacOutputMethod = function(outputType, bits) {
        return function(key, message) {
          return new HmacSha512(key, bits, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function(bits) {
        var method = createHmacOutputMethod("hex", bits);
        method.create = function(key) {
          return new HmacSha512(key, bits);
        };
        method.update = function(key, message) {
          return method.create(key).update(message);
        };
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createHmacOutputMethod(type, bits);
        }
        return method;
      };
      function Sha512(bits, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] = blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] = blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (bits == 384) {
          this.h0h = 3418070365;
          this.h0l = 3238371032;
          this.h1h = 1654270250;
          this.h1l = 914150663;
          this.h2h = 2438529370;
          this.h2l = 812702999;
          this.h3h = 355462360;
          this.h3l = 4144912697;
          this.h4h = 1731405415;
          this.h4l = 4290775857;
          this.h5h = 2394180231;
          this.h5l = 1750603025;
          this.h6h = 3675008525;
          this.h6l = 1694076839;
          this.h7h = 1203062813;
          this.h7l = 3204075428;
        } else if (bits == 256) {
          this.h0h = 573645204;
          this.h0l = 4230739756;
          this.h1h = 2673172387;
          this.h1l = 3360449730;
          this.h2h = 596883563;
          this.h2l = 1867755857;
          this.h3h = 2520282905;
          this.h3l = 1497426621;
          this.h4h = 2519219938;
          this.h4l = 2827943907;
          this.h5h = 3193839141;
          this.h5l = 1401305490;
          this.h6h = 721525244;
          this.h6l = 746961066;
          this.h7h = 246885852;
          this.h7l = 2177182882;
        } else if (bits == 224) {
          this.h0h = 2352822216;
          this.h0l = 424955298;
          this.h1h = 1944164710;
          this.h1l = 2312950998;
          this.h2h = 502970286;
          this.h2l = 855612546;
          this.h3h = 1738396948;
          this.h3l = 1479516111;
          this.h4h = 258812777;
          this.h4l = 2077511080;
          this.h5h = 2011393907;
          this.h5l = 79989058;
          this.h6h = 1067287976;
          this.h6l = 1780299464;
          this.h7h = 286451373;
          this.h7l = 2446758561;
        } else {
          this.h0h = 1779033703;
          this.h0l = 4089235720;
          this.h1h = 3144134277;
          this.h1l = 2227873595;
          this.h2h = 1013904242;
          this.h2l = 4271175723;
          this.h3h = 2773480762;
          this.h3l = 1595750129;
          this.h4h = 1359893119;
          this.h4l = 2917565137;
          this.h5h = 2600822924;
          this.h5l = 725511199;
          this.h6h = 528734635;
          this.h6l = 4215389547;
          this.h7h = 1541459225;
          this.h7l = 327033209;
        }
        this.bits = bits;
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
      }
      Sha512.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var code, index = 0, i2, length = message.length, blocks2 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
          }
          if (notString) {
            for (i2 = this.start; index < length && i2 < 128; ++index) {
              blocks2[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length && i2 < 128; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i2 >> 2] |= code << SHIFT[i2++ & 3];
              } else if (code < 2048) {
                blocks2[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          this.bytes += i2 - this.start;
          if (i2 >= 128) {
            this.block = blocks2[32];
            this.start = i2 - 128;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i2;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha512.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i2 = this.lastByteIndex;
        blocks2[32] = this.block;
        blocks2[i2 >> 2] |= EXTRA[i2 & 3];
        this.block = blocks2[32];
        if (i2 >= 112) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
        }
        blocks2[30] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[31] = this.bytes << 3;
        this.hash();
      };
      Sha512.prototype.hash = function() {
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, blocks2 = this.blocks, j2, s0h, s0l, s1h, s1l, c1, c2, c3, c4, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl;
        for (j2 = 32; j2 < 160; j2 += 2) {
          t1h = blocks2[j2 - 30];
          t1l = blocks2[j2 - 29];
          s0h = (t1h >>> 1 | t1l << 31) ^ (t1h >>> 8 | t1l << 24) ^ t1h >>> 7;
          s0l = (t1l >>> 1 | t1h << 31) ^ (t1l >>> 8 | t1h << 24) ^ (t1l >>> 7 | t1h << 25);
          t1h = blocks2[j2 - 4];
          t1l = blocks2[j2 - 3];
          s1h = (t1h >>> 19 | t1l << 13) ^ (t1l >>> 29 | t1h << 3) ^ t1h >>> 6;
          s1l = (t1l >>> 19 | t1h << 13) ^ (t1h >>> 29 | t1l << 3) ^ (t1l >>> 6 | t1h << 26);
          t1h = blocks2[j2 - 32];
          t1l = blocks2[j2 - 31];
          t2h = blocks2[j2 - 14];
          t2l = blocks2[j2 - 13];
          c1 = (t2l & 65535) + (t1l & 65535) + (s0l & 65535) + (s1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (s0h & 65535) + (s1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);
          blocks2[j2] = c4 << 16 | c3 & 65535;
          blocks2[j2 + 1] = c2 << 16 | c1 & 65535;
        }
        var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
        bch = bh & ch;
        bcl = bl & cl;
        for (j2 = 0; j2 < 160; j2 += 8) {
          s0h = (ah >>> 28 | al << 4) ^ (al >>> 2 | ah << 30) ^ (al >>> 7 | ah << 25);
          s0l = (al >>> 28 | ah << 4) ^ (ah >>> 2 | al << 30) ^ (ah >>> 7 | al << 25);
          s1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (el >>> 9 | eh << 23);
          s1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (eh >>> 9 | el << 23);
          abh = ah & bh;
          abl = al & bl;
          majh = abh ^ ah & ch ^ bch;
          majl = abl ^ al & cl ^ bcl;
          chh = eh & fh ^ ~eh & gh;
          chl = el & fl ^ ~el & gl;
          t1h = blocks2[j2];
          t1l = blocks2[j2 + 1];
          t2h = K2[j2];
          t2l = K2[j2 + 1];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (hl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (hh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (dl & 65535) + (t1l & 65535);
          c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (dh & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          hh = c4 << 16 | c3 & 65535;
          hl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          dh = c4 << 16 | c3 & 65535;
          dl = c2 << 16 | c1 & 65535;
          s0h = (dh >>> 28 | dl << 4) ^ (dl >>> 2 | dh << 30) ^ (dl >>> 7 | dh << 25);
          s0l = (dl >>> 28 | dh << 4) ^ (dh >>> 2 | dl << 30) ^ (dh >>> 7 | dl << 25);
          s1h = (hh >>> 14 | hl << 18) ^ (hh >>> 18 | hl << 14) ^ (hl >>> 9 | hh << 23);
          s1l = (hl >>> 14 | hh << 18) ^ (hl >>> 18 | hh << 14) ^ (hh >>> 9 | hl << 23);
          dah = dh & ah;
          dal = dl & al;
          majh = dah ^ dh & bh ^ abh;
          majl = dal ^ dl & bl ^ abl;
          chh = hh & eh ^ ~hh & fh;
          chl = hl & el ^ ~hl & fl;
          t1h = blocks2[j2 + 2];
          t1l = blocks2[j2 + 3];
          t2h = K2[j2 + 2];
          t2l = K2[j2 + 3];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (gl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (gh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (cl & 65535) + (t1l & 65535);
          c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (ch & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          gh = c4 << 16 | c3 & 65535;
          gl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          ch = c4 << 16 | c3 & 65535;
          cl = c2 << 16 | c1 & 65535;
          s0h = (ch >>> 28 | cl << 4) ^ (cl >>> 2 | ch << 30) ^ (cl >>> 7 | ch << 25);
          s0l = (cl >>> 28 | ch << 4) ^ (ch >>> 2 | cl << 30) ^ (ch >>> 7 | cl << 25);
          s1h = (gh >>> 14 | gl << 18) ^ (gh >>> 18 | gl << 14) ^ (gl >>> 9 | gh << 23);
          s1l = (gl >>> 14 | gh << 18) ^ (gl >>> 18 | gh << 14) ^ (gh >>> 9 | gl << 23);
          cdh = ch & dh;
          cdl = cl & dl;
          majh = cdh ^ ch & ah ^ dah;
          majl = cdl ^ cl & al ^ dal;
          chh = gh & hh ^ ~gh & eh;
          chl = gl & hl ^ ~gl & el;
          t1h = blocks2[j2 + 4];
          t1l = blocks2[j2 + 5];
          t2h = K2[j2 + 4];
          t2l = K2[j2 + 5];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (fl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (fh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (bl & 65535) + (t1l & 65535);
          c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (bh & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          fh = c4 << 16 | c3 & 65535;
          fl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          bh = c4 << 16 | c3 & 65535;
          bl = c2 << 16 | c1 & 65535;
          s0h = (bh >>> 28 | bl << 4) ^ (bl >>> 2 | bh << 30) ^ (bl >>> 7 | bh << 25);
          s0l = (bl >>> 28 | bh << 4) ^ (bh >>> 2 | bl << 30) ^ (bh >>> 7 | bl << 25);
          s1h = (fh >>> 14 | fl << 18) ^ (fh >>> 18 | fl << 14) ^ (fl >>> 9 | fh << 23);
          s1l = (fl >>> 14 | fh << 18) ^ (fl >>> 18 | fh << 14) ^ (fh >>> 9 | fl << 23);
          bch = bh & ch;
          bcl = bl & cl;
          majh = bch ^ bh & dh ^ cdh;
          majl = bcl ^ bl & dl ^ cdl;
          chh = fh & gh ^ ~fh & hh;
          chl = fl & gl ^ ~fl & hl;
          t1h = blocks2[j2 + 6];
          t1l = blocks2[j2 + 7];
          t2h = K2[j2 + 6];
          t2l = K2[j2 + 7];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (el & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (eh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (al & 65535) + (t1l & 65535);
          c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (ah & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          eh = c4 << 16 | c3 & 65535;
          el = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          ah = c4 << 16 | c3 & 65535;
          al = c2 << 16 | c1 & 65535;
        }
        c1 = (h0l & 65535) + (al & 65535);
        c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
        c3 = (h0h & 65535) + (ah & 65535) + (c2 >>> 16);
        c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);
        this.h0h = c4 << 16 | c3 & 65535;
        this.h0l = c2 << 16 | c1 & 65535;
        c1 = (h1l & 65535) + (bl & 65535);
        c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
        c3 = (h1h & 65535) + (bh & 65535) + (c2 >>> 16);
        c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);
        this.h1h = c4 << 16 | c3 & 65535;
        this.h1l = c2 << 16 | c1 & 65535;
        c1 = (h2l & 65535) + (cl & 65535);
        c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
        c3 = (h2h & 65535) + (ch & 65535) + (c2 >>> 16);
        c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);
        this.h2h = c4 << 16 | c3 & 65535;
        this.h2l = c2 << 16 | c1 & 65535;
        c1 = (h3l & 65535) + (dl & 65535);
        c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
        c3 = (h3h & 65535) + (dh & 65535) + (c2 >>> 16);
        c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);
        this.h3h = c4 << 16 | c3 & 65535;
        this.h3l = c2 << 16 | c1 & 65535;
        c1 = (h4l & 65535) + (el & 65535);
        c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
        c3 = (h4h & 65535) + (eh & 65535) + (c2 >>> 16);
        c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);
        this.h4h = c4 << 16 | c3 & 65535;
        this.h4l = c2 << 16 | c1 & 65535;
        c1 = (h5l & 65535) + (fl & 65535);
        c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
        c3 = (h5h & 65535) + (fh & 65535) + (c2 >>> 16);
        c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);
        this.h5h = c4 << 16 | c3 & 65535;
        this.h5l = c2 << 16 | c1 & 65535;
        c1 = (h6l & 65535) + (gl & 65535);
        c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
        c3 = (h6h & 65535) + (gh & 65535) + (c2 >>> 16);
        c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);
        this.h6h = c4 << 16 | c3 & 65535;
        this.h6l = c2 << 16 | c1 & 65535;
        c1 = (h7l & 65535) + (hl & 65535);
        c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
        c3 = (h7h & 65535) + (hh & 65535) + (c2 >>> 16);
        c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);
        this.h7h = c4 << 16 | c3 & 65535;
        this.h7l = c2 << 16 | c1 & 65535;
      };
      Sha512.prototype.hex = function() {
        this.finalize();
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
        var hex2 = HEX_CHARS[h0h >> 28 & 15] + HEX_CHARS[h0h >> 24 & 15] + HEX_CHARS[h0h >> 20 & 15] + HEX_CHARS[h0h >> 16 & 15] + HEX_CHARS[h0h >> 12 & 15] + HEX_CHARS[h0h >> 8 & 15] + HEX_CHARS[h0h >> 4 & 15] + HEX_CHARS[h0h & 15] + HEX_CHARS[h0l >> 28 & 15] + HEX_CHARS[h0l >> 24 & 15] + HEX_CHARS[h0l >> 20 & 15] + HEX_CHARS[h0l >> 16 & 15] + HEX_CHARS[h0l >> 12 & 15] + HEX_CHARS[h0l >> 8 & 15] + HEX_CHARS[h0l >> 4 & 15] + HEX_CHARS[h0l & 15] + HEX_CHARS[h1h >> 28 & 15] + HEX_CHARS[h1h >> 24 & 15] + HEX_CHARS[h1h >> 20 & 15] + HEX_CHARS[h1h >> 16 & 15] + HEX_CHARS[h1h >> 12 & 15] + HEX_CHARS[h1h >> 8 & 15] + HEX_CHARS[h1h >> 4 & 15] + HEX_CHARS[h1h & 15] + HEX_CHARS[h1l >> 28 & 15] + HEX_CHARS[h1l >> 24 & 15] + HEX_CHARS[h1l >> 20 & 15] + HEX_CHARS[h1l >> 16 & 15] + HEX_CHARS[h1l >> 12 & 15] + HEX_CHARS[h1l >> 8 & 15] + HEX_CHARS[h1l >> 4 & 15] + HEX_CHARS[h1l & 15] + HEX_CHARS[h2h >> 28 & 15] + HEX_CHARS[h2h >> 24 & 15] + HEX_CHARS[h2h >> 20 & 15] + HEX_CHARS[h2h >> 16 & 15] + HEX_CHARS[h2h >> 12 & 15] + HEX_CHARS[h2h >> 8 & 15] + HEX_CHARS[h2h >> 4 & 15] + HEX_CHARS[h2h & 15] + HEX_CHARS[h2l >> 28 & 15] + HEX_CHARS[h2l >> 24 & 15] + HEX_CHARS[h2l >> 20 & 15] + HEX_CHARS[h2l >> 16 & 15] + HEX_CHARS[h2l >> 12 & 15] + HEX_CHARS[h2l >> 8 & 15] + HEX_CHARS[h2l >> 4 & 15] + HEX_CHARS[h2l & 15] + HEX_CHARS[h3h >> 28 & 15] + HEX_CHARS[h3h >> 24 & 15] + HEX_CHARS[h3h >> 20 & 15] + HEX_CHARS[h3h >> 16 & 15] + HEX_CHARS[h3h >> 12 & 15] + HEX_CHARS[h3h >> 8 & 15] + HEX_CHARS[h3h >> 4 & 15] + HEX_CHARS[h3h & 15];
        if (bits >= 256) {
          hex2 += HEX_CHARS[h3l >> 28 & 15] + HEX_CHARS[h3l >> 24 & 15] + HEX_CHARS[h3l >> 20 & 15] + HEX_CHARS[h3l >> 16 & 15] + HEX_CHARS[h3l >> 12 & 15] + HEX_CHARS[h3l >> 8 & 15] + HEX_CHARS[h3l >> 4 & 15] + HEX_CHARS[h3l & 15];
        }
        if (bits >= 384) {
          hex2 += HEX_CHARS[h4h >> 28 & 15] + HEX_CHARS[h4h >> 24 & 15] + HEX_CHARS[h4h >> 20 & 15] + HEX_CHARS[h4h >> 16 & 15] + HEX_CHARS[h4h >> 12 & 15] + HEX_CHARS[h4h >> 8 & 15] + HEX_CHARS[h4h >> 4 & 15] + HEX_CHARS[h4h & 15] + HEX_CHARS[h4l >> 28 & 15] + HEX_CHARS[h4l >> 24 & 15] + HEX_CHARS[h4l >> 20 & 15] + HEX_CHARS[h4l >> 16 & 15] + HEX_CHARS[h4l >> 12 & 15] + HEX_CHARS[h4l >> 8 & 15] + HEX_CHARS[h4l >> 4 & 15] + HEX_CHARS[h4l & 15] + HEX_CHARS[h5h >> 28 & 15] + HEX_CHARS[h5h >> 24 & 15] + HEX_CHARS[h5h >> 20 & 15] + HEX_CHARS[h5h >> 16 & 15] + HEX_CHARS[h5h >> 12 & 15] + HEX_CHARS[h5h >> 8 & 15] + HEX_CHARS[h5h >> 4 & 15] + HEX_CHARS[h5h & 15] + HEX_CHARS[h5l >> 28 & 15] + HEX_CHARS[h5l >> 24 & 15] + HEX_CHARS[h5l >> 20 & 15] + HEX_CHARS[h5l >> 16 & 15] + HEX_CHARS[h5l >> 12 & 15] + HEX_CHARS[h5l >> 8 & 15] + HEX_CHARS[h5l >> 4 & 15] + HEX_CHARS[h5l & 15];
        }
        if (bits == 512) {
          hex2 += HEX_CHARS[h6h >> 28 & 15] + HEX_CHARS[h6h >> 24 & 15] + HEX_CHARS[h6h >> 20 & 15] + HEX_CHARS[h6h >> 16 & 15] + HEX_CHARS[h6h >> 12 & 15] + HEX_CHARS[h6h >> 8 & 15] + HEX_CHARS[h6h >> 4 & 15] + HEX_CHARS[h6h & 15] + HEX_CHARS[h6l >> 28 & 15] + HEX_CHARS[h6l >> 24 & 15] + HEX_CHARS[h6l >> 20 & 15] + HEX_CHARS[h6l >> 16 & 15] + HEX_CHARS[h6l >> 12 & 15] + HEX_CHARS[h6l >> 8 & 15] + HEX_CHARS[h6l >> 4 & 15] + HEX_CHARS[h6l & 15] + HEX_CHARS[h7h >> 28 & 15] + HEX_CHARS[h7h >> 24 & 15] + HEX_CHARS[h7h >> 20 & 15] + HEX_CHARS[h7h >> 16 & 15] + HEX_CHARS[h7h >> 12 & 15] + HEX_CHARS[h7h >> 8 & 15] + HEX_CHARS[h7h >> 4 & 15] + HEX_CHARS[h7h & 15] + HEX_CHARS[h7l >> 28 & 15] + HEX_CHARS[h7l >> 24 & 15] + HEX_CHARS[h7l >> 20 & 15] + HEX_CHARS[h7l >> 16 & 15] + HEX_CHARS[h7l >> 12 & 15] + HEX_CHARS[h7l >> 8 & 15] + HEX_CHARS[h7l >> 4 & 15] + HEX_CHARS[h7l & 15];
        }
        return hex2;
      };
      Sha512.prototype.toString = Sha512.prototype.hex;
      Sha512.prototype.digest = function() {
        this.finalize();
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
        var arr = [
          h0h >> 24 & 255,
          h0h >> 16 & 255,
          h0h >> 8 & 255,
          h0h & 255,
          h0l >> 24 & 255,
          h0l >> 16 & 255,
          h0l >> 8 & 255,
          h0l & 255,
          h1h >> 24 & 255,
          h1h >> 16 & 255,
          h1h >> 8 & 255,
          h1h & 255,
          h1l >> 24 & 255,
          h1l >> 16 & 255,
          h1l >> 8 & 255,
          h1l & 255,
          h2h >> 24 & 255,
          h2h >> 16 & 255,
          h2h >> 8 & 255,
          h2h & 255,
          h2l >> 24 & 255,
          h2l >> 16 & 255,
          h2l >> 8 & 255,
          h2l & 255,
          h3h >> 24 & 255,
          h3h >> 16 & 255,
          h3h >> 8 & 255,
          h3h & 255
        ];
        if (bits >= 256) {
          arr.push(h3l >> 24 & 255, h3l >> 16 & 255, h3l >> 8 & 255, h3l & 255);
        }
        if (bits >= 384) {
          arr.push(
            h4h >> 24 & 255,
            h4h >> 16 & 255,
            h4h >> 8 & 255,
            h4h & 255,
            h4l >> 24 & 255,
            h4l >> 16 & 255,
            h4l >> 8 & 255,
            h4l & 255,
            h5h >> 24 & 255,
            h5h >> 16 & 255,
            h5h >> 8 & 255,
            h5h & 255,
            h5l >> 24 & 255,
            h5l >> 16 & 255,
            h5l >> 8 & 255,
            h5l & 255
          );
        }
        if (bits == 512) {
          arr.push(
            h6h >> 24 & 255,
            h6h >> 16 & 255,
            h6h >> 8 & 255,
            h6h & 255,
            h6l >> 24 & 255,
            h6l >> 16 & 255,
            h6l >> 8 & 255,
            h6l & 255,
            h7h >> 24 & 255,
            h7h >> 16 & 255,
            h7h >> 8 & 255,
            h7h & 255,
            h7l >> 24 & 255,
            h7l >> 16 & 255,
            h7l >> 8 & 255,
            h7l & 255
          );
        }
        return arr;
      };
      Sha512.prototype.array = Sha512.prototype.digest;
      Sha512.prototype.arrayBuffer = function() {
        this.finalize();
        var bits = this.bits;
        var buffer2 = new ArrayBuffer(bits / 8);
        var dataView = new DataView(buffer2);
        dataView.setUint32(0, this.h0h);
        dataView.setUint32(4, this.h0l);
        dataView.setUint32(8, this.h1h);
        dataView.setUint32(12, this.h1l);
        dataView.setUint32(16, this.h2h);
        dataView.setUint32(20, this.h2l);
        dataView.setUint32(24, this.h3h);
        if (bits >= 256) {
          dataView.setUint32(28, this.h3l);
        }
        if (bits >= 384) {
          dataView.setUint32(32, this.h4h);
          dataView.setUint32(36, this.h4l);
          dataView.setUint32(40, this.h5h);
          dataView.setUint32(44, this.h5l);
        }
        if (bits == 512) {
          dataView.setUint32(48, this.h6h);
          dataView.setUint32(52, this.h6l);
          dataView.setUint32(56, this.h7h);
          dataView.setUint32(60, this.h7l);
        }
        return buffer2;
      };
      Sha512.prototype.clone = function() {
        var hash2 = new Sha512(this.bits, false);
        this.copyTo(hash2);
        return hash2;
      };
      Sha512.prototype.copyTo = function(hash2) {
        var i2 = 0, attrs = [
          "h0h",
          "h0l",
          "h1h",
          "h1l",
          "h2h",
          "h2l",
          "h3h",
          "h3l",
          "h4h",
          "h4l",
          "h5h",
          "h5l",
          "h6h",
          "h6l",
          "h7h",
          "h7l",
          "start",
          "bytes",
          "hBytes",
          "finalized",
          "hashed",
          "lastByteIndex"
        ];
        for (i2 = 0; i2 < attrs.length; ++i2) {
          hash2[attrs[i2]] = this[attrs[i2]];
        }
        for (i2 = 0; i2 < this.blocks.length; ++i2) {
          hash2.blocks[i2] = this.blocks[i2];
        }
      };
      function HmacSha512(key, bits, sharedMemory) {
        var notString, type = typeof key;
        if (type !== "string") {
          if (type === "object") {
            if (key === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var length = key.length;
        if (!notString) {
          var bytes = [], length = key.length, index = 0, code;
          for (var i2 = 0; i2 < length; ++i2) {
            code = key.charCodeAt(i2);
            if (code < 128) {
              bytes[index++] = code;
            } else if (code < 2048) {
              bytes[index++] = 192 | code >> 6;
              bytes[index++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index++] = 224 | code >> 12;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i2) & 1023);
              bytes[index++] = 240 | code >> 18;
              bytes[index++] = 128 | code >> 12 & 63;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            }
          }
          key = bytes;
        }
        if (key.length > 128) {
          key = new Sha512(bits, true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (var i2 = 0; i2 < 128; ++i2) {
          var b2 = key[i2] || 0;
          oKeyPad[i2] = 92 ^ b2;
          iKeyPad[i2] = 54 ^ b2;
        }
        Sha512.call(this, bits, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha512.prototype = new Sha512();
      HmacSha512.prototype.finalize = function() {
        Sha512.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha512.call(this, this.bits, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha512.prototype.finalize.call(this);
        }
      };
      HmacSha512.prototype.clone = function() {
        var hash2 = new HmacSha512([], this.bits, false);
        this.copyTo(hash2);
        hash2.inner = this.inner;
        for (var i2 = 0; i2 < this.oKeyPad.length; ++i2) {
          hash2.oKeyPad[i2] = this.oKeyPad[i2];
        }
        return hash2;
      };
      var exports = createMethod(512);
      exports.sha512 = exports;
      exports.sha384 = createMethod(384);
      exports.sha512_256 = createMethod(256);
      exports.sha512_224 = createMethod(224);
      exports.sha512.hmac = createHmacMethod(512);
      exports.sha384.hmac = createHmacMethod(384);
      exports.sha512_256.hmac = createHmacMethod(256);
      exports.sha512_224.hmac = createHmacMethod(224);
      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.sha512 = exports.sha512;
        root.sha384 = exports.sha384;
        root.sha512_256 = exports.sha512_256;
        root.sha512_224 = exports.sha512_224;
      }
    })();
  })(sha512$1);
  return sha512$1.exports;
}
var sha512Exports = requireSha512();
const sha512 = /* @__PURE__ */ getDefaultExportFromCjs(sha512Exports);
var jsonBigint = { exports: {} };
var stringify = { exports: {} };
var bignumber$1 = { exports: {} };
var bignumber = bignumber$1.exports;
var hasRequiredBignumber;
function requireBignumber() {
  if (hasRequiredBignumber) return bignumber$1.exports;
  hasRequiredBignumber = 1;
  (function(module) {
    (function(globalObject) {
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor2 = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE2 = 1e14, LOG_BASE2 = 14, MAX_SAFE_INTEGER2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone2(configObject) {
        var div, convertBase, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE2 = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v2, b2) {
          var alphabet, c2, caseChanged, e3, i2, isNum, len, str, x2 = this;
          if (!(x2 instanceof BigNumber2)) return new BigNumber2(v2, b2);
          if (b2 == null) {
            if (v2 && v2._isBigNumber === true) {
              x2.s = v2.s;
              if (!v2.c || v2.e > MAX_EXP) {
                x2.c = x2.e = null;
              } else if (v2.e < MIN_EXP) {
                x2.c = [x2.e = 0];
              } else {
                x2.e = v2.e;
                x2.c = v2.c.slice();
              }
              return;
            }
            if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
              x2.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
              if (v2 === ~~v2) {
                for (e3 = 0, i2 = v2; i2 >= 10; i2 /= 10, e3++) ;
                if (e3 > MAX_EXP) {
                  x2.c = x2.e = null;
                } else {
                  x2.e = e3;
                  x2.c = [v2];
                }
                return;
              }
              str = String(v2);
            } else {
              if (!isNumeric.test(str = String(v2))) return parseNumeric(x2, str, isNum);
              x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e3 = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i2 = str.search(/e/i)) > 0) {
              if (e3 < 0) e3 = i2;
              e3 += +str.slice(i2 + 1);
              str = str.substring(0, i2);
            } else if (e3 < 0) {
              e3 = str.length;
            }
          } else {
            intCheck(b2, 2, ALPHABET.length, "Base");
            if (b2 == 10 && alphabetHasNormalDecimalDigits) {
              x2 = new BigNumber2(v2);
              return round2(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
            }
            str = String(v2);
            if (isNum = typeof v2 == "number") {
              if (v2 * 0 != 0) return parseNumeric(x2, str, isNum, b2);
              x2.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v2);
              }
            } else {
              x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b2);
            e3 = i2 = 0;
            for (len = str.length; i2 < len; i2++) {
              if (alphabet.indexOf(c2 = str.charAt(i2)) < 0) {
                if (c2 == ".") {
                  if (i2 > e3) {
                    e3 = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i2 = -1;
                    e3 = 0;
                    continue;
                  }
                }
                return parseNumeric(x2, String(v2), isNum, b2);
              }
            }
            isNum = false;
            str = convertBase(str, b2, 10, x2.s);
            if ((e3 = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e3 = str.length;
          }
          for (i2 = 0; str.charCodeAt(i2) === 48; i2++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i2, ++len)) {
            len -= i2;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER2 || v2 !== mathfloor2(v2))) {
              throw Error(tooManyDigits + x2.s * v2);
            }
            if ((e3 = e3 - i2 - 1) > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (e3 < MIN_EXP) {
              x2.c = [x2.e = 0];
            } else {
              x2.e = e3;
              x2.c = [];
              i2 = (e3 + 1) % LOG_BASE2;
              if (e3 < 0) i2 += LOG_BASE2;
              if (i2 < len) {
                if (i2) x2.c.push(+str.slice(0, i2));
                for (len -= LOG_BASE2; i2 < len; ) {
                  x2.c.push(+str.slice(i2, i2 += LOG_BASE2));
                }
                i2 = LOG_BASE2 - (str = str.slice(i2)).length;
              } else {
                i2 -= len;
              }
              for (; i2--; str += "0") ;
              x2.c.push(+str);
            }
          } else {
            x2.c = [x2.e = 0];
          }
        }
        BigNumber2.clone = clone2;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p2, v2;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
                v2 = obj[p2];
                intCheck(v2, 0, MAX, p2);
                DECIMAL_PLACES = v2;
              }
              if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
                v2 = obj[p2];
                intCheck(v2, 0, 8, p2);
                ROUNDING_MODE = v2;
              }
              if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
                v2 = obj[p2];
                if (v2 && v2.pop) {
                  intCheck(v2[0], -MAX, 0, p2);
                  intCheck(v2[1], 0, MAX, p2);
                  TO_EXP_NEG = v2[0];
                  TO_EXP_POS = v2[1];
                } else {
                  intCheck(v2, -MAX, MAX, p2);
                  TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
                }
              }
              if (obj.hasOwnProperty(p2 = "RANGE")) {
                v2 = obj[p2];
                if (v2 && v2.pop) {
                  intCheck(v2[0], -MAX, -1, p2);
                  intCheck(v2[1], 1, MAX, p2);
                  MIN_EXP = v2[0];
                  MAX_EXP = v2[1];
                } else {
                  intCheck(v2, -MAX, MAX, p2);
                  if (v2) {
                    MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
                  } else {
                    throw Error(bignumberError + p2 + " cannot be zero: " + v2);
                  }
                }
              }
              if (obj.hasOwnProperty(p2 = "CRYPTO")) {
                v2 = obj[p2];
                if (v2 === !!v2) {
                  if (v2) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v2;
                    } else {
                      CRYPTO = !v2;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v2;
                  }
                } else {
                  throw Error(bignumberError + p2 + " not true or false: " + v2);
                }
              }
              if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
                v2 = obj[p2];
                intCheck(v2, 0, 9, p2);
                MODULO_MODE = v2;
              }
              if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
                v2 = obj[p2];
                intCheck(v2, 0, MAX, p2);
                POW_PRECISION = v2;
              }
              if (obj.hasOwnProperty(p2 = "FORMAT")) {
                v2 = obj[p2];
                if (typeof v2 == "object") FORMAT = v2;
                else throw Error(bignumberError + p2 + " not an object: " + v2);
              }
              if (obj.hasOwnProperty(p2 = "ALPHABET")) {
                v2 = obj[p2];
                if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
                  alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
                  ALPHABET = v2;
                } else {
                  throw Error(bignumberError + p2 + " invalid: " + v2);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v2) {
          if (!v2 || v2._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i2, n2, c2 = v2.c, e3 = v2.e, s2 = v2.s;
          out: if ({}.toString.call(c2) == "[object Array]") {
            if ((s2 === 1 || s2 === -1) && e3 >= -MAX && e3 <= MAX && e3 === mathfloor2(e3)) {
              if (c2[0] === 0) {
                if (e3 === 0 && c2.length === 1) return true;
                break out;
              }
              i2 = (e3 + 1) % LOG_BASE2;
              if (i2 < 1) i2 += LOG_BASE2;
              if (String(c2[0]).length == i2) {
                for (i2 = 0; i2 < c2.length; i2++) {
                  n2 = c2[i2];
                  if (n2 < 0 || n2 >= BASE2 || n2 !== mathfloor2(n2)) break out;
                }
                if (n2 !== 0) return true;
              }
            }
          } else if (c2 === null && e3 === null && (s2 === null || s2 === 1 || s2 === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v2);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = (function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor2(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a2, b2, e3, k2, v2, i2 = 0, c2 = [], rand = new BigNumber2(ONE2);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k2 = mathceil(dp / LOG_BASE2);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a2 = crypto.getRandomValues(new Uint32Array(k2 *= 2));
                for (; i2 < k2; ) {
                  v2 = a2[i2] * 131072 + (a2[i2 + 1] >>> 11);
                  if (v2 >= 9e15) {
                    b2 = crypto.getRandomValues(new Uint32Array(2));
                    a2[i2] = b2[0];
                    a2[i2 + 1] = b2[1];
                  } else {
                    c2.push(v2 % 1e14);
                    i2 += 2;
                  }
                }
                i2 = k2 / 2;
              } else if (crypto.randomBytes) {
                a2 = crypto.randomBytes(k2 *= 7);
                for (; i2 < k2; ) {
                  v2 = (a2[i2] & 31) * 281474976710656 + a2[i2 + 1] * 1099511627776 + a2[i2 + 2] * 4294967296 + a2[i2 + 3] * 16777216 + (a2[i2 + 4] << 16) + (a2[i2 + 5] << 8) + a2[i2 + 6];
                  if (v2 >= 9e15) {
                    crypto.randomBytes(7).copy(a2, i2);
                  } else {
                    c2.push(v2 % 1e14);
                    i2 += 7;
                  }
                }
                i2 = k2 / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i2 < k2; ) {
                v2 = random53bitInt();
                if (v2 < 9e15) c2[i2++] = v2 % 1e14;
              }
            }
            k2 = c2[--i2];
            dp %= LOG_BASE2;
            if (k2 && dp) {
              v2 = POWS_TEN[LOG_BASE2 - dp];
              c2[i2] = mathfloor2(k2 / v2) * v2;
            }
            for (; c2[i2] === 0; c2.pop(), i2--) ;
            if (i2 < 0) {
              c2 = [e3 = 0];
            } else {
              for (e3 = -1; c2[0] === 0; c2.splice(0, 1), e3 -= LOG_BASE2) ;
              for (i2 = 1, v2 = c2[0]; v2 >= 10; v2 /= 10, i2++) ;
              if (i2 < LOG_BASE2) e3 -= LOG_BASE2 - i2;
            }
            rand.e = e3;
            rand.c = c2;
            return rand;
          };
        })();
        BigNumber2.sum = function() {
          var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i2 < args.length; ) sum = sum.plus(args[i2++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ (function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j2, arr = [0], arrL, i2 = 0, len = str.length;
            for (; i2 < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i2++));
              for (j2 = 0; j2 < arr.length; j2++) {
                if (arr[j2] > baseOut - 1) {
                  if (arr[j2 + 1] == null) arr[j2 + 1] = 0;
                  arr[j2 + 1] += arr[j2] / baseOut | 0;
                  arr[j2] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign2, callerIsToString) {
            var alphabet, d2, e3, k2, r2, x2, xc, y2, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i2 >= 0) {
              k2 = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y2 = new BigNumber2(baseIn);
              x2 = y2.pow(str.length - i2);
              POW_PRECISION = k2;
              y2.c = toBaseOut(
                toFixedPoint(coeffToString(x2.c), x2.e, "0"),
                10,
                baseOut,
                decimal
              );
              y2.e = y2.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e3 = k2 = xc.length;
            for (; xc[--k2] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i2 < 0) {
              --e3;
            } else {
              x2.c = xc;
              x2.e = e3;
              x2.s = sign2;
              x2 = div(x2, y2, dp, rm, baseOut);
              xc = x2.c;
              r2 = x2.r;
              e3 = x2.e;
            }
            d2 = e3 + dp + 1;
            i2 = xc[d2];
            k2 = baseOut / 2;
            r2 = r2 || d2 < 0 || xc[d2 + 1] != null;
            r2 = rm < 4 ? (i2 != null || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i2 > k2 || i2 == k2 && (rm == 4 || r2 || rm == 6 && xc[d2 - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
            if (d2 < 1 || !xc[0]) {
              str = r2 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d2;
              if (r2) {
                for (--baseOut; ++xc[--d2] > baseOut; ) {
                  xc[d2] = 0;
                  if (!d2) {
                    ++e3;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k2 = xc.length; !xc[--k2]; ) ;
              for (i2 = 0, str = ""; i2 <= k2; str += alphabet.charAt(xc[i2++])) ;
              str = toFixedPoint(str, e3, alphabet.charAt(0));
            }
            return str;
          };
        })();
        div = /* @__PURE__ */ (function() {
          function multiply(x2, k2, base) {
            var m2, temp, xlo, xhi, carry = 0, i2 = x2.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
            for (x2 = x2.slice(); i2--; ) {
              xlo = x2[i2] % SQRT_BASE;
              xhi = x2[i2] / SQRT_BASE | 0;
              m2 = khi * xlo + xhi * klo;
              temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
              x2[i2] = temp % base;
            }
            if (carry) x2 = [carry].concat(x2);
            return x2;
          }
          function compare2(a2, b2, aL, bL) {
            var i2, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i2 = cmp = 0; i2 < aL; i2++) {
                if (a2[i2] != b2[i2]) {
                  cmp = a2[i2] > b2[i2] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract2(a2, b2, aL, base) {
            var i2 = 0;
            for (; aL--; ) {
              a2[aL] -= i2;
              i2 = a2[aL] < b2[aL] ? 1 : 0;
              a2[aL] = i2 * base + a2[aL] - b2[aL];
            }
            for (; !a2[0] && a2.length > 1; a2.splice(0, 1)) ;
          }
          return function(x2, y2, dp, rm, base) {
            var cmp, e3, i2, more, n2, prod, prodL, q2, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x2.s == y2.s ? 1 : -1, xc = x2.c, yc = y2.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x2.s || !y2.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
                )
              );
            }
            q2 = new BigNumber2(s2);
            qc = q2.c = [];
            e3 = x2.e - y2.e;
            s2 = dp + e3 + 1;
            if (!base) {
              base = BASE2;
              e3 = bitFloor(x2.e / LOG_BASE2) - bitFloor(y2.e / LOG_BASE2);
              s2 = s2 / LOG_BASE2 | 0;
            }
            for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++) ;
            if (yc[i2] > (xc[i2] || 0)) e3--;
            if (s2 < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i2 = 0;
              s2 += 2;
              n2 = mathfloor2(base / (yc[0] + 1));
              if (n2 > 1) {
                yc = multiply(yc, n2, base);
                xc = multiply(xc, n2, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n2 = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n2 = mathfloor2(rem0 / yc0);
                  if (n2 > 1) {
                    if (n2 >= base) n2 = base - 1;
                    prod = multiply(yc, n2, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n2--;
                      subtract2(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n2 == 0) {
                      cmp = n2 = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract2(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n2++;
                      subtract2(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n2++;
                  rem = [0];
                }
                qc[i2++] = n2;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s2--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE2) {
              for (i2 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i2++) ;
              round2(q2, dp + (q2.e = i2 + e3 * LOG_BASE2 - 1) + 1, rm, more);
            } else {
              q2.e = e3;
              q2.r = +more;
            }
            return q2;
          };
        })();
        function format2(n2, i2, rm, id) {
          var c0, e3, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n2.c) return n2.toString();
          c0 = n2.c[0];
          ne = n2.e;
          if (i2 == null) {
            str = coeffToString(n2.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n2 = round2(new BigNumber2(n2), i2, rm);
            e3 = n2.e;
            str = coeffToString(n2.c);
            len = str.length;
            if (id == 1 || id == 2 && (i2 <= e3 || e3 <= TO_EXP_NEG)) {
              for (; len < i2; str += "0", len++) ;
              str = toExponential(str, e3);
            } else {
              i2 -= ne + (id === 2 && e3 > ne);
              str = toFixedPoint(str, e3, "0");
              if (e3 + 1 > len) {
                if (--i2 > 0) for (str += "."; i2--; str += "0") ;
              } else {
                i2 += e3 - len;
                if (i2 > 0) {
                  if (e3 + 1 == len) str += ".";
                  for (; i2--; str += "0") ;
                }
              }
            }
          }
          return n2.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n2) {
          var k2, y2, i2 = 1, x2 = new BigNumber2(args[0]);
          for (; i2 < args.length; i2++) {
            y2 = new BigNumber2(args[i2]);
            if (!y2.s || (k2 = compare(x2, y2)) === n2 || k2 === 0 && x2.s === n2) {
              x2 = y2;
            }
          }
          return x2;
        }
        function normalise(n2, c2, e3) {
          var i2 = 1, j2 = c2.length;
          for (; !c2[--j2]; c2.pop()) ;
          for (j2 = c2[0]; j2 >= 10; j2 /= 10, i2++) ;
          if ((e3 = i2 + e3 * LOG_BASE2 - 1) > MAX_EXP) {
            n2.c = n2.e = null;
          } else if (e3 < MIN_EXP) {
            n2.c = [n2.e = 0];
          } else {
            n2.e = e3;
            n2.c = c2;
          }
          return n2;
        }
        parseNumeric = /* @__PURE__ */ (function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x2, str, isNum, b2) {
            var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s2)) {
              x2.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s2 = s2.replace(basePrefix, function(m2, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b2 || b2 == base ? p1 : m2;
                });
                if (b2) {
                  base = b2;
                  s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s2) return new BigNumber2(s2, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
              }
              x2.s = null;
            }
            x2.c = x2.e = null;
          };
        })();
        function round2(x2, sd, rm, r2) {
          var d2, i2, j2, k2, n2, ni, rd, xc = x2.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d2 = 1, k2 = xc[0]; k2 >= 10; k2 /= 10, d2++) ;
              i2 = sd - d2;
              if (i2 < 0) {
                i2 += LOG_BASE2;
                j2 = sd;
                n2 = xc[ni = 0];
                rd = mathfloor2(n2 / pows10[d2 - j2 - 1] % 10);
              } else {
                ni = mathceil((i2 + 1) / LOG_BASE2);
                if (ni >= xc.length) {
                  if (r2) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n2 = rd = 0;
                    d2 = 1;
                    i2 %= LOG_BASE2;
                    j2 = i2 - LOG_BASE2 + 1;
                  } else {
                    break out;
                  }
                } else {
                  n2 = k2 = xc[ni];
                  for (d2 = 1; k2 >= 10; k2 /= 10, d2++) ;
                  i2 %= LOG_BASE2;
                  j2 = i2 - LOG_BASE2 + d2;
                  rd = j2 < 0 ? 0 : mathfloor2(n2 / pows10[d2 - j2 - 1] % 10);
                }
              }
              r2 = r2 || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j2 < 0 ? n2 : n2 % pows10[d2 - j2 - 1]);
              r2 = rm < 4 ? (rd || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r2 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i2 > 0 ? j2 > 0 ? n2 / pows10[d2 - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r2) {
                  sd -= x2.e + 1;
                  xc[0] = pows10[(LOG_BASE2 - sd % LOG_BASE2) % LOG_BASE2];
                  x2.e = -sd || 0;
                } else {
                  xc[0] = x2.e = 0;
                }
                return x2;
              }
              if (i2 == 0) {
                xc.length = ni;
                k2 = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k2 = pows10[LOG_BASE2 - i2];
                xc[ni] = j2 > 0 ? mathfloor2(n2 / pows10[d2 - j2] % pows10[j2]) * k2 : 0;
              }
              if (r2) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i2 = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i2++) ;
                    j2 = xc[0] += k2;
                    for (k2 = 1; j2 >= 10; j2 /= 10, k2++) ;
                    if (i2 != k2) {
                      x2.e++;
                      if (xc[0] == BASE2) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k2;
                    if (xc[ni] != BASE2) break;
                    xc[ni--] = 0;
                    k2 = 1;
                  }
                }
              }
              for (i2 = xc.length; xc[--i2] === 0; xc.pop()) ;
            }
            if (x2.e > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (x2.e < MIN_EXP) {
              x2.c = [x2.e = 0];
            }
          }
          return x2;
        }
        function valueOf(n2) {
          var str, e3 = n2.e;
          if (e3 === null) return n2.toString();
          str = coeffToString(n2.c);
          str = e3 <= TO_EXP_NEG || e3 >= TO_EXP_POS ? toExponential(str, e3) : toFixedPoint(str, e3, "0");
          return n2.s < 0 ? "-" + str : str;
        }
        P2.absoluteValue = P2.abs = function() {
          var x2 = new BigNumber2(this);
          if (x2.s < 0) x2.s = 1;
          return x2;
        };
        P2.comparedTo = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2));
        };
        P2.decimalPlaces = P2.dp = function(dp, rm) {
          var c2, n2, v2, x2 = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round2(new BigNumber2(x2), dp + x2.e + 1, rm);
          }
          if (!(c2 = x2.c)) return null;
          n2 = ((v2 = c2.length - 1) - bitFloor(this.e / LOG_BASE2)) * LOG_BASE2;
          if (v2 = c2[v2]) for (; v2 % 10 == 0; v2 /= 10, n2--) ;
          if (n2 < 0) n2 = 0;
          return n2;
        };
        P2.dividedBy = P2.div = function(y2, b2) {
          return div(this, new BigNumber2(y2, b2), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P2.dividedToIntegerBy = P2.idiv = function(y2, b2) {
          return div(this, new BigNumber2(y2, b2), 0, 1);
        };
        P2.exponentiatedBy = P2.pow = function(n2, m2) {
          var half, isModExp, i2, k2, more, nIsBig, nIsNeg, nIsOdd, y2, x2 = this;
          n2 = new BigNumber2(n2);
          if (n2.c && !n2.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n2));
          }
          if (m2 != null) m2 = new BigNumber2(m2);
          nIsBig = n2.e > 14;
          if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n2.c || !n2.c[0]) {
            y2 = new BigNumber2(Math.pow(+valueOf(x2), nIsBig ? n2.s * (2 - isOdd(n2)) : +valueOf(n2)));
            return m2 ? y2.mod(m2) : y2;
          }
          nIsNeg = n2.s < 0;
          if (m2) {
            if (m2.c ? !m2.c[0] : !m2.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x2.isInteger() && m2.isInteger();
            if (isModExp) x2 = x2.mod(m2);
          } else if (n2.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
            k2 = x2.s < 0 && isOdd(n2) ? -0 : 0;
            if (x2.e > -1) k2 = 1 / k2;
            return new BigNumber2(nIsNeg ? 1 / k2 : k2);
          } else if (POW_PRECISION) {
            k2 = mathceil(POW_PRECISION / LOG_BASE2 + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n2.s = 1;
            nIsOdd = isOdd(n2);
          } else {
            i2 = Math.abs(+valueOf(n2));
            nIsOdd = i2 % 2;
          }
          y2 = new BigNumber2(ONE2);
          for (; ; ) {
            if (nIsOdd) {
              y2 = y2.times(x2);
              if (!y2.c) break;
              if (k2) {
                if (y2.c.length > k2) y2.c.length = k2;
              } else if (isModExp) {
                y2 = y2.mod(m2);
              }
            }
            if (i2) {
              i2 = mathfloor2(i2 / 2);
              if (i2 === 0) break;
              nIsOdd = i2 % 2;
            } else {
              n2 = n2.times(half);
              round2(n2, n2.e + 1, 1);
              if (n2.e > 14) {
                nIsOdd = isOdd(n2);
              } else {
                i2 = +valueOf(n2);
                if (i2 === 0) break;
                nIsOdd = i2 % 2;
              }
            }
            x2 = x2.times(x2);
            if (k2) {
              if (x2.c && x2.c.length > k2) x2.c.length = k2;
            } else if (isModExp) {
              x2 = x2.mod(m2);
            }
          }
          if (isModExp) return y2;
          if (nIsNeg) y2 = ONE2.div(y2);
          return m2 ? y2.mod(m2) : k2 ? round2(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
        };
        P2.integerValue = function(rm) {
          var n2 = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round2(n2, n2.e + 1, rm);
        };
        P2.isEqualTo = P2.eq = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2)) === 0;
        };
        P2.isFinite = function() {
          return !!this.c;
        };
        P2.isGreaterThan = P2.gt = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2)) > 0;
        };
        P2.isGreaterThanOrEqualTo = P2.gte = function(y2, b2) {
          return (b2 = compare(this, new BigNumber2(y2, b2))) === 1 || b2 === 0;
        };
        P2.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE2) > this.c.length - 2;
        };
        P2.isLessThan = P2.lt = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2)) < 0;
        };
        P2.isLessThanOrEqualTo = P2.lte = function(y2, b2) {
          return (b2 = compare(this, new BigNumber2(y2, b2))) === -1 || b2 === 0;
        };
        P2.isNaN = function() {
          return !this.s;
        };
        P2.isNegative = function() {
          return this.s < 0;
        };
        P2.isPositive = function() {
          return this.s > 0;
        };
        P2.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P2.minus = function(y2, b2) {
          var i2, j2, t2, xLTy, x2 = this, a2 = x2.s;
          y2 = new BigNumber2(y2, b2);
          b2 = y2.s;
          if (!a2 || !b2) return new BigNumber2(NaN);
          if (a2 != b2) {
            y2.s = -b2;
            return x2.plus(y2);
          }
          var xe = x2.e / LOG_BASE2, ye = y2.e / LOG_BASE2, xc = x2.c, yc = y2.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y2.s = -b2, y2) : new BigNumber2(yc ? x2 : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y2.s = -b2, y2) : new BigNumber2(xc[0] ? x2 : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a2 = xe - ye) {
            if (xLTy = a2 < 0) {
              a2 = -a2;
              t2 = xc;
            } else {
              ye = xe;
              t2 = yc;
            }
            t2.reverse();
            for (b2 = a2; b2--; t2.push(0)) ;
            t2.reverse();
          } else {
            j2 = (xLTy = (a2 = xc.length) < (b2 = yc.length)) ? a2 : b2;
            for (a2 = b2 = 0; b2 < j2; b2++) {
              if (xc[b2] != yc[b2]) {
                xLTy = xc[b2] < yc[b2];
                break;
              }
            }
          }
          if (xLTy) {
            t2 = xc;
            xc = yc;
            yc = t2;
            y2.s = -y2.s;
          }
          b2 = (j2 = yc.length) - (i2 = xc.length);
          if (b2 > 0) for (; b2--; xc[i2++] = 0) ;
          b2 = BASE2 - 1;
          for (; j2 > a2; ) {
            if (xc[--j2] < yc[j2]) {
              for (i2 = j2; i2 && !xc[--i2]; xc[i2] = b2) ;
              --xc[i2];
              xc[j2] += BASE2;
            }
            xc[j2] -= yc[j2];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y2.s = ROUNDING_MODE == 3 ? -1 : 1;
            y2.c = [y2.e = 0];
            return y2;
          }
          return normalise(y2, xc, ye);
        };
        P2.modulo = P2.mod = function(y2, b2) {
          var q2, s2, x2 = this;
          y2 = new BigNumber2(y2, b2);
          if (!x2.c || !y2.s || y2.c && !y2.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y2.c || x2.c && !x2.c[0]) {
            return new BigNumber2(x2);
          }
          if (MODULO_MODE == 9) {
            s2 = y2.s;
            y2.s = 1;
            q2 = div(x2, y2, 0, 3);
            y2.s = s2;
            q2.s *= s2;
          } else {
            q2 = div(x2, y2, 0, MODULO_MODE);
          }
          y2 = x2.minus(q2.times(y2));
          if (!y2.c[0] && MODULO_MODE == 1) y2.s = x2.s;
          return y2;
        };
        P2.multipliedBy = P2.times = function(y2, b2) {
          var c2, e3, i2, j2, k2, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x2 = this, xc = x2.c, yc = (y2 = new BigNumber2(y2, b2)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x2.s || !y2.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y2.c = y2.e = y2.s = null;
            } else {
              y2.s *= x2.s;
              if (!xc || !yc) {
                y2.c = y2.e = null;
              } else {
                y2.c = [0];
                y2.e = 0;
              }
            }
            return y2;
          }
          e3 = bitFloor(x2.e / LOG_BASE2) + bitFloor(y2.e / LOG_BASE2);
          y2.s *= x2.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i2 = xcL;
            xcL = ycL;
            ycL = i2;
          }
          for (i2 = xcL + ycL, zc = []; i2--; zc.push(0)) ;
          base = BASE2;
          sqrtBase = SQRT_BASE;
          for (i2 = ycL; --i2 >= 0; ) {
            c2 = 0;
            ylo = yc[i2] % sqrtBase;
            yhi = yc[i2] / sqrtBase | 0;
            for (k2 = xcL, j2 = i2 + k2; j2 > i2; ) {
              xlo = xc[--k2] % sqrtBase;
              xhi = xc[k2] / sqrtBase | 0;
              m2 = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc[j2] + c2;
              c2 = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
              zc[j2--] = xlo % base;
            }
            zc[j2] = c2;
          }
          if (c2) {
            ++e3;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y2, zc, e3);
        };
        P2.negated = function() {
          var x2 = new BigNumber2(this);
          x2.s = -x2.s || null;
          return x2;
        };
        P2.plus = function(y2, b2) {
          var t2, x2 = this, a2 = x2.s;
          y2 = new BigNumber2(y2, b2);
          b2 = y2.s;
          if (!a2 || !b2) return new BigNumber2(NaN);
          if (a2 != b2) {
            y2.s = -b2;
            return x2.minus(y2);
          }
          var xe = x2.e / LOG_BASE2, ye = y2.e / LOG_BASE2, xc = x2.c, yc = y2.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a2 / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y2 : new BigNumber2(xc[0] ? x2 : a2 * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a2 = xe - ye) {
            if (a2 > 0) {
              ye = xe;
              t2 = yc;
            } else {
              a2 = -a2;
              t2 = xc;
            }
            t2.reverse();
            for (; a2--; t2.push(0)) ;
            t2.reverse();
          }
          a2 = xc.length;
          b2 = yc.length;
          if (a2 - b2 < 0) {
            t2 = yc;
            yc = xc;
            xc = t2;
            b2 = a2;
          }
          for (a2 = 0; b2; ) {
            a2 = (xc[--b2] = xc[b2] + yc[b2] + a2) / BASE2 | 0;
            xc[b2] = BASE2 === xc[b2] ? 0 : xc[b2] % BASE2;
          }
          if (a2) {
            xc = [a2].concat(xc);
            ++ye;
          }
          return normalise(y2, xc, ye);
        };
        P2.precision = P2.sd = function(sd, rm) {
          var c2, n2, v2, x2 = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round2(new BigNumber2(x2), sd, rm);
          }
          if (!(c2 = x2.c)) return null;
          v2 = c2.length - 1;
          n2 = v2 * LOG_BASE2 + 1;
          if (v2 = c2[v2]) {
            for (; v2 % 10 == 0; v2 /= 10, n2--) ;
            for (v2 = c2[0]; v2 >= 10; v2 /= 10, n2++) ;
          }
          if (sd && x2.e + 1 > n2) n2 = x2.e + 1;
          return n2;
        };
        P2.shiftedBy = function(k2) {
          intCheck(k2, -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2);
          return this.times("1e" + k2);
        };
        P2.squareRoot = P2.sqrt = function() {
          var m2, n2, r2, rep, t2, x2 = this, c2 = x2.c, s2 = x2.s, e3 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s2 !== 1 || !c2 || !c2[0]) {
            return new BigNumber2(!s2 || s2 < 0 && (!c2 || c2[0]) ? NaN : c2 ? x2 : 1 / 0);
          }
          s2 = Math.sqrt(+valueOf(x2));
          if (s2 == 0 || s2 == 1 / 0) {
            n2 = coeffToString(c2);
            if ((n2.length + e3) % 2 == 0) n2 += "0";
            s2 = Math.sqrt(+n2);
            e3 = bitFloor((e3 + 1) / 2) - (e3 < 0 || e3 % 2);
            if (s2 == 1 / 0) {
              n2 = "5e" + e3;
            } else {
              n2 = s2.toExponential();
              n2 = n2.slice(0, n2.indexOf("e") + 1) + e3;
            }
            r2 = new BigNumber2(n2);
          } else {
            r2 = new BigNumber2(s2 + "");
          }
          if (r2.c[0]) {
            e3 = r2.e;
            s2 = e3 + dp;
            if (s2 < 3) s2 = 0;
            for (; ; ) {
              t2 = r2;
              r2 = half.times(t2.plus(div(x2, t2, dp, 1)));
              if (coeffToString(t2.c).slice(0, s2) === (n2 = coeffToString(r2.c)).slice(0, s2)) {
                if (r2.e < e3) --s2;
                n2 = n2.slice(s2 - 3, s2 + 1);
                if (n2 == "9999" || !rep && n2 == "4999") {
                  if (!rep) {
                    round2(t2, t2.e + DECIMAL_PLACES + 2, 0);
                    if (t2.times(t2).eq(x2)) {
                      r2 = t2;
                      break;
                    }
                  }
                  dp += 4;
                  s2 += 4;
                  rep = 1;
                } else {
                  if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
                    round2(r2, r2.e + DECIMAL_PLACES + 2, 1);
                    m2 = !r2.times(r2).eq(x2);
                  }
                  break;
                }
              }
            }
          }
          return round2(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
        };
        P2.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format2(this, dp, rm, 1);
        };
        P2.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format2(this, dp, rm);
        };
        P2.toFormat = function(dp, rm, format22) {
          var str, x2 = this;
          if (format22 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format22 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format22 = dp;
              dp = rm = null;
            } else {
              format22 = FORMAT;
            }
          } else if (typeof format22 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format22);
          }
          str = x2.toFixed(dp, rm);
          if (x2.c) {
            var i2, arr = str.split("."), g1 = +format22.groupSize, g2 = +format22.secondaryGroupSize, groupSeparator = format22.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i2 = g1;
              g1 = g2;
              g2 = i2;
              len -= i2;
            }
            if (g1 > 0 && len > 0) {
              i2 = len % g1 || g1;
              intPart = intDigits.substr(0, i2);
              for (; i2 < len; i2 += g1) intPart += groupSeparator + intDigits.substr(i2, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i2);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format22.decimalSeparator || "") + ((g2 = +format22.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format22.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format22.prefix || "") + str + (format22.suffix || "");
        };
        P2.toFraction = function(md) {
          var d2, d0, d1, d22, e3, exp2, n2, n0, n1, q2, r2, s2, x2 = this, xc = x2.c;
          if (md != null) {
            n2 = new BigNumber2(md);
            if (!n2.isInteger() && (n2.c || n2.s !== 1) || n2.lt(ONE2)) {
              throw Error(bignumberError + "Argument " + (n2.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n2));
            }
          }
          if (!xc) return new BigNumber2(x2);
          d2 = new BigNumber2(ONE2);
          n1 = d0 = new BigNumber2(ONE2);
          d1 = n0 = new BigNumber2(ONE2);
          s2 = coeffToString(xc);
          e3 = d2.e = s2.length - x2.e - 1;
          d2.c[0] = POWS_TEN[(exp2 = e3 % LOG_BASE2) < 0 ? LOG_BASE2 + exp2 : exp2];
          md = !md || n2.comparedTo(d2) > 0 ? e3 > 0 ? d2 : n1 : n2;
          exp2 = MAX_EXP;
          MAX_EXP = 1 / 0;
          n2 = new BigNumber2(s2);
          n0.c[0] = 0;
          for (; ; ) {
            q2 = div(n2, d2, 0, 1);
            d22 = d0.plus(q2.times(d1));
            if (d22.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d22;
            n1 = n0.plus(q2.times(d22 = n1));
            n0 = d22;
            d2 = n2.minus(q2.times(d22 = d2));
            n2 = d22;
          }
          d22 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d22.times(n1));
          d0 = d0.plus(d22.times(d1));
          n0.s = n1.s = x2.s;
          e3 = e3 * 2;
          r2 = div(n1, d1, e3, ROUNDING_MODE).minus(x2).abs().comparedTo(
            div(n0, d0, e3, ROUNDING_MODE).minus(x2).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp2;
          return r2;
        };
        P2.toNumber = function() {
          return +valueOf(this);
        };
        P2.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format2(this, sd, rm, 2);
        };
        P2.toString = function(b2) {
          var str, n2 = this, s2 = n2.s, e3 = n2.e;
          if (e3 === null) {
            if (s2) {
              str = "Infinity";
              if (s2 < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b2 == null) {
              str = e3 <= TO_EXP_NEG || e3 >= TO_EXP_POS ? toExponential(coeffToString(n2.c), e3) : toFixedPoint(coeffToString(n2.c), e3, "0");
            } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
              n2 = round2(new BigNumber2(n2), DECIMAL_PLACES + e3 + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n2.c), n2.e, "0");
            } else {
              intCheck(b2, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n2.c), e3, "0"), 10, b2, s2, true);
            }
            if (s2 < 0 && n2.c[0]) str = "-" + str;
          }
          return str;
        };
        P2.valueOf = P2.toJSON = function() {
          return valueOf(this);
        };
        P2._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n2) {
        var i2 = n2 | 0;
        return n2 > 0 || n2 === i2 ? i2 : i2 - 1;
      }
      function coeffToString(a2) {
        var s2, z2, i2 = 1, j2 = a2.length, r2 = a2[0] + "";
        for (; i2 < j2; ) {
          s2 = a2[i2++] + "";
          z2 = LOG_BASE2 - s2.length;
          for (; z2--; s2 = "0" + s2) ;
          r2 += s2;
        }
        for (j2 = r2.length; r2.charCodeAt(--j2) === 48; ) ;
        return r2.slice(0, j2 + 1 || 1);
      }
      function compare(x2, y2) {
        var a2, b2, xc = x2.c, yc = y2.c, i2 = x2.s, j2 = y2.s, k2 = x2.e, l2 = y2.e;
        if (!i2 || !j2) return null;
        a2 = xc && !xc[0];
        b2 = yc && !yc[0];
        if (a2 || b2) return a2 ? b2 ? 0 : -j2 : i2;
        if (i2 != j2) return i2;
        a2 = i2 < 0;
        b2 = k2 == l2;
        if (!xc || !yc) return b2 ? 0 : !xc ^ a2 ? 1 : -1;
        if (!b2) return k2 > l2 ^ a2 ? 1 : -1;
        j2 = (k2 = xc.length) < (l2 = yc.length) ? k2 : l2;
        for (i2 = 0; i2 < j2; i2++) if (xc[i2] != yc[i2]) return xc[i2] > yc[i2] ^ a2 ? 1 : -1;
        return k2 == l2 ? 0 : k2 > l2 ^ a2 ? 1 : -1;
      }
      function intCheck(n2, min2, max2, name) {
        if (n2 < min2 || n2 > max2 || n2 !== mathfloor2(n2)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n2 == "number" ? n2 < min2 || n2 > max2 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n2));
        }
      }
      function isOdd(n2) {
        var k2 = n2.c.length - 1;
        return bitFloor(n2.e / LOG_BASE2) == k2 && n2.c[k2] % 2 != 0;
      }
      function toExponential(str, e3) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e3 < 0 ? "e" : "e+") + e3;
      }
      function toFixedPoint(str, e3, z2) {
        var len, zs;
        if (e3 < 0) {
          for (zs = z2 + "."; ++e3; zs += z2) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e3 > len) {
            for (zs = z2, e3 -= len; --e3; zs += z2) ;
            str += zs;
          } else if (e3 < len) {
            str = str.slice(0, e3) + "." + str.slice(e3);
          }
        }
        return str;
      }
      BigNumber = clone2();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(bignumber);
  })(bignumber$1);
  return bignumber$1.exports;
}
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify.exports;
  hasRequiredStringify = 1;
  (function(module) {
    var BigNumber = requireBignumber();
    var JSON2 = module.exports;
    (function() {
      var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string2) {
        escapable.lastIndex = 0;
        return escapable.test(string2) ? '"' + string2.replace(escapable, function(a2) {
          var c2 = meta[a2];
          return typeof c2 === "string" ? c2 : "\\u" + ("0000" + a2.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string2 + '"';
      }
      function str(key, holder) {
        var i2, k2, v2, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          // If the type is 'object', we might be dealing with an object or an array or
          // null.
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i2 = 0; i2 < length; i2 += 1) {
                partial[i2] = str(i2, value) || "null";
              }
              v2 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v2;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i2 = 0; i2 < length; i2 += 1) {
                if (typeof rep[i2] === "string") {
                  k2 = rep[i2];
                  v2 = str(k2, value);
                  if (v2) {
                    partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k22) {
                var v22 = str(k22, value);
                if (v22) {
                  partial.push(quote(k22) + (gap ? ": " : ":") + v22);
                }
              });
            }
            v2 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v2;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i2;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i2 = 0; i2 < space; i2 += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  })(stringify);
  return stringify.exports;
}
var parse;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  var BigNumber = null;
  const suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
  const suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
  var json_parse = function(options) {
    var _options = {
      strict: false,
      // not being strict means do not generate syntax errors for "duplicate key"
      storeAsString: false,
      // toggles whether the values should be stored as BigNumber (default) or a string
      alwaysParseAsBig: false,
      // toggles whether all numbers should be Big
      useNativeBigInt: false,
      // toggles whether to use native BigInt instead of bignumber.js
      protoAction: "error",
      constructorAction: "error"
    };
    if (options !== void 0 && options !== null) {
      if (options.strict === true) {
        _options.strict = true;
      }
      if (options.storeAsString === true) {
        _options.storeAsString = true;
      }
      _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
      _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
      if (typeof options.constructorAction !== "undefined") {
        if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
          _options.constructorAction = options.constructorAction;
        } else {
          throw new Error(
            `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
          );
        }
      }
      if (typeof options.protoAction !== "undefined") {
        if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
          _options.protoAction = options.protoAction;
        } else {
          throw new Error(
            `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
          );
        }
      }
    }
    var at, ch, escapee = {
      '"': '"',
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	"
    }, text, error = function(m2) {
      throw {
        name: "SyntaxError",
        message: m2,
        at,
        text
      };
    }, next = function(c2) {
      if (c2 && c2 !== ch) {
        error("Expected '" + c2 + "' instead of '" + ch + "'");
      }
      ch = text.charAt(at);
      at += 1;
      return ch;
    }, number2 = function() {
      var number22, string22 = "";
      if (ch === "-") {
        string22 = "-";
        next("-");
      }
      while (ch >= "0" && ch <= "9") {
        string22 += ch;
        next();
      }
      if (ch === ".") {
        string22 += ".";
        while (next() && ch >= "0" && ch <= "9") {
          string22 += ch;
        }
      }
      if (ch === "e" || ch === "E") {
        string22 += ch;
        next();
        if (ch === "-" || ch === "+") {
          string22 += ch;
          next();
        }
        while (ch >= "0" && ch <= "9") {
          string22 += ch;
          next();
        }
      }
      number22 = +string22;
      if (!isFinite(number22)) {
        error("Bad number");
      } else {
        if (BigNumber == null) BigNumber = requireBignumber();
        if (string22.length > 15)
          return _options.storeAsString ? string22 : _options.useNativeBigInt ? BigInt(string22) : new BigNumber(string22);
        else
          return !_options.alwaysParseAsBig ? number22 : _options.useNativeBigInt ? BigInt(number22) : new BigNumber(number22);
      }
    }, string2 = function() {
      var hex2, i2, string22 = "", uffff;
      if (ch === '"') {
        var startAt = at;
        while (next()) {
          if (ch === '"') {
            if (at - 1 > startAt) string22 += text.substring(startAt, at - 1);
            next();
            return string22;
          }
          if (ch === "\\") {
            if (at - 1 > startAt) string22 += text.substring(startAt, at - 1);
            next();
            if (ch === "u") {
              uffff = 0;
              for (i2 = 0; i2 < 4; i2 += 1) {
                hex2 = parseInt(next(), 16);
                if (!isFinite(hex2)) {
                  break;
                }
                uffff = uffff * 16 + hex2;
              }
              string22 += String.fromCharCode(uffff);
            } else if (typeof escapee[ch] === "string") {
              string22 += escapee[ch];
            } else {
              break;
            }
            startAt = at;
          }
        }
      }
      error("Bad string");
    }, white = function() {
      while (ch && ch <= " ") {
        next();
      }
    }, word = function() {
      switch (ch) {
        case "t":
          next("t");
          next("r");
          next("u");
          next("e");
          return true;
        case "f":
          next("f");
          next("a");
          next("l");
          next("s");
          next("e");
          return false;
        case "n":
          next("n");
          next("u");
          next("l");
          next("l");
          return null;
      }
      error("Unexpected '" + ch + "'");
    }, value, array2 = function() {
      var array22 = [];
      if (ch === "[") {
        next("[");
        white();
        if (ch === "]") {
          next("]");
          return array22;
        }
        while (ch) {
          array22.push(value());
          white();
          if (ch === "]") {
            next("]");
            return array22;
          }
          next(",");
          white();
        }
      }
      error("Bad array");
    }, object2 = function() {
      var key, object22 = /* @__PURE__ */ Object.create(null);
      if (ch === "{") {
        next("{");
        white();
        if (ch === "}") {
          next("}");
          return object22;
        }
        while (ch) {
          key = string2();
          white();
          next(":");
          if (_options.strict === true && Object.hasOwnProperty.call(object22, key)) {
            error('Duplicate key "' + key + '"');
          }
          if (suspectProtoRx.test(key) === true) {
            if (_options.protoAction === "error") {
              error("Object contains forbidden prototype property");
            } else if (_options.protoAction === "ignore") {
              value();
            } else {
              object22[key] = value();
            }
          } else if (suspectConstructorRx.test(key) === true) {
            if (_options.constructorAction === "error") {
              error("Object contains forbidden constructor property");
            } else if (_options.constructorAction === "ignore") {
              value();
            } else {
              object22[key] = value();
            }
          } else {
            object22[key] = value();
          }
          white();
          if (ch === "}") {
            next("}");
            return object22;
          }
          next(",");
          white();
        }
      }
      error("Bad object");
    };
    value = function() {
      white();
      switch (ch) {
        case "{":
          return object2();
        case "[":
          return array2();
        case '"':
          return string2();
        case "-":
          return number2();
        default:
          return ch >= "0" && ch <= "9" ? number2() : word();
      }
    };
    return function(source, reviver) {
      var result;
      text = source + "";
      at = 0;
      ch = " ";
      result = value();
      white();
      if (ch) {
        error("Syntax error");
      }
      return typeof reviver === "function" ? (function walk(holder, key) {
        var v2, value2 = holder[key];
        if (value2 && typeof value2 === "object") {
          Object.keys(value2).forEach(function(k2) {
            v2 = walk(value2, k2);
            if (v2 !== void 0) {
              value2[k2] = v2;
            } else {
              delete value2[k2];
            }
          });
        }
        return reviver.call(holder, key, value2);
      })({ "": result }, "") : result;
    };
  };
  parse = json_parse;
  return parse;
}
var hasRequiredJsonBigint;
function requireJsonBigint() {
  if (hasRequiredJsonBigint) return jsonBigint.exports;
  hasRequiredJsonBigint = 1;
  var json_stringify = requireStringify().stringify;
  var json_parse = requireParse();
  jsonBigint.exports = function(options) {
    return {
      parse: json_parse(options),
      stringify: json_stringify
    };
  };
  jsonBigint.exports.parse = json_parse();
  jsonBigint.exports.stringify = json_stringify;
  return jsonBigint.exports;
}
var jsonBigintExports = requireJsonBigint();
const JSONbigWithoutConfig = /* @__PURE__ */ getDefaultExportFromCjs(jsonBigintExports);
var IntDecoding;
(function(IntDecoding2) {
  IntDecoding2["UNSAFE"] = "unsafe";
  IntDecoding2["SAFE"] = "safe";
  IntDecoding2["MIXED"] = "mixed";
  IntDecoding2["BIGINT"] = "bigint";
})(IntDecoding || (IntDecoding = {}));
JSONbigWithoutConfig({
  useNativeBigInt: true,
  strict: true
});
function arrayEqual(a2, b2) {
  if (a2.length !== b2.length) {
    return false;
  }
  return Array.from(a2).every((val, i2) => val === b2[i2]);
}
function concatArrays(...arrs) {
  const size = arrs.reduce((sum, arr) => sum + arr.length, 0);
  const c2 = new Uint8Array(size);
  let offset = 0;
  for (let i2 = 0; i2 < arrs.length; i2++) {
    c2.set(arrs[i2], offset);
    offset += arrs[i2].length;
  }
  return c2;
}
function isNode() {
  return (
    // @ts-ignore
    typeof process === "object" && // @ts-ignore
    typeof process.versions === "object" && // @ts-ignore
    typeof process.versions.node !== "undefined"
  );
}
function ensureSafeInteger(value) {
  if (typeof value === "undefined") {
    throw new Error("Value is undefined");
  }
  if (typeof value === "bigint") {
    if (value > BigInt(Number.MAX_SAFE_INTEGER) || value < BigInt(Number.MIN_SAFE_INTEGER)) {
      throw new Error(`BigInt value ${value} is not a safe integer`);
    }
    return Number(value);
  }
  if (typeof value === "number") {
    if (Number.isSafeInteger(value)) {
      return value;
    }
    throw new Error(`Value ${value} is not a safe integer`);
  }
  throw new Error(`Unexpected type ${typeof value}, ${value}`);
}
function ensureSafeUnsignedInteger(value) {
  const intValue = ensureSafeInteger(value);
  if (intValue < 0) {
    throw new Error(`Value ${intValue} is negative`);
  }
  return intValue;
}
function ensureBigInt(value) {
  if (typeof value === "undefined") {
    throw new Error("Value is undefined");
  }
  if (typeof value === "bigint") {
    return value;
  }
  if (typeof value === "number") {
    if (!Number.isSafeInteger(value)) {
      throw new Error(`Value ${value} is not a safe integer`);
    }
    return BigInt(value);
  }
  throw new Error(`Unexpected type ${typeof value}, ${value}`);
}
function ensureUint64(value) {
  const bigIntValue = ensureBigInt(value);
  if (bigIntValue < 0 || bigIntValue > BigInt("0xffffffffffffffff")) {
    throw new Error(`Value ${bigIntValue} is not a uint64`);
  }
  return bigIntValue;
}
function genericHash(arr) {
  return sha512.sha512_256.array(arr);
}
function isValidSignatureLength(len) {
  return len === nacl.sign.signatureLength;
}
function keyPairFromSecretKey(sk) {
  return nacl.sign.keyPair.fromSecretKey(sk);
}
function sign(msg, secretKey) {
  return nacl.sign.detached(msg, secretKey);
}
function verify(message, signature, verifyKey) {
  return nacl.sign.detached.verify(message, signature, verifyKey);
}
const PUBLIC_KEY_LENGTH = nacl.sign.publicKeyLength;
nacl.sign.secretKeyLength;
const HASH_BYTES_LENGTH = 32;
var base32$1 = { exports: {} };
/*
 * [hi-base32]{@link https://github.com/emn178/hi-base32}
 *
 * @version 0.5.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
var hasRequiredBase32;
function requireBase32() {
  if (hasRequiredBase32) return base32$1.exports;
  hasRequiredBase32 = 1;
  (function(module) {
    (function() {
      var root = typeof window === "object" ? window : {};
      var NODE_JS = !root.HI_BASE32_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = globalThis;
      }
      var COMMON_JS = !root.HI_BASE32_NO_COMMON_JS && true && module.exports;
      var BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
      var BASE32_DECODE_CHAR = {
        "A": 0,
        "B": 1,
        "C": 2,
        "D": 3,
        "E": 4,
        "F": 5,
        "G": 6,
        "H": 7,
        "I": 8,
        "J": 9,
        "K": 10,
        "L": 11,
        "M": 12,
        "N": 13,
        "O": 14,
        "P": 15,
        "Q": 16,
        "R": 17,
        "S": 18,
        "T": 19,
        "U": 20,
        "V": 21,
        "W": 22,
        "X": 23,
        "Y": 24,
        "Z": 25,
        "2": 26,
        "3": 27,
        "4": 28,
        "5": 29,
        "6": 30,
        "7": 31
      };
      var blocks = [0, 0, 0, 0, 0, 0, 0, 0];
      var throwInvalidUtf8 = function(position, partial) {
        if (partial.length > 10) {
          partial = "..." + partial.substr(-10);
        }
        var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
        err.position = position;
        throw err;
      };
      var toUtf8String = function(bytes) {
        var str = "", length = bytes.length, i2 = 0, followingChars = 0, b2, c2;
        while (i2 < length) {
          b2 = bytes[i2++];
          if (b2 <= 127) {
            str += String.fromCharCode(b2);
            continue;
          } else if (b2 > 191 && b2 <= 223) {
            c2 = b2 & 31;
            followingChars = 1;
          } else if (b2 <= 239) {
            c2 = b2 & 15;
            followingChars = 2;
          } else if (b2 <= 247) {
            c2 = b2 & 7;
            followingChars = 3;
          } else {
            throwInvalidUtf8(i2, str);
          }
          for (var j2 = 0; j2 < followingChars; ++j2) {
            b2 = bytes[i2++];
            if (b2 < 128 || b2 > 191) {
              throwInvalidUtf8(i2, str);
            }
            c2 <<= 6;
            c2 += b2 & 63;
          }
          if (c2 >= 55296 && c2 <= 57343) {
            throwInvalidUtf8(i2, str);
          }
          if (c2 > 1114111) {
            throwInvalidUtf8(i2, str);
          }
          if (c2 <= 65535) {
            str += String.fromCharCode(c2);
          } else {
            c2 -= 65536;
            str += String.fromCharCode((c2 >> 10) + 55296);
            str += String.fromCharCode((c2 & 1023) + 56320);
          }
        }
        return str;
      };
      var decodeAsBytes = function(base32Str) {
        if (base32Str === "") {
          return [];
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        base32Str = base32Str.replace(/=/g, "");
        var v1, v2, v3, v4, v5, v6, v7, v8, bytes = [], index = 0, length = base32Str.length;
        for (var i2 = 0, count = length >> 3 << 3; i2 < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
          bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
          bytes[index++] = (v7 << 5 | v8) & 255;
        }
        var remain = length - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
          bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
        }
        return bytes;
      };
      var encodeAscii = function(str) {
        var v1, v2, v3, v4, v5, base32Str = "", length = str.length;
        for (var i2 = 0, count = parseInt(length / 5) * 5; i2 < count; ) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2++);
          v3 = str.charCodeAt(i2++);
          v4 = str.charCodeAt(i2++);
          v5 = str.charCodeAt(i2++);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        }
        var remain = length - count;
        if (remain === 1) {
          v1 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2++);
          v3 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2++);
          v3 = str.charCodeAt(i2++);
          v4 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encodeUtf8 = function(str) {
        var v1, v2, v3, v4, v5, code, end = false, base32Str = "", index = 0, i2, start = 0, length = str.length;
        if (str === "") {
          return base32Str;
        }
        do {
          blocks[0] = blocks[5];
          blocks[1] = blocks[6];
          blocks[2] = blocks[7];
          for (i2 = start; index < length && i2 < 5; ++index) {
            code = str.charCodeAt(index);
            if (code < 128) {
              blocks[i2++] = code;
            } else if (code < 2048) {
              blocks[i2++] = 192 | code >> 6;
              blocks[i2++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              blocks[i2++] = 224 | code >> 12;
              blocks[i2++] = 128 | code >> 6 & 63;
              blocks[i2++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++index) & 1023);
              blocks[i2++] = 240 | code >> 18;
              blocks[i2++] = 128 | code >> 12 & 63;
              blocks[i2++] = 128 | code >> 6 & 63;
              blocks[i2++] = 128 | code & 63;
            }
          }
          start = i2 - 5;
          if (index === length) {
            ++index;
          }
          if (index > length && i2 < 6) {
            end = true;
          }
          v1 = blocks[0];
          if (i2 > 4) {
            v2 = blocks[1];
            v3 = blocks[2];
            v4 = blocks[3];
            v5 = blocks[4];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
          } else if (i2 === 1) {
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
          } else if (i2 === 2) {
            v2 = blocks[1];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
          } else if (i2 === 3) {
            v2 = blocks[1];
            v3 = blocks[2];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
          } else {
            v2 = blocks[1];
            v3 = blocks[2];
            v4 = blocks[3];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
          }
        } while (!end);
        return base32Str;
      };
      var encodeBytes = function(bytes) {
        var v1, v2, v3, v4, v5, base32Str = "", length = bytes.length;
        for (var i2 = 0, count = parseInt(length / 5) * 5; i2 < count; ) {
          v1 = bytes[i2++];
          v2 = bytes[i2++];
          v3 = bytes[i2++];
          v4 = bytes[i2++];
          v5 = bytes[i2++];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        }
        var remain = length - count;
        if (remain === 1) {
          v1 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = bytes[i2++];
          v2 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = bytes[i2++];
          v2 = bytes[i2++];
          v3 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = bytes[i2++];
          v2 = bytes[i2++];
          v3 = bytes[i2++];
          v4 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encode2 = function(input, asciiOnly) {
        var notString = typeof input !== "string";
        if (notString && input.constructor === ArrayBuffer) {
          input = new Uint8Array(input);
        }
        if (notString) {
          return encodeBytes(input);
        } else if (asciiOnly) {
          return encodeAscii(input);
        } else {
          return encodeUtf8(input);
        }
      };
      var decode2 = function(base32Str, asciiOnly) {
        if (!asciiOnly) {
          return toUtf8String(decodeAsBytes(base32Str));
        }
        if (base32Str === "") {
          return "";
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        var v1, v2, v3, v4, v5, v6, v7, v8, str = "", length = base32Str.indexOf("=");
        if (length === -1) {
          length = base32Str.length;
        }
        for (var i2 = 0, count = length >> 3 << 3; i2 < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255) + String.fromCharCode((v7 << 5 | v8) & 255);
        }
        var remain = length - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255);
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255);
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255);
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255);
        }
        return str;
      };
      var exports = {
        encode: encode2,
        decode: decode2
      };
      decode2.asBytes = decodeAsBytes;
      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.base32 = exports;
      }
    })();
  })(base32$1);
  return base32$1.exports;
}
var base32Exports = requireBase32();
const base32 = /* @__PURE__ */ getDefaultExportFromCjs(base32Exports);
function base64ToBytes(base64String) {
  if (isNode()) {
    return new Uint8Array(Buffer.from(base64String, "base64"));
  }
  const binString = atob(base64String);
  return Uint8Array.from(binString, (m2) => m2.codePointAt(0));
}
function bytesToBase64(byteArray) {
  if (isNode()) {
    return Buffer.from(byteArray).toString("base64");
  }
  const binString = Array.from(byteArray, (x2) => String.fromCodePoint(x2)).join("");
  return btoa(binString);
}
function bytesToString(byteArray) {
  return new TextDecoder().decode(byteArray);
}
function coerceToBytes(input) {
  if (typeof input === "string") {
    return new TextEncoder().encode(input);
  }
  return input;
}
function bytesToHex(byteArray) {
  if (isNode()) {
    return Buffer.from(byteArray).toString("hex");
  }
  return Array.from(byteArray).map((i2) => i2.toString(16).padStart(2, "0")).join("");
}
const ALGORAND_ADDRESS_BYTE_LENGTH = 36;
const ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
const ALGORAND_ADDRESS_LENGTH = 58;
const MALFORMED_ADDRESS_ERROR_MSG = "address seems to be malformed";
const CHECKSUM_ADDRESS_ERROR_MSG = "wrong checksum for address";
function checksumFromPublicKey(pk) {
  return Uint8Array.from(genericHash(pk).slice(HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, HASH_BYTES_LENGTH));
}
class Address {
  /**
   * Create a new Address object from its binary form.
   * @param publicKey - The binary form of the address. Must be 32 bytes.
   */
  constructor(publicKey) {
    if (!(publicKey instanceof Uint8Array)) {
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: ${publicKey} is not Uint8Array, type ${typeof publicKey}`);
    }
    if (publicKey.length !== ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH)
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: 0x${bytesToHex(publicKey)}, length ${publicKey.length}`);
    this.publicKey = publicKey;
  }
  /**
   * Check if the address is equal to another address.
   */
  equals(other) {
    return other instanceof Address && arrayEqual(this.publicKey, other.publicKey);
  }
  /**
   * Compute the 4 byte checksum of the address.
   */
  checksum() {
    return checksumFromPublicKey(this.publicKey);
  }
  /**
   * Encode the address into a string form.
   */
  toString() {
    const addr = base32.encode(concatArrays(this.publicKey, this.checksum()));
    return addr.slice(0, ALGORAND_ADDRESS_LENGTH);
  }
  /**
   * Decode an address from a string.
   * @param address - The address to decode. Must be 58 bytes long.
   * @returns An Address object corresponding to the input string.
   */
  static fromString(address) {
    if (typeof address !== "string")
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected string, got ${typeof address}, ${address}`);
    if (address.length !== ALGORAND_ADDRESS_LENGTH)
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected length ${ALGORAND_ADDRESS_LENGTH}, got ${address.length}: ${address}`);
    const decoded = base32.decode.asBytes(address);
    if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected byte length ${ALGORAND_ADDRESS_BYTE_LENGTH}, got ${decoded.length}`);
    const pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
    const cs = new Uint8Array(decoded.slice(PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));
    const checksum = checksumFromPublicKey(pk);
    if (!arrayEqual(checksum, cs))
      throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);
    return new Address(pk);
  }
  /**
   * Get the zero address.
   */
  static zeroAddress() {
    return new Address(new Uint8Array(ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
  }
}
function isValidAddress(address) {
  try {
    Address.fromString(address);
  } catch (e3) {
    return false;
  }
  return true;
}
new TextEncoder().encode("appID");
function utf8Count(str) {
  var strLength = str.length;
  var byteLength = 0;
  var pos = 0;
  while (pos < strLength) {
    var value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      byteLength++;
      continue;
    } else if ((value & 4294965248) === 0) {
      byteLength += 2;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          var extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        byteLength += 3;
      } else {
        byteLength += 4;
      }
    }
  }
  return byteLength;
}
function utf8EncodeJs(str, output, outputOffset) {
  var strLength = str.length;
  var offset = outputOffset;
  var pos = 0;
  while (pos < strLength) {
    var value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      output[offset++] = value;
      continue;
    } else if ((value & 4294965248) === 0) {
      output[offset++] = value >> 6 & 31 | 192;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          var extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        output[offset++] = value >> 12 & 15 | 224;
        output[offset++] = value >> 6 & 63 | 128;
      } else {
        output[offset++] = value >> 18 & 7 | 240;
        output[offset++] = value >> 12 & 63 | 128;
        output[offset++] = value >> 6 & 63 | 128;
      }
    }
    output[offset++] = value & 63 | 128;
  }
}
var sharedTextEncoder = new TextEncoder();
var TEXT_ENCODER_THRESHOLD = 50;
function utf8EncodeTE(str, output, outputOffset) {
  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
}
function utf8Encode(str, output, outputOffset) {
  if (str.length > TEXT_ENCODER_THRESHOLD) {
    utf8EncodeTE(str, output, outputOffset);
  } else {
    utf8EncodeJs(str, output, outputOffset);
  }
}
var CHUNK_SIZE = 4096;
function utf8DecodeJs(bytes, inputOffset, byteLength) {
  var offset = inputOffset;
  var end = offset + byteLength;
  var units = [];
  var result = "";
  while (offset < end) {
    var byte1 = bytes[offset++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      var byte2 = bytes[offset++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      var byte2 = bytes[offset++] & 63;
      var byte3 = bytes[offset++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      var byte2 = bytes[offset++] & 63;
      var byte3 = bytes[offset++] & 63;
      var byte4 = bytes[offset++] & 63;
      var unit2 = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit2 > 65535) {
        unit2 -= 65536;
        units.push(unit2 >>> 10 & 1023 | 55296);
        unit2 = 56320 | unit2 & 1023;
      }
      units.push(unit2);
    } else {
      units.push(byte1);
    }
    if (units.length >= CHUNK_SIZE) {
      result += String.fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += String.fromCharCode.apply(String, units);
  }
  return result;
}
var sharedTextDecoder = new TextDecoder();
var TEXT_DECODER_THRESHOLD = 200;
function utf8DecodeTD(bytes, inputOffset, byteLength) {
  var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
  return sharedTextDecoder.decode(stringBytes);
}
function utf8Decode(bytes, inputOffset, byteLength) {
  if (byteLength > TEXT_DECODER_THRESHOLD) {
    return utf8DecodeTD(bytes, inputOffset, byteLength);
  } else {
    return utf8DecodeJs(bytes, inputOffset, byteLength);
  }
}
var ExtData = (
  /** @class */
  /* @__PURE__ */ (function() {
    function ExtData2(type, data) {
      this.type = type;
      this.data = data;
    }
    return ExtData2;
  })()
);
var __extends = /* @__PURE__ */ (function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
})();
var DecodeError = (
  /** @class */
  (function(_super) {
    __extends(DecodeError2, _super);
    function DecodeError2(message) {
      var _this = _super.call(this, message) || this;
      var proto = Object.create(DecodeError2.prototype);
      Object.setPrototypeOf(_this, proto);
      Object.defineProperty(_this, "name", {
        configurable: true,
        enumerable: false,
        value: DecodeError2.name
      });
      return _this;
    }
    return DecodeError2;
  })(Error)
);
var IntMode;
(function(IntMode2) {
  IntMode2[IntMode2["UNSAFE_NUMBER"] = 0] = "UNSAFE_NUMBER";
  IntMode2[IntMode2["SAFE_NUMBER"] = 1] = "SAFE_NUMBER";
  IntMode2[IntMode2["AS_ENCODED"] = 2] = "AS_ENCODED";
  IntMode2[IntMode2["MIXED"] = 3] = "MIXED";
  IntMode2[IntMode2["BIGINT"] = 4] = "BIGINT";
})(IntMode || (IntMode = {}));
var UINT32_MAX = 4294967295;
function setUint64(view, offset, value) {
  var high = value / 4294967296;
  var low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function setInt64(view, offset, value) {
  var high = Math.floor(value / 4294967296);
  var low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function getInt64(view, offset, mode2) {
  if (mode2 === IntMode.UNSAFE_NUMBER || mode2 === IntMode.SAFE_NUMBER) {
    var high = view.getInt32(offset);
    var low = view.getUint32(offset + 4);
    if (mode2 === IntMode.SAFE_NUMBER && (high < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || high === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && low === 0 || high > (Number.MAX_SAFE_INTEGER - low) / 4294967296)) {
      var hexValue = "".concat(high < 0 ? "-" : "", "0x").concat(Math.abs(high).toString(16)).concat(low.toString(16).padStart(8, "0"));
      throw new Error("Mode is IntMode.SAFE_NUMBER and value is not a safe integer: ".concat(hexValue));
    }
    return high * 4294967296 + low;
  }
  var value = view.getBigInt64(offset);
  if (mode2 === IntMode.MIXED && value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  return value;
}
function getUint64(view, offset, mode2) {
  if (mode2 === IntMode.UNSAFE_NUMBER || mode2 === IntMode.SAFE_NUMBER) {
    var high = view.getUint32(offset);
    var low = view.getUint32(offset + 4);
    if (mode2 === IntMode.SAFE_NUMBER && high > (Number.MAX_SAFE_INTEGER - low) / 4294967296) {
      var hexValue = "0x".concat(high.toString(16)).concat(low.toString(16).padStart(8, "0"));
      throw new Error("Mode is IntMode.SAFE_NUMBER and value is not a safe integer: ".concat(hexValue));
    }
    return high * 4294967296 + low;
  }
  var value = view.getBigUint64(offset);
  if (mode2 === IntMode.MIXED && value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  return value;
}
function convertSafeIntegerToMode(value, mode2) {
  if (mode2 === IntMode.BIGINT) {
    return BigInt(value);
  }
  return Number(value);
}
var EXT_TIMESTAMP = -1;
var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
function encodeTimeSpecToTimestamp(_a) {
  var sec = _a.sec, nsec = _a.nsec;
  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
      var rv = new Uint8Array(4);
      var view = new DataView(rv.buffer);
      view.setUint32(0, sec);
      return rv;
    } else {
      var secHigh = sec / 4294967296;
      var secLow = sec & 4294967295;
      var rv = new Uint8Array(8);
      var view = new DataView(rv.buffer);
      view.setUint32(0, nsec << 2 | secHigh & 3);
      view.setUint32(4, secLow);
      return rv;
    }
  } else {
    var rv = new Uint8Array(12);
    var view = new DataView(rv.buffer);
    view.setUint32(0, nsec);
    setInt64(view, 4, sec);
    return rv;
  }
}
function encodeDateToTimeSpec(date2) {
  var msec = date2.getTime();
  var sec = Math.floor(msec / 1e3);
  var nsec = (msec - sec * 1e3) * 1e6;
  var nsecInSec = Math.floor(nsec / 1e9);
  return {
    sec: sec + nsecInSec,
    nsec: nsec - nsecInSec * 1e9
  };
}
function encodeTimestampExtension(object2) {
  if (object2 instanceof Date) {
    var timeSpec = encodeDateToTimeSpec(object2);
    return encodeTimeSpecToTimestamp(timeSpec);
  } else {
    return null;
  }
}
function decodeTimestampToTimeSpec(data) {
  var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  switch (data.byteLength) {
    case 4: {
      var sec = view.getUint32(0);
      var nsec = 0;
      return { sec, nsec };
    }
    case 8: {
      var nsec30AndSecHigh2 = view.getUint32(0);
      var secLow32 = view.getUint32(4);
      var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
      var nsec = nsec30AndSecHigh2 >>> 2;
      return { sec, nsec };
    }
    case 12: {
      var sec = getInt64(view, 4, IntMode.UNSAFE_NUMBER);
      var nsec = view.getUint32(0);
      return { sec, nsec };
    }
    default:
      throw new DecodeError("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(data.length));
  }
}
function decodeTimestampExtension(data) {
  var timeSpec = decodeTimestampToTimeSpec(data);
  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
var timestampExtension = {
  type: EXT_TIMESTAMP,
  encode: encodeTimestampExtension,
  decode: decodeTimestampExtension
};
var ExtensionCodec = (
  /** @class */
  (function() {
    function ExtensionCodec2() {
      this.builtInEncoders = [];
      this.builtInDecoders = [];
      this.encoders = [];
      this.decoders = [];
      this.register(timestampExtension);
    }
    ExtensionCodec2.prototype.register = function(_a) {
      var type = _a.type, encode2 = _a.encode, decode2 = _a.decode;
      if (type >= 0) {
        this.encoders[type] = encode2;
        this.decoders[type] = decode2;
      } else {
        var index = 1 + type;
        this.builtInEncoders[index] = encode2;
        this.builtInDecoders[index] = decode2;
      }
    };
    ExtensionCodec2.prototype.tryToEncode = function(object2, context) {
      for (var i2 = 0; i2 < this.builtInEncoders.length; i2++) {
        var encodeExt = this.builtInEncoders[i2];
        if (encodeExt != null) {
          var data = encodeExt(object2, context);
          if (data != null) {
            var type = -1 - i2;
            return new ExtData(type, data);
          }
        }
      }
      for (var i2 = 0; i2 < this.encoders.length; i2++) {
        var encodeExt = this.encoders[i2];
        if (encodeExt != null) {
          var data = encodeExt(object2, context);
          if (data != null) {
            var type = i2;
            return new ExtData(type, data);
          }
        }
      }
      if (object2 instanceof ExtData) {
        return object2;
      }
      return null;
    };
    ExtensionCodec2.prototype.decode = function(data, type, context) {
      var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
      if (decodeExt) {
        return decodeExt(data, type, context);
      } else {
        return new ExtData(type, data);
      }
    };
    ExtensionCodec2.defaultCodec = new ExtensionCodec2();
    return ExtensionCodec2;
  })()
);
function ensureUint8Array$1(buffer2) {
  if (buffer2 instanceof Uint8Array) {
    return buffer2;
  } else if (ArrayBuffer.isView(buffer2)) {
    return new Uint8Array(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
  } else if (buffer2 instanceof ArrayBuffer) {
    return new Uint8Array(buffer2);
  } else {
    return Uint8Array.from(buffer2);
  }
}
function createDataView(buffer2) {
  if (buffer2 instanceof ArrayBuffer) {
    return new DataView(buffer2);
  }
  var bufferView = ensureUint8Array$1(buffer2);
  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
}
function compareUint8Arrays(a2, b2) {
  var length = Math.min(a2.length, b2.length);
  for (var i2 = 0; i2 < length; i2++) {
    var diff = a2[i2] - b2[i2];
    if (diff !== 0) {
      return diff;
    }
  }
  return a2.length - b2.length;
}
var RawBinaryString = (
  /** @class */
  /* @__PURE__ */ (function() {
    function RawBinaryString2(rawBinaryValue) {
      this.rawBinaryValue = rawBinaryValue;
      if (!ArrayBuffer.isView(rawBinaryValue)) {
        throw new TypeError("RawBinaryString: rawBinaryValue must be an ArrayBufferView");
      }
    }
    return RawBinaryString2;
  })()
);
var DEFAULT_MAX_DEPTH = 100;
var DEFAULT_INITIAL_BUFFER_SIZE = 2048;
var Encoder = (
  /** @class */
  (function() {
    function Encoder2(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : ExtensionCodec.defaultCodec;
      this.context = options === null || options === void 0 ? void 0 : options.context;
      this.forceBigIntToInt64 = (_b = options === null || options === void 0 ? void 0 : options.forceBigIntToInt64) !== null && _b !== void 0 ? _b : false;
      this.maxDepth = (_c = options === null || options === void 0 ? void 0 : options.maxDepth) !== null && _c !== void 0 ? _c : DEFAULT_MAX_DEPTH;
      this.initialBufferSize = (_d = options === null || options === void 0 ? void 0 : options.initialBufferSize) !== null && _d !== void 0 ? _d : DEFAULT_INITIAL_BUFFER_SIZE;
      this.sortKeys = (_e = options === null || options === void 0 ? void 0 : options.sortKeys) !== null && _e !== void 0 ? _e : false;
      this.forceFloat32 = (_f = options === null || options === void 0 ? void 0 : options.forceFloat32) !== null && _f !== void 0 ? _f : false;
      this.ignoreUndefined = (_g = options === null || options === void 0 ? void 0 : options.ignoreUndefined) !== null && _g !== void 0 ? _g : false;
      this.forceIntegerToFloat = (_h = options === null || options === void 0 ? void 0 : options.forceIntegerToFloat) !== null && _h !== void 0 ? _h : false;
      this.pos = 0;
      this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
      this.bytes = new Uint8Array(this.view.buffer);
    }
    Encoder2.prototype.reinitializeState = function() {
      this.pos = 0;
    };
    Encoder2.prototype.encodeSharedRef = function(object2) {
      this.reinitializeState();
      this.doEncode(object2, 1);
      return this.bytes.subarray(0, this.pos);
    };
    Encoder2.prototype.encode = function(object2) {
      this.reinitializeState();
      this.doEncode(object2, 1);
      return this.bytes.slice(0, this.pos);
    };
    Encoder2.prototype.doEncode = function(object2, depth) {
      if (depth > this.maxDepth) {
        throw new Error("Too deep objects in depth ".concat(depth));
      }
      if (object2 == null) {
        this.encodeNil();
      } else if (typeof object2 === "boolean") {
        this.encodeBoolean(object2);
      } else if (typeof object2 === "number") {
        this.encodeNumber(object2);
      } else if (typeof object2 === "string") {
        this.encodeString(object2);
      } else {
        this.encodeObject(object2, depth);
      }
    };
    Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {
      var requiredSize = this.pos + sizeToWrite;
      if (this.view.byteLength < requiredSize) {
        this.resizeBuffer(requiredSize * 2);
      }
    };
    Encoder2.prototype.resizeBuffer = function(newSize) {
      var newBuffer = new ArrayBuffer(newSize);
      var newBytes = new Uint8Array(newBuffer);
      var newView = new DataView(newBuffer);
      newBytes.set(this.bytes);
      this.view = newView;
      this.bytes = newBytes;
    };
    Encoder2.prototype.encodeNil = function() {
      this.writeU8(192);
    };
    Encoder2.prototype.encodeBoolean = function(object2) {
      if (object2 === false) {
        this.writeU8(194);
      } else {
        this.writeU8(195);
      }
    };
    Encoder2.prototype.encodeNumber = function(object2) {
      if (!this.forceIntegerToFloat && Number.isSafeInteger(object2)) {
        if (object2 >= 0) {
          if (object2 < 128) {
            this.writeU8(object2);
          } else if (object2 < 256) {
            this.writeU8(204);
            this.writeU8(object2);
          } else if (object2 < 65536) {
            this.writeU8(205);
            this.writeU16(object2);
          } else if (object2 < 4294967296) {
            this.writeU8(206);
            this.writeU32(object2);
          } else {
            this.writeU8(207);
            this.writeU64(object2);
          }
        } else {
          if (object2 >= -32) {
            this.writeU8(224 | object2 + 32);
          } else if (object2 >= -128) {
            this.writeU8(208);
            this.writeI8(object2);
          } else if (object2 >= -32768) {
            this.writeU8(209);
            this.writeI16(object2);
          } else if (object2 >= -2147483648) {
            this.writeU8(210);
            this.writeI32(object2);
          } else {
            this.writeU8(211);
            this.writeI64(object2);
          }
        }
      } else {
        this.encodeNumberAsFloat(object2);
      }
    };
    Encoder2.prototype.encodeNumberAsFloat = function(object2) {
      if (this.forceFloat32) {
        this.writeU8(202);
        this.writeF32(object2);
      } else {
        this.writeU8(203);
        this.writeF64(object2);
      }
    };
    Encoder2.prototype.encodeBigInt = function(object2) {
      if (this.forceBigIntToInt64) {
        this.encodeBigIntAsInt64(object2);
      } else if (object2 >= 0) {
        if (object2 < 4294967296 || this.forceIntegerToFloat) {
          this.encodeNumber(Number(object2));
        } else if (object2 < BigInt("0x10000000000000000")) {
          this.encodeBigIntAsInt64(object2);
        } else {
          throw new Error("Bigint is too large for uint64: ".concat(object2));
        }
      } else {
        if (object2 >= -2147483648 || this.forceIntegerToFloat) {
          this.encodeNumber(Number(object2));
        } else if (object2 >= BigInt(-1) * BigInt("0x8000000000000000")) {
          this.encodeBigIntAsInt64(object2);
        } else {
          throw new Error("Bigint is too small for int64: ".concat(object2));
        }
      }
    };
    Encoder2.prototype.encodeBigIntAsInt64 = function(object2) {
      if (object2 >= BigInt(0)) {
        this.writeU8(207);
        this.writeBigUint64(object2);
      } else {
        this.writeU8(211);
        this.writeBigInt64(object2);
      }
    };
    Encoder2.prototype.writeStringHeader = function(byteLength) {
      if (byteLength < 32) {
        this.writeU8(160 + byteLength);
      } else if (byteLength < 256) {
        this.writeU8(217);
        this.writeU8(byteLength);
      } else if (byteLength < 65536) {
        this.writeU8(218);
        this.writeU16(byteLength);
      } else if (byteLength < 4294967296) {
        this.writeU8(219);
        this.writeU32(byteLength);
      } else {
        throw new Error("Too long string: ".concat(byteLength, " bytes in UTF-8"));
      }
    };
    Encoder2.prototype.encodeString = function(object2) {
      var maxHeaderSize = 1 + 4;
      var byteLength = utf8Count(object2);
      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
      this.writeStringHeader(byteLength);
      utf8Encode(object2, this.bytes, this.pos);
      this.pos += byteLength;
    };
    Encoder2.prototype.encodeObject = function(object2, depth) {
      var ext = this.extensionCodec.tryToEncode(object2, this.context);
      if (ext != null) {
        this.encodeExtension(ext);
      } else if (Array.isArray(object2)) {
        this.encodeArray(object2, depth);
      } else if (ArrayBuffer.isView(object2)) {
        this.encodeBinary(object2);
      } else if (object2 instanceof RawBinaryString) {
        this.encodeBinaryAsString(object2);
      } else if (typeof object2 === "bigint") {
        this.encodeBigInt(object2);
      } else if (object2 instanceof Map) {
        this.encodeMap(object2, depth);
      } else if (typeof object2 === "object") {
        this.encodeMapObject(object2, depth);
      } else {
        throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(object2)));
      }
    };
    Encoder2.prototype.encodeBinary = function(object2) {
      var size = object2.byteLength;
      if (size < 256) {
        this.writeU8(196);
        this.writeU8(size);
      } else if (size < 65536) {
        this.writeU8(197);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(198);
        this.writeU32(size);
      } else {
        throw new Error("Too large binary: ".concat(size));
      }
      var bytes = ensureUint8Array$1(object2);
      this.writeU8a(bytes);
    };
    Encoder2.prototype.encodeBinaryAsString = function(binaryString) {
      var object2 = binaryString.rawBinaryValue;
      this.writeStringHeader(object2.byteLength);
      var bytes = ensureUint8Array$1(object2);
      this.writeU8a(bytes);
    };
    Encoder2.prototype.encodeArray = function(object2, depth) {
      var size = object2.length;
      if (size < 16) {
        this.writeU8(144 + size);
      } else if (size < 65536) {
        this.writeU8(220);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(221);
        this.writeU32(size);
      } else {
        throw new Error("Too large array: ".concat(size));
      }
      for (var _i = 0, object_1 = object2; _i < object_1.length; _i++) {
        var item = object_1[_i];
        this.doEncode(item, depth + 1);
      }
    };
    Encoder2.prototype.countWithoutUndefined = function(map2, keys) {
      var count = 0;
      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        if (map2.get(key) !== void 0) {
          count++;
        }
      }
      return count;
    };
    Encoder2.prototype.sortMapKeys = function(keys) {
      var numericKeys = [];
      var stringKeys = [];
      var rawStringKeys = [];
      var binaryKeys = [];
      for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
        var key = keys_2[_i];
        if (typeof key === "number") {
          if (isNaN(key)) {
            throw new Error("Cannot sort map keys with NaN value");
          }
          numericKeys.push(key);
        } else if (typeof key === "bigint") {
          numericKeys.push(key);
        } else if (typeof key === "string") {
          stringKeys.push(key);
        } else if (ArrayBuffer.isView(key)) {
          binaryKeys.push(ensureUint8Array$1(key));
        } else if (key instanceof RawBinaryString) {
          rawStringKeys.push(key);
        } else {
          throw new Error("Unsupported map key type: ".concat(Object.prototype.toString.apply(key)));
        }
      }
      numericKeys.sort(function(a2, b2) {
        return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
      });
      stringKeys.sort();
      rawStringKeys.sort(function(a2, b2) {
        return compareUint8Arrays(ensureUint8Array$1(a2.rawBinaryValue), ensureUint8Array$1(b2.rawBinaryValue));
      });
      binaryKeys.sort(compareUint8Arrays);
      return [].concat(numericKeys, stringKeys, rawStringKeys, binaryKeys);
    };
    Encoder2.prototype.encodeMapObject = function(object2, depth) {
      this.encodeMap(new Map(Object.entries(object2)), depth);
    };
    Encoder2.prototype.encodeMap = function(map2, depth) {
      var keys = Array.from(map2.keys());
      if (this.sortKeys) {
        keys = this.sortMapKeys(keys);
      }
      var size = this.ignoreUndefined ? this.countWithoutUndefined(map2, keys) : keys.length;
      if (size < 16) {
        this.writeU8(128 + size);
      } else if (size < 65536) {
        this.writeU8(222);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(223);
        this.writeU32(size);
      } else {
        throw new Error("Too large map object: ".concat(size));
      }
      for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {
        var key = keys_3[_i];
        var value = map2.get(key);
        if (!(this.ignoreUndefined && value === void 0)) {
          if (typeof key === "string") {
            this.encodeString(key);
          } else if (typeof key === "number") {
            this.encodeNumber(key);
          } else if (typeof key === "bigint") {
            this.encodeBigInt(key);
          } else if (ArrayBuffer.isView(key)) {
            this.encodeBinary(key);
          } else if (key instanceof RawBinaryString) {
            this.encodeBinaryAsString(key);
          } else {
            throw new Error("Unsupported map key type: ".concat(Object.prototype.toString.apply(key)));
          }
          this.doEncode(value, depth + 1);
        }
      }
    };
    Encoder2.prototype.encodeExtension = function(ext) {
      var size = ext.data.length;
      if (size === 1) {
        this.writeU8(212);
      } else if (size === 2) {
        this.writeU8(213);
      } else if (size === 4) {
        this.writeU8(214);
      } else if (size === 8) {
        this.writeU8(215);
      } else if (size === 16) {
        this.writeU8(216);
      } else if (size < 256) {
        this.writeU8(199);
        this.writeU8(size);
      } else if (size < 65536) {
        this.writeU8(200);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(201);
        this.writeU32(size);
      } else {
        throw new Error("Too large extension object: ".concat(size));
      }
      this.writeI8(ext.type);
      this.writeU8a(ext.data);
    };
    Encoder2.prototype.writeU8 = function(value) {
      this.ensureBufferSizeToWrite(1);
      this.view.setUint8(this.pos, value);
      this.pos++;
    };
    Encoder2.prototype.writeU8a = function(values) {
      var size = values.length;
      this.ensureBufferSizeToWrite(size);
      this.bytes.set(values, this.pos);
      this.pos += size;
    };
    Encoder2.prototype.writeI8 = function(value) {
      this.ensureBufferSizeToWrite(1);
      this.view.setInt8(this.pos, value);
      this.pos++;
    };
    Encoder2.prototype.writeU16 = function(value) {
      this.ensureBufferSizeToWrite(2);
      this.view.setUint16(this.pos, value);
      this.pos += 2;
    };
    Encoder2.prototype.writeI16 = function(value) {
      this.ensureBufferSizeToWrite(2);
      this.view.setInt16(this.pos, value);
      this.pos += 2;
    };
    Encoder2.prototype.writeU32 = function(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setUint32(this.pos, value);
      this.pos += 4;
    };
    Encoder2.prototype.writeI32 = function(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setInt32(this.pos, value);
      this.pos += 4;
    };
    Encoder2.prototype.writeF32 = function(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setFloat32(this.pos, value);
      this.pos += 4;
    };
    Encoder2.prototype.writeF64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      this.view.setFloat64(this.pos, value);
      this.pos += 8;
    };
    Encoder2.prototype.writeU64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      setUint64(this.view, this.pos, value);
      this.pos += 8;
    };
    Encoder2.prototype.writeI64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      setInt64(this.view, this.pos, value);
      this.pos += 8;
    };
    Encoder2.prototype.writeBigUint64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      this.view.setBigUint64(this.pos, value);
      this.pos += 8;
    };
    Encoder2.prototype.writeBigInt64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      this.view.setBigInt64(this.pos, value);
      this.pos += 8;
    };
    return Encoder2;
  })()
);
function encode(value, options) {
  var encoder = new Encoder(options);
  return encoder.encodeSharedRef(value);
}
function prettyByte(byte) {
  return "".concat(byte < 0 ? "-" : "", "0x").concat(Math.abs(byte).toString(16).padStart(2, "0"));
}
var DEFAULT_MAX_KEY_LENGTH = 16;
var DEFAULT_MAX_LENGTH_PER_KEY = 16;
var CachedKeyDecoder = (
  /** @class */
  (function() {
    function CachedKeyDecoder2(maxKeyLength, maxLengthPerKey) {
      if (maxKeyLength === void 0) {
        maxKeyLength = DEFAULT_MAX_KEY_LENGTH;
      }
      if (maxLengthPerKey === void 0) {
        maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;
      }
      this.maxKeyLength = maxKeyLength;
      this.maxLengthPerKey = maxLengthPerKey;
      this.hit = 0;
      this.miss = 0;
      this.caches = [];
      for (var i2 = 0; i2 < this.maxKeyLength; i2++) {
        this.caches.push([]);
      }
    }
    CachedKeyDecoder2.prototype.canBeCached = function(byteLength) {
      return byteLength > 0 && byteLength <= this.maxKeyLength;
    };
    CachedKeyDecoder2.prototype.find = function(bytes, inputOffset, byteLength) {
      var records = this.caches[byteLength - 1];
      FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {
        var record = records_1[_i];
        var recordBytes = record.bytes;
        for (var j2 = 0; j2 < byteLength; j2++) {
          if (recordBytes[j2] !== bytes[inputOffset + j2]) {
            continue FIND_CHUNK;
          }
        }
        return record.str;
      }
      return null;
    };
    CachedKeyDecoder2.prototype.store = function(bytes, value) {
      var records = this.caches[bytes.length - 1];
      var record = { bytes, str: value };
      if (records.length >= this.maxLengthPerKey) {
        records[Math.random() * records.length | 0] = record;
      } else {
        records.push(record);
      }
    };
    CachedKeyDecoder2.prototype.decode = function(bytes, inputOffset, byteLength) {
      var cachedValue = this.find(bytes, inputOffset, byteLength);
      if (cachedValue != null) {
        this.hit++;
        return cachedValue;
      }
      this.miss++;
      var str = utf8DecodeJs(bytes, inputOffset, byteLength);
      var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
      this.store(slicedCopyOfBytes, str);
      return str;
    };
    return CachedKeyDecoder2;
  })()
);
var __awaiter = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e3) {
      op = [6, e3];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __asyncValues = function(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
};
var __await = function(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
};
var __asyncGenerator = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2]) i2[n2] = function(v2) {
      return new Promise(function(a2, b2) {
        q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
      });
    };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e3) {
      settle(q2[0][3], e3);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
  }
};
var STATE_ARRAY = "array";
var STATE_MAP_KEY = "map_key";
var STATE_MAP_VALUE = "map_value";
function isValidMapKeyType(key, useMap, supportObjectNumberKeys) {
  if (useMap) {
    return typeof key === "string" || typeof key === "number" || typeof key === "bigint" || key instanceof Uint8Array || key instanceof RawBinaryString;
  }
  return typeof key === "string" || supportObjectNumberKeys && typeof key === "number";
}
var StackPool = (
  /** @class */
  (function() {
    function StackPool2(useMap) {
      this.useMap = useMap;
      this.stack = [];
      this.stackHeadPosition = -1;
    }
    Object.defineProperty(StackPool2.prototype, "length", {
      get: function() {
        return this.stackHeadPosition + 1;
      },
      enumerable: false,
      configurable: true
    });
    StackPool2.prototype.top = function() {
      return this.stack[this.stackHeadPosition];
    };
    StackPool2.prototype.pushArrayState = function(size) {
      var state = this.getUninitializedStateFromPool();
      state.type = STATE_ARRAY;
      state.position = 0;
      state.size = size;
      state.array = new Array(size);
    };
    StackPool2.prototype.pushMapState = function(size) {
      var state = this.getUninitializedStateFromPool();
      state.type = STATE_MAP_KEY;
      state.readCount = 0;
      state.size = size;
      state.map = this.useMap ? /* @__PURE__ */ new Map() : {};
    };
    StackPool2.prototype.getUninitializedStateFromPool = function() {
      this.stackHeadPosition++;
      if (this.stackHeadPosition === this.stack.length) {
        var partialState = {
          type: void 0,
          size: 0,
          array: void 0,
          position: 0,
          readCount: 0,
          map: void 0,
          key: null
        };
        this.stack.push(partialState);
      }
      return this.stack[this.stackHeadPosition];
    };
    StackPool2.prototype.release = function(state) {
      var topStackState = this.stack[this.stackHeadPosition];
      if (topStackState !== state) {
        throw new Error("Invalid stack state. Released state is not on top of the stack.");
      }
      if (state.type === STATE_ARRAY) {
        var partialState = state;
        partialState.size = 0;
        partialState.array = void 0;
        partialState.position = 0;
        partialState.type = void 0;
      }
      if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {
        var partialState = state;
        partialState.size = 0;
        partialState.map = void 0;
        partialState.readCount = 0;
        partialState.type = void 0;
      }
      this.stackHeadPosition--;
    };
    StackPool2.prototype.reset = function() {
      this.stack.length = 0;
      this.stackHeadPosition = -1;
    };
    return StackPool2;
  })()
);
var HEAD_BYTE_REQUIRED = -1;
var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
try {
  EMPTY_VIEW.getInt8(0);
} catch (e3) {
  if (!(e3 instanceof RangeError)) {
    throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
  }
}
var DataViewIndexOutOfBoundsError = RangeError;
var MORE_DATA = new DataViewIndexOutOfBoundsError("Insufficient data");
var sharedCachedKeyDecoder = new CachedKeyDecoder();
var Decoder = (
  /** @class */
  (function() {
    function Decoder2(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      this.totalPos = 0;
      this.pos = 0;
      this.view = EMPTY_VIEW;
      this.bytes = EMPTY_BYTES;
      this.headByte = HEAD_BYTE_REQUIRED;
      this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : ExtensionCodec.defaultCodec;
      this.context = options === null || options === void 0 ? void 0 : options.context;
      this.intMode = (_b = options === null || options === void 0 ? void 0 : options.intMode) !== null && _b !== void 0 ? _b : (options === null || options === void 0 ? void 0 : options.useBigInt64) ? IntMode.AS_ENCODED : IntMode.UNSAFE_NUMBER;
      this.rawBinaryStringValues = (_c = options === null || options === void 0 ? void 0 : options.rawBinaryStringValues) !== null && _c !== void 0 ? _c : false;
      this.rawBinaryStringKeys = (_d = options === null || options === void 0 ? void 0 : options.rawBinaryStringKeys) !== null && _d !== void 0 ? _d : false;
      this.useRawBinaryStringClass = (_e = options === null || options === void 0 ? void 0 : options.useRawBinaryStringClass) !== null && _e !== void 0 ? _e : false;
      this.useMap = (_f = options === null || options === void 0 ? void 0 : options.useMap) !== null && _f !== void 0 ? _f : false;
      this.supportObjectNumberKeys = (_g = options === null || options === void 0 ? void 0 : options.supportObjectNumberKeys) !== null && _g !== void 0 ? _g : false;
      this.maxStrLength = (_h = options === null || options === void 0 ? void 0 : options.maxStrLength) !== null && _h !== void 0 ? _h : UINT32_MAX;
      this.maxBinLength = (_j = options === null || options === void 0 ? void 0 : options.maxBinLength) !== null && _j !== void 0 ? _j : UINT32_MAX;
      this.maxArrayLength = (_k = options === null || options === void 0 ? void 0 : options.maxArrayLength) !== null && _k !== void 0 ? _k : UINT32_MAX;
      this.maxMapLength = (_l = options === null || options === void 0 ? void 0 : options.maxMapLength) !== null && _l !== void 0 ? _l : UINT32_MAX;
      this.maxExtLength = (_m = options === null || options === void 0 ? void 0 : options.maxExtLength) !== null && _m !== void 0 ? _m : UINT32_MAX;
      this.keyDecoder = (options === null || options === void 0 ? void 0 : options.keyDecoder) !== void 0 ? options.keyDecoder : sharedCachedKeyDecoder;
      if (this.rawBinaryStringKeys && !this.useMap) {
        throw new Error("rawBinaryStringKeys is only supported when useMap is true");
      }
      this.stack = new StackPool(this.useMap);
    }
    Decoder2.prototype.reinitializeState = function() {
      this.totalPos = 0;
      this.headByte = HEAD_BYTE_REQUIRED;
      this.stack.reset();
    };
    Decoder2.prototype.setBuffer = function(buffer2) {
      this.bytes = ensureUint8Array$1(buffer2);
      this.view = createDataView(this.bytes);
      this.pos = 0;
    };
    Decoder2.prototype.appendBuffer = function(buffer2) {
      if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
        this.setBuffer(buffer2);
      } else {
        var remainingData = this.bytes.subarray(this.pos);
        var newData = ensureUint8Array$1(buffer2);
        var newBuffer = new Uint8Array(remainingData.length + newData.length);
        newBuffer.set(remainingData);
        newBuffer.set(newData, remainingData.length);
        this.setBuffer(newBuffer);
      }
    };
    Decoder2.prototype.hasRemaining = function(size) {
      return this.view.byteLength - this.pos >= size;
    };
    Decoder2.prototype.createExtraByteError = function(posToShow) {
      var _a = this, view = _a.view, pos = _a.pos;
      return new RangeError("Extra ".concat(view.byteLength - pos, " of ").concat(view.byteLength, " byte(s) found at buffer[").concat(posToShow, "]"));
    };
    Decoder2.prototype.decode = function(buffer2) {
      this.reinitializeState();
      this.setBuffer(buffer2);
      var object2 = this.doDecodeSync();
      if (this.hasRemaining(1)) {
        throw this.createExtraByteError(this.pos);
      }
      return object2;
    };
    Decoder2.prototype.decodeMulti = function(buffer2) {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            this.reinitializeState();
            this.setBuffer(buffer2);
            _a.label = 1;
          case 1:
            if (!this.hasRemaining(1)) return [3, 3];
            return [4, this.doDecodeSync()];
          case 2:
            _a.sent();
            return [3, 1];
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    };
    Decoder2.prototype.decodeAsync = function(stream) {
      var _a, stream_1, stream_1_1;
      var _b, e_1, _c, _d;
      return __awaiter(this, void 0, void 0, function() {
        var decoded, object2, buffer2, e_1_1, _e, headByte, pos, totalPos;
        return __generator(this, function(_f) {
          switch (_f.label) {
            case 0:
              decoded = false;
              _f.label = 1;
            case 1:
              _f.trys.push([1, 6, 7, 12]);
              _a = true, stream_1 = __asyncValues(stream);
              _f.label = 2;
            case 2:
              return [4, stream_1.next()];
            case 3:
              if (!(stream_1_1 = _f.sent(), _b = stream_1_1.done, !_b)) return [3, 5];
              _d = stream_1_1.value;
              _a = false;
              buffer2 = _d;
              if (decoded) {
                throw this.createExtraByteError(this.totalPos);
              }
              this.appendBuffer(buffer2);
              try {
                object2 = this.doDecodeSync();
                decoded = true;
              } catch (e3) {
                if (!(e3 instanceof DataViewIndexOutOfBoundsError)) {
                  throw e3;
                }
              }
              this.totalPos += this.pos;
              _f.label = 4;
            case 4:
              _a = true;
              return [3, 2];
            case 5:
              return [3, 12];
            case 6:
              e_1_1 = _f.sent();
              e_1 = { error: e_1_1 };
              return [3, 12];
            case 7:
              _f.trys.push([7, , 10, 11]);
              if (!(!_a && !_b && (_c = stream_1.return))) return [3, 9];
              return [4, _c.call(stream_1)];
            case 8:
              _f.sent();
              _f.label = 9;
            case 9:
              return [3, 11];
            case 10:
              if (e_1) throw e_1.error;
              return [
                7
                /*endfinally*/
              ];
            case 11:
              return [
                7
                /*endfinally*/
              ];
            case 12:
              if (decoded) {
                if (this.hasRemaining(1)) {
                  throw this.createExtraByteError(this.totalPos);
                }
                return [2, object2];
              }
              _e = this, headByte = _e.headByte, pos = _e.pos, totalPos = _e.totalPos;
              throw new RangeError("Insufficient data in parsing ".concat(prettyByte(headByte), " at ").concat(totalPos, " (").concat(pos, " in the current buffer)"));
          }
        });
      });
    };
    Decoder2.prototype.decodeArrayStream = function(stream) {
      return this.decodeMultiAsync(stream, true);
    };
    Decoder2.prototype.decodeStream = function(stream) {
      return this.decodeMultiAsync(stream, false);
    };
    Decoder2.prototype.decodeMultiAsync = function(stream, isArray) {
      return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {
        var isArrayHeaderRequired, arrayItemsLeft, _a, stream_2, stream_2_1, buffer2, e_2, e_3_1;
        var _b, e_3, _c, _d;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              isArrayHeaderRequired = isArray;
              arrayItemsLeft = -1;
              _e.label = 1;
            case 1:
              _e.trys.push([1, 13, 14, 19]);
              _a = true, stream_2 = __asyncValues(stream);
              _e.label = 2;
            case 2:
              return [4, __await(stream_2.next())];
            case 3:
              if (!(stream_2_1 = _e.sent(), _b = stream_2_1.done, !_b)) return [3, 12];
              _d = stream_2_1.value;
              _a = false;
              buffer2 = _d;
              if (isArray && arrayItemsLeft === 0) {
                throw this.createExtraByteError(this.totalPos);
              }
              this.appendBuffer(buffer2);
              if (isArrayHeaderRequired) {
                arrayItemsLeft = this.readArraySize();
                isArrayHeaderRequired = false;
                this.complete();
              }
              _e.label = 4;
            case 4:
              _e.trys.push([4, 9, , 10]);
              _e.label = 5;
            case 5:
              return [4, __await(this.doDecodeSync())];
            case 6:
              return [4, _e.sent()];
            case 7:
              _e.sent();
              if (--arrayItemsLeft === 0) {
                return [3, 8];
              }
              return [3, 5];
            case 8:
              return [3, 10];
            case 9:
              e_2 = _e.sent();
              if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {
                throw e_2;
              }
              return [3, 10];
            case 10:
              this.totalPos += this.pos;
              _e.label = 11;
            case 11:
              _a = true;
              return [3, 2];
            case 12:
              return [3, 19];
            case 13:
              e_3_1 = _e.sent();
              e_3 = { error: e_3_1 };
              return [3, 19];
            case 14:
              _e.trys.push([14, , 17, 18]);
              if (!(!_a && !_b && (_c = stream_2.return))) return [3, 16];
              return [4, __await(_c.call(stream_2))];
            case 15:
              _e.sent();
              _e.label = 16;
            case 16:
              return [3, 18];
            case 17:
              if (e_3) throw e_3.error;
              return [
                7
                /*endfinally*/
              ];
            case 18:
              return [
                7
                /*endfinally*/
              ];
            case 19:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Decoder2.prototype.doDecodeSync = function() {
      DECODE: while (true) {
        var headByte = this.readHeadByte();
        var object2 = void 0;
        if (headByte >= 224) {
          object2 = this.convertNumber(headByte - 256);
        } else if (headByte < 192) {
          if (headByte < 128) {
            object2 = this.convertNumber(headByte);
          } else if (headByte < 144) {
            var size = headByte - 128;
            if (size !== 0) {
              this.pushMapState(size);
              this.complete();
              continue DECODE;
            } else {
              object2 = this.useMap ? /* @__PURE__ */ new Map() : {};
            }
          } else if (headByte < 160) {
            var size = headByte - 144;
            if (size !== 0) {
              this.pushArrayState(size);
              this.complete();
              continue DECODE;
            } else {
              object2 = [];
            }
          } else {
            var byteLength = headByte - 160;
            object2 = this.decodeString(byteLength, 0);
          }
        } else if (headByte === 192) {
          object2 = null;
        } else if (headByte === 194) {
          object2 = false;
        } else if (headByte === 195) {
          object2 = true;
        } else if (headByte === 202) {
          object2 = this.readF32();
        } else if (headByte === 203) {
          object2 = this.readF64();
        } else if (headByte === 204) {
          object2 = this.convertNumber(this.readU8());
        } else if (headByte === 205) {
          object2 = this.convertNumber(this.readU16());
        } else if (headByte === 206) {
          object2 = this.convertNumber(this.readU32());
        } else if (headByte === 207) {
          object2 = this.readU64();
        } else if (headByte === 208) {
          object2 = this.convertNumber(this.readI8());
        } else if (headByte === 209) {
          object2 = this.convertNumber(this.readI16());
        } else if (headByte === 210) {
          object2 = this.convertNumber(this.readI32());
        } else if (headByte === 211) {
          object2 = this.readI64();
        } else if (headByte === 217) {
          var byteLength = this.lookU8();
          object2 = this.decodeString(byteLength, 1);
        } else if (headByte === 218) {
          var byteLength = this.lookU16();
          object2 = this.decodeString(byteLength, 2);
        } else if (headByte === 219) {
          var byteLength = this.lookU32();
          object2 = this.decodeString(byteLength, 4);
        } else if (headByte === 220) {
          var size = this.readU16();
          if (size !== 0) {
            this.pushArrayState(size);
            this.complete();
            continue DECODE;
          } else {
            object2 = [];
          }
        } else if (headByte === 221) {
          var size = this.readU32();
          if (size !== 0) {
            this.pushArrayState(size);
            this.complete();
            continue DECODE;
          } else {
            object2 = [];
          }
        } else if (headByte === 222) {
          var size = this.readU16();
          if (size !== 0) {
            this.pushMapState(size);
            this.complete();
            continue DECODE;
          } else {
            object2 = {};
          }
        } else if (headByte === 223) {
          var size = this.readU32();
          if (size !== 0) {
            this.pushMapState(size);
            this.complete();
            continue DECODE;
          } else {
            object2 = {};
          }
        } else if (headByte === 196) {
          var size = this.lookU8();
          object2 = this.decodeBinary(size, 1);
        } else if (headByte === 197) {
          var size = this.lookU16();
          object2 = this.decodeBinary(size, 2);
        } else if (headByte === 198) {
          var size = this.lookU32();
          object2 = this.decodeBinary(size, 4);
        } else if (headByte === 212) {
          object2 = this.decodeExtension(1, 0);
        } else if (headByte === 213) {
          object2 = this.decodeExtension(2, 0);
        } else if (headByte === 214) {
          object2 = this.decodeExtension(4, 0);
        } else if (headByte === 215) {
          object2 = this.decodeExtension(8, 0);
        } else if (headByte === 216) {
          object2 = this.decodeExtension(16, 0);
        } else if (headByte === 199) {
          var size = this.lookU8();
          object2 = this.decodeExtension(size, 1);
        } else if (headByte === 200) {
          var size = this.lookU16();
          object2 = this.decodeExtension(size, 2);
        } else if (headByte === 201) {
          var size = this.lookU32();
          object2 = this.decodeExtension(size, 4);
        } else {
          throw new DecodeError("Unrecognized type byte: ".concat(prettyByte(headByte)));
        }
        this.complete();
        var stack = this.stack;
        while (stack.length > 0) {
          var state = stack.top();
          if (state.type === STATE_ARRAY) {
            state.array[state.position] = object2;
            state.position++;
            if (state.position === state.size) {
              object2 = state.array;
              stack.release(state);
            } else {
              continue DECODE;
            }
          } else if (state.type === STATE_MAP_KEY) {
            if (!isValidMapKeyType(object2, this.useMap, this.supportObjectNumberKeys)) {
              var acceptableTypes = this.useMap ? "string, number, bigint, or Uint8Array" : this.supportObjectNumberKeys ? "string or number" : "string";
              throw new DecodeError("The type of key must be ".concat(acceptableTypes, " but got ").concat(typeof object2));
            }
            if (!this.useMap && object2 === "__proto__") {
              throw new DecodeError("The key __proto__ is not allowed");
            }
            state.key = object2;
            state.type = STATE_MAP_VALUE;
            continue DECODE;
          } else {
            if (this.useMap) {
              state.map.set(state.key, object2);
            } else {
              state.map[state.key] = object2;
            }
            state.readCount++;
            if (state.readCount === state.size) {
              object2 = state.map;
              stack.release(state);
            } else {
              state.key = null;
              state.type = STATE_MAP_KEY;
              continue DECODE;
            }
          }
        }
        return object2;
      }
    };
    Decoder2.prototype.readHeadByte = function() {
      if (this.headByte === HEAD_BYTE_REQUIRED) {
        this.headByte = this.readU8();
      }
      return this.headByte;
    };
    Decoder2.prototype.complete = function() {
      this.headByte = HEAD_BYTE_REQUIRED;
    };
    Decoder2.prototype.readArraySize = function() {
      var headByte = this.readHeadByte();
      switch (headByte) {
        case 220:
          return this.readU16();
        case 221:
          return this.readU32();
        default: {
          if (headByte < 160) {
            return headByte - 144;
          } else {
            throw new DecodeError("Unrecognized array type byte: ".concat(prettyByte(headByte)));
          }
        }
      }
    };
    Decoder2.prototype.pushMapState = function(size) {
      if (size > this.maxMapLength) {
        throw new DecodeError("Max length exceeded: map length (".concat(size, ") > maxMapLengthLength (").concat(this.maxMapLength, ")"));
      }
      this.stack.pushMapState(size);
    };
    Decoder2.prototype.pushArrayState = function(size) {
      if (size > this.maxArrayLength) {
        throw new DecodeError("Max length exceeded: array length (".concat(size, ") > maxArrayLength (").concat(this.maxArrayLength, ")"));
      }
      this.stack.pushArrayState(size);
    };
    Decoder2.prototype.decodeString = function(byteLength, headerOffset) {
      if (this.stateIsMapKey() ? this.rawBinaryStringKeys : this.rawBinaryStringValues) {
        var decoded = this.decodeBinary(byteLength, headerOffset);
        if (this.useRawBinaryStringClass) {
          return new RawBinaryString(decoded);
        }
        return decoded;
      }
      return this.decodeUtf8String(byteLength, headerOffset);
    };
    Decoder2.prototype.decodeUtf8String = function(byteLength, headerOffset) {
      var _a;
      if (byteLength > this.maxStrLength) {
        throw new DecodeError("Max length exceeded: UTF-8 byte length (".concat(byteLength, ") > maxStrLength (").concat(this.maxStrLength, ")"));
      }
      if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
        throw MORE_DATA;
      }
      var offset = this.pos + headerOffset;
      var object2;
      if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
        object2 = this.keyDecoder.decode(this.bytes, offset, byteLength);
      } else {
        object2 = utf8Decode(this.bytes, offset, byteLength);
      }
      this.pos += headerOffset + byteLength;
      return object2;
    };
    Decoder2.prototype.stateIsMapKey = function() {
      if (this.stack.length > 0) {
        var state = this.stack.top();
        return state.type === STATE_MAP_KEY;
      }
      return false;
    };
    Decoder2.prototype.decodeBinary = function(byteLength, headOffset) {
      if (byteLength > this.maxBinLength) {
        throw new DecodeError("Max length exceeded: bin length (".concat(byteLength, ") > maxBinLength (").concat(this.maxBinLength, ")"));
      }
      if (!this.hasRemaining(byteLength + headOffset)) {
        throw MORE_DATA;
      }
      var offset = this.pos + headOffset;
      var object2 = this.bytes.subarray(offset, offset + byteLength);
      this.pos += headOffset + byteLength;
      return object2;
    };
    Decoder2.prototype.decodeExtension = function(size, headOffset) {
      if (size > this.maxExtLength) {
        throw new DecodeError("Max length exceeded: ext length (".concat(size, ") > maxExtLength (").concat(this.maxExtLength, ")"));
      }
      var extType = this.view.getInt8(this.pos + headOffset);
      var data = this.decodeBinary(
        size,
        headOffset + 1
        /* extType */
      );
      return this.extensionCodec.decode(data, extType, this.context);
    };
    Decoder2.prototype.convertNumber = function(value) {
      return convertSafeIntegerToMode(value, this.intMode);
    };
    Decoder2.prototype.lookU8 = function() {
      return this.view.getUint8(this.pos);
    };
    Decoder2.prototype.lookU16 = function() {
      return this.view.getUint16(this.pos);
    };
    Decoder2.prototype.lookU32 = function() {
      return this.view.getUint32(this.pos);
    };
    Decoder2.prototype.readU8 = function() {
      var value = this.view.getUint8(this.pos);
      this.pos++;
      return value;
    };
    Decoder2.prototype.readI8 = function() {
      var value = this.view.getInt8(this.pos);
      this.pos++;
      return value;
    };
    Decoder2.prototype.readU16 = function() {
      var value = this.view.getUint16(this.pos);
      this.pos += 2;
      return value;
    };
    Decoder2.prototype.readI16 = function() {
      var value = this.view.getInt16(this.pos);
      this.pos += 2;
      return value;
    };
    Decoder2.prototype.readU32 = function() {
      var value = this.view.getUint32(this.pos);
      this.pos += 4;
      return value;
    };
    Decoder2.prototype.readI32 = function() {
      var value = this.view.getInt32(this.pos);
      this.pos += 4;
      return value;
    };
    Decoder2.prototype.readU64 = function() {
      var value = getUint64(this.view, this.pos, this.intMode);
      this.pos += 8;
      return value;
    };
    Decoder2.prototype.readI64 = function() {
      var value = getInt64(this.view, this.pos, this.intMode);
      this.pos += 8;
      return value;
    };
    Decoder2.prototype.readF32 = function() {
      var value = this.view.getFloat32(this.pos);
      this.pos += 4;
      return value;
    };
    Decoder2.prototype.readF64 = function() {
      var value = this.view.getFloat64(this.pos);
      this.pos += 8;
      return value;
    };
    return Decoder2;
  })()
);
function decode(buffer2, options) {
  var decoder = new Decoder(options);
  return decoder.decode(buffer2);
}
function msgpackRawEncode(obj) {
  const options = { sortKeys: true };
  return encode(obj, options);
}
function msgpackRawDecodeAsMap(encoded, options) {
  const decoderOptions = {
    intMode: IntMode.BIGINT,
    useMap: true
  };
  return decode(encoded, decoderOptions);
}
function msgpackRawDecodeAsMapWithRawStrings(encoded, options) {
  const decoderOptions = {
    intMode: IntMode.BIGINT,
    useMap: true,
    rawBinaryStringKeys: true,
    rawBinaryStringValues: true,
    useRawBinaryStringClass: true
  };
  return decode(encoded, decoderOptions);
}
function msgpackEncodingDataToJSONEncodingData(e3) {
  if (e3 === null || e3 === void 0) {
    return e3;
  }
  if (e3 instanceof Uint8Array) {
    return bytesToBase64(e3);
  }
  if (Array.isArray(e3)) {
    return e3.map(msgpackEncodingDataToJSONEncodingData);
  }
  if (e3 instanceof Map) {
    const obj = {};
    for (const [k2, v2] of e3) {
      if (typeof k2 !== "string") {
        throw new Error(`JSON map key must be a string: ${k2}`);
      }
      obj[k2] = msgpackEncodingDataToJSONEncodingData(v2);
    }
    return obj;
  }
  return e3;
}
function jsonEncodingDataToMsgpackEncodingData(e3) {
  if (e3 === null || e3 === void 0) {
    return e3;
  }
  if (typeof e3 === "string" || // Note, this will not convert base64 to Uint8Array
  typeof e3 === "number" || typeof e3 === "bigint" || typeof e3 === "boolean") {
    return e3;
  }
  if (Array.isArray(e3)) {
    return e3.map(jsonEncodingDataToMsgpackEncodingData);
  }
  if (typeof e3 === "object") {
    const obj = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(e3)) {
      obj.set(key, jsonEncodingDataToMsgpackEncodingData(value));
    }
    return obj;
  }
  throw new Error(`Invalid JSON encoding data: ${e3}`);
}
var MsgpackObjectPathSegmentKind;
(function(MsgpackObjectPathSegmentKind2) {
  MsgpackObjectPathSegmentKind2[MsgpackObjectPathSegmentKind2["MAP_VALUE"] = 0] = "MAP_VALUE";
  MsgpackObjectPathSegmentKind2[MsgpackObjectPathSegmentKind2["ARRAY_ELEMENT"] = 1] = "ARRAY_ELEMENT";
})(MsgpackObjectPathSegmentKind || (MsgpackObjectPathSegmentKind = {}));
class MsgpackRawStringProvider {
  constructor({ parent, segment, baseObjectBytes }) {
    this.resolvedCache = null;
    this.resolvedCachePresent = false;
    this.parent = parent;
    this.segment = segment;
    this.baseObjectBytes = baseObjectBytes;
  }
  /**
   * Create a new provider that resolves to the current provider's map value at the given key.
   */
  withMapValue(key) {
    return new MsgpackRawStringProvider({
      parent: this,
      segment: {
        kind: MsgpackObjectPathSegmentKind.MAP_VALUE,
        key
      }
    });
  }
  /**
   * Create a new provider that resolves to the current provider's array element at the given index.
   */
  withArrayElement(index) {
    return new MsgpackRawStringProvider({
      parent: this,
      segment: {
        kind: MsgpackObjectPathSegmentKind.ARRAY_ELEMENT,
        key: index
      }
    });
  }
  /**
   * Get the raw string at the current location. If the current location is not a raw string, an error is thrown.
   */
  getRawStringAtCurrentLocation() {
    const resolved = this.resolve();
    if (resolved instanceof RawBinaryString) {
      return resolved.rawBinaryValue;
    }
    throw new Error(`Invalid type. Expected RawBinaryString, got ${resolved} (${typeof resolved})`);
  }
  /**
   * Get the raw string map keys and values at the current location. If the current location is not a map, an error is thrown.
   */
  getRawStringKeysAndValuesAtCurrentLocation() {
    const resolved = this.resolve();
    if (!(resolved instanceof Map)) {
      throw new Error(`Invalid type. Expected Map, got ${resolved} (${typeof resolved})`);
    }
    const keysAndValues = /* @__PURE__ */ new Map();
    for (const [key, value] of resolved) {
      if (key instanceof RawBinaryString) {
        keysAndValues.set(key.rawBinaryValue, value);
      } else {
        throw new Error(`Invalid type for map key. Expected RawBinaryString, got ${key} (${typeof key})`);
      }
    }
    return keysAndValues;
  }
  /**
   * Resolve the provider by extracting the value it indicates from the base msgpack object.
   */
  resolve() {
    if (this.resolvedCachePresent) {
      return this.resolvedCache;
    }
    let parentResolved;
    if (this.parent) {
      parentResolved = this.parent.resolve();
    } else {
      parentResolved = msgpackRawDecodeAsMapWithRawStrings(this.baseObjectBytes);
    }
    if (!this.segment) {
      this.resolvedCache = parentResolved;
      this.resolvedCachePresent = true;
      return parentResolved;
    }
    if (this.segment.kind === MsgpackObjectPathSegmentKind.MAP_VALUE) {
      if (!(parentResolved instanceof Map)) {
        throw new Error(`Invalid type. Expected Map, got ${parentResolved} (${typeof parentResolved})`);
      }
      if (typeof this.segment.key === "string" || this.segment.key instanceof Uint8Array || this.segment.key instanceof RawBinaryString) {
        const targetBytes = this.segment.key instanceof RawBinaryString ? (
          // Decoded rawBinaryValue will always be a Uint8Array
          this.segment.key.rawBinaryValue
        ) : coerceToBytes(this.segment.key);
        const targetIsRawString = typeof this.segment.key === "string" || this.segment.key instanceof RawBinaryString;
        for (const [key, value] of parentResolved) {
          let potentialKeyBytes;
          if (targetIsRawString) {
            if (key instanceof RawBinaryString) {
              potentialKeyBytes = key.rawBinaryValue;
            }
          } else if (key instanceof Uint8Array) {
            potentialKeyBytes = key;
          }
          if (potentialKeyBytes && arrayEqual(targetBytes, potentialKeyBytes)) {
            this.resolvedCache = value;
            break;
          }
        }
      } else {
        this.resolvedCache = parentResolved.get(this.segment.key);
      }
      this.resolvedCachePresent = true;
      return this.resolvedCache;
    }
    if (this.segment.kind === MsgpackObjectPathSegmentKind.ARRAY_ELEMENT) {
      if (!Array.isArray(parentResolved)) {
        throw new Error(`Invalid type. Expected Array, got ${parentResolved} (${typeof parentResolved})`);
      }
      this.resolvedCache = parentResolved[this.segment.key];
      this.resolvedCachePresent = true;
      return this.resolvedCache;
    }
    throw new Error(`Invalid segment kind: ${this.segment.kind}`);
  }
  /**
   * Get the path string of the current location indicated by the provider. Useful for debugging.
   */
  getPathString() {
    const parentPathString = this.parent ? this.parent.getPathString() : "root";
    if (!this.segment) {
      return parentPathString;
    }
    if (this.segment.kind === MsgpackObjectPathSegmentKind.MAP_VALUE) {
      return `${parentPathString} -> map key "${this.segment.key}" (${typeof this.segment.key})`;
    }
    if (this.segment.kind === MsgpackObjectPathSegmentKind.ARRAY_ELEMENT) {
      return `${parentPathString} -> array index ${this.segment.key} (${typeof this.segment.key})`;
    }
    return `${parentPathString} -> unknown segment kind ${this.segment.kind}`;
  }
}
class Schema {
}
function decodeMsgpack(encoded, c2) {
  const decoded = msgpackRawDecodeAsMap(encoded);
  const rawStringProvider = new MsgpackRawStringProvider({
    baseObjectBytes: encoded
  });
  return c2.fromEncodingData(c2.encodingSchema.fromPreparedMsgpack(decoded, rawStringProvider));
}
function encodeMsgpack(e3) {
  return msgpackRawEncode(e3.getEncodingSchema().prepareMsgpack(e3.toEncodingData()));
}
class BooleanSchema extends Schema {
  defaultValue() {
    return false;
  }
  isDefaultValue(data) {
    return data === false;
  }
  prepareMsgpack(data) {
    if (typeof data === "boolean") {
      return data;
    }
    throw new Error("Invalid boolean");
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (typeof encoded === "boolean") {
      return encoded;
    }
    throw new Error("Invalid boolean");
  }
  prepareJSON(data, _options) {
    if (typeof data === "boolean") {
      return data;
    }
    throw new Error("Invalid boolean");
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "boolean") {
      return encoded;
    }
    throw new Error("Invalid boolean");
  }
}
class StringSchema extends Schema {
  defaultValue() {
    return "";
  }
  isDefaultValue(data) {
    return data === "";
  }
  prepareMsgpack(data) {
    if (typeof data === "string") {
      return data;
    }
    throw new Error(`Invalid string: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (typeof encoded === "string") {
      return encoded;
    }
    throw new Error(`Invalid string: (${typeof encoded}) ${encoded}`);
  }
  prepareJSON(data, _options) {
    if (typeof data === "string") {
      return data;
    }
    throw new Error(`Invalid string: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "string") {
      return encoded;
    }
    throw new Error(`Invalid string: (${typeof encoded}) ${encoded}`);
  }
}
class Uint64Schema extends Schema {
  defaultValue() {
    return BigInt(0);
  }
  isDefaultValue(data) {
    if (typeof data === "bigint")
      return data === BigInt(0);
    if (typeof data === "number")
      return data === 0;
    return false;
  }
  prepareMsgpack(data) {
    return ensureUint64(data);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    return ensureUint64(encoded);
  }
  prepareJSON(data, _options) {
    return ensureUint64(data);
  }
  fromPreparedJSON(encoded) {
    return ensureUint64(encoded);
  }
}
class AddressSchema extends Schema {
  defaultValue() {
    return Address.zeroAddress();
  }
  isDefaultValue(data) {
    return Address.zeroAddress().equals(data);
  }
  prepareMsgpack(data) {
    if (data instanceof Address) {
      return data.publicKey;
    }
    throw new Error(`Invalid address: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    return new Address(encoded);
  }
  prepareJSON(data, _options) {
    if (data instanceof Address) {
      return data.toString();
    }
    throw new Error(`Invalid address: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    return Address.fromString(encoded);
  }
}
class ByteArraySchema extends Schema {
  defaultValue() {
    return new Uint8Array();
  }
  isDefaultValue(data) {
    return data instanceof Uint8Array && data.byteLength === 0;
  }
  prepareMsgpack(data) {
    if (data instanceof Uint8Array) {
      return data;
    }
    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (encoded instanceof Uint8Array) {
      return encoded;
    }
    throw new Error(`Invalid byte array: (${typeof encoded}) ${encoded}`);
  }
  prepareJSON(data, _options) {
    if (data instanceof Uint8Array) {
      return bytesToBase64(data);
    }
    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    if (encoded === null || encoded === void 0) {
      return this.defaultValue();
    }
    if (typeof encoded === "string") {
      return base64ToBytes(encoded);
    }
    throw new Error(`Invalid byte array: (${typeof encoded}) ${encoded}`);
  }
}
class FixedLengthByteArraySchema extends Schema {
  constructor(length) {
    super();
    this.length = length;
  }
  defaultValue() {
    return new Uint8Array(this.length);
  }
  isDefaultValue(data) {
    return data instanceof Uint8Array && data.byteLength === this.length && data.every((byte) => byte === 0);
  }
  prepareMsgpack(data) {
    if (data instanceof Uint8Array) {
      if (data.byteLength === this.length) {
        return data;
      }
      throw new Error(`Invalid byte array length: wanted ${this.length}, got ${data.byteLength}`);
    }
    throw new Error("Invalid byte array");
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (encoded instanceof Uint8Array) {
      if (encoded.byteLength === this.length) {
        return encoded;
      }
      throw new Error(`Invalid byte array length: wanted ${this.length}, got ${encoded.byteLength}`);
    }
    throw new Error("Invalid byte array");
  }
  prepareJSON(data) {
    if (data instanceof Uint8Array) {
      if (data.byteLength === this.length) {
        return bytesToBase64(data);
      }
      throw new Error(`Invalid byte array length: wanted ${this.length}, got ${data.byteLength}`);
    }
    throw new Error("Invalid byte array");
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "string") {
      const bytes = base64ToBytes(encoded);
      if (bytes.byteLength === this.length) {
        return bytes;
      }
      throw new Error(`Invalid byte array length: wanted ${this.length}, got ${bytes.byteLength}`);
    }
    throw new Error("Invalid base64 byte array");
  }
}
const blockHashByteLength = 32;
const base32Length = 52;
class BlockHashSchema extends Schema {
  defaultValue() {
    return new Uint8Array(blockHashByteLength);
  }
  isDefaultValue(data) {
    return data instanceof Uint8Array && data.byteLength === blockHashByteLength && data.every((byte) => byte === 0);
  }
  prepareMsgpack(data) {
    if (data instanceof Uint8Array && data.byteLength === blockHashByteLength) {
      return data;
    }
    throw new Error(`Invalid block hash: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (encoded instanceof Uint8Array && encoded.byteLength === blockHashByteLength) {
      return encoded;
    }
    throw new Error(`Invalid block hash: (${typeof encoded}) ${encoded}`);
  }
  prepareJSON(data, _options) {
    if (data instanceof Uint8Array && data.byteLength === blockHashByteLength) {
      return `blk-${base32.encode(data).slice(0, base32Length)}`;
    }
    throw new Error(`Invalid block hash: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "string" && encoded.length === base32Length + 4 && encoded.startsWith("blk-")) {
      return Uint8Array.from(base32.decode.asBytes(encoded.slice(4)));
    }
    throw new Error(`Invalid block hash: (${typeof encoded}) ${encoded}`);
  }
}
class SpecialCaseBinaryStringSchema extends Schema {
  defaultValue() {
    return new Uint8Array();
  }
  isDefaultValue(data) {
    return data instanceof Uint8Array && data.byteLength === 0;
  }
  prepareMsgpack(data) {
    if (data instanceof Uint8Array) {
      return new RawBinaryString(data);
    }
    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(_encoded, rawStringProvider) {
    return rawStringProvider.getRawStringAtCurrentLocation();
  }
  prepareJSON(data, options) {
    if (data instanceof Uint8Array) {
      const stringValue = bytesToString(data);
      if (!options.lossyBinaryStringConversion && !arrayEqual(coerceToBytes(stringValue), data)) {
        throw new Error(`Invalid UTF-8 byte array encountered. Encode with lossyBinaryStringConversion enabled to bypass this check. Base64 value: ${bytesToBase64(data)}`);
      }
      return stringValue;
    }
    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "string") {
      return coerceToBytes(encoded);
    }
    throw new Error(`Invalid byte array: (${typeof encoded}) ${encoded}`);
  }
}
class ArraySchema extends Schema {
  constructor(itemSchema) {
    super();
    this.itemSchema = itemSchema;
  }
  defaultValue() {
    return [];
  }
  isDefaultValue(data) {
    return Array.isArray(data) && data.length === 0;
  }
  prepareMsgpack(data) {
    if (Array.isArray(data)) {
      return data.map((item) => this.itemSchema.prepareMsgpack(item));
    }
    throw new Error("ArraySchema data must be an array");
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (Array.isArray(encoded)) {
      return encoded.map((item, index) => this.itemSchema.fromPreparedMsgpack(item, rawStringProvider.withArrayElement(index)));
    }
    throw new Error(`ArraySchema encoded data must be an array: ${encoded} (${typeof encoded})`);
  }
  prepareJSON(data, options) {
    if (Array.isArray(data)) {
      return data.map((item) => this.itemSchema.prepareJSON(item, options));
    }
    throw new Error("ArraySchema data must be an array");
  }
  fromPreparedJSON(encoded) {
    if (Array.isArray(encoded)) {
      return encoded.map((item) => this.itemSchema.fromPreparedJSON(item));
    }
    throw new Error(`ArraySchema encoded data must be an array: ${encoded} (${typeof encoded})`);
  }
}
function allOmitEmpty(entries) {
  return entries.map((entry) => ({ ...entry, omitEmpty: true }));
}
class NamedMapSchema extends Schema {
  constructor(entries) {
    super();
    this.entries = entries;
    this.checkEntries();
  }
  /**
   * Adds new entries to the map schema. WARNING: this is a mutable operation, and you should be very
   * careful when using it. Any error that happens here is non-recoverable and will corrupt the
   * NamedMapSchema object;
   * @param entries - The entries to add.
   */
  pushEntries(...entries) {
    this.entries.push(...entries);
    this.checkEntries();
  }
  checkEntries() {
    for (const entry of this.entries) {
      if (entry.embedded) {
        if (entry.key !== "") {
          throw new Error("Embedded entries must have an empty key");
        }
        if (!(entry.valueSchema instanceof NamedMapSchema)) {
          throw new Error("Embedded entry valueSchema must be a NamedMapSchema");
        }
      }
    }
    const keys = /* @__PURE__ */ new Set();
    for (const entry of this.getEntries()) {
      if (keys.has(entry.key)) {
        throw new Error(`Duplicate key: ${entry.key}`);
      }
      keys.add(entry.key);
    }
  }
  /**
   * Returns all top-level entries, properly accounting for fields from embedded entries.
   * @returns An array of all top-level entries for this map.
   */
  getEntries() {
    const entries = [];
    for (const entry of this.entries) {
      if (entry.embedded) {
        const embeddedMapSchema = entry.valueSchema;
        entries.push(...embeddedMapSchema.getEntries());
      } else {
        entries.push(entry);
      }
    }
    return entries;
  }
  defaultValue() {
    const map2 = /* @__PURE__ */ new Map();
    for (const entry of this.getEntries()) {
      map2.set(entry.key, entry.valueSchema.defaultValue());
    }
    return map2;
  }
  isDefaultValue(data) {
    if (!(data instanceof Map))
      return false;
    for (const entry of this.getEntries()) {
      if (!entry.valueSchema.isDefaultValue(data.get(entry.key))) {
        return false;
      }
    }
    return true;
  }
  prepareMsgpack(data) {
    if (!(data instanceof Map)) {
      throw new Error(`NamedMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const map2 = /* @__PURE__ */ new Map();
    for (const entry of this.getEntries()) {
      const value = data.get(entry.key);
      if (entry.omitEmpty && entry.valueSchema.isDefaultValue(value)) {
        continue;
      }
      map2.set(entry.key, entry.valueSchema.prepareMsgpack(value));
    }
    return map2;
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (!(encoded instanceof Map)) {
      throw new Error("NamedMapSchema data must be a Map");
    }
    const map2 = /* @__PURE__ */ new Map();
    for (const entry of this.getEntries()) {
      if (encoded.has(entry.key)) {
        map2.set(entry.key, entry.valueSchema.fromPreparedMsgpack(encoded.get(entry.key), rawStringProvider.withMapValue(entry.key)));
      } else if (entry.omitEmpty) {
        map2.set(entry.key, entry.valueSchema.defaultValue());
      } else {
        throw new Error(`Missing key: ${entry.key}`);
      }
    }
    return map2;
  }
  prepareJSON(data, options) {
    if (!(data instanceof Map)) {
      throw new Error("NamedMapSchema data must be a Map");
    }
    const obj = {};
    for (const entry of this.getEntries()) {
      const value = data.get(entry.key);
      if (entry.omitEmpty && entry.valueSchema.isDefaultValue(value)) {
        continue;
      }
      obj[entry.key] = entry.valueSchema.prepareJSON(value, options);
    }
    return obj;
  }
  fromPreparedJSON(encoded) {
    if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
      throw new Error("NamedMapSchema data must be an object");
    }
    const map2 = /* @__PURE__ */ new Map();
    for (const entry of this.getEntries()) {
      if (Object.prototype.hasOwnProperty.call(encoded, entry.key)) {
        map2.set(entry.key, entry.valueSchema.fromPreparedJSON(encoded[entry.key]));
      } else if (entry.omitEmpty) {
        map2.set(entry.key, entry.valueSchema.defaultValue());
      } else {
        throw new Error(`Missing key: ${entry.key}`);
      }
    }
    return map2;
  }
}
function combineMaps(...maps) {
  const combined = /* @__PURE__ */ new Map();
  for (const map2 of maps) {
    for (const [key, value] of map2) {
      if (combined.has(key)) {
        throw new Error(`Duplicate key: ${key}`);
      }
      combined.set(key, value);
    }
  }
  return combined;
}
function convertMap(map2, func) {
  const mapped = /* @__PURE__ */ new Map();
  for (const [key, value] of map2) {
    const [newKey, newValue] = func(key, value);
    mapped.set(newKey, newValue);
  }
  return mapped;
}
class Uint64MapSchema extends Schema {
  constructor(valueSchema) {
    super();
    this.valueSchema = valueSchema;
  }
  defaultValue() {
    return /* @__PURE__ */ new Map();
  }
  isDefaultValue(data) {
    return data instanceof Map && data.size === 0;
  }
  prepareMsgpack(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Uint64MapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      const bigintKey = ensureUint64(key);
      if (prepared.has(bigintKey)) {
        throw new Error(`Duplicate key: ${bigintKey}`);
      }
      prepared.set(bigintKey, this.valueSchema.prepareMsgpack(value));
    }
    return prepared;
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (!(encoded instanceof Map)) {
      throw new Error("Uint64MapSchema data must be a Map");
    }
    const map2 = /* @__PURE__ */ new Map();
    for (const [key, value] of encoded) {
      const bigintKey = ensureUint64(key);
      if (map2.has(bigintKey)) {
        throw new Error(`Duplicate key: ${bigintKey}`);
      }
      map2.set(bigintKey, this.valueSchema.fromPreparedMsgpack(value, rawStringProvider.withMapValue(key)));
    }
    return map2;
  }
  prepareJSON(data, options) {
    if (!(data instanceof Map)) {
      throw new Error(`Uint64MapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      const bigintKey = ensureUint64(key);
      if (prepared.has(bigintKey)) {
        throw new Error(`Duplicate key: ${bigintKey}`);
      }
      prepared.set(bigintKey, this.valueSchema.prepareJSON(value, options));
    }
    const obj = {};
    for (const [key, value] of prepared) {
      obj[key.toString()] = value;
    }
    return obj;
  }
  fromPreparedJSON(encoded) {
    if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
      throw new Error("Uint64MapSchema data must be an object");
    }
    const map2 = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(encoded)) {
      const bigintKey = BigInt(key);
      if (map2.has(bigintKey)) {
        throw new Error(`Duplicate key: ${bigintKey}`);
      }
      map2.set(bigintKey, this.valueSchema.fromPreparedJSON(value));
    }
    return map2;
  }
}
class ByteArrayMapSchema extends Schema {
  constructor(valueSchema) {
    super();
    this.valueSchema = valueSchema;
  }
  defaultValue() {
    return /* @__PURE__ */ new Map();
  }
  isDefaultValue(data) {
    return data instanceof Map && data.size === 0;
  }
  prepareMsgpack(data) {
    if (!(data instanceof Map)) {
      throw new Error(`ByteArrayMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key} (${typeof key})`);
      }
      prepared.set(key, this.valueSchema.prepareMsgpack(value));
    }
    return prepared;
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (!(encoded instanceof Map)) {
      throw new Error("ByteArrayMapSchema data must be a Map");
    }
    const map2 = /* @__PURE__ */ new Map();
    for (const [key, value] of encoded) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key} (${typeof key})`);
      }
      map2.set(key, this.valueSchema.fromPreparedMsgpack(value, rawStringProvider.withMapValue(key)));
    }
    return map2;
  }
  prepareJSON(data, options) {
    if (!(data instanceof Map)) {
      throw new Error(`ByteArrayMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key} (${typeof key})`);
      }
      const b64Encoded = bytesToBase64(key);
      if (prepared.has(b64Encoded)) {
        throw new Error(`Duplicate key (base64): ${b64Encoded}`);
      }
      prepared.set(b64Encoded, this.valueSchema.prepareJSON(value, options));
    }
    const obj = {};
    for (const [key, value] of prepared) {
      obj[key] = value;
    }
    return obj;
  }
  fromPreparedJSON(encoded) {
    if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
      throw new Error("ByteArrayMapSchema data must be an object");
    }
    const map2 = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(encoded)) {
      map2.set(base64ToBytes(key), this.valueSchema.fromPreparedJSON(value));
    }
    return map2;
  }
}
function convertRawStringsInMsgpackValue(value) {
  if (value instanceof RawBinaryString) {
    return bytesToString(value.rawBinaryValue);
  }
  if (value instanceof Map) {
    const newMap = /* @__PURE__ */ new Map();
    for (const [key, val] of value) {
      newMap.set(convertRawStringsInMsgpackValue(key), convertRawStringsInMsgpackValue(val));
    }
    return newMap;
  }
  if (Array.isArray(value)) {
    return value.map(convertRawStringsInMsgpackValue);
  }
  return value;
}
class SpecialCaseBinaryStringMapSchema extends Schema {
  constructor(valueSchema) {
    super();
    this.valueSchema = valueSchema;
  }
  defaultValue() {
    return /* @__PURE__ */ new Map();
  }
  isDefaultValue(data) {
    return data instanceof Map && data.size === 0;
  }
  prepareMsgpack(data) {
    if (!(data instanceof Map)) {
      throw new Error(`SpecialCaseBinaryStringMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key} (${typeof key})`);
      }
      prepared.set(new RawBinaryString(key), this.valueSchema.prepareMsgpack(value));
    }
    return prepared;
  }
  fromPreparedMsgpack(_encoded, rawStringProvider) {
    const map2 = /* @__PURE__ */ new Map();
    const keysAndValues = rawStringProvider.getRawStringKeysAndValuesAtCurrentLocation();
    for (const [key, value] of keysAndValues) {
      map2.set(key, this.valueSchema.fromPreparedMsgpack(convertRawStringsInMsgpackValue(value), rawStringProvider.withMapValue(new RawBinaryString(key))));
    }
    return map2;
  }
  prepareJSON(data, options) {
    if (!(data instanceof Map)) {
      throw new Error(`SpecialCaseBinaryStringMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key}`);
      }
      const keyStringValue = bytesToString(key);
      if (!options.lossyBinaryStringConversion && !arrayEqual(coerceToBytes(keyStringValue), key)) {
        throw new Error(`Invalid UTF-8 byte array encountered. Encode with lossyBinaryStringConversion enabled to bypass this check. Base64 value: ${bytesToBase64(key)}`);
      }
      prepared.set(keyStringValue, this.valueSchema.prepareJSON(value, options));
    }
    const obj = {};
    for (const [key, value] of prepared) {
      obj[key] = value;
    }
    return obj;
  }
  fromPreparedJSON(encoded) {
    if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
      throw new Error("SpecialCaseBinaryStringMapSchema data must be an object");
    }
    const map2 = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(encoded)) {
      map2.set(coerceToBytes(key), this.valueSchema.fromPreparedJSON(value));
    }
    return map2;
  }
}
class OptionalSchema extends Schema {
  constructor(valueSchema) {
    super();
    this.valueSchema = valueSchema;
  }
  defaultValue() {
    return void 0;
  }
  isDefaultValue(data) {
    return data === void 0 || this.valueSchema.isDefaultValue(data);
  }
  prepareMsgpack(data) {
    if (data === void 0) {
      return void 0;
    }
    return this.valueSchema.prepareMsgpack(data);
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (encoded === void 0 || encoded === null) {
      return void 0;
    }
    return this.valueSchema.fromPreparedMsgpack(encoded, rawStringProvider);
  }
  prepareJSON(data, options) {
    if (data === void 0) {
      return null;
    }
    return this.valueSchema.prepareJSON(data, options);
  }
  fromPreparedJSON(encoded) {
    if (encoded === void 0 || encoded === null) {
      return void 0;
    }
    return this.valueSchema.fromPreparedJSON(encoded);
  }
}
class UntypedSchema extends Schema {
  defaultValue() {
    return void 0;
  }
  isDefaultValue(data) {
    return data === void 0;
  }
  prepareMsgpack(data) {
    return data;
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    return encoded;
  }
  prepareJSON(data, _options) {
    return msgpackEncodingDataToJSONEncodingData(data);
  }
  fromPreparedJSON(encoded) {
    return jsonEncodingDataToMsgpackEncodingData(encoded);
  }
}
function boxReferenceToEncodingData(reference, foreignApps, appIndex) {
  const referenceId = BigInt(reference.appIndex);
  const referenceName = reference.name;
  const isOwnReference = referenceId === BigInt(0) || referenceId === appIndex;
  const index = foreignApps.indexOf(referenceId) + 1;
  if (index === 0 && !isOwnReference) {
    throw new Error(`Box ref with appId ${referenceId} not in foreign-apps`);
  }
  return /* @__PURE__ */ new Map([
    ["i", index],
    ["n", referenceName]
  ]);
}
function boxReferencesToEncodingData(references, foreignApps, appIndex) {
  const appIndexBigInt = BigInt(appIndex);
  const foreignAppsBigInt = foreignApps.map(BigInt);
  return references.map((bx) => boxReferenceToEncodingData(bx, foreignAppsBigInt, appIndexBigInt));
}
function resourceReferencesToEncodingData(appIndex, references) {
  const accessList = [];
  function ensure(target) {
    for (let idx = 0; idx < accessList.length; idx++) {
      const a2 = accessList[idx];
      const aAddress = a2.get("d");
      const addressesEqual = !target.address && !aAddress || target.address && aAddress && target.address.equals(aAddress);
      if (addressesEqual && a2.get("s") === target.assetIndex && a2.get("p") === target.appIndex) {
        return idx + 1;
      }
    }
    if (target.address) {
      accessList.push(/* @__PURE__ */ new Map([["d", target.address]]));
    }
    if (target.assetIndex) {
      accessList.push(/* @__PURE__ */ new Map([["s", target.assetIndex]]));
    }
    if (target.appIndex) {
      accessList.push(/* @__PURE__ */ new Map([["p", target.appIndex]]));
    }
    return accessList.length;
  }
  const zeroAddr = Address.zeroAddress();
  for (const rr of references) {
    if (rr.address || rr.assetIndex || rr.appIndex) {
      ensure(rr);
      continue;
    }
    if (rr.holding) {
      const h2 = rr.holding;
      let addrIdx = 0;
      if (h2.address && !h2.address.equals(zeroAddr)) {
        addrIdx = ensure({ address: h2.address });
      }
      const assetIdx = ensure({ assetIndex: h2.assetIndex });
      accessList.push(/* @__PURE__ */ new Map([
        [
          "h",
          /* @__PURE__ */ new Map([
            ["d", addrIdx],
            ["s", assetIdx]
          ])
        ]
      ]));
      continue;
    }
    if (rr.locals) {
      const l2 = rr.locals;
      let addrIdx = 0;
      if (l2.address && !l2.address.equals(zeroAddr)) {
        addrIdx = ensure({ address: l2.address });
      }
      let appIdx = 0;
      if (l2.appIndex && BigInt(l2.appIndex) !== appIndex) {
        appIdx = ensure({ appIndex: l2.appIndex });
      }
      accessList.push(/* @__PURE__ */ new Map([
        [
          "l",
          /* @__PURE__ */ new Map([
            ["d", addrIdx],
            ["p", appIdx]
          ])
        ]
      ]));
      continue;
    }
    if (rr.box) {
      const b2 = rr.box;
      let appIdx = 0;
      if (b2.appIndex && BigInt(b2.appIndex) !== appIndex) {
        appIdx = ensure({ appIndex: b2.appIndex });
      }
      accessList.push(/* @__PURE__ */ new Map([
        [
          "b",
          /* @__PURE__ */ new Map([
            ["i", appIdx],
            ["n", b2.name]
          ])
        ]
      ]));
    }
  }
  return accessList;
}
function convertIndicesToResourceReferences(accessList) {
  const references = [];
  for (const item of accessList) {
    const address = item.get("d");
    const assetIndex = item.get("s");
    const appIndex = item.get("p");
    if (address) {
      references.push({ address });
      continue;
    }
    if (assetIndex) {
      references.push({ assetIndex });
      continue;
    }
    if (appIndex) {
      references.push({ appIndex });
      continue;
    }
    const holding = item.get("h");
    if (holding) {
      const hAddressIndex = ensureSafeUnsignedInteger(holding.get("d") ?? 0);
      const hAssetIndex = ensureSafeUnsignedInteger(holding.get("s"));
      if (!hAssetIndex) {
        throw new Error(`Holding missing asset index: ${holding}`);
      }
      const hAddress = hAddressIndex === 0 ? Address.zeroAddress() : references[hAddressIndex - 1].address;
      const asset = references[hAssetIndex - 1].assetIndex;
      references.push({ holding: { address: hAddress, assetIndex: asset } });
      continue;
    }
    const locals = item.get("l");
    if (locals) {
      const lAddressIndex = ensureSafeUnsignedInteger(locals.get("d") ?? 0);
      const lAppIndex = ensureSafeUnsignedInteger(locals.get("p") ?? 0);
      const lAddress = lAddressIndex === 0 ? Address.zeroAddress() : references[lAddressIndex - 1].address;
      const app = lAppIndex === 0 ? BigInt(0) : references[lAppIndex - 1].appIndex;
      references.push({ locals: { address: lAddress, appIndex: app } });
      continue;
    }
    const box = item.get("b");
    if (box) {
      const bAppIndex = ensureSafeUnsignedInteger(box.get("i") ?? 0);
      const name = box.get("n");
      if (!name) {
        throw new Error(`Box missing name: ${box}`);
      }
      const app = bAppIndex === 0 ? BigInt(0) : references[bAppIndex - 1].appIndex;
      references.push({ box: { appIndex: app, name } });
    }
  }
  return references;
}
var TransactionType;
(function(TransactionType2) {
  TransactionType2["pay"] = "pay";
  TransactionType2["keyreg"] = "keyreg";
  TransactionType2["acfg"] = "acfg";
  TransactionType2["axfer"] = "axfer";
  TransactionType2["afrz"] = "afrz";
  TransactionType2["appl"] = "appl";
  TransactionType2["stpf"] = "stpf";
  TransactionType2["hb"] = "hb";
})(TransactionType || (TransactionType = {}));
function isTransactionType(s2) {
  return s2 === TransactionType.pay || s2 === TransactionType.keyreg || s2 === TransactionType.acfg || s2 === TransactionType.axfer || s2 === TransactionType.afrz || s2 === TransactionType.appl || s2 === TransactionType.stpf || s2 === TransactionType.hb;
}
var OnApplicationComplete;
(function(OnApplicationComplete2) {
  OnApplicationComplete2[OnApplicationComplete2["NoOpOC"] = 0] = "NoOpOC";
  OnApplicationComplete2[OnApplicationComplete2["OptInOC"] = 1] = "OptInOC";
  OnApplicationComplete2[OnApplicationComplete2["CloseOutOC"] = 2] = "CloseOutOC";
  OnApplicationComplete2[OnApplicationComplete2["ClearStateOC"] = 3] = "ClearStateOC";
  OnApplicationComplete2[OnApplicationComplete2["UpdateApplicationOC"] = 4] = "UpdateApplicationOC";
  OnApplicationComplete2[OnApplicationComplete2["DeleteApplicationOC"] = 5] = "DeleteApplicationOC";
})(OnApplicationComplete || (OnApplicationComplete = {}));
function isOnApplicationComplete(v2) {
  return v2 === OnApplicationComplete.NoOpOC || v2 === OnApplicationComplete.OptInOC || v2 === OnApplicationComplete.CloseOutOC || v2 === OnApplicationComplete.ClearStateOC || v2 === OnApplicationComplete.UpdateApplicationOC || v2 === OnApplicationComplete.DeleteApplicationOC;
}
class HashFactory {
  constructor(params) {
    this.hashType = params.hashType;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return HashFactory.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["t", this.hashType]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded HashFactory: ${data}`);
    }
    return new HashFactory({
      hashType: Number(data.get("t"))
    });
  }
}
HashFactory.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "t", valueSchema: new Uint64Schema() }
  // hashType
]));
class MerkleArrayProof {
  constructor(params) {
    this.path = params.path;
    this.hashFactory = params.hashFactory;
    this.treeDepth = params.treeDepth;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return MerkleArrayProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["pth", this.path],
      ["hsh", this.hashFactory.toEncodingData()],
      ["td", this.treeDepth]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded MerkleArrayProof: ${data}`);
    }
    return new MerkleArrayProof({
      path: data.get("pth"),
      hashFactory: HashFactory.fromEncodingData(data.get("hsh")),
      treeDepth: Number(data.get("td"))
    });
  }
}
MerkleArrayProof.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "pth",
    // path
    valueSchema: new ArraySchema(new ByteArraySchema())
  },
  {
    key: "hsh",
    // hashFactory
    valueSchema: HashFactory.encodingSchema
  },
  {
    key: "td",
    // treeDepth
    valueSchema: new Uint64Schema()
  }
]));
class MerkleSignatureVerifier {
  constructor(params) {
    this.commitment = params.commitment;
    this.keyLifetime = params.keyLifetime;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return MerkleSignatureVerifier.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["cmt", this.commitment],
      ["lf", this.keyLifetime]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded MerkleSignatureVerifier: ${data}`);
    }
    return new MerkleSignatureVerifier({
      commitment: data.get("cmt"),
      keyLifetime: data.get("lf")
    });
  }
}
MerkleSignatureVerifier.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "cmt",
    // commitment
    valueSchema: new FixedLengthByteArraySchema(64)
  },
  {
    key: "lf",
    // keyLifetime
    valueSchema: new Uint64Schema()
  }
]));
class Participant {
  constructor(params) {
    this.pk = params.pk;
    this.weight = params.weight;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return Participant.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["p", this.pk.toEncodingData()],
      ["w", this.weight]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Participant: ${data}`);
    }
    return new Participant({
      pk: MerkleSignatureVerifier.fromEncodingData(data.get("p")),
      weight: data.get("w")
    });
  }
}
Participant.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "p",
    // pk
    valueSchema: MerkleSignatureVerifier.encodingSchema
  },
  {
    key: "w",
    // weight
    valueSchema: new Uint64Schema()
  }
]));
class FalconVerifier {
  constructor(params) {
    this.publicKey = params.publicKey;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return FalconVerifier.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["k", this.publicKey]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded FalconVerifier: ${data}`);
    }
    return new FalconVerifier({
      publicKey: data.get("k")
    });
  }
}
FalconVerifier.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "k", valueSchema: new FixedLengthByteArraySchema(1793) }
  // publicKey
]));
class FalconSignatureStruct {
  constructor(params) {
    this.signature = params.signature;
    this.vectorCommitmentIndex = params.index;
    this.proof = params.proof;
    this.verifyingKey = params.verifyingKey;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return FalconSignatureStruct.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["sig", this.signature],
      ["idx", this.vectorCommitmentIndex],
      ["prf", this.proof.toEncodingData()],
      ["vkey", this.verifyingKey.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded FalconSignatureStruct: ${data}`);
    }
    return new FalconSignatureStruct({
      signature: data.get("sig"),
      index: data.get("idx"),
      proof: MerkleArrayProof.fromEncodingData(data.get("prf")),
      verifyingKey: FalconVerifier.fromEncodingData(data.get("vkey"))
    });
  }
}
FalconSignatureStruct.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "sig", valueSchema: new ByteArraySchema() },
  // signature
  { key: "idx", valueSchema: new Uint64Schema() },
  // index
  { key: "prf", valueSchema: MerkleArrayProof.encodingSchema },
  // proof
  { key: "vkey", valueSchema: FalconVerifier.encodingSchema }
  // verifyingKey
]));
class SigslotCommit {
  constructor(params) {
    this.sig = params.sig;
    this.l = params.l;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return SigslotCommit.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["s", this.sig.toEncodingData()],
      ["l", this.l]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SigslotCommit: ${data}`);
    }
    return new SigslotCommit({
      sig: FalconSignatureStruct.fromEncodingData(data.get("s")),
      l: data.get("l")
    });
  }
}
SigslotCommit.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "s", valueSchema: FalconSignatureStruct.encodingSchema },
  // sigslot
  { key: "l", valueSchema: new Uint64Schema() }
  // l
]));
class Reveal {
  constructor(params) {
    this.sigslot = params.sigslot;
    this.participant = params.participant;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return Reveal.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["s", this.sigslot.toEncodingData()],
      ["p", this.participant.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Reveal: ${data}`);
    }
    return new Reveal({
      sigslot: SigslotCommit.fromEncodingData(data.get("s")),
      participant: Participant.fromEncodingData(data.get("p"))
    });
  }
}
Reveal.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "s", valueSchema: SigslotCommit.encodingSchema },
  // sigslotCommit
  { key: "p", valueSchema: Participant.encodingSchema }
  // participant
]));
class StateProof {
  constructor(params) {
    this.sigCommit = params.sigCommit;
    this.signedWeight = params.signedWeight;
    this.sigProofs = params.sigProofs;
    this.partProofs = params.partProofs;
    this.merkleSignatureSaltVersion = params.merkleSignatureSaltVersion;
    this.reveals = params.reveals;
    this.positionsToReveal = params.positionsToReveal;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return StateProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["c", this.sigCommit],
      ["w", this.signedWeight],
      ["S", this.sigProofs.toEncodingData()],
      ["P", this.partProofs.toEncodingData()],
      ["v", this.merkleSignatureSaltVersion],
      [
        "r",
        convertMap(this.reveals, (key, value) => [key, value.toEncodingData()])
      ],
      ["pr", this.positionsToReveal]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProof: ${data}`);
    }
    return new StateProof({
      sigCommit: data.get("c"),
      signedWeight: data.get("w"),
      sigProofs: MerkleArrayProof.fromEncodingData(data.get("S")),
      partProofs: MerkleArrayProof.fromEncodingData(data.get("P")),
      merkleSignatureSaltVersion: Number(data.get("v")),
      reveals: convertMap(data.get("r"), (key, value) => [
        key,
        Reveal.fromEncodingData(value)
      ]),
      positionsToReveal: data.get("pr")
    });
  }
}
StateProof.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "c",
    // sigCommit
    valueSchema: new ByteArraySchema()
  },
  {
    key: "w",
    // signedWeight
    valueSchema: new Uint64Schema()
  },
  {
    key: "S",
    // sigProofs
    valueSchema: MerkleArrayProof.encodingSchema
  },
  {
    key: "P",
    // partProofs
    valueSchema: MerkleArrayProof.encodingSchema
  },
  {
    key: "v",
    // merkleSignatureSaltVersion
    valueSchema: new Uint64Schema()
  },
  {
    key: "r",
    // reveals
    valueSchema: new Uint64MapSchema(Reveal.encodingSchema)
  },
  {
    key: "pr",
    // positionsToReveal
    valueSchema: new ArraySchema(new Uint64Schema())
  }
]));
class StateProofMessage {
  constructor(params) {
    this.blockHeadersCommitment = params.blockHeadersCommitment;
    this.votersCommitment = params.votersCommitment;
    this.lnProvenWeight = params.lnProvenWeight;
    this.firstAttestedRound = params.firstAttestedRound;
    this.lastAttestedRound = params.lastAttestedRound;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return StateProofMessage.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["b", this.blockHeadersCommitment],
      ["v", this.votersCommitment],
      ["P", this.lnProvenWeight],
      ["f", this.firstAttestedRound],
      ["l", this.lastAttestedRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofMessage: ${data}`);
    }
    return new StateProofMessage({
      blockHeadersCommitment: data.get("b"),
      votersCommitment: data.get("v"),
      lnProvenWeight: data.get("P"),
      firstAttestedRound: data.get("f"),
      lastAttestedRound: data.get("l")
    });
  }
  static fromMap(data) {
    return new StateProofMessage({
      blockHeadersCommitment: data.get("b"),
      votersCommitment: data.get("v"),
      lnProvenWeight: data.get("P"),
      firstAttestedRound: data.get("f"),
      lastAttestedRound: data.get("l")
    });
  }
}
StateProofMessage.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "b", valueSchema: new ByteArraySchema() },
  // blockHeadersCommitment
  { key: "v", valueSchema: new ByteArraySchema() },
  // votersCommitment
  { key: "P", valueSchema: new Uint64Schema() },
  // lnProvenWeight
  { key: "f", valueSchema: new Uint64Schema() },
  // firstAttestedRound
  { key: "l", valueSchema: new Uint64Schema() }
  // lastAttestedRound
]));
class HeartbeatProof {
  constructor(params) {
    this.sig = params.sig;
    this.pk = params.pk;
    this.pk2 = params.pk2;
    this.pk1Sig = params.pk1Sig;
    this.pk2Sig = params.pk2Sig;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return HeartbeatProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["s", this.sig],
      ["p", this.pk],
      ["p2", this.pk2],
      ["p1s", this.pk1Sig],
      ["p2s", this.pk2Sig]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded HeartbeatProof: ${data}`);
    }
    return new HeartbeatProof({
      sig: data.get("s"),
      pk: data.get("p"),
      pk2: data.get("p2"),
      pk1Sig: data.get("p1s"),
      pk2Sig: data.get("p2s")
    });
  }
}
HeartbeatProof.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "s",
    // Sig
    valueSchema: new FixedLengthByteArraySchema(64)
  },
  {
    key: "p",
    // PK
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "p2",
    // PK2
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "p1s",
    // PK1Sig
    valueSchema: new FixedLengthByteArraySchema(64)
  },
  {
    key: "p2s",
    // PK2Sig
    valueSchema: new FixedLengthByteArraySchema(64)
  }
]));
class Heartbeat {
  constructor(params) {
    this.address = params.address;
    this.proof = params.proof;
    this.seed = params.seed;
    this.voteID = params.voteID;
    this.keyDilution = params.keyDilution;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return Heartbeat.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["a", this.address],
      ["prf", this.proof.toEncodingData()],
      ["sd", this.seed],
      ["vid", this.voteID],
      ["kd", this.keyDilution]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Heartbeat: ${data}`);
    }
    return new Heartbeat({
      address: data.get("a"),
      proof: HeartbeatProof.fromEncodingData(data.get("prf")),
      seed: data.get("sd"),
      voteID: data.get("vid"),
      keyDilution: data.get("kd")
    });
  }
}
Heartbeat.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "a",
    // HbAddress
    valueSchema: new AddressSchema()
  },
  {
    key: "prf",
    // HbProof
    valueSchema: HeartbeatProof.encodingSchema
  },
  {
    key: "sd",
    // HbSeed
    valueSchema: new ByteArraySchema()
  },
  {
    key: "vid",
    // HbVoteID
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "kd",
    // HbKeyDilution
    valueSchema: new Uint64Schema()
  }
]));
const ALGORAND_TRANSACTION_LENGTH = 52;
const ALGORAND_TRANSACTION_LEASE_LENGTH = 32;
const NUM_ADDL_BYTES_AFTER_SIGNING = 75;
const ASSET_METADATA_HASH_LENGTH = 32;
const KEYREG_VOTE_KEY_LENGTH = 32;
const KEYREG_SELECTION_KEY_LENGTH = 32;
const KEYREG_STATE_PROOF_KEY_LENGTH = 64;
const ALGORAND_TRANSACTION_GROUP_LENGTH = 32;
function uint8ArrayIsEmpty(input) {
  return input.every((value) => value === 0);
}
function getKeyregKey(input, inputName, length) {
  if (input == null) {
    return void 0;
  }
  let inputBytes;
  if (input instanceof Uint8Array) {
    inputBytes = input;
  }
  if (inputBytes == null || inputBytes.byteLength !== length) {
    throw Error(`${inputName} must be a ${length} byte Uint8Array`);
  }
  return inputBytes;
}
function ensureAddress(input) {
  if (input == null) {
    throw new Error("Address must not be null or undefined");
  }
  if (typeof input === "string") {
    return Address.fromString(input);
  }
  if (input instanceof Address) {
    return input;
  }
  throw new Error(`Not an address: ${input}`);
}
function optionalAddress(input) {
  if (input == null) {
    return void 0;
  }
  let addr;
  if (input instanceof Address) {
    addr = input;
  } else if (typeof input === "string") {
    addr = Address.fromString(input);
  } else {
    throw new Error(`Not an address: ${input}`);
  }
  if (uint8ArrayIsEmpty(addr.publicKey)) {
    throw new Error("Invalid use of the zero address. To omit this value, pass in undefined");
  }
  return addr;
}
function optionalUint8Array(input) {
  if (typeof input === "undefined") {
    return void 0;
  }
  if (input instanceof Uint8Array) {
    return input;
  }
  throw new Error(`Not a Uint8Array: ${input}`);
}
function ensureUint8Array(input) {
  if (input instanceof Uint8Array) {
    return input;
  }
  throw new Error(`Not a Uint8Array: ${input}`);
}
function optionalUint64(input) {
  if (typeof input === "undefined") {
    return void 0;
  }
  return ensureUint64(input);
}
function ensureBoolean(input) {
  if (input === true || input === false) {
    return input;
  }
  throw new Error(`Not a boolean: ${input}`);
}
function ensureArray(input) {
  if (Array.isArray(input)) {
    return input.slice();
  }
  throw new Error(`Not an array: ${input}`);
}
function optionalFixedLengthByteArray(input, length, name) {
  const bytes = optionalUint8Array(input);
  if (typeof bytes === "undefined") {
    return void 0;
  }
  if (bytes.byteLength !== length) {
    throw new Error(`${name} must be ${length} bytes long, was ${bytes.byteLength}`);
  }
  if (uint8ArrayIsEmpty(bytes)) {
    return void 0;
  }
  return bytes;
}
function ensureBoxReference(input) {
  if (input != null && typeof input === "object") {
    const { appIndex, name } = input;
    return {
      appIndex: ensureUint64(appIndex),
      name: ensureUint8Array(name)
    };
  }
  throw new Error(`Not a box reference: ${input}`);
}
function ensureHoldingReference(input) {
  if (input != null && typeof input === "object") {
    const { assetIndex, address } = input;
    return {
      assetIndex: ensureUint64(assetIndex),
      address: ensureAddress(address)
    };
  }
  throw new Error(`Not a holding reference: ${input}`);
}
function ensureLocalsReference(input) {
  if (input != null && typeof input === "object") {
    const { appIndex, address } = input;
    return {
      appIndex: ensureUint64(appIndex),
      address: ensureAddress(address)
    };
  }
  throw new Error(`Not a locals reference: ${input}`);
}
function ensureResourceReference(input) {
  if (input != null && typeof input === "object") {
    const { address, appIndex, assetIndex, holding, locals, box } = input;
    if (address !== void 0) {
      return { address: ensureAddress(address) };
    }
    if (appIndex !== void 0) {
      return { appIndex: ensureUint64(appIndex) };
    }
    if (assetIndex !== void 0) {
      return { assetIndex: ensureUint64(assetIndex) };
    }
    if (holding !== void 0) {
      return { holding: ensureHoldingReference(holding) };
    }
    if (locals !== void 0) {
      return { locals: ensureLocalsReference(locals) };
    }
    if (box !== void 0) {
      return { box: ensureBoxReference(box) };
    }
  }
  throw new Error(`Not a resource reference: ${input}`);
}
const TX_TAG = new TextEncoder().encode("TX");
class Transaction {
  constructor(params) {
    if (!isTransactionType(params.type)) {
      throw new Error(`Invalid transaction type: ${params.type}`);
    }
    this.type = params.type;
    this.sender = ensureAddress(params.sender);
    this.note = ensureUint8Array(params.note ?? new Uint8Array());
    this.lease = optionalFixedLengthByteArray(params.lease, ALGORAND_TRANSACTION_LEASE_LENGTH, "lease");
    this.rekeyTo = optionalAddress(params.rekeyTo);
    this.group = void 0;
    this.firstValid = ensureUint64(params.suggestedParams.firstValid);
    this.lastValid = ensureUint64(params.suggestedParams.lastValid);
    if (params.suggestedParams.genesisID) {
      if (typeof params.suggestedParams.genesisID !== "string") {
        throw new Error("Genesis ID must be a string if present");
      }
      this.genesisID = params.suggestedParams.genesisID;
    }
    this.genesisHash = optionalUint8Array(params.suggestedParams.genesisHash);
    const fieldsPresent = [];
    if (params.paymentParams)
      fieldsPresent.push(TransactionType.pay);
    if (params.keyregParams)
      fieldsPresent.push(TransactionType.keyreg);
    if (params.assetConfigParams)
      fieldsPresent.push(TransactionType.acfg);
    if (params.assetTransferParams)
      fieldsPresent.push(TransactionType.axfer);
    if (params.assetFreezeParams)
      fieldsPresent.push(TransactionType.afrz);
    if (params.appCallParams)
      fieldsPresent.push(TransactionType.appl);
    if (params.stateProofParams)
      fieldsPresent.push(TransactionType.stpf);
    if (params.heartbeatParams)
      fieldsPresent.push(TransactionType.hb);
    if (fieldsPresent.length !== 1) {
      throw new Error(`Transaction has wrong number of type fields present (${fieldsPresent.length}): ${fieldsPresent}`);
    }
    if (this.type !== fieldsPresent[0]) {
      throw new Error(`Transaction has type ${this.type} but fields present for ${fieldsPresent[0]}`);
    }
    if (params.paymentParams) {
      this.payment = {
        receiver: ensureAddress(params.paymentParams.receiver),
        amount: ensureUint64(params.paymentParams.amount),
        closeRemainderTo: optionalAddress(params.paymentParams.closeRemainderTo)
      };
    }
    if (params.keyregParams) {
      this.keyreg = {
        voteKey: getKeyregKey(params.keyregParams.voteKey, "voteKey", KEYREG_VOTE_KEY_LENGTH),
        selectionKey: getKeyregKey(params.keyregParams.selectionKey, "selectionKey", KEYREG_SELECTION_KEY_LENGTH),
        stateProofKey: getKeyregKey(params.keyregParams.stateProofKey, "stateProofKey", KEYREG_STATE_PROOF_KEY_LENGTH),
        voteFirst: optionalUint64(params.keyregParams.voteFirst),
        voteLast: optionalUint64(params.keyregParams.voteLast),
        voteKeyDilution: optionalUint64(params.keyregParams.voteKeyDilution),
        nonParticipation: ensureBoolean(params.keyregParams.nonParticipation ?? false)
      };
      if (this.keyreg.nonParticipation && (this.keyreg.voteKey || this.keyreg.selectionKey || this.keyreg.stateProofKey || typeof this.keyreg.voteFirst !== "undefined" || typeof this.keyreg.voteLast !== "undefined" || typeof this.keyreg.voteKeyDilution !== "undefined")) {
        throw new Error("nonParticipation is true but participation params are present.");
      }
      if (
        // If we are participating
        !this.keyreg.nonParticipation && // And *ANY* participating fields are present
        (this.keyreg.voteKey || this.keyreg.selectionKey || this.keyreg.stateProofKey || typeof this.keyreg.voteFirst !== "undefined" || typeof this.keyreg.voteLast !== "undefined" || typeof this.keyreg.voteKeyDilution !== "undefined") && // Then *ALL* participating fields must be present (with an exception for stateProofKey,
        // which was introduced later so for backwards compatibility we don't require it)
        !(this.keyreg.voteKey && this.keyreg.selectionKey && typeof this.keyreg.voteFirst !== "undefined" && typeof this.keyreg.voteLast !== "undefined" && typeof this.keyreg.voteKeyDilution !== "undefined")
      ) {
        throw new Error(`Online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution`);
      }
    }
    if (params.assetConfigParams) {
      this.assetConfig = {
        assetIndex: ensureUint64(params.assetConfigParams.assetIndex ?? 0),
        total: ensureUint64(params.assetConfigParams.total ?? 0),
        decimals: ensureSafeUnsignedInteger(params.assetConfigParams.decimals ?? 0),
        defaultFrozen: ensureBoolean(params.assetConfigParams.defaultFrozen ?? false),
        manager: optionalAddress(params.assetConfigParams.manager),
        reserve: optionalAddress(params.assetConfigParams.reserve),
        freeze: optionalAddress(params.assetConfigParams.freeze),
        clawback: optionalAddress(params.assetConfigParams.clawback),
        unitName: params.assetConfigParams.unitName,
        assetName: params.assetConfigParams.assetName,
        assetURL: params.assetConfigParams.assetURL,
        assetMetadataHash: optionalFixedLengthByteArray(params.assetConfigParams.assetMetadataHash, ASSET_METADATA_HASH_LENGTH, "assetMetadataHash")
      };
    }
    if (params.assetTransferParams) {
      this.assetTransfer = {
        assetIndex: ensureUint64(params.assetTransferParams.assetIndex),
        amount: ensureUint64(params.assetTransferParams.amount),
        assetSender: optionalAddress(params.assetTransferParams.assetSender),
        receiver: ensureAddress(params.assetTransferParams.receiver),
        closeRemainderTo: optionalAddress(params.assetTransferParams.closeRemainderTo)
      };
    }
    if (params.assetFreezeParams) {
      this.assetFreeze = {
        assetIndex: ensureUint64(params.assetFreezeParams.assetIndex),
        freezeAccount: ensureAddress(params.assetFreezeParams.freezeTarget),
        frozen: ensureBoolean(params.assetFreezeParams.frozen)
      };
    }
    if (params.appCallParams) {
      const { onComplete } = params.appCallParams;
      if (!isOnApplicationComplete(onComplete)) {
        throw new Error(`Invalid onCompletion value: ${onComplete}`);
      }
      this.applicationCall = {
        appIndex: ensureUint64(params.appCallParams.appIndex),
        onComplete,
        numLocalInts: ensureSafeUnsignedInteger(params.appCallParams.numLocalInts ?? 0),
        numLocalByteSlices: ensureSafeUnsignedInteger(params.appCallParams.numLocalByteSlices ?? 0),
        numGlobalInts: ensureSafeUnsignedInteger(params.appCallParams.numGlobalInts ?? 0),
        numGlobalByteSlices: ensureSafeUnsignedInteger(params.appCallParams.numGlobalByteSlices ?? 0),
        extraPages: ensureSafeUnsignedInteger(params.appCallParams.extraPages ?? 0),
        approvalProgram: ensureUint8Array(params.appCallParams.approvalProgram ?? new Uint8Array()),
        clearProgram: ensureUint8Array(params.appCallParams.clearProgram ?? new Uint8Array()),
        appArgs: ensureArray(params.appCallParams.appArgs ?? []).map(ensureUint8Array),
        accounts: ensureArray(params.appCallParams.accounts ?? []).map(ensureAddress),
        foreignApps: ensureArray(params.appCallParams.foreignApps ?? []).map(ensureUint64),
        foreignAssets: ensureArray(params.appCallParams.foreignAssets ?? []).map(ensureUint64),
        boxes: ensureArray(params.appCallParams.boxes ?? []).map(ensureBoxReference),
        access: ensureArray(params.appCallParams.access ?? []).map(ensureResourceReference),
        rejectVersion: ensureSafeUnsignedInteger(params.appCallParams.rejectVersion ?? 0)
      };
    }
    if (params.stateProofParams) {
      this.stateProof = {
        stateProofType: ensureSafeUnsignedInteger(params.stateProofParams.stateProofType ?? 0),
        stateProof: params.stateProofParams.stateProof,
        message: params.stateProofParams.message
      };
    }
    if (params.heartbeatParams) {
      this.heartbeat = new Heartbeat({
        address: params.heartbeatParams.address,
        proof: params.heartbeatParams.proof,
        seed: params.heartbeatParams.seed,
        voteID: params.heartbeatParams.voteID,
        keyDilution: params.heartbeatParams.keyDilution
      });
    }
    this.fee = ensureUint64(params.suggestedParams.fee);
    const feeDependsOnSize = !ensureBoolean(params.suggestedParams.flatFee ?? false);
    if (feeDependsOnSize) {
      const minFee = ensureUint64(params.suggestedParams.minFee);
      this.fee *= BigInt(this.estimateSize());
      if (this.fee < minFee) {
        this.fee = minFee;
      }
    }
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return Transaction.encodingSchema;
  }
  toEncodingData() {
    const data = /* @__PURE__ */ new Map([
      ["type", this.type],
      ["fv", this.firstValid],
      ["lv", this.lastValid],
      ["snd", this.sender],
      ["gen", this.genesisID],
      ["gh", this.genesisHash],
      ["fee", this.fee],
      ["note", this.note],
      ["lx", this.lease],
      ["rekey", this.rekeyTo],
      ["grp", this.group]
    ]);
    if (this.payment) {
      data.set("amt", this.payment.amount);
      data.set("rcv", this.payment.receiver);
      data.set("close", this.payment.closeRemainderTo);
      return data;
    }
    if (this.keyreg) {
      data.set("votekey", this.keyreg.voteKey);
      data.set("selkey", this.keyreg.selectionKey);
      data.set("sprfkey", this.keyreg.stateProofKey);
      data.set("votefst", this.keyreg.voteFirst);
      data.set("votelst", this.keyreg.voteLast);
      data.set("votekd", this.keyreg.voteKeyDilution);
      data.set("nonpart", this.keyreg.nonParticipation);
      return data;
    }
    if (this.assetConfig) {
      data.set("caid", this.assetConfig.assetIndex);
      const assetParams = /* @__PURE__ */ new Map([
        ["t", this.assetConfig.total],
        ["dc", this.assetConfig.decimals],
        ["df", this.assetConfig.defaultFrozen],
        ["m", this.assetConfig.manager],
        ["r", this.assetConfig.reserve],
        ["f", this.assetConfig.freeze],
        ["c", this.assetConfig.clawback],
        ["un", this.assetConfig.unitName],
        ["an", this.assetConfig.assetName],
        ["au", this.assetConfig.assetURL],
        ["am", this.assetConfig.assetMetadataHash]
      ]);
      data.set("apar", assetParams);
      return data;
    }
    if (this.assetTransfer) {
      data.set("xaid", this.assetTransfer.assetIndex);
      data.set("aamt", this.assetTransfer.amount);
      data.set("arcv", this.assetTransfer.receiver);
      data.set("aclose", this.assetTransfer.closeRemainderTo);
      data.set("asnd", this.assetTransfer.assetSender);
      return data;
    }
    if (this.assetFreeze) {
      data.set("faid", this.assetFreeze.assetIndex);
      data.set("afrz", this.assetFreeze.frozen);
      data.set("fadd", this.assetFreeze.freezeAccount);
      return data;
    }
    if (this.applicationCall) {
      data.set("apid", this.applicationCall.appIndex);
      data.set("apan", this.applicationCall.onComplete);
      data.set("apaa", this.applicationCall.appArgs);
      data.set("apat", this.applicationCall.accounts);
      data.set("apas", this.applicationCall.foreignAssets);
      data.set("apfa", this.applicationCall.foreignApps);
      data.set("apbx", boxReferencesToEncodingData(this.applicationCall.boxes, this.applicationCall.foreignApps, this.applicationCall.appIndex));
      data.set("al", resourceReferencesToEncodingData(this.applicationCall.appIndex, this.applicationCall.access));
      data.set("apap", this.applicationCall.approvalProgram);
      data.set("apsu", this.applicationCall.clearProgram);
      data.set("apls", /* @__PURE__ */ new Map([
        ["nui", this.applicationCall.numLocalInts],
        ["nbs", this.applicationCall.numLocalByteSlices]
      ]));
      data.set("apgs", /* @__PURE__ */ new Map([
        ["nui", this.applicationCall.numGlobalInts],
        ["nbs", this.applicationCall.numGlobalByteSlices]
      ]));
      data.set("apep", this.applicationCall.extraPages);
      data.set("aprv", this.applicationCall.rejectVersion);
      return data;
    }
    if (this.stateProof) {
      data.set("sptype", this.stateProof.stateProofType);
      data.set("sp", this.stateProof.stateProof ? this.stateProof.stateProof.toEncodingData() : void 0);
      data.set("spmsg", this.stateProof.message ? this.stateProof.message.toEncodingData() : void 0);
      return data;
    }
    if (this.heartbeat) {
      const heartbeat = new Heartbeat({
        address: this.heartbeat.address,
        proof: this.heartbeat.proof,
        seed: this.heartbeat.seed,
        voteID: this.heartbeat.voteID,
        keyDilution: this.heartbeat.keyDilution
      });
      data.set("hb", heartbeat.toEncodingData());
      return data;
    }
    throw new Error(`Unexpected transaction type: ${this.type}`);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded logic sig account: ${data}`);
    }
    const suggestedParams = {
      minFee: BigInt(0),
      flatFee: true,
      fee: data.get("fee") ?? 0,
      firstValid: data.get("fv") ?? 0,
      lastValid: data.get("lv") ?? 0,
      genesisHash: data.get("gh"),
      genesisID: data.get("gen")
    };
    const txnType = data.get("type");
    if (!isTransactionType(txnType)) {
      throw new Error(`Unrecognized transaction type: ${txnType}`);
    }
    const params = {
      type: txnType,
      sender: data.get("snd") ?? Address.zeroAddress(),
      note: data.get("note"),
      lease: data.get("lx"),
      suggestedParams
    };
    if (data.get("rekey")) {
      params.rekeyTo = data.get("rekey");
    }
    if (params.type === TransactionType.pay) {
      const paymentParams = {
        amount: data.get("amt") ?? 0,
        receiver: data.get("rcv") ?? Address.zeroAddress()
      };
      if (data.get("close")) {
        paymentParams.closeRemainderTo = data.get("close");
      }
      params.paymentParams = paymentParams;
    } else if (params.type === TransactionType.keyreg) {
      const keyregParams = {
        voteKey: data.get("votekey"),
        selectionKey: data.get("selkey"),
        stateProofKey: data.get("sprfkey"),
        voteFirst: data.get("votefst"),
        voteLast: data.get("votelst"),
        voteKeyDilution: data.get("votekd"),
        nonParticipation: data.get("nonpart")
      };
      params.keyregParams = keyregParams;
    } else if (params.type === TransactionType.acfg) {
      const assetConfigParams = {
        assetIndex: data.get("caid")
      };
      if (data.get("apar")) {
        const assetParams = data.get("apar");
        assetConfigParams.total = assetParams.get("t");
        assetConfigParams.decimals = assetParams.get("dc");
        assetConfigParams.defaultFrozen = assetParams.get("df");
        assetConfigParams.unitName = assetParams.get("un");
        assetConfigParams.assetName = assetParams.get("an");
        assetConfigParams.assetURL = assetParams.get("au");
        assetConfigParams.assetMetadataHash = assetParams.get("am");
        if (assetParams.get("m")) {
          assetConfigParams.manager = assetParams.get("m");
        }
        if (assetParams.get("r")) {
          assetConfigParams.reserve = assetParams.get("r");
        }
        if (assetParams.get("f")) {
          assetConfigParams.freeze = assetParams.get("f");
        }
        if (assetParams.get("c")) {
          assetConfigParams.clawback = assetParams.get("c");
        }
      }
      params.assetConfigParams = assetConfigParams;
    } else if (params.type === TransactionType.axfer) {
      const assetTransferParams = {
        assetIndex: data.get("xaid") ?? 0,
        amount: data.get("aamt") ?? 0,
        receiver: data.get("arcv") ?? Address.zeroAddress()
      };
      if (data.get("aclose")) {
        assetTransferParams.closeRemainderTo = data.get("aclose");
      }
      if (data.get("asnd")) {
        assetTransferParams.assetSender = data.get("asnd");
      }
      params.assetTransferParams = assetTransferParams;
    } else if (params.type === TransactionType.afrz) {
      const assetFreezeParams = {
        assetIndex: data.get("faid") ?? 0,
        freezeTarget: data.get("fadd") ?? Address.zeroAddress(),
        frozen: data.get("afrz") ?? false
      };
      params.assetFreezeParams = assetFreezeParams;
    } else if (params.type === TransactionType.appl) {
      const appCallParams = {
        appIndex: data.get("apid") ?? 0,
        onComplete: ensureSafeUnsignedInteger(data.get("apan") ?? 0),
        appArgs: data.get("apaa"),
        accounts: data.get("apat"),
        foreignAssets: data.get("apas"),
        foreignApps: data.get("apfa"),
        approvalProgram: data.get("apap"),
        clearProgram: data.get("apsu"),
        extraPages: data.get("apep"),
        rejectVersion: data.get("aprv") ?? 0
      };
      const localSchema = data.get("apls");
      if (localSchema) {
        appCallParams.numLocalInts = localSchema.get("nui");
        appCallParams.numLocalByteSlices = localSchema.get("nbs");
      }
      const globalSchema = data.get("apgs");
      if (globalSchema) {
        appCallParams.numGlobalInts = globalSchema.get("nui");
        appCallParams.numGlobalByteSlices = globalSchema.get("nbs");
      }
      const boxes = data.get("apbx");
      if (boxes) {
        appCallParams.boxes = boxes.map((box) => {
          const index = ensureSafeUnsignedInteger(box.get("i") ?? 0);
          const name = ensureUint8Array(box.get("n") ?? new Uint8Array());
          if (index === 0) {
            return {
              appIndex: 0,
              name
            };
          }
          if (!appCallParams.foreignApps || index > appCallParams.foreignApps.length) {
            throw new Error(`Cannot find foreign app index ${index} in ${appCallParams.foreignApps}`);
          }
          return {
            appIndex: appCallParams.foreignApps[index - 1],
            name
          };
        });
      }
      const references = data.get("al");
      if (references) {
        appCallParams.access = convertIndicesToResourceReferences(references);
      }
      params.appCallParams = appCallParams;
    } else if (params.type === TransactionType.stpf) {
      const stateProofParams = {
        stateProofType: data.get("sptype"),
        stateProof: data.get("sp") ? StateProof.fromEncodingData(data.get("sp")) : void 0,
        message: data.get("spmsg") ? StateProofMessage.fromEncodingData(data.get("spmsg")) : void 0
      };
      params.stateProofParams = stateProofParams;
    } else if (params.type === TransactionType.hb) {
      const heartbeat = Heartbeat.fromEncodingData(data.get("hb"));
      const heartbeatParams = {
        address: heartbeat.address,
        proof: heartbeat.proof,
        seed: heartbeat.seed,
        voteID: heartbeat.voteID,
        keyDilution: heartbeat.keyDilution
      };
      params.heartbeatParams = heartbeatParams;
    } else {
      const exhaustiveCheck = params.type;
      throw new Error(`Unexpected transaction type: ${exhaustiveCheck}`);
    }
    const txn = new Transaction(params);
    if (data.get("grp")) {
      const group = ensureUint8Array(data.get("grp"));
      if (group.byteLength !== ALGORAND_TRANSACTION_GROUP_LENGTH) {
        throw new Error(`Invalid group length: ${group.byteLength}`);
      }
      txn.group = group;
    }
    return txn;
  }
  estimateSize() {
    return this.toByte().length + NUM_ADDL_BYTES_AFTER_SIGNING;
  }
  bytesToSign() {
    const encodedMsg = this.toByte();
    return concatArrays(TX_TAG, encodedMsg);
  }
  toByte() {
    return encodeMsgpack(this);
  }
  // returns the raw signature
  rawSignTxn(sk) {
    const toBeSigned = this.bytesToSign();
    const sig = sign(toBeSigned, sk);
    return sig;
  }
  signTxn(sk) {
    const keypair = keyPairFromSecretKey(sk);
    const signerAddr = new Address(keypair.publicKey);
    const sig = this.rawSignTxn(sk);
    return this.attachSignature(signerAddr, sig);
  }
  attachSignature(signerAddr, signature) {
    if (!isValidSignatureLength(signature.length)) {
      throw new Error("Invalid signature length");
    }
    const sTxn = /* @__PURE__ */ new Map([
      ["sig", signature],
      ["txn", this.toEncodingData()]
    ]);
    const signerAddrObj = ensureAddress(signerAddr);
    if (!this.sender.equals(signerAddrObj)) {
      sTxn.set("sgnr", signerAddrObj);
    }
    const stxnSchema = new NamedMapSchema(allOmitEmpty([
      {
        key: "txn",
        valueSchema: Transaction.encodingSchema
      },
      {
        key: "sig",
        valueSchema: new FixedLengthByteArraySchema(64)
      },
      {
        key: "sgnr",
        valueSchema: new OptionalSchema(new AddressSchema())
      }
    ]));
    return msgpackRawEncode(stxnSchema.prepareMsgpack(sTxn));
  }
  rawTxID() {
    const enMsg = this.toByte();
    const gh = concatArrays(TX_TAG, enMsg);
    return Uint8Array.from(genericHash(gh));
  }
  txID() {
    const hash2 = this.rawTxID();
    return base32.encode(hash2).slice(0, ALGORAND_TRANSACTION_LENGTH);
  }
}
Transaction.encodingSchema = new NamedMapSchema(allOmitEmpty([
  // Common
  { key: "type", valueSchema: new StringSchema() },
  { key: "snd", valueSchema: new AddressSchema() },
  { key: "lv", valueSchema: new Uint64Schema() },
  { key: "gen", valueSchema: new OptionalSchema(new StringSchema()) },
  {
    key: "gh",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  { key: "fee", valueSchema: new Uint64Schema() },
  { key: "fv", valueSchema: new Uint64Schema() },
  { key: "note", valueSchema: new ByteArraySchema() },
  {
    key: "lx",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  { key: "rekey", valueSchema: new OptionalSchema(new AddressSchema()) },
  {
    key: "grp",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  // We mark all top-level type-specific fields optional because they will not be present when
  // the transaction is not that type.
  // Payment
  { key: "amt", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "rcv", valueSchema: new OptionalSchema(new AddressSchema()) },
  { key: "close", valueSchema: new OptionalSchema(new AddressSchema()) },
  // Keyreg
  {
    key: "votekey",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  {
    key: "selkey",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  {
    key: "sprfkey",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
  },
  { key: "votefst", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "votelst", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "votekd", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "nonpart", valueSchema: new OptionalSchema(new BooleanSchema()) },
  // AssetConfig
  { key: "caid", valueSchema: new OptionalSchema(new Uint64Schema()) },
  {
    key: "apar",
    valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
      { key: "t", valueSchema: new Uint64Schema() },
      { key: "dc", valueSchema: new Uint64Schema() },
      { key: "df", valueSchema: new BooleanSchema() },
      {
        key: "m",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "r",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "f",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "c",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "un",
        valueSchema: new OptionalSchema(new StringSchema())
      },
      {
        key: "an",
        valueSchema: new OptionalSchema(new StringSchema())
      },
      {
        key: "au",
        valueSchema: new OptionalSchema(new StringSchema())
      },
      {
        key: "am",
        valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
      }
    ])))
  },
  // AssetTransfer
  { key: "xaid", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "aamt", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "arcv", valueSchema: new OptionalSchema(new AddressSchema()) },
  { key: "aclose", valueSchema: new OptionalSchema(new AddressSchema()) },
  { key: "asnd", valueSchema: new OptionalSchema(new AddressSchema()) },
  // AssetFreeze
  { key: "faid", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "afrz", valueSchema: new OptionalSchema(new BooleanSchema()) },
  { key: "fadd", valueSchema: new OptionalSchema(new AddressSchema()) },
  // Application
  { key: "apid", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "apan", valueSchema: new OptionalSchema(new Uint64Schema()) },
  {
    key: "apaa",
    valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema()))
  },
  {
    key: "apat",
    valueSchema: new OptionalSchema(new ArraySchema(new AddressSchema()))
  },
  {
    key: "apas",
    valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema()))
  },
  {
    key: "apfa",
    valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema()))
  },
  {
    key: "apbx",
    valueSchema: new OptionalSchema(new ArraySchema(new NamedMapSchema(allOmitEmpty([
      {
        key: "i",
        valueSchema: new Uint64Schema()
      },
      {
        key: "n",
        valueSchema: new ByteArraySchema()
      }
    ]))))
  },
  {
    key: "al",
    valueSchema: new OptionalSchema(new ArraySchema(new NamedMapSchema(allOmitEmpty([
      {
        key: "d",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "s",
        valueSchema: new OptionalSchema(new Uint64Schema())
      },
      {
        key: "p",
        valueSchema: new OptionalSchema(new Uint64Schema())
      },
      {
        key: "h",
        valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
          {
            key: "d",
            valueSchema: new Uint64Schema()
          },
          {
            key: "s",
            valueSchema: new Uint64Schema()
          }
        ])))
      },
      {
        key: "l",
        valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
          {
            key: "d",
            valueSchema: new Uint64Schema()
          },
          {
            key: "p",
            valueSchema: new Uint64Schema()
          }
        ])))
      },
      {
        key: "b",
        valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
          {
            key: "i",
            valueSchema: new Uint64Schema()
          },
          {
            key: "n",
            valueSchema: new ByteArraySchema()
          }
        ])))
      }
    ]))))
  },
  { key: "apap", valueSchema: new OptionalSchema(new ByteArraySchema()) },
  { key: "apsu", valueSchema: new OptionalSchema(new ByteArraySchema()) },
  {
    key: "apls",
    valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
      {
        key: "nui",
        valueSchema: new Uint64Schema()
      },
      {
        key: "nbs",
        valueSchema: new Uint64Schema()
      }
    ])))
  },
  {
    key: "apgs",
    valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
      {
        key: "nui",
        valueSchema: new Uint64Schema()
      },
      {
        key: "nbs",
        valueSchema: new Uint64Schema()
      }
    ])))
  },
  { key: "apep", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "aprv", valueSchema: new OptionalSchema(new Uint64Schema()) },
  // StateProof
  { key: "sptype", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "sp", valueSchema: new OptionalSchema(StateProof.encodingSchema) },
  {
    key: "spmsg",
    valueSchema: new OptionalSchema(StateProofMessage.encodingSchema)
  },
  // Heartbeat
  { key: "hb", valueSchema: new OptionalSchema(Heartbeat.encodingSchema) }
]));
const MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([
  77,
  117,
  108,
  116,
  105,
  115,
  105,
  103,
  65,
  100,
  100,
  114
]);
const INVALID_MSIG_VERSION_ERROR_MSG = "invalid multisig version";
const INVALID_MSIG_THRESHOLD_ERROR_MSG = "bad multisig threshold";
const INVALID_MSIG_PK_ERROR_MSG = "bad multisig public key - wrong length";
const UNEXPECTED_PK_LEN_ERROR_MSG = "nacl public key length is not 32 bytes";
function pksFromAddresses(addrs) {
  return addrs.map((addr) => {
    if (typeof addr === "string") {
      return Address.fromString(addr).publicKey;
    }
    return addr.publicKey;
  });
}
function addressFromMultisigPreImg({ version: version2, threshold: threshold2, pks }) {
  if (version2 !== 1 || version2 > 255 || version2 < 0) {
    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);
  }
  if (threshold2 === 0 || pks.length === 0 || threshold2 > pks.length || threshold2 > 255) {
    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);
  }
  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;
  if (pkLen !== PUBLIC_KEY_LENGTH) {
    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);
  }
  const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);
  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);
  merged.set([version2], MULTISIG_PREIMG2ADDR_PREFIX.length);
  merged.set([threshold2], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);
  for (let i2 = 0; i2 < pks.length; i2++) {
    if (pks[i2].length !== pkLen) {
      throw new Error(INVALID_MSIG_PK_ERROR_MSG);
    }
    merged.set(pks[i2], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i2 * pkLen);
  }
  return new Address(Uint8Array.from(genericHash(merged)));
}
function verifyMultisig(toBeVerified, msig, publicKey) {
  const version2 = msig.v;
  const threshold2 = msig.thr;
  const subsigs = msig.subsig;
  const pks = subsigs.map((subsig) => subsig.pk);
  if (msig.subsig.length < threshold2) {
    return false;
  }
  let pk;
  try {
    pk = addressFromMultisigPreImg({ version: version2, threshold: threshold2, pks }).publicKey;
  } catch (e3) {
    return false;
  }
  if (!arrayEqual(pk, publicKey)) {
    return false;
  }
  let counter = 0;
  for (const subsig of subsigs) {
    if (subsig.s !== void 0) {
      counter += 1;
    }
  }
  if (counter < threshold2) {
    return false;
  }
  let verifiedCounter = 0;
  for (const subsig of subsigs) {
    if (subsig.s !== void 0) {
      if (verify(toBeVerified, subsig.s, subsig.pk)) {
        verifiedCounter += 1;
      }
    }
  }
  if (verifiedCounter < threshold2) {
    return false;
  }
  return true;
}
const ENCODED_SUBSIG_SCHEMA = new NamedMapSchema(allOmitEmpty([
  {
    key: "pk",
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "s",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
  }
]));
function encodedSubsigFromEncodingData(data) {
  if (!(data instanceof Map)) {
    throw new Error(`Invalid decoded EncodedSubsig: ${data}`);
  }
  const subsig = {
    pk: data.get("pk")
  };
  if (data.get("s")) {
    subsig.s = data.get("s");
  }
  return subsig;
}
function encodedSubsigToEncodingData(subsig) {
  const data = /* @__PURE__ */ new Map([["pk", subsig.pk]]);
  if (subsig.s) {
    data.set("s", subsig.s);
  }
  return data;
}
const ENCODED_MULTISIG_SCHEMA = new NamedMapSchema(allOmitEmpty([
  {
    key: "v",
    valueSchema: new Uint64Schema()
  },
  {
    key: "thr",
    valueSchema: new Uint64Schema()
  },
  {
    key: "subsig",
    valueSchema: new ArraySchema(ENCODED_SUBSIG_SCHEMA)
  }
]));
function encodedMultiSigFromEncodingData(data) {
  if (!(data instanceof Map)) {
    throw new Error(`Invalid decoded EncodedMultiSig: ${data}`);
  }
  return {
    v: ensureSafeUnsignedInteger(data.get("v")),
    thr: ensureSafeUnsignedInteger(data.get("thr")),
    subsig: data.get("subsig").map(encodedSubsigFromEncodingData)
  };
}
function encodedMultiSigToEncodingData(msig) {
  return /* @__PURE__ */ new Map([
    ["v", msig.v],
    ["thr", msig.thr],
    ["subsig", msig.subsig.map(encodedSubsigToEncodingData)]
  ]);
}
const base64regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
function sanityCheckProgram(program) {
  if (!program || program.length === 0)
    throw new Error("empty program");
  const lineBreakOrd = "\n".charCodeAt(0);
  const blankSpaceOrd = " ".charCodeAt(0);
  const tildeOrd = "~".charCodeAt(0);
  const isPrintable = (x2) => blankSpaceOrd <= x2 && x2 <= tildeOrd;
  const isAsciiPrintable = program.every((x2) => x2 === lineBreakOrd || isPrintable(x2));
  if (isAsciiPrintable) {
    const programStr = new TextDecoder().decode(program);
    if (isValidAddress(programStr))
      throw new Error("requesting program bytes, get Algorand address");
    if (base64regex.test(programStr))
      throw new Error("program should not be b64 encoded");
    throw new Error("program bytes are all ASCII printable characters, not looking like Teal byte code");
  }
}
const programTag = new TextEncoder().encode("Program");
const multisigProgramTag = new TextEncoder().encode("MsigProgram");
class LogicSig {
  constructor(program, programArgs) {
    if (programArgs && (!Array.isArray(programArgs) || !programArgs.every((arg) => arg.constructor === Uint8Array))) {
      throw new TypeError("Invalid arguments");
    }
    let args = [];
    if (programArgs != null)
      args = programArgs.map((arg) => new Uint8Array(arg));
    sanityCheckProgram(program);
    this.logic = program;
    this.args = args;
    this.sig = void 0;
    this.msig = void 0;
    this.lmsig = void 0;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return LogicSig.encodingSchema;
  }
  toEncodingData() {
    const data = /* @__PURE__ */ new Map([
      ["l", this.logic],
      ["arg", this.args],
      ["sig", this.sig]
    ]);
    if (this.msig) {
      data.set("msig", encodedMultiSigToEncodingData(this.msig));
    }
    if (this.lmsig) {
      data.set("lmsig", encodedMultiSigToEncodingData(this.lmsig));
    }
    return data;
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded logic sig: ${data}`);
    }
    const lsig = new LogicSig(data.get("l"), data.get("arg"));
    lsig.sig = data.get("sig");
    if (data.get("msig")) {
      lsig.msig = encodedMultiSigFromEncodingData(data.get("msig"));
    }
    if (data.get("lmsig")) {
      lsig.lmsig = encodedMultiSigFromEncodingData(data.get("lmsig"));
    }
    return lsig;
  }
  /**
   * Performs signature verification
   * @param publicKey - Verification key (derived from sender address or escrow address)
   */
  verify(publicKey) {
    const sigCount = [this.sig, this.msig, this.lmsig].filter(Boolean).length;
    if (sigCount > 1) {
      return false;
    }
    try {
      sanityCheckProgram(this.logic);
    } catch (e3) {
      return false;
    }
    const toBeSigned = concatArrays(programTag, this.logic);
    if (!this.sig && !this.msig && !this.lmsig) {
      const hash2 = genericHash(toBeSigned);
      return arrayEqual(hash2, publicKey);
    }
    if (this.sig) {
      return verify(toBeSigned, this.sig, publicKey);
    }
    if (this.lmsig) {
      const multisigAddr = addressFromMultisigPreImg({
        version: this.lmsig.v,
        threshold: this.lmsig.thr,
        pks: this.lmsig.subsig.map((subsig) => subsig.pk)
      });
      const lmsigProgram = concatArrays(multisigProgramTag, multisigAddr.publicKey, this.logic);
      return verifyMultisig(lmsigProgram, this.lmsig, publicKey);
    }
    if (this.msig) {
      return verifyMultisig(toBeSigned, this.msig, publicKey);
    }
    return false;
  }
  /**
   * Compute hash of the logic sig program (that is the same as escrow account address) as string address
   * @returns String representation of the address
   */
  address() {
    const toBeSigned = concatArrays(programTag, this.logic);
    const hash2 = genericHash(toBeSigned);
    return new Address(Uint8Array.from(hash2));
  }
  /**
   * Creates signature (if no msig provided) or multi signature otherwise
   * @param secretKey - Secret key to sign with
   * @param msig - Multisig account as \{version, threshold, addrs\}
   */
  sign(secretKey, msig) {
    if (msig == null) {
      this.sig = this.signProgram(secretKey);
    } else {
      const subsigs = pksFromAddresses(msig.addrs).map((pk) => ({ pk }));
      this.lmsig = {
        v: msig.version,
        thr: msig.threshold,
        subsig: subsigs
      };
      const [sig, index] = this.singleSignMultisig(secretKey, this.lmsig);
      this.lmsig.subsig[index].s = sig;
    }
  }
  /**
   * Appends a signature to multi signature
   * @param secretKey - Secret key to sign with
   */
  appendToMultisig(secretKey) {
    if (this.lmsig === void 0) {
      throw new Error("no multisig present");
    }
    const [sig, index] = this.singleSignMultisig(secretKey, this.lmsig);
    this.lmsig.subsig[index].s = sig;
  }
  signProgram(secretKey) {
    const toBeSigned = concatArrays(programTag, this.logic);
    const sig = sign(toBeSigned, secretKey);
    return sig;
  }
  signProgramMultisig(secretKey, msig) {
    const multisigAddr = addressFromMultisigPreImg({
      version: msig.v,
      threshold: msig.thr,
      pks: msig.subsig.map((subsig) => subsig.pk)
    });
    const toBeSigned = concatArrays(multisigProgramTag, multisigAddr.publicKey, this.logic);
    const sig = sign(toBeSigned, secretKey);
    return sig;
  }
  singleSignMultisig(secretKey, msig) {
    let index = -1;
    const myPk = keyPairFromSecretKey(secretKey).publicKey;
    for (let i2 = 0; i2 < msig.subsig.length; i2++) {
      const { pk } = msig.subsig[i2];
      if (arrayEqual(pk, myPk)) {
        index = i2;
        break;
      }
    }
    if (index === -1) {
      throw new Error("invalid secret key");
    }
    const sig = this.signProgramMultisig(secretKey, msig);
    return [sig, index];
  }
  toByte() {
    return encodeMsgpack(this);
  }
  static fromByte(encoded) {
    return decodeMsgpack(encoded, LogicSig);
  }
}
LogicSig.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "l",
    valueSchema: new ByteArraySchema()
  },
  {
    key: "arg",
    valueSchema: new ArraySchema(new ByteArraySchema())
  },
  {
    key: "sig",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
  },
  {
    key: "msig",
    valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA)
  },
  {
    key: "lmsig",
    valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA)
  }
]));
new NamedMapSchema(allOmitEmpty([
  {
    key: "lsig",
    valueSchema: LogicSig.encodingSchema
  },
  {
    key: "sigkey",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  }
]));
new TextEncoder().encode("ProgData");
class SignedTransaction {
  constructor({ txn, sig, msig, lsig, sgnr }) {
    this.txn = txn;
    this.sig = sig;
    this.msig = msig;
    this.lsig = lsig;
    this.sgnr = sgnr;
    let numberOfSigs = 0;
    if (sig)
      numberOfSigs += 1;
    if (msig)
      numberOfSigs += 1;
    if (lsig)
      numberOfSigs += 1;
    if (numberOfSigs > 1) {
      throw new Error(`SignedTransaction must not have more than 1 signature. Got ${numberOfSigs}`);
    }
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return SignedTransaction.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["txn", this.txn.toEncodingData()],
      ["sig", this.sig],
      [
        "msig",
        this.msig ? encodedMultiSigToEncodingData(this.msig) : void 0
      ],
      ["lsig", this.lsig ? this.lsig.toEncodingData() : void 0],
      ["sgnr", this.sgnr]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SignedTransaction: ${data}`);
    }
    return new SignedTransaction({
      txn: Transaction.fromEncodingData(data.get("txn")),
      sig: data.get("sig"),
      msig: data.get("msig") ? encodedMultiSigFromEncodingData(data.get("msig")) : void 0,
      lsig: data.get("lsig") ? LogicSig.fromEncodingData(data.get("lsig")) : void 0,
      sgnr: data.get("sgnr")
    });
  }
}
SignedTransaction.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "txn",
    valueSchema: Transaction.encodingSchema
  },
  {
    key: "sig",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
  },
  {
    key: "msig",
    valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA)
  },
  {
    key: "lsig",
    valueSchema: new OptionalSchema(LogicSig.encodingSchema)
  },
  {
    key: "sgnr",
    valueSchema: new OptionalSchema(new AddressSchema())
  }
]));
class StateProofTrackingData {
  constructor(params) {
    this.stateProofVotersCommitment = params.stateProofVotersCommitment;
    this.stateProofOnlineTotalWeight = params.stateProofOnlineTotalWeight;
    this.stateProofNextRound = params.stateProofNextRound;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return StateProofTrackingData.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["v", this.stateProofVotersCommitment],
      ["t", this.stateProofOnlineTotalWeight],
      ["n", this.stateProofNextRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofTrackingData: ${data}`);
    }
    return new StateProofTrackingData({
      stateProofVotersCommitment: data.get("v"),
      stateProofOnlineTotalWeight: data.get("t"),
      stateProofNextRound: data.get("n")
    });
  }
}
StateProofTrackingData.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "v",
    // stateProofVotersCommitment
    valueSchema: new ByteArraySchema()
  },
  {
    key: "t",
    // stateProofOnlineTotalWeight
    valueSchema: new Uint64Schema()
  },
  {
    key: "n",
    // stateProofNextRound
    valueSchema: new Uint64Schema()
  }
]));
class TxnCommitments {
  constructor(params) {
    this.nativeSha512_256Commitment = params.nativeSha512_256Commitment;
    this.sha256Commitment = params.sha256Commitment;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return TxnCommitments.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["txn", this.nativeSha512_256Commitment],
      ["txn256", this.sha256Commitment]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TxnCommitments: ${data}`);
    }
    return new TxnCommitments({
      nativeSha512_256Commitment: data.get("txn"),
      sha256Commitment: data.get("txn256")
    });
  }
}
TxnCommitments.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "txn",
    // nativeSha512_256Commitment
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "txn256",
    // sha256Commitment
    valueSchema: new FixedLengthByteArraySchema(32)
  }
]));
class RewardState {
  constructor(params) {
    this.feeSink = params.feeSink;
    this.rewardsPool = params.rewardsPool;
    this.rewardsLevel = params.rewardsLevel;
    this.rewardsRate = params.rewardsRate;
    this.rewardsResidue = params.rewardsResidue;
    this.rewardsRecalculationRound = params.rewardsRecalculationRound;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return RewardState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["fees", this.feeSink],
      ["rwd", this.rewardsPool],
      ["earn", this.rewardsLevel],
      ["rate", this.rewardsRate],
      ["frac", this.rewardsResidue],
      ["rwcalr", this.rewardsRecalculationRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded RewardState: ${data}`);
    }
    return new RewardState({
      feeSink: data.get("fees"),
      rewardsPool: data.get("rwd"),
      rewardsLevel: data.get("earn"),
      rewardsRate: data.get("rate"),
      rewardsResidue: data.get("frac"),
      rewardsRecalculationRound: data.get("rwcalr")
    });
  }
}
RewardState.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "fees",
    // feeSink
    valueSchema: new AddressSchema()
  },
  {
    key: "rwd",
    // rewardsPool
    valueSchema: new AddressSchema()
  },
  {
    key: "earn",
    // rewardsLevel
    valueSchema: new Uint64Schema()
  },
  {
    key: "rate",
    // rewardsRate
    valueSchema: new Uint64Schema()
  },
  {
    key: "frac",
    // rewardsResidue
    valueSchema: new Uint64Schema()
  },
  {
    key: "rwcalr",
    // rewardsRecalculationRound
    valueSchema: new Uint64Schema()
  }
]));
class UpgradeState {
  constructor(params) {
    this.currentProtocol = params.currentProtocol;
    this.nextProtocol = params.nextProtocol;
    this.nextProtocolApprovals = params.nextProtocolApprovals;
    this.nextProtocolVoteBefore = params.nextProtocolVoteBefore;
    this.nextProtocolSwitchOn = params.nextProtocolSwitchOn;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return UpgradeState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["proto", this.currentProtocol],
      ["nextproto", this.nextProtocol],
      ["nextyes", this.nextProtocolApprovals],
      ["nextbefore", this.nextProtocolVoteBefore],
      ["nextswitch", this.nextProtocolSwitchOn]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded UpgradeState: ${data}`);
    }
    return new UpgradeState({
      currentProtocol: data.get("proto"),
      nextProtocol: data.get("nextproto"),
      nextProtocolApprovals: data.get("nextyes"),
      nextProtocolVoteBefore: data.get("nextbefore"),
      nextProtocolSwitchOn: data.get("nextswitch")
    });
  }
}
UpgradeState.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "proto",
    // currentProtocol
    valueSchema: new StringSchema()
  },
  {
    key: "nextproto",
    // nextProtocol
    valueSchema: new StringSchema()
  },
  {
    key: "nextyes",
    // nextProtocolApprovals
    valueSchema: new Uint64Schema()
  },
  {
    key: "nextbefore",
    // nextProtocolVoteBefore
    valueSchema: new Uint64Schema()
  },
  {
    key: "nextswitch",
    // nextProtocolSwitchOn
    valueSchema: new Uint64Schema()
  }
]));
class UpgradeVote {
  constructor(params) {
    this.upgradePropose = params.upgradePropose;
    this.upgradeDelay = params.upgradeDelay;
    this.upgradeApprove = params.upgradeApprove;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return UpgradeVote.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["upgradeprop", this.upgradePropose],
      ["upgradedelay", this.upgradeDelay],
      ["upgradeyes", this.upgradeApprove]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded UpgradeVote: ${data}`);
    }
    return new UpgradeVote({
      upgradePropose: data.get("upgradeprop"),
      upgradeDelay: data.get("upgradedelay"),
      upgradeApprove: data.get("upgradeyes")
    });
  }
}
UpgradeVote.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "upgradeprop",
    // upgradePropose
    valueSchema: new StringSchema()
  },
  {
    key: "upgradedelay",
    // upgradeDelay
    valueSchema: new Uint64Schema()
  },
  {
    key: "upgradeyes",
    // upgradeApprove
    valueSchema: new BooleanSchema()
  }
]));
class ParticipationUpdates {
  constructor(params) {
    this.expiredParticipationAccounts = params.expiredParticipationAccounts;
    this.absentParticipationAccounts = params.absentParticipationAccounts;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return ParticipationUpdates.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["partupdrmv", this.expiredParticipationAccounts],
      ["partupdabs", this.absentParticipationAccounts]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ParticipationUpdates: ${data}`);
    }
    return new ParticipationUpdates({
      expiredParticipationAccounts: data.get("partupdrmv"),
      absentParticipationAccounts: data.get("partupdabs")
    });
  }
}
ParticipationUpdates.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "partupdrmv",
    // expiredParticipationAccounts
    valueSchema: new ArraySchema(new AddressSchema())
  },
  {
    key: "partupdabs",
    // absentParticipationAccounts
    valueSchema: new ArraySchema(new AddressSchema())
  }
]));
class BlockHeader {
  constructor(params) {
    this.round = params.round;
    this.branch = params.branch;
    this.seed = params.seed;
    this.txnCommitments = params.txnCommitments;
    this.timestamp = params.timestamp;
    this.genesisID = params.genesisID;
    this.genesisHash = params.genesisHash;
    this.proposer = params.proposer;
    this.feesCollected = params.feesCollected;
    this.bonus = params.bonus;
    this.proposerPayout = params.proposerPayout;
    this.rewardState = params.rewardState;
    this.upgradeState = params.upgradeState;
    this.upgradeVote = params.upgradeVote;
    this.txnCounter = params.txnCounter;
    this.stateproofTracking = params.stateproofTracking;
    this.participationUpdates = params.participationUpdates;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return BlockHeader.encodingSchema;
  }
  toEncodingData() {
    const data = /* @__PURE__ */ new Map([
      ["rnd", this.round],
      ["prev", this.branch],
      ["seed", this.seed],
      ["ts", this.timestamp],
      ["gen", this.genesisID],
      ["gh", this.genesisHash],
      ["prp", this.proposer],
      ["fc", this.feesCollected],
      ["bi", this.bonus],
      ["pp", this.proposerPayout],
      ["tc", this.txnCounter],
      [
        "spt",
        convertMap(this.stateproofTracking, (key, value) => [
          key,
          value.toEncodingData()
        ])
      ]
    ]);
    return combineMaps(data, this.txnCommitments.toEncodingData(), this.rewardState.toEncodingData(), this.upgradeState.toEncodingData(), this.upgradeVote.toEncodingData(), this.participationUpdates.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockHeader: ${data}`);
    }
    return new BlockHeader({
      round: data.get("rnd"),
      branch: data.get("prev"),
      seed: data.get("seed"),
      txnCommitments: TxnCommitments.fromEncodingData(data),
      timestamp: data.get("ts"),
      genesisID: data.get("gen"),
      genesisHash: data.get("gh"),
      proposer: data.get("prp"),
      feesCollected: data.get("fc"),
      bonus: data.get("bi"),
      proposerPayout: data.get("pp"),
      rewardState: RewardState.fromEncodingData(data),
      upgradeState: UpgradeState.fromEncodingData(data),
      upgradeVote: UpgradeVote.fromEncodingData(data),
      txnCounter: data.get("tc"),
      stateproofTracking: convertMap(data.get("spt"), (key, value) => [
        Number(key),
        StateProofTrackingData.fromEncodingData(value)
      ]),
      participationUpdates: ParticipationUpdates.fromEncodingData(data)
    });
  }
}
BlockHeader.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "rnd",
    // round
    valueSchema: new Uint64Schema()
  },
  {
    key: "prev",
    // branch
    valueSchema: new BlockHashSchema()
  },
  {
    key: "seed",
    // seed
    valueSchema: new ByteArraySchema()
  },
  {
    key: "",
    valueSchema: TxnCommitments.encodingSchema,
    embedded: true
  },
  {
    key: "ts",
    // timestamp
    valueSchema: new Uint64Schema()
  },
  {
    key: "gen",
    // genesisID
    valueSchema: new StringSchema()
  },
  {
    key: "gh",
    // genesisHash
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "prp",
    // proposer
    valueSchema: new AddressSchema()
  },
  {
    key: "fc",
    // feesCollected
    valueSchema: new Uint64Schema()
  },
  {
    key: "bi",
    // bonus
    valueSchema: new Uint64Schema()
  },
  {
    key: "pp",
    // proposerPayout
    valueSchema: new Uint64Schema()
  },
  {
    key: "",
    valueSchema: RewardState.encodingSchema,
    embedded: true
  },
  {
    key: "",
    valueSchema: UpgradeState.encodingSchema,
    embedded: true
  },
  {
    key: "",
    valueSchema: UpgradeVote.encodingSchema,
    embedded: true
  },
  {
    key: "tc",
    // txnCounter
    valueSchema: new Uint64Schema()
  },
  {
    key: "spt",
    // stateproofTracking
    valueSchema: new Uint64MapSchema(StateProofTrackingData.encodingSchema)
  },
  {
    key: "",
    valueSchema: ParticipationUpdates.encodingSchema,
    embedded: true
  }
]));
class ValueDelta {
  constructor(params) {
    this.action = params.action;
    this.bytes = params.bytes;
    this.uint = params.uint;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return ValueDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["at", this.action],
      ["bs", this.bytes],
      ["ui", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ValueDelta: ${data}`);
    }
    return new ValueDelta({
      action: Number(data.get("at")),
      bytes: data.get("bs"),
      uint: data.get("ui")
    });
  }
}
ValueDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "at",
    // action
    valueSchema: new Uint64Schema()
  },
  {
    key: "bs",
    // bytes
    valueSchema: new SpecialCaseBinaryStringSchema()
  },
  {
    key: "ui",
    // uint
    valueSchema: new Uint64Schema()
  }
]));
class EvalDelta {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries(...allOmitEmpty([
        {
          key: "gd",
          // globalDelta
          valueSchema: new OptionalSchema(new SpecialCaseBinaryStringMapSchema(ValueDelta.encodingSchema))
        },
        {
          key: "ld",
          // localDeltas
          valueSchema: new OptionalSchema(new Uint64MapSchema(new SpecialCaseBinaryStringMapSchema(ValueDelta.encodingSchema)))
        },
        {
          key: "sa",
          // sharedAccts
          valueSchema: new OptionalSchema(new ArraySchema(new AddressSchema()))
        },
        {
          key: "lg",
          // logs
          valueSchema: new OptionalSchema(new ArraySchema(new SpecialCaseBinaryStringSchema()))
        },
        {
          key: "itx",
          // innerTxns
          valueSchema: new OptionalSchema(
            // eslint-disable-next-line no-use-before-define
            new ArraySchema(SignedTxnWithAD.encodingSchema)
          )
        }
      ]));
    }
    return this.encodingSchemaValue;
  }
  constructor(params) {
    this.globalDelta = params.globalDelta ?? /* @__PURE__ */ new Map();
    this.localDeltas = params.localDeltas ?? /* @__PURE__ */ new Map();
    this.sharedAccts = params.sharedAccts ?? [];
    this.logs = params.logs ?? [];
    this.innerTxns = params.innerTxns ?? [];
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return EvalDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "gd",
        convertMap(this.globalDelta, (key, value) => [
          key,
          value.toEncodingData()
        ])
      ],
      [
        "ld",
        convertMap(this.localDeltas, (key, value) => [
          key,
          convertMap(value, (k2, v2) => [k2, v2.toEncodingData()])
        ])
      ],
      ["sa", this.sharedAccts],
      ["lg", this.logs],
      ["itx", this.innerTxns.map((t2) => t2.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded EvalDelta: ${data}`);
    }
    return new EvalDelta({
      globalDelta: data.get("gd") ? convertMap(data.get("gd"), (key, value) => [key, ValueDelta.fromEncodingData(value)]) : void 0,
      localDeltas: data.get("ld") ? convertMap(data.get("ld"), (key, value) => [
        Number(key),
        convertMap(value, (k2, v2) => [k2, ValueDelta.fromEncodingData(v2)])
      ]) : void 0,
      sharedAccts: data.get("sa"),
      logs: data.get("lg"),
      // eslint-disable-next-line no-use-before-define
      innerTxns: (data.get("itx") ?? []).map(SignedTxnWithAD.fromEncodingData)
    });
  }
}
class ApplyData {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries(...allOmitEmpty([
        {
          key: "ca",
          // closingAmount
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "aca",
          // assetClosingAmount
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "rs",
          // senderRewards
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "rr",
          // receiverRewards
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "rc",
          // closeRewards
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "dt",
          // evalDelta
          valueSchema: new OptionalSchema(EvalDelta.encodingSchema)
        },
        {
          key: "caid",
          // configAsset
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "apid",
          // applicationID
          valueSchema: new OptionalSchema(new Uint64Schema())
        }
      ]));
    }
    return this.encodingSchemaValue;
  }
  constructor(params) {
    this.closingAmount = params.closingAmount;
    this.assetClosingAmount = params.assetClosingAmount;
    this.senderRewards = params.senderRewards;
    this.receiverRewards = params.receiverRewards;
    this.closeRewards = params.closeRewards;
    this.evalDelta = params.evalDelta;
    this.configAsset = params.configAsset;
    this.applicationID = params.applicationID;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return ApplyData.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["ca", this.closingAmount],
      ["aca", this.assetClosingAmount],
      ["rs", this.senderRewards],
      ["rr", this.receiverRewards],
      ["rc", this.closeRewards],
      ["dt", this.evalDelta ? this.evalDelta.toEncodingData() : void 0],
      ["caid", this.configAsset],
      ["apid", this.applicationID]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplyData: ${data}`);
    }
    return new ApplyData({
      closingAmount: data.get("ca"),
      assetClosingAmount: data.get("aca"),
      senderRewards: data.get("rs"),
      receiverRewards: data.get("rr"),
      closeRewards: data.get("rc"),
      evalDelta: data.get("dt") ? EvalDelta.fromEncodingData(data.get("dt")) : void 0,
      configAsset: data.get("caid"),
      applicationID: data.get("apid")
    });
  }
}
class SignedTxnWithAD {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries(...allOmitEmpty([
        {
          key: "",
          valueSchema: SignedTransaction.encodingSchema,
          embedded: true
        },
        {
          key: "",
          valueSchema: ApplyData.encodingSchema,
          embedded: true
        }
      ]));
    }
    return this.encodingSchemaValue;
  }
  constructor(params) {
    this.signedTxn = params.signedTxn;
    this.applyData = params.applyData;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return SignedTxnWithAD.encodingSchema;
  }
  toEncodingData() {
    return combineMaps(this.signedTxn.toEncodingData(), this.applyData.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SignedTxnWithAD: ${data}`);
    }
    return new SignedTxnWithAD({
      signedTxn: SignedTransaction.fromEncodingData(data),
      applyData: ApplyData.fromEncodingData(data)
    });
  }
}
class SignedTxnInBlock {
  constructor(params) {
    this.signedTxn = params.signedTxn;
    this.hasGenesisID = params.hasGenesisID;
    this.hasGenesisHash = params.hasGenesisHash;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return SignedTxnInBlock.encodingSchema;
  }
  toEncodingData() {
    const data = /* @__PURE__ */ new Map([
      ["hgi", this.hasGenesisID],
      ["hgh", this.hasGenesisHash]
    ]);
    return combineMaps(data, this.signedTxn.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SignedTxnInBlock: ${data}`);
    }
    return new SignedTxnInBlock({
      signedTxn: SignedTxnWithAD.fromEncodingData(data),
      hasGenesisID: data.get("hgi"),
      hasGenesisHash: data.get("hgh")
    });
  }
}
SignedTxnInBlock.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "",
    valueSchema: SignedTxnWithAD.encodingSchema,
    embedded: true
  },
  {
    key: "hgi",
    // hasGenesisID
    valueSchema: new BooleanSchema()
  },
  {
    key: "hgh",
    // hasGenesisHash
    valueSchema: new BooleanSchema()
  }
]));
new NamedMapSchema(allOmitEmpty([
  {
    key: "",
    valueSchema: BlockHeader.encodingSchema,
    embedded: true
  },
  {
    key: "txns",
    // payset
    valueSchema: new ArraySchema(SignedTxnInBlock.encodingSchema)
  }
]));
class TealValue {
  constructor(params) {
    this.type = params.type;
    this.bytes = params.bytes;
    this.uint = params.uint;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return TealValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["tt", this.type],
      ["tb", this.bytes],
      ["ui", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TealValue: ${data}`);
    }
    return new TealValue({
      type: Number(data.get("tt")),
      bytes: data.get("tb"),
      uint: data.get("ui")
    });
  }
}
TealValue.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "tt", valueSchema: new Uint64Schema() },
  // type
  {
    key: "tb",
    // bytes
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
  },
  { key: "ui", valueSchema: new OptionalSchema(new Uint64Schema()) }
  // uint
]));
class StateSchema {
  constructor(params) {
    this.numUints = params.numUints;
    this.numByteSlices = params.numByteSlices;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return StateSchema.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["nui", this.numUints],
      ["nbs", this.numByteSlices]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateSchema: ${data}`);
    }
    return new StateSchema({
      numUints: Number(data.get("nui")),
      numByteSlices: Number(data.get("nbs"))
    });
  }
}
StateSchema.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "nui",
    // numUints
    valueSchema: new Uint64Schema()
  },
  {
    key: "nbs",
    // numByteSlices
    valueSchema: new Uint64Schema()
  }
]));
class AppParams {
  constructor(params) {
    this.approvalProgram = params.approvalProgram;
    this.clearStateProgram = params.clearStateProgram;
    this.globalState = params.globalState;
    this.localStateSchema = params.localStateSchema;
    this.globalStateSchema = params.globalStateSchema;
    this.extraProgramPages = params.extraProgramPages;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AppParams.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["approv", this.approvalProgram],
      ["clearp", this.clearStateProgram],
      ["gs", convertMap(this.globalState, (k2, v2) => [k2, v2.toEncodingData()])],
      ["lsch", this.localStateSchema.toEncodingData()],
      ["gsch", this.globalStateSchema.toEncodingData()],
      ["epp", this.extraProgramPages]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppParams: ${data}`);
    }
    return new AppParams({
      approvalProgram: data.get("approv"),
      clearStateProgram: data.get("clearp"),
      globalState: convertMap(data.get("gs"), (k2, v2) => [k2, TealValue.fromEncodingData(v2)]),
      localStateSchema: StateSchema.fromEncodingData(data.get("lsch")),
      globalStateSchema: StateSchema.fromEncodingData(data.get("gsch")),
      extraProgramPages: Number(data.get("epp"))
    });
  }
}
AppParams.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "approv", valueSchema: new ByteArraySchema() },
  // approvalProgram
  { key: "clearp", valueSchema: new ByteArraySchema() },
  // alearStateProgram
  {
    key: "gs",
    valueSchema: new SpecialCaseBinaryStringMapSchema(TealValue.encodingSchema)
  },
  // globalState
  { key: "lsch", valueSchema: StateSchema.encodingSchema },
  // localStateSchema
  { key: "gsch", valueSchema: StateSchema.encodingSchema },
  // globalStateSchema
  { key: "epp", valueSchema: new Uint64Schema() }
  // extraProgramPages
]));
class AppLocalState {
  constructor(params) {
    this.schema = params.schema;
    this.keyValue = params.keyValue;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AppLocalState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["hsch", this.schema.toEncodingData()],
      ["tkv", convertMap(this.keyValue, (k2, v2) => [k2, v2.toEncodingData()])]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppLocalState: ${data}`);
    }
    return new AppLocalState({
      schema: StateSchema.fromEncodingData(data.get("hsch")),
      keyValue: convertMap(data.get("tkv"), (k2, v2) => [k2, TealValue.fromEncodingData(v2)])
    });
  }
}
AppLocalState.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "hsch", valueSchema: StateSchema.encodingSchema },
  // schema
  {
    key: "tkv",
    // keyValue
    valueSchema: new SpecialCaseBinaryStringMapSchema(TealValue.encodingSchema)
  }
]));
class AppLocalStateDelta {
  constructor(params) {
    this.localState = params.localState;
    this.deleted = params.deleted;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AppLocalStateDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "LocalState",
        this.localState ? this.localState.toEncodingData() : void 0
      ],
      ["Deleted", this.deleted]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppLocalStateDelta: ${data}`);
    }
    return new AppLocalStateDelta({
      localState: data.get("LocalState") ? AppLocalState.fromEncodingData(data.get("LocalState")) : void 0,
      deleted: data.get("Deleted")
    });
  }
}
AppLocalStateDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "LocalState",
    // localState
    valueSchema: new OptionalSchema(AppLocalState.encodingSchema)
  },
  { key: "Deleted", valueSchema: new BooleanSchema() }
  // deleted
]));
class AppParamsDelta {
  constructor(params) {
    this.params = params.params;
    this.deleted = params.deleted;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AppParamsDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Params", this.params ? this.params.toEncodingData() : void 0],
      ["Deleted", this.deleted]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppParamsDelta: ${data}`);
    }
    return new AppParamsDelta({
      params: data.get("Params") ? AppParams.fromEncodingData(data.get("Params")) : void 0,
      deleted: data.get("Deleted")
    });
  }
}
AppParamsDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Params",
    // params
    valueSchema: new OptionalSchema(AppParams.encodingSchema)
  },
  { key: "Deleted", valueSchema: new BooleanSchema() }
  // deleted
]));
class AppResourceRecord {
  constructor(params) {
    this.id = params.id;
    this.address = params.address;
    this.params = params.params;
    this.state = params.state;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AppResourceRecord.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Aidx", this.id],
      ["Addr", this.address],
      ["Params", this.params.toEncodingData()],
      ["State", this.state.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppResourceRecord: ${data}`);
    }
    return new AppResourceRecord({
      id: data.get("Aidx"),
      address: data.get("Addr"),
      params: AppParamsDelta.fromEncodingData(data.get("Params")),
      state: AppLocalStateDelta.fromEncodingData(data.get("State"))
    });
  }
}
AppResourceRecord.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "Aidx", valueSchema: new Uint64Schema() },
  // id
  { key: "Addr", valueSchema: new AddressSchema() },
  // address
  {
    key: "Params",
    // params
    valueSchema: AppParamsDelta.encodingSchema
  },
  {
    key: "State",
    // state
    valueSchema: AppLocalStateDelta.encodingSchema
  }
]));
class AssetHolding {
  constructor(params) {
    this.amount = params.amount;
    this.frozen = params.frozen;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AssetHolding.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["a", this.amount],
      ["f", this.frozen]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetHolding: ${data}`);
    }
    return new AssetHolding({
      amount: data.get("a"),
      frozen: data.get("f")
    });
  }
}
AssetHolding.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "a", valueSchema: new Uint64Schema() },
  // amount
  { key: "f", valueSchema: new BooleanSchema() }
  // frozen
]));
class AssetHoldingDelta {
  constructor(params) {
    this.holding = params.holding;
    this.deleted = params.deleted;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AssetHoldingDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Holding", this.holding ? this.holding.toEncodingData() : void 0],
      ["Deleted", this.deleted]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetHoldingDelta: ${data}`);
    }
    return new AssetHoldingDelta({
      holding: data.get("Holding") ? AssetHolding.fromEncodingData(data.get("Holding")) : void 0,
      deleted: data.get("Deleted")
    });
  }
}
AssetHoldingDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Holding",
    // holding
    valueSchema: new OptionalSchema(AssetHolding.encodingSchema)
  },
  { key: "Deleted", valueSchema: new BooleanSchema() }
  // deleted
]));
class AssetParams {
  constructor(params) {
    this.total = params.total;
    this.decimals = params.decimals;
    this.defaultFrozen = params.defaultFrozen;
    this.unitName = params.unitName;
    this.assetName = params.assetName;
    this.url = params.url;
    this.metadataHash = params.metadataHash;
    this.manager = params.manager;
    this.reserve = params.reserve;
    this.freeze = params.freeze;
    this.clawback = params.clawback;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AssetParams.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["t", this.total],
      ["dc", this.decimals],
      ["df", this.defaultFrozen],
      ["un", this.unitName],
      ["an", this.assetName],
      ["au", this.url],
      ["am", this.metadataHash],
      ["m", this.manager],
      ["r", this.reserve],
      ["f", this.freeze],
      ["c", this.clawback]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetParams: ${data}`);
    }
    return new AssetParams({
      total: data.get("t"),
      decimals: data.get("dc"),
      defaultFrozen: data.get("df"),
      unitName: data.get("un"),
      assetName: data.get("an"),
      url: data.get("au"),
      metadataHash: data.get("am"),
      manager: data.get("m"),
      reserve: data.get("r"),
      freeze: data.get("f"),
      clawback: data.get("c")
    });
  }
}
AssetParams.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "t", valueSchema: new Uint64Schema() },
  // total
  { key: "dc", valueSchema: new Uint64Schema() },
  // decimals
  { key: "df", valueSchema: new BooleanSchema() },
  // defaultFrozen
  {
    key: "un",
    // unitName
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
  },
  {
    key: "an",
    // assetName
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
  },
  {
    key: "au",
    // url
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
  },
  { key: "am", valueSchema: new FixedLengthByteArraySchema(32) },
  // metadataHash
  { key: "m", valueSchema: new OptionalSchema(new AddressSchema()) },
  // manager
  { key: "r", valueSchema: new OptionalSchema(new AddressSchema()) },
  // reserve
  { key: "f", valueSchema: new OptionalSchema(new AddressSchema()) },
  // freeze
  { key: "c", valueSchema: new OptionalSchema(new AddressSchema()) }
  // clawback
]));
class AssetParamsDelta {
  constructor(params) {
    this.params = params.params;
    this.deleted = params.deleted;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AssetParamsDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Params", this.params ? this.params.toEncodingData() : void 0],
      ["Deleted", this.deleted]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetParamsDelta: ${data}`);
    }
    return new AssetParamsDelta({
      params: data.get("Params") ? AssetParams.fromEncodingData(data.get("Params")) : void 0,
      deleted: data.get("Deleted")
    });
  }
}
AssetParamsDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Params",
    // params
    valueSchema: new OptionalSchema(AssetParams.encodingSchema)
  },
  { key: "Deleted", valueSchema: new BooleanSchema() }
  // deleted
]));
class AssetResourceRecord {
  constructor(params) {
    this.id = params.id;
    this.address = params.address;
    this.params = params.params;
    this.holding = params.holding;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AssetResourceRecord.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Aidx", this.id],
      ["Addr", this.address],
      ["Params", this.params.toEncodingData()],
      ["Holding", this.holding.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetResourceRecord: ${data}`);
    }
    return new AssetResourceRecord({
      id: data.get("Aidx"),
      address: data.get("Addr"),
      params: AssetParamsDelta.fromEncodingData(data.get("Params")),
      holding: AssetHoldingDelta.fromEncodingData(data.get("Holding"))
    });
  }
}
AssetResourceRecord.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "Aidx", valueSchema: new Uint64Schema() },
  // id
  { key: "Addr", valueSchema: new AddressSchema() },
  // address
  {
    key: "Params",
    // params
    valueSchema: AssetParamsDelta.encodingSchema
  },
  {
    key: "Holding",
    // holding
    valueSchema: AssetHoldingDelta.encodingSchema
  }
]));
class VotingData {
  constructor(params) {
    this.voteID = params.voteID;
    this.selectionID = params.selectionID;
    this.stateProofID = params.stateProofID;
    this.voteFirstValid = params.voteFirstValid;
    this.voteLastValid = params.voteLastValid;
    this.voteKeyDilution = params.voteKeyDilution;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return VotingData.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["VoteID", this.voteID],
      ["SelectionID", this.selectionID],
      ["StateProofID", this.stateProofID],
      ["VoteFirstValid", this.voteFirstValid],
      ["VoteLastValid", this.voteLastValid],
      ["VoteKeyDilution", this.voteKeyDilution]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded VotingData: ${data}`);
    }
    return new VotingData({
      voteID: data.get("VoteID"),
      selectionID: data.get("SelectionID"),
      stateProofID: data.get("StateProofID"),
      voteFirstValid: data.get("VoteFirstValid"),
      voteLastValid: data.get("VoteLastValid"),
      voteKeyDilution: data.get("VoteKeyDilution")
    });
  }
}
VotingData.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "VoteID",
    // voteID
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "SelectionID",
    // selectionID
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "StateProofID",
    // stateProofID
    valueSchema: new FixedLengthByteArraySchema(64)
  },
  {
    key: "VoteFirstValid",
    // voteFirstValid
    valueSchema: new Uint64Schema()
  },
  {
    key: "VoteLastValid",
    // voteLastValid
    valueSchema: new Uint64Schema()
  },
  {
    key: "VoteKeyDilution",
    // voteKeyDilution
    valueSchema: new Uint64Schema()
  }
]));
class AccountBaseData {
  constructor(params) {
    this.status = params.status;
    this.microAlgos = params.microAlgos;
    this.rewardsBase = params.rewardsBase;
    this.rewardedMicroAlgos = params.rewardedMicroAlgos;
    this.authAddr = params.authAddr;
    this.incentiveEligible = params.incentiveEligible;
    this.totalAppSchema = params.totalAppSchema;
    this.totalExtraAppPages = params.totalExtraAppPages;
    this.totalAppParams = params.totalAppParams;
    this.totalAppLocalStates = params.totalAppLocalStates;
    this.totalAssetParams = params.totalAssetParams;
    this.totalAssets = params.totalAssets;
    this.totalBoxes = params.totalBoxes;
    this.totalBoxBytes = params.totalBoxBytes;
    this.lastProposed = params.lastProposed;
    this.lastHeartbeat = params.lastHeartbeat;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AccountBaseData.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Status", this.status],
      ["MicroAlgos", this.microAlgos],
      ["RewardsBase", this.rewardsBase],
      ["RewardedMicroAlgos", this.rewardedMicroAlgos],
      ["AuthAddr", this.authAddr],
      ["IncentiveEligible", this.incentiveEligible],
      ["TotalAppSchema", this.totalAppSchema.toEncodingData()],
      ["TotalExtraAppPages", this.totalExtraAppPages],
      ["TotalAppParams", this.totalAppParams],
      ["TotalAppLocalStates", this.totalAppLocalStates],
      ["TotalAssetParams", this.totalAssetParams],
      ["TotalAssets", this.totalAssets],
      ["TotalBoxes", this.totalBoxes],
      ["TotalBoxBytes", this.totalBoxBytes],
      ["LastProposed", this.lastProposed],
      ["LastHeartbeat", this.lastHeartbeat]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountBaseData: ${data}`);
    }
    return new AccountBaseData({
      status: Number(data.get("Status")),
      microAlgos: data.get("MicroAlgos"),
      rewardsBase: data.get("RewardsBase"),
      rewardedMicroAlgos: data.get("RewardedMicroAlgos"),
      authAddr: data.get("AuthAddr"),
      incentiveEligible: data.get("IncentiveEligible"),
      totalAppSchema: StateSchema.fromEncodingData(data.get("TotalAppSchema")),
      totalExtraAppPages: Number(data.get("TotalExtraAppPages")),
      totalAppParams: data.get("TotalAppParams"),
      totalAppLocalStates: data.get("TotalAppLocalStates"),
      totalAssetParams: data.get("TotalAssetParams"),
      totalAssets: data.get("TotalAssets"),
      totalBoxes: data.get("TotalBoxes"),
      totalBoxBytes: data.get("TotalBoxBytes"),
      lastProposed: data.get("LastProposed"),
      lastHeartbeat: data.get("LastHeartbeat")
    });
  }
}
AccountBaseData.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "Status", valueSchema: new Uint64Schema() },
  // status
  { key: "MicroAlgos", valueSchema: new Uint64Schema() },
  // microAlgos
  { key: "RewardsBase", valueSchema: new Uint64Schema() },
  // rewardsBase
  {
    key: "RewardedMicroAlgos",
    // rewardedMicroAlgos
    valueSchema: new Uint64Schema()
  },
  { key: "AuthAddr", valueSchema: new AddressSchema() },
  // authAddr
  {
    key: "IncentiveEligible",
    // incentiveEligible
    valueSchema: new BooleanSchema()
  },
  {
    key: "TotalAppSchema",
    // totalAppSchema
    valueSchema: StateSchema.encodingSchema
  },
  {
    key: "TotalExtraAppPages",
    // totalExtraAppPages
    valueSchema: new Uint64Schema()
  },
  {
    key: "TotalAppParams",
    // totalAppParams
    valueSchema: new Uint64Schema()
  },
  {
    key: "TotalAppLocalStates",
    // totalAppLocalStates
    valueSchema: new Uint64Schema()
  },
  {
    key: "TotalAssetParams",
    // totalAssetParams
    valueSchema: new Uint64Schema()
  },
  { key: "TotalAssets", valueSchema: new Uint64Schema() },
  // totalAssets
  { key: "TotalBoxes", valueSchema: new Uint64Schema() },
  // totalBoxes
  {
    key: "TotalBoxBytes",
    // totalBoxBytes
    valueSchema: new Uint64Schema()
  },
  { key: "LastProposed", valueSchema: new Uint64Schema() },
  // lastProposed
  {
    key: "LastHeartbeat",
    // lastHeartbeat
    valueSchema: new Uint64Schema()
  }
]));
class AccountData {
  constructor(params) {
    this.accountBaseData = params.accountBaseData;
    this.votingData = params.votingData;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AccountData.encodingSchema;
  }
  toEncodingData() {
    return combineMaps(this.accountBaseData.toEncodingData(), this.votingData.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountData: ${data}`);
    }
    return new AccountData({
      accountBaseData: AccountBaseData.fromEncodingData(data),
      votingData: VotingData.fromEncodingData(data)
    });
  }
}
AccountData.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "",
    valueSchema: AccountBaseData.encodingSchema,
    embedded: true
  },
  {
    key: "",
    valueSchema: VotingData.encodingSchema,
    embedded: true
  }
]));
class BalanceRecord {
  constructor(params) {
    this.addr = params.addr;
    this.accountData = params.accountData;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return BalanceRecord.encodingSchema;
  }
  toEncodingData() {
    return combineMaps(/* @__PURE__ */ new Map([["Addr", this.addr]]), this.accountData.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BalanceRecord: ${data}`);
    }
    return new BalanceRecord({
      addr: data.get("Addr"),
      accountData: AccountData.fromEncodingData(data)
    });
  }
}
BalanceRecord.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Addr",
    valueSchema: new AddressSchema()
  },
  {
    key: "",
    valueSchema: AccountData.encodingSchema,
    embedded: true
  }
]));
class AccountDeltas {
  constructor(params) {
    this.accounts = params.accounts;
    this.appResources = params.appResources;
    this.assetResources = params.assetResources;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AccountDeltas.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Accts", this.accounts.map((account) => account.toEncodingData())],
      [
        "AppResources",
        this.appResources.length === 0 ? void 0 : this.appResources.map((appResource) => appResource.toEncodingData())
      ],
      [
        "AssetResources",
        this.assetResources.length === 0 ? void 0 : this.assetResources.map((assetResource) => assetResource.toEncodingData())
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountDeltas: ${data}`);
    }
    return new AccountDeltas({
      accounts: (data.get("Accts") ?? []).map(BalanceRecord.fromEncodingData),
      appResources: (data.get("AppResources") ?? []).map(AppResourceRecord.fromEncodingData),
      assetResources: (data.get("AssetResources") ?? []).map(AssetResourceRecord.fromEncodingData)
    });
  }
}
AccountDeltas.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Accts",
    // accounts
    valueSchema: new ArraySchema(BalanceRecord.encodingSchema)
  },
  {
    key: "AppResources",
    // appResources
    valueSchema: new OptionalSchema(new ArraySchema(AppResourceRecord.encodingSchema))
  },
  {
    key: "AssetResources",
    // assetResources
    valueSchema: new OptionalSchema(new ArraySchema(AssetResourceRecord.encodingSchema))
  }
]));
class KvValueDelta {
  constructor(params) {
    this.data = params.data;
    this.oldData = params.oldData;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return KvValueDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Data", this.data],
      ["OldData", this.oldData]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded KvValueDelta: ${data}`);
    }
    return new KvValueDelta({
      data: data.get("Data"),
      oldData: data.get("OldData")
    });
  }
}
KvValueDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Data",
    valueSchema: new OptionalSchema(new ByteArraySchema())
  },
  {
    key: "OldData",
    valueSchema: new OptionalSchema(new ByteArraySchema())
  }
]));
class IncludedTransactions {
  constructor(params) {
    this.lastValid = params.lastValid;
    this.intra = params.intra;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return IncludedTransactions.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["LastValid", this.lastValid],
      ["Intra", this.intra]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded IncludedTransactions: ${data}`);
    }
    return new IncludedTransactions({
      lastValid: data.get("LastValid"),
      intra: Number(data.get("Intra"))
    });
  }
}
IncludedTransactions.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "LastValid",
    valueSchema: new Uint64Schema()
  },
  {
    key: "Intra",
    valueSchema: new Uint64Schema()
  }
]));
class ModifiedCreatable {
  constructor(params) {
    this.creatableType = params.creatableType;
    this.created = params.created;
    this.creator = params.creator;
    this.ndeltas = params.ndeltas;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return ModifiedCreatable.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Ctype", this.creatableType],
      ["Created", this.created],
      ["Creator", this.creator],
      ["Ndeltas", this.ndeltas]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ModifiedCreatable: ${data}`);
    }
    return new ModifiedCreatable({
      creatableType: Number(data.get("Ctype")),
      created: data.get("Created"),
      creator: data.get("Creator"),
      ndeltas: Number(data.get("Ndeltas"))
    });
  }
}
ModifiedCreatable.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Ctype",
    // creatableType
    valueSchema: new Uint64Schema()
  },
  {
    key: "Created",
    // created
    valueSchema: new BooleanSchema()
  },
  {
    key: "Creator",
    // creator
    valueSchema: new AddressSchema()
  },
  {
    key: "Ndeltas",
    // ndeltas
    valueSchema: new Uint64Schema()
  }
]));
class AlgoCount {
  constructor(params) {
    this.money = params.money;
    this.rewardUnits = params.rewardUnits;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AlgoCount.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["mon", this.money],
      ["rwd", this.rewardUnits]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AlgoCount: ${data}`);
    }
    return new AlgoCount({
      money: data.get("mon"),
      rewardUnits: data.get("rwd")
    });
  }
}
AlgoCount.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "mon", valueSchema: new Uint64Schema() },
  // money
  { key: "rwd", valueSchema: new Uint64Schema() }
  // rewardUnits
]));
class AccountTotals {
  constructor(params) {
    this.online = params.online;
    this.offline = params.offline;
    this.notParticipating = params.notParticipating;
    this.rewardsLevel = params.rewardsLevel;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return AccountTotals.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["online", this.online.toEncodingData()],
      ["offline", this.offline.toEncodingData()],
      ["notpart", this.notParticipating.toEncodingData()],
      ["rwdlvl", this.rewardsLevel]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountTotals: ${data}`);
    }
    return new AccountTotals({
      online: AlgoCount.fromEncodingData(data.get("online")),
      offline: AlgoCount.fromEncodingData(data.get("offline")),
      notParticipating: AlgoCount.fromEncodingData(data.get("notpart")),
      rewardsLevel: data.get("rwdlvl")
    });
  }
}
AccountTotals.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "online", valueSchema: AlgoCount.encodingSchema },
  // online
  { key: "offline", valueSchema: AlgoCount.encodingSchema },
  // offline
  { key: "notpart", valueSchema: AlgoCount.encodingSchema },
  // notParticipating
  { key: "rwdlvl", valueSchema: new Uint64Schema() }
  // rewardsLevel
]));
new NamedMapSchema(allOmitEmpty([
  {
    key: "Accts",
    // accounts
    valueSchema: AccountDeltas.encodingSchema
  },
  {
    key: "KvMods",
    // kvMods
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringMapSchema(KvValueDelta.encodingSchema))
  },
  {
    key: "Txids",
    // txids
    valueSchema: new ByteArrayMapSchema(IncludedTransactions.encodingSchema)
  },
  {
    key: "Txleases",
    // txleases
    // Note: because txleases is currently just an UntypedSchema and we are expected to decode
    // null values for this field, we use OptionalSchema to coerce null values to undefined so
    // that the values can be properly omitted during encoding.
    valueSchema: new OptionalSchema(new UntypedSchema())
  },
  {
    key: "Creatables",
    // creatables
    valueSchema: new OptionalSchema(new Uint64MapSchema(ModifiedCreatable.encodingSchema))
  },
  {
    key: "Hdr",
    // blockHeader
    valueSchema: BlockHeader.encodingSchema
  },
  {
    key: "StateProofNext",
    // stateProofNext
    valueSchema: new Uint64Schema()
  },
  {
    key: "PrevTimestamp",
    // prevTimestamp
    valueSchema: new Uint64Schema()
  },
  {
    key: "Totals",
    // totals
    valueSchema: AccountTotals.encodingSchema
  }
]));
new TextEncoder().encode("TG");
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("").forEach(function(char, i2) {
});
var ABITransactionType;
(function(ABITransactionType2) {
  ABITransactionType2["any"] = "txn";
  ABITransactionType2["pay"] = "pay";
  ABITransactionType2["keyreg"] = "keyreg";
  ABITransactionType2["acfg"] = "acfg";
  ABITransactionType2["axfer"] = "axfer";
  ABITransactionType2["afrz"] = "afrz";
  ABITransactionType2["appl"] = "appl";
})(ABITransactionType || (ABITransactionType = {}));
var ABIReferenceType;
(function(ABIReferenceType2) {
  ABIReferenceType2["account"] = "account";
  ABIReferenceType2["application"] = "application";
  ABIReferenceType2["asset"] = "asset";
})(ABIReferenceType || (ABIReferenceType = {}));
var AtomicTransactionComposerStatus;
(function(AtomicTransactionComposerStatus2) {
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILDING"] = 0] = "BUILDING";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILT"] = 1] = "BUILT";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SIGNED"] = 2] = "SIGNED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SUBMITTED"] = 3] = "SUBMITTED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["COMMITTED"] = 4] = "COMMITTED";
})(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));
Uint8Array.from([77, 88]);
class WalletService {
  constructor() {
    this.myAlgoWallet = null;
    this.walletConnector = null;
    this.connected = false;
    this.accounts = [];
    this.simulationMode = false;
  }
  // Generate a simulated wallet address
  generateSimulatedAddress() {
    const chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
    let result = "";
    for (let i2 = 0; i2 < 58; i2++) {
      result += chars2.charAt(Math.floor(Math.random() * chars2.length));
    }
    return result + "PY";
  }
  async initMyAlgo() {
    try {
      this.myAlgoWallet = new MyAlgoConnect();
      return true;
    } catch (error) {
      console.error("Failed to initialize MyAlgo:", error);
      return false;
    }
  }
  async connectMyAlgo() {
    try {
      const initSuccess = await this.initMyAlgo();
      if (!initSuccess) {
        throw new Error("Failed to initialize MyAlgo");
      }
      const accounts = await this.myAlgoWallet.connect({
        shouldSelectOneAccount: false
      });
      this.accounts = accounts.map((account) => ({
        address: account.address,
        name: account.name,
        provider: "myalgo"
      }));
      this.connected = true;
      this.simulationMode = false;
      return { success: true, accounts: this.accounts };
    } catch (error) {
      console.error("MyAlgo connection error:", error);
      this.simulationMode = true;
      const simulatedAccount = {
        address: this.generateSimulatedAddress(),
        name: "Simulated MyAlgo Account",
        provider: "myalgo"
      };
      this.accounts = [simulatedAccount];
      this.connected = true;
      return {
        success: true,
        accounts: this.accounts,
        simulated: true,
        message: "Connected to simulated MyAlgo wallet for demo purposes"
      };
    }
  }
  async initWalletConnect() {
    try {
      this.walletConnector = new WalletConnect({
        bridge: "https://bridge.walletconnect.org",
        // Required
        qrcodeModal: QRCodeModal
      });
      if (!this.walletConnector.connected) {
        await this.walletConnector.createSession();
      }
      this.walletConnector.on("connect", (error, payload) => {
        if (error) {
          throw error;
        }
        const { accounts } = payload.params[0];
        this.accounts = accounts.map((address) => ({
          address,
          provider: "walletconnect"
        }));
        this.connected = true;
        console.log("WalletConnect connected:", accounts);
      });
      this.walletConnector.on("session_update", (error, payload) => {
        if (error) {
          throw error;
        }
        const { accounts } = payload.params[0];
        this.accounts = accounts.map((address) => ({
          address,
          provider: "walletconnect"
        }));
        console.log("WalletConnect session updated:", accounts);
      });
      this.walletConnector.on("disconnect", (error, payload) => {
        if (error) {
          throw error;
        }
        this.connected = false;
        this.accounts = [];
        console.log("WalletConnect disconnected");
      });
      return true;
    } catch (error) {
      console.error("Failed to initialize WalletConnect:", error);
      return false;
    }
  }
  async connectWalletConnect() {
    try {
      const initSuccess = await this.initWalletConnect();
      if (!initSuccess) {
        throw new Error("Failed to initialize WalletConnect");
      }
      if (!this.walletConnector.connected) {
        await this.walletConnector.createSession();
      }
      return { success: true, message: "Please scan the QR code with your WalletConnect-compatible wallet" };
    } catch (error) {
      console.error("WalletConnect connection error:", error);
      this.simulationMode = true;
      const simulatedAccount = {
        address: this.generateSimulatedAddress(),
        name: "Simulated WalletConnect Account",
        provider: "walletconnect"
      };
      this.accounts = [simulatedAccount];
      this.connected = true;
      return {
        success: true,
        accounts: this.accounts,
        simulated: true,
        message: "Connected to simulated WalletConnect wallet for demo purposes"
      };
    }
  }
  async disconnect() {
    try {
      if (this.walletConnector && this.walletConnector.connected) {
        await this.walletConnector.killSession();
      }
      this.connected = false;
      this.accounts = [];
      this.simulationMode = false;
      return { success: true };
    } catch (error) {
      console.error("Disconnect error:", error);
      this.connected = false;
      this.accounts = [];
      this.simulationMode = false;
      return { success: true };
    }
  }
  async signTransaction(txn) {
    try {
      if (!this.connected) {
        throw new Error("No wallet connected");
      }
      if (this.simulationMode) {
        await new Promise((resolve) => setTimeout(resolve, 1500));
        const simulatedTxId = "SIMULATED-" + Math.random().toString(36).substring(2, 15);
        return {
          txID: simulatedTxId,
          blob: new Uint8Array(64),
          // Simulated signature blob
          simulated: true
        };
      }
      if (this.accounts[0].provider === "myalgo") {
        if (!this.myAlgoWallet) {
          await this.initMyAlgo();
        }
        const signedTxn = await this.myAlgoWallet.signTransaction(txn.toByte());
        return signedTxn;
      }
      if (this.accounts[0].provider === "walletconnect") {
        if (!this.walletConnector) {
          throw new Error("WalletConnect not initialized");
        }
        const txnsToSign = [{
          txn,
          message: "Transaction request from ImpactX"
        }];
        const request = this.walletConnector.signTransaction([txnsToSign]);
        return request;
      }
      throw new Error("Unsupported wallet provider");
    } catch (error) {
      console.error("Sign transaction error:", error);
      if (this.connected) {
        await new Promise((resolve) => setTimeout(resolve, 1500));
        const simulatedTxId = "SIMULATED-" + Math.random().toString(36).substring(2, 15);
        return {
          txID: simulatedTxId,
          blob: new Uint8Array(64),
          // Simulated signature blob
          simulated: true
        };
      }
      throw error;
    }
  }
  getAccounts() {
    return this.accounts;
  }
  isConnected() {
    return this.connected;
  }
  // Method to check if we're in simulation mode
  isSimulationMode() {
    return this.simulationMode;
  }
}
const walletService = new WalletService();
const useWallet = () => {
  const [wallet, setWallet] = reactExports.useState(null);
  const [connected, setConnected] = reactExports.useState(false);
  const [loading, setLoading] = reactExports.useState(false);
  const [accounts, setAccounts] = reactExports.useState([]);
  const [simulationMode, setSimulationMode] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const storedWallet = localStorage.getItem("connectedWallet");
    if (storedWallet) {
      const parsedWallet = JSON.parse(storedWallet);
      setWallet(parsedWallet);
      setConnected(true);
      setAccounts(parsedWallet.accounts || []);
      if (parsedWallet.simulated) {
        setSimulationMode(true);
      }
    }
  }, []);
  const connectMyAlgo = async () => {
    setLoading(true);
    try {
      const result = await walletService.connectMyAlgo();
      if (result.success) {
        const walletData = {
          provider: "myalgo",
          accounts: result.accounts,
          simulated: result.simulated || false
          // Store simulation status
        };
        setWallet(walletData);
        setConnected(true);
        setAccounts(result.accounts);
        setSimulationMode(result.simulated || false);
        localStorage.setItem("connectedWallet", JSON.stringify(walletData));
        return { success: true, wallet: walletData, message: result.message };
      } else {
        return { success: false, error: result.error || "Failed to connect to MyAlgo wallet" };
      }
    } catch (error) {
      console.error("MyAlgo connection error:", error);
      return { success: false, error: error.message };
    } finally {
      setLoading(false);
    }
  };
  const connectWalletConnect = async () => {
    setLoading(true);
    try {
      const result = await walletService.connectWalletConnect();
      if (result.success) {
        if (result.accounts) {
          const walletData = {
            provider: "walletconnect",
            accounts: result.accounts,
            simulated: result.simulated || false
          };
          setWallet(walletData);
          setConnected(true);
          setAccounts(result.accounts);
          setSimulationMode(result.simulated || false);
          localStorage.setItem("connectedWallet", JSON.stringify(walletData));
        }
        return { success: true, message: result.message };
      } else {
        return { success: false, error: result.error || "Failed to connect to WalletConnect" };
      }
    } catch (error) {
      console.error("WalletConnect connection error:", error);
      return { success: false, error: error.message };
    } finally {
      setLoading(false);
    }
  };
  const disconnectWallet = async () => {
    try {
      await walletService.disconnect();
      setWallet(null);
      setConnected(false);
      setAccounts([]);
      setSimulationMode(false);
      localStorage.removeItem("connectedWallet");
      return { success: true };
    } catch (error) {
      console.error("Disconnect error:", error);
      setWallet(null);
      setConnected(false);
      setAccounts([]);
      setSimulationMode(false);
      localStorage.removeItem("connectedWallet");
      return { success: true };
    }
  };
  return {
    wallet,
    connected,
    loading,
    accounts,
    simulationMode,
    // Expose simulation mode status
    connectMyAlgo,
    connectWalletConnect,
    disconnectWallet
  };
};
class AuthHelper {
  constructor() {
    this.tokenKey = "impactx_auth_token";
    this.userKey = "impactx_user_data";
    this.mockMode = true;
  }
  // Store token and user data in localStorage
  storeAuthData(token, userData) {
    localStorage.setItem(this.tokenKey, token);
    localStorage.setItem(this.userKey, JSON.stringify(userData));
  }
  // Retrieve token from localStorage
  getToken() {
    if (this.mockMode) {
      return "mock-jwt-token";
    }
    return localStorage.getItem(this.tokenKey);
  }
  // Retrieve user data from localStorage
  getUserData() {
    if (this.mockMode) {
      return {
        id: 1,
        email: "user@example.com",
        role: "DONOR",
        name: "Mock User"
      };
    }
    const userData = localStorage.getItem(this.userKey);
    return userData ? JSON.parse(userData) : null;
  }
  // Clear authentication data
  clearAuthData() {
    localStorage.removeItem(this.tokenKey);
    localStorage.removeItem(this.userKey);
  }
  // Check if user is authenticated
  isAuthenticated() {
    if (this.mockMode) {
      return true;
    }
    const token = this.getToken();
    return !!token;
  }
  // Get authentication headers for API requests
  getAuthHeaders() {
    if (this.mockMode) {
      return {
        "Authorization": "Bearer mock-jwt-token",
        "Content-Type": "application/json"
      };
    }
    const token = this.getToken();
    if (!token) {
      throw new Error("No authentication token found. Please log in.");
    }
    return {
      "Authorization": `Bearer ${token}`,
      "Content-Type": "application/json"
    };
  }
  // Make authenticated API request (mock implementation)
  async makeAuthenticatedRequest(endpoint, options = {}) {
    console.log("Mock authenticated request to:", endpoint);
    await new Promise((resolve) => setTimeout(resolve, 300));
    if (endpoint.includes("/donations")) {
      return this.getMockDonationsResponse();
    } else if (endpoint.includes("/campaigns")) {
      return this.getMockCampaignsResponse();
    } else if (endpoint.includes("/auth/login")) {
      return this.getMockLoginResponse();
    } else if (endpoint.includes("/auth/register")) {
      return this.getMockRegisterResponse();
    }
    return {
      ok: true,
      json: async () => ({
        message: "Mock response",
        data: null
      })
    };
  }
  // Mock response methods
  getMockDonationsResponse() {
    return {
      ok: true,
      json: async () => ({
        donations: [
          { id: 1, amount: 1e3, campaignId: 1, date: "2023-06-15", donor: "Anonymous" },
          { id: 2, amount: 500, campaignId: 2, date: "2023-06-10", donor: "John Doe" },
          { id: 3, amount: 2500, campaignId: 1, date: "2023-06-05", donor: "Jane Smith" }
        ]
      })
    };
  }
  getMockCampaignsResponse() {
    return {
      ok: true,
      json: async () => ({
        campaigns: [
          {
            id: 1,
            title: "Flood Relief in Kerala",
            description: "Support flood victims in Kerala with emergency supplies and shelter",
            goal: 1e5,
            raised: 75e3,
            endDate: "2023-12-31",
            image: "/placeholder-image.jpg"
          },
          {
            id: 2,
            title: "Earthquake Recovery in Manipur",
            description: "Help rebuild communities affected by the recent earthquake",
            goal: 5e4,
            raised: 3e4,
            endDate: "2023-11-30",
            image: "/placeholder-image.jpg"
          }
        ]
      })
    };
  }
  getMockLoginResponse() {
    return {
      ok: true,
      json: async () => ({
        token: "mock-jwt-token",
        user: {
          id: 1,
          email: "user@example.com",
          role: "DONOR",
          name: "Mock User"
        }
      })
    };
  }
  getMockRegisterResponse() {
    return {
      ok: true,
      json: async () => ({
        token: "mock-jwt-token",
        user: {
          id: 1,
          email: "user@example.com",
          role: "DONOR",
          name: "Mock User"
        }
      })
    };
  }
  // Simulate automatic login for demo purposes (mock implementation)
  async simulateAutoLogin() {
    console.log("Mock auto-login simulation");
    if (this.mockMode) {
      return {
        token: "mock-jwt-token",
        user: {
          id: 1,
          email: "user@example.com",
          role: "DONOR",
          name: "Mock User"
        }
      };
    }
    if (this.isAuthenticated()) {
      return {
        token: this.getToken(),
        user: this.getUserData()
      };
    }
  }
  // Enhanced method to handle any API call with automatic authentication
  async apiCall(endpoint, method = "GET", data = null) {
    const options = {
      method,
      headers: {}
    };
    if (data) {
      options.headers["Content-Type"] = "application/json";
      options.body = JSON.stringify(data);
    }
    return await this.makeAuthenticatedRequest(endpoint, options);
  }
}
const authHelper = new AuthHelper();
const useAuth = () => {
  const [isAuthenticated, setIsAuthenticated] = reactExports.useState(false);
  const [user, setUser] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  reactExports.useEffect(() => {
    checkAuthStatus();
  }, []);
  const checkAuthStatus = () => {
    try {
      const authStatus = authHelper.isAuthenticated();
      const userData = authHelper.getUserData();
      setIsAuthenticated(authStatus);
      setUser(userData);
    } catch (error) {
      console.error("Error checking auth status:", error);
    } finally {
      setLoading(false);
    }
  };
  const login = async (email, password) => {
    try {
      setLoading(true);
      const response = await fetch("http://localhost:5000/api/v1/auth/login", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ email, password })
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Login failed");
      }
      const data = await response.json();
      authHelper.storeAuthData(data.token, data.user);
      setIsAuthenticated(true);
      setUser(data.user);
      return { success: true, data };
    } catch (error) {
      console.error("Login error:", error);
      return { success: false, error: error.message };
    } finally {
      setLoading(false);
    }
  };
  const register = async (email, password, role) => {
    try {
      setLoading(true);
      const response = await fetch("http://localhost:5000/api/v1/auth/register", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ email, password, role })
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Registration failed");
      }
      const data = await response.json();
      authHelper.storeAuthData(data.token, data.user);
      setIsAuthenticated(true);
      setUser(data.user);
      return { success: true, data };
    } catch (error) {
      console.error("Registration error:", error);
      return { success: false, error: error.message };
    } finally {
      setLoading(false);
    }
  };
  const logout = () => {
    authHelper.clearAuthData();
    setIsAuthenticated(false);
    setUser(null);
  };
  const makeAuthenticatedRequest = async (endpoint, options = {}) => {
    try {
      const response = await authHelper.makeAuthenticatedRequest(endpoint, options);
      return response;
    } catch (error) {
      console.error("Authenticated request failed:", error);
      throw error;
    }
  };
  const simulateAuth = async () => {
    try {
      setLoading(true);
      const authData = await authHelper.simulateAutoLogin();
      setIsAuthenticated(true);
      setUser(authData.user);
      return authData;
    } catch (error) {
      console.error("Simulation failed:", error);
      throw error;
    } finally {
      setLoading(false);
    }
  };
  const apiCall = async (endpoint, method = "GET", data = null) => {
    try {
      const response = await authHelper.apiCall(endpoint, method, data);
      return response;
    } catch (error) {
      console.error("API call failed:", error);
      throw error;
    }
  };
  return {
    isAuthenticated,
    user,
    loading,
    login,
    register,
    logout,
    makeAuthenticatedRequest,
    simulateAuth,
    checkAuthStatus,
    apiCall
  };
};
const Donate = () => {
  const [amount, setAmount] = reactExports.useState("");
  const [selectedCampaign, setSelectedCampaign] = reactExports.useState("");
  const [campaigns, setCampaigns] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const [success, setSuccess] = reactExports.useState(false);
  const [walletType, setWalletType] = reactExports.useState("");
  const [donationType, setDonationType] = reactExports.useState("general");
  const [transactionStatus, setTransactionStatus] = reactExports.useState("");
  const [transactionId, setTransactionId] = reactExports.useState("");
  const {
    wallet,
    connected,
    accounts,
    simulationMode,
    connectMyAlgo,
    connectWalletConnect,
    disconnectWallet
  } = useWallet();
  useAuth();
  const location = useLocation();
  const navigate = useNavigate();
  reactExports.useEffect(() => {
    const mockCampaigns = [
      {
        id: "1",
        title: "Kerala Flood Relief",
        description: "Providing emergency aid to flood-affected families in Kerala",
        goal: 5e6,
        raised: 375e4,
        status: "active",
        source: "NDRF Kerala Unit",
        ngo: "Kerala Relief Foundation"
      },
      {
        id: "2",
        title: "Rajasthan Drought Support",
        description: "Water conservation and distribution in drought-prone areas of Rajasthan",
        goal: 3e6,
        raised: 285e4,
        status: "active",
        source: "Government of Rajasthan",
        ngo: "Rajasthan Water Initiative"
      },
      {
        id: "3",
        title: "Himalayan Earthquake Recovery",
        description: "Rebuilding homes and infrastructure after the earthquake in Uttarakhand",
        goal: 8e6,
        raised: 8e6,
        status: "completed",
        source: "Ministry of Home Affairs",
        ngo: "Himalayan Reconstruction Trust"
      }
    ];
    setCampaigns(mockCampaigns);
    const params = new URLSearchParams(location.search);
    const campaignId = params.get("campaign");
    if (campaignId) {
      setSelectedCampaign(campaignId);
    } else if (mockCampaigns.length > 0) {
      setSelectedCampaign(mockCampaigns[0].id);
    }
  }, [location.search]);
  const handleConnectWallet = async () => {
    if (!walletType) {
      setError("Please select a wallet type");
      return;
    }
    setError(null);
    if (walletType === "myalgo") {
      const result = await connectMyAlgo();
      if (!result.success) {
        setError(result.error);
      } else if (result.message) {
        setError(result.message);
      }
    } else if (walletType === "walletconnect") {
      const result = await connectWalletConnect();
      if (!result.success) {
        setError(result.error);
      } else if (result.message) {
        setError(result.message);
      }
    }
  };
  const handleDonate = async (e3) => {
    e3.preventDefault();
    if (!connected) {
      setError("Please connect your wallet first");
      return;
    }
    if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
      setError("Please enter a valid amount");
      return;
    }
    if (donationType === "specific" && !selectedCampaign) {
      setError("Please select a campaign");
      return;
    }
    setLoading(true);
    setError(null);
    setTransactionStatus("Processing your donation...");
    setTransactionId("");
    try {
      setTransactionStatus("Preparing transaction...");
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      setTransactionStatus("Connecting to wallet...");
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      if (simulationMode) {
        setTransactionStatus("Simulating blockchain transaction...");
        await new Promise((resolve) => setTimeout(resolve, 2e3));
        const simulatedTxId = "SIMULATED-" + Math.random().toString(36).substring(2, 15).toUpperCase();
        setTransactionId(simulatedTxId);
        setTransactionStatus("Transaction confirmed on blockchain!");
      } else {
        setTransactionStatus("Waiting for wallet confirmation...");
        await new Promise((resolve) => setTimeout(resolve, 2e3));
        setTransactionStatus("Transaction confirmed on blockchain!");
      }
      setTransactionStatus("Recording donation in database...");
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      const donationData = {
        amount: parseFloat(amount),
        campaignId: donationType === "specific" ? selectedCampaign : null
      };
      await apiService.createDonation(donationData);
      setTransactionStatus("Donation recorded successfully!");
      setSuccess(true);
      setAmount("");
      setTimeout(() => {
        navigate("/campaigns");
      }, 3e3);
    } catch (err) {
      setError(err.message || "Failed to process donation");
      setTransactionStatus("");
    } finally {
      setLoading(false);
      setTimeout(() => {
        setTransactionStatus("");
        setTransactionId("");
      }, 5e3);
    }
  };
  const presetAmounts = [
    { value: 100, label: "100" },
    { value: 500, label: "500" },
    { value: 1e3, label: "1000" },
    { value: 5e3, label: "5000" }
  ];
  const selectedCampaignDetails = campaigns.find((c2) => c2.id === selectedCampaign);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-10", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-4xl font-bold text-gray-800 dark:text-white mb-4", children: "Make a Donation" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-gray-600 dark:text-gray-300 max-w-2xl mx-auto", children: "Your contribution helps provide immediate relief and long-term support to communities in need across India" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lg:col-span-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-2xl shadow-xl p-6 mb-8 border border-gray-100 dark:border-gray-700", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white mb-6 flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6 mr-2 text-blue-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }) }),
            "Donation Details"
          ] }),
          success ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gradient-to-r from-green-500 to-emerald-600 text-white p-6 rounded-xl mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-10 h-10 mr-3", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold", children: "Donation Successful!" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Thank you for your generous contribution. Your donation is making a difference." })
            ] })
          ] }) }) : null,
          transactionStatus && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 dark:bg-blue-900/30 border-l-4 border-blue-500 text-blue-700 dark:text-blue-300 p-4 rounded-lg mb-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 mr-2 animate-spin", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Transaction:" }),
                " ",
                transactionStatus
              ] })
            ] }),
            transactionId && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mt-2 text-sm font-mono", children: [
              "Transaction ID: ",
              transactionId
            ] })
          ] }),
          error ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-red-100 dark:bg-red-900/30 border-l-4 border-red-500 text-red-700 dark:text-red-300 p-4 rounded-lg mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Error:" }),
            " ",
            error
          ] }) }) : null,
          /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleDonate, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-gray-700 dark:text-gray-300 font-medium mb-3", children: "Donation Type" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    type: "button",
                    onClick: () => setDonationType("general"),
                    className: `py-4 px-4 rounded-xl border-2 transition-all ${donationType === "general" ? "border-blue-500 bg-blue-50 dark:bg-blue-900/30" : "border-gray-200 dark:border-gray-700 hover:border-gray-300 dark:hover:border-gray-600"}`,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-semibold text-lg", children: "General Fund" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-600 dark:text-gray-400 mt-1", children: "Support all relief efforts" })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    type: "button",
                    onClick: () => setDonationType("specific"),
                    className: `py-4 px-4 rounded-xl border-2 transition-all ${donationType === "specific" ? "border-blue-500 bg-blue-50 dark:bg-blue-900/30" : "border-gray-200 dark:border-gray-700 hover:border-gray-300 dark:hover:border-gray-600"}`,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-semibold text-lg", children: "Specific Campaign" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-600 dark:text-gray-400 mt-1", children: "Support a specific cause" })
                    ]
                  }
                )
              ] })
            ] }),
            donationType === "specific" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "campaign", className: "block text-gray-700 dark:text-gray-300 font-medium mb-2", children: "Select Campaign" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "select",
                {
                  id: "campaign",
                  value: selectedCampaign,
                  onChange: (e3) => setSelectedCampaign(e3.target.value),
                  className: "w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-white",
                  disabled: loading,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Choose a campaign" }),
                    campaigns.map((campaign) => /* @__PURE__ */ jsxRuntimeExports.jsxs("option", { value: campaign.id, children: [
                      campaign.title,
                      " (Goal: ",
                      campaign.goal.toLocaleString(),
                      ")"
                    ] }, campaign.id))
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-gray-700 dark:text-gray-300 font-medium mb-3", children: "Donation Amount" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-4 gap-3 mb-4", children: presetAmounts.map((preset) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: () => setAmount(preset.value.toString()),
                  className: `py-3 rounded-xl font-medium transition-all ${amount === preset.value.toString() ? "bg-blue-600 text-white shadow-md" : "bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600"}`,
                  children: preset.label
                },
                preset.value
              )) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500 dark:text-gray-400", children: "" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "number",
                    value: amount,
                    onChange: (e3) => setAmount(e3.target.value),
                    placeholder: "Enter custom amount",
                    className: "w-full pl-8 pr-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-white",
                    disabled: !connected || loading,
                    min: "1"
                  }
                )
              ] })
            ] }),
            !connected ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-gray-700 dark:text-gray-300 font-medium mb-3", children: "Connect Wallet" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    type: "button",
                    onClick: () => setWalletType("myalgo"),
                    className: `py-4 px-4 rounded-xl border-2 transition-all flex flex-col items-center ${walletType === "myalgo" ? "border-blue-500 bg-blue-50 dark:bg-blue-900/30" : "border-gray-200 dark:border-gray-700 hover:border-gray-300 dark:hover:border-gray-600"}`,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-200 dark:bg-gray-600 border-2 border-dashed rounded-xl w-16 h-16 mb-2" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-semibold", children: "MyAlgo Wallet" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-600 dark:text-gray-400", children: "Browser extension" })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    type: "button",
                    onClick: () => setWalletType("walletconnect"),
                    className: `py-4 px-4 rounded-xl border-2 transition-all flex flex-col items-center ${walletType === "walletconnect" ? "border-blue-500 bg-blue-50 dark:bg-blue-900/30" : "border-gray-200 dark:border-gray-700 hover:border-gray-300 dark:hover:border-gray-600"}`,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-200 dark:bg-gray-600 border-2 border-dashed rounded-xl w-16 h-16 mb-2" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-semibold", children: "WalletConnect" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-600 dark:text-gray-400", children: "Mobile wallet" })
                    ]
                  }
                )
              ] }),
              walletType && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: handleConnectWallet,
                  disabled: loading,
                  className: "w-full mt-4 bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white font-bold py-3 px-4 rounded-xl transition-all shadow-lg",
                  children: loading ? "Connecting..." : `Connect ${walletType === "myalgo" ? "MyAlgo" : "WalletConnect"}`
                }
              )
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-6 p-4 bg-green-50 dark:bg-green-900/30 rounded-xl border border-green-200 dark:border-green-800", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium text-green-800 dark:text-green-200", children: "Connected Wallet" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-green-600 dark:text-green-400", children: [
                  wallet.provider === "myalgo" ? "MyAlgo Wallet" : "WalletConnect",
                  simulationMode && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 px-2 py-1 bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-200 text-xs rounded-full", children: "Demo Mode" })
                ] }),
                accounts.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-green-600 dark:text-green-400 font-mono", children: [
                  accounts[0].address.substring(0, 6),
                  "...",
                  accounts[0].address.substring(accounts[0].address.length - 4)
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: disconnectWallet,
                  className: "bg-red-100 dark:bg-red-900/30 hover:bg-red-200 dark:hover:bg-red-800 text-red-700 dark:text-red-300 font-bold py-2 px-4 rounded-lg transition-colors",
                  children: "Disconnect"
                }
              )
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "submit",
                disabled: !connected || loading || !amount,
                className: `w-full py-4 rounded-xl font-bold text-lg transition-all shadow-lg ${connected && amount ? "bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white transform hover:scale-[1.02]" : "bg-gray-300 dark:bg-gray-700 text-gray-500 dark:text-gray-400 cursor-not-allowed"}`,
                children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "animate-spin -ml-1 mr-3 h-5 w-5 text-white", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })
                  ] }),
                  "Processing Donation..."
                ] }) : `Donate ${amount || 0}`
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-gray-800 dark:to-gray-900 rounded-2xl p-6 border border-blue-100 dark:border-gray-700", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-4 flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 mr-2 text-blue-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }) }),
            "How Your Donation Helps"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-100 dark:bg-blue-900/30 rounded-full p-2 mr-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-blue-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "Transparent Tracking" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 dark:text-gray-400", children: "Every rupee is tracked on the blockchain" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-100 dark:bg-blue-900/30 rounded-full p-2 mr-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-blue-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "Multi-Verification" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 dark:text-gray-400", children: "Verified by multiple independent sources" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-100 dark:bg-blue-900/30 rounded-full p-2 mr-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-blue-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "100% Accountable" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 dark:text-gray-400", children: "Funds released only upon verification" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-100 dark:bg-blue-900/30 rounded-full p-2 mr-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-blue-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "Tax Benefits" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 dark:text-gray-400", children: "Eligible for 80G tax deductions" })
              ] })
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        selectedCampaignDetails && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-2xl shadow-xl p-6 border border-gray-100 dark:border-gray-700 mb-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-4", children: "Campaign Details" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold text-lg", children: selectedCampaignDetails.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-400 text-sm mt-1", children: selectedCampaignDetails.description })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-sm text-gray-500 dark:text-gray-400 mb-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Raised" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Goal" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "h-full bg-gradient-to-r from-green-400 to-emerald-500 rounded-full",
                style: { width: `${selectedCampaignDetails.raised / selectedCampaignDetails.goal * 100}%` }
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-sm mt-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-semibold", children: [
                "",
                selectedCampaignDetails.raised.toLocaleString()
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-semibold", children: [
                "",
                selectedCampaignDetails.goal.toLocaleString()
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-600 dark:text-gray-400", children: "Source:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: selectedCampaignDetails.source })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-600 dark:text-gray-400", children: "NGO:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: selectedCampaignDetails.ngo })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-600 dark:text-gray-400", children: "Status:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `font-medium ${selectedCampaignDetails.status === "active" ? "text-green-600 dark:text-green-400" : "text-blue-600 dark:text-blue-400"}`, children: selectedCampaignDetails.status === "active" ? "Active" : "Completed" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-blue-600 to-indigo-700 text-white rounded-2xl shadow-xl p-6 mb-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold mb-4", children: "Your Impact" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center pb-3 border-b border-blue-500/30", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Families Fed" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-xl", children: "1,240" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center pb-3 border-b border-blue-500/30", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Homes Rebuilt" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-xl", children: "320" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center pb-3 border-b border-blue-500/30", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Students Educated" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-xl", children: "890" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Water Wells" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-xl", children: "45" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-2xl shadow-xl p-6 border border-gray-100 dark:border-gray-700", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-4", children: "Donor Stories" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 dark:bg-gray-700 p-4 rounded-xl", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center mb-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-200 dark:bg-gray-600 border-2 border-dashed rounded-xl w-10 h-10 mr-3" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-semibold", children: "Priya Sharma" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-600 dark:text-gray-400", children: "Mumbai, Maharashtra" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-700 dark:text-gray-300 text-sm", children: `"I can see exactly where my donation went. It's so reassuring to know that my money is actually helping people."` })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 dark:bg-gray-700 p-4 rounded-xl", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center mb-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-200 dark:bg-gray-600 border-2 border-dashed rounded-xl w-10 h-10 mr-3" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-semibold", children: "Rajesh Kumar" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-600 dark:text-gray-400", children: "Bangalore, Karnataka" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-700 dark:text-gray-300 text-sm", children: `"The transparency is unmatched. I've never felt more confident about donating to a cause."` })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-green-500 to-emerald-600 text-white rounded-2xl shadow-xl p-6 mt-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold mb-2", children: "Tax Benefits" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-4", children: "All donations are eligible for 80G tax deductions" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white/20 rounded-lg p-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm", children: "Potential Tax Savings" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-2xl font-bold", children: [
              "",
              amount ? Math.round(parseInt(amount) * 0.33) : 0
            ] })
          ] })
        ] })
      ] })
    ] })
  ] });
};
const NGODashboard = () => {
  const [description, setDescription] = reactExports.useState("");
  const [proofFile, setProofFile] = reactExports.useState(null);
  const [selectedCampaign, setSelectedCampaign] = reactExports.useState("");
  const [campaigns, setCampaigns] = reactExports.useState([]);
  const [uploading, setUploading] = reactExports.useState(false);
  const [uploaded, setUploaded] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const [activeTab, setActiveTab] = reactExports.useState("upload");
  const [proofs, setProofs] = reactExports.useState([]);
  useAuth();
  reactExports.useEffect(() => {
    setCampaigns([
      { id: "1", title: "Kerala Flood Relief", goal: 5e6, raised: 375e4, status: "active" },
      { id: "2", title: "Rajasthan Drought Support", goal: 3e6, raised: 285e4, status: "active" },
      { id: "3", title: "Himalayan Earthquake Recovery", goal: 8e6, raised: 8e6, status: "completed" }
    ]);
    setProofs([
      { id: "1", campaign: "Kerala Flood Relief", status: "verified", date: "2025-10-15", amount: 15e5 },
      { id: "2", campaign: "Rajasthan Drought Support", status: "pending", date: "2025-10-18", amount: 95e4 },
      { id: "3", campaign: "Himalayan Earthquake Recovery", status: "verified", date: "2025-10-10", amount: 8e6 }
    ]);
  }, []);
  const handleFileChange = (e3) => {
    setProofFile(e3.target.files[0]);
  };
  const handleSubmit = async (e3) => {
    e3.preventDefault();
    if (!description.trim()) {
      setError("Please provide a description of the aid delivery");
      return;
    }
    if (!selectedCampaign) {
      setError("Please select a campaign");
      return;
    }
    setUploading(true);
    setError(null);
    try {
      await new Promise((resolve) => setTimeout(resolve, 2e3));
      setUploaded(true);
      setDescription("");
      setProofFile(null);
      setSelectedCampaign("");
      const newProof = {
        id: (proofs.length + 1).toString(),
        campaign: campaigns.find((c2) => c2.id === selectedCampaign)?.title || "Unknown Campaign",
        status: "pending",
        date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        amount: Math.floor(Math.random() * 1e6) + 5e5
      };
      setProofs([newProof, ...proofs]);
      e3.target.reset();
    } catch (err) {
      setError(err.message || "Failed to upload proof");
    } finally {
      setUploading(false);
    }
  };
  const totalRaised = campaigns.reduce((sum, c2) => sum + c2.raised, 0);
  const totalVerified = proofs.filter((p2) => p2.status === "verified").length;
  const pendingVerification = proofs.filter((p2) => p2.status === "pending").length;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-6xl mx-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-4xl font-bold text-gray-800 dark:text-white mb-2", children: "NGO Dashboard" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-gray-600 dark:text-gray-300", children: "Manage your campaigns and verify aid distribution" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-4 gap-6 mb-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-2xl p-6 shadow-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-3xl font-bold", children: [
          "",
          totalRaised.toLocaleString()
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-blue-100", children: "Total Funds Raised" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-green-500 to-emerald-600 text-white rounded-2xl p-6 shadow-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-bold", children: campaigns.filter((c2) => c2.status === "active").length }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-green-100", children: "Active Campaigns" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-amber-500 to-orange-600 text-white rounded-2xl p-6 shadow-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-bold", children: totalVerified }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-amber-100", children: "Verified Proofs" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-purple-500 to-fuchsia-600 text-white rounded-2xl p-6 shadow-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-bold", children: pendingVerification }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-purple-100", children: "Pending Verification" })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-2xl shadow-lg mb-8 border border-gray-100 dark:border-gray-700", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-b border-gray-200 dark:border-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "flex -mb-px overflow-x-auto", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setActiveTab("upload"),
            className: `py-4 px-6 text-center border-b-2 font-medium text-sm whitespace-nowrap ${activeTab === "upload" ? "border-blue-500 text-blue-600 dark:text-blue-400" : "border-transparent text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600"}`,
            children: "Upload Proof"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setActiveTab("campaigns"),
            className: `py-4 px-6 text-center border-b-2 font-medium text-sm whitespace-nowrap ${activeTab === "campaigns" ? "border-blue-500 text-blue-600 dark:text-blue-400" : "border-transparent text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600"}`,
            children: "My Campaigns"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setActiveTab("analytics"),
            className: `py-4 px-6 text-center border-b-2 font-medium text-sm whitespace-nowrap ${activeTab === "analytics" ? "border-blue-500 text-blue-600 dark:text-blue-400" : "border-transparent text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600"}`,
            children: "Analytics"
          }
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6", children: [
        activeTab === "upload" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white mb-6", children: "Upload Proof of Aid Delivery" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300 mb-6", children: "As an authorized NGO, you can upload proof that aid has been delivered to release the escrowed funds." }),
            uploaded && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-6 p-4 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-xl", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6 mr-2", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold", children: "Proof Uploaded Successfully!" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-green-100", children: "The escrowed funds will be released after oracle verification." })
              ] })
            ] }) }),
            error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-6 p-4 bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300 rounded-xl", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Error:" }),
              " ",
              error
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "campaign", className: "block text-gray-700 dark:text-gray-300 font-medium mb-2", children: "Select Campaign" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "select",
                  {
                    id: "campaign",
                    value: selectedCampaign,
                    onChange: (e3) => setSelectedCampaign(e3.target.value),
                    className: "w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-white",
                    disabled: uploading,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Choose a campaign" }),
                      campaigns.map((campaign) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: campaign.id, children: campaign.title }, campaign.id))
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "description", className: "block text-gray-700 dark:text-gray-300 font-medium mb-2", children: "Description of Aid Delivery" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "textarea",
                  {
                    id: "description",
                    value: description,
                    onChange: (e3) => setDescription(e3.target.value),
                    placeholder: "Describe the aid that has been delivered, including quantities, locations, and beneficiaries...",
                    rows: "4",
                    className: "w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-white",
                    disabled: uploading
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "proof", className: "block text-gray-700 dark:text-gray-300 font-medium mb-2", children: "Proof Document/Image" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex flex-col items-center justify-center w-full h-48 border-2 border-gray-300 dark:border-gray-600 border-dashed rounded-xl cursor-pointer bg-gray-50 dark:bg-gray-700 hover:bg-gray-100 dark:hover:bg-gray-600", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center pt-5 pb-6", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-10 h-10 mb-3 text-gray-400 dark:text-gray-500", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mb-2 text-sm text-gray-500 dark:text-gray-400", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: "Click to upload" }),
                      " or drag and drop"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-500 dark:text-gray-400", children: "PNG, JPG, PDF up to 10MB" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "file",
                      id: "proof",
                      onChange: handleFileChange,
                      accept: "image/*,application/pdf",
                      className: "hidden",
                      disabled: uploading
                    }
                  )
                ] }) }),
                proofFile && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mt-2 text-sm text-gray-600 dark:text-gray-400", children: [
                  "Selected file: ",
                  proofFile.name
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "submit",
                  disabled: uploading,
                  className: `w-full py-4 rounded-xl font-bold text-lg transition-all shadow-lg ${uploading ? "bg-gray-300 dark:bg-gray-700 text-gray-500 dark:text-gray-400 cursor-not-allowed" : "bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white transform hover:scale-[1.02]"}`,
                  children: uploading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "animate-spin -ml-1 mr-3 h-5 w-5 text-white", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })
                    ] }),
                    "Uploading Proof..."
                  ] }) : "Upload Proof & Request Fund Release"
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-6", children: "Verification Process" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gradient-to-br from-blue-50 to-indigo-50 dark:from-gray-700 dark:to-gray-800 rounded-2xl p-6 border border-blue-100 dark:border-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-100 dark:bg-blue-900/30 rounded-full p-2 mr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold", children: "1" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold text-lg", children: "Upload Proof" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-400", children: "Submit detailed documentation of aid distribution" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-100 dark:bg-blue-900/30 rounded-full p-2 mr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold", children: "2" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold text-lg", children: "Multi-Oracle Verification" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-400", children: "Multiple independent sources verify your proof" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-100 dark:bg-blue-900/30 rounded-full p-2 mr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold", children: "3" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold text-lg", children: "Fund Release" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-400", children: "Upon successful verification, funds are released to your account" })
                ] })
              ] })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 bg-white dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-2xl p-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-4", children: "Recent Uploads" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: proofs.slice(0, 3).map((proof) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 bg-gray-50 dark:bg-gray-600 rounded-xl", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: proof.campaign }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-600 dark:text-gray-300", children: [
                    "",
                    proof.amount.toLocaleString(),
                    "  ",
                    proof.date
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-3 py-1 rounded-full text-xs font-semibold ${proof.status === "verified" ? "bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300" : "bg-amber-100 dark:bg-amber-900/30 text-amber-800 dark:text-amber-300"}`, children: proof.status === "verified" ? "Verified" : "Pending" })
              ] }, proof.id)) })
            ] })
          ] })
        ] }),
        activeTab === "campaigns" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white", children: "My Campaigns" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white font-bold py-2 px-4 rounded-xl transition-all shadow-md", children: "+ New Campaign" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6", children: campaigns.map((campaign) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-2xl overflow-hidden shadow-lg hover:shadow-xl transition-all", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-32 bg-gradient-to-r from-blue-400 to-indigo-500 relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-4 right-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-3 py-1 rounded-full text-sm font-semibold ${campaign.status === "active" ? "bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300" : "bg-gray-100 dark:bg-gray-600 text-gray-800 dark:text-gray-300"}`, children: campaign.status === "active" ? "Active" : "Completed" }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-2", children: campaign.title }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-sm text-gray-500 dark:text-gray-400 mb-1", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Raised" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Goal" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-2 bg-gray-200 dark:bg-gray-600 rounded-full overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "h-full bg-gradient-to-r from-green-400 to-emerald-500 rounded-full",
                    style: { width: `${campaign.raised / campaign.goal * 100}%` }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-sm mt-1", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-semibold", children: [
                    "",
                    campaign.raised.toLocaleString()
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-semibold", children: [
                    "",
                    campaign.goal.toLocaleString()
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "flex-1 bg-blue-100 dark:bg-blue-900/30 hover:bg-blue-200 dark:hover:bg-blue-800 text-blue-700 dark:text-blue-300 font-bold py-2 px-4 rounded-lg transition-colors", children: "View Details" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "flex-1 bg-gray-100 dark:bg-gray-600 hover:bg-gray-200 dark:hover:bg-gray-500 text-gray-700 dark:text-gray-300 font-bold py-2 px-4 rounded-lg transition-colors", children: "Edit" })
              ] })
            ] })
          ] }, campaign.id)) })
        ] }),
        activeTab === "analytics" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white mb-6", children: "Campaign Analytics" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-blue-50 to-indigo-50 dark:from-gray-700 dark:to-gray-800 rounded-2xl p-6 border border-blue-100 dark:border-gray-700", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-4", children: "Funds Distribution" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3 h-3 bg-blue-500 rounded-full mr-3" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Kerala Flood Relief" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "45%" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-500 h-2 rounded-full", style: { width: "45%" } }) })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3 h-3 bg-green-500 rounded-full mr-3" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Rajasthan Drought Support" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "30%" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-green-500 h-2 rounded-full", style: { width: "30%" } }) })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3 h-3 bg-amber-500 rounded-full mr-3" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Himalayan Earthquake Recovery" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "25%" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-amber-500 h-2 rounded-full", style: { width: "25%" } }) })
                  ] })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-green-50 to-emerald-50 dark:from-gray-700 dark:to-gray-800 rounded-2xl p-6 border border-green-100 dark:border-gray-700", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-4", children: "Impact Metrics" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-600 p-4 rounded-xl text-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-green-600", children: "1,240" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-600 dark:text-gray-300", children: "Families Fed" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-600 p-4 rounded-xl text-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-green-600", children: "320" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-600 dark:text-gray-300", children: "Homes Rebuilt" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-600 p-4 rounded-xl text-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-green-600", children: "890" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-600 dark:text-gray-300", children: "Students Educated" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-600 p-4 rounded-xl text-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-green-600", children: "45" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-600 dark:text-gray-300", children: "Water Wells" })
                ] })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 bg-white dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-2xl p-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-4", children: "Recent Activities" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center p-4 bg-gray-50 dark:bg-gray-600 rounded-xl", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-100 dark:bg-blue-900/30 rounded-full p-2 mr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-blue-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "Proof Verified" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300", children: "Kerala Flood Relief - 1,500,000 released" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-500 dark:text-gray-400 text-sm", children: "2 hours ago" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center p-4 bg-gray-50 dark:bg-gray-600 rounded-xl", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-green-100 dark:bg-green-900/30 rounded-full p-2 mr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-green-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "Donation Received" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300", children: "Rajasthan Drought Support - 500,000 from donor@example.com" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-500 dark:text-gray-400 text-sm", children: "1 day ago" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center p-4 bg-gray-50 dark:bg-gray-600 rounded-xl", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-amber-100 dark:bg-amber-900/30 rounded-full p-2 mr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-amber-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" }) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "Campaign Created" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300", children: "Himalayan Earthquake Recovery" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-500 dark:text-gray-400 text-sm", children: "3 days ago" })
              ] })
            ] })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gradient-to-r from-blue-600 to-indigo-700 rounded-2xl p-8 text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold mb-2", children: "Important Guidelines" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "space-y-2 text-blue-100", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 mr-2 mt-0.5 text-blue-200", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }),
            "Provide detailed proof with photos/documentation"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 mr-2 mt-0.5 text-blue-200", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }),
            "Include GPS coordinates of aid distribution"
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold mb-2", children: "Verification Process" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "space-y-2 text-blue-100", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 mr-2 mt-0.5 text-blue-200", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }),
            "Multi-oracle verification takes 24-48 hours"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 mr-2 mt-0.5 text-blue-200", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }),
            "Funds released immediately upon verification"
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold mb-2", children: "Support" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "space-y-2 text-blue-100", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 mr-2 mt-0.5 text-blue-200", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" }) }),
            "contact@impactx.org"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 mr-2 mt-0.5 text-blue-200", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z" }) }),
            "+91 98765 43210"
          ] })
        ] })
      ] })
    ] }) })
  ] });
};
const AdminDashboard = () => {
  const [campaigns, setCampaigns] = reactExports.useState([]);
  const [oracles, setOracles] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [error, setError] = reactExports.useState(null);
  const [activeTab, setActiveTab] = reactExports.useState("overview");
  const [stats, setStats] = reactExports.useState({});
  useAuth();
  reactExports.useEffect(() => {
    fetchData();
  }, []);
  const fetchData = async () => {
    try {
      setLoading(true);
      const mockCampaigns = [
        { id: "1", title: "Kerala Flood Relief", goal: 5e6, raised: 375e4, status: "active", creator: { email: "ngo1@example.com" } },
        { id: "2", title: "Rajasthan Drought Support", goal: 3e6, raised: 285e4, status: "active", creator: { email: "ngo2@example.com" } },
        { id: "3", title: "Himalayan Earthquake Recovery", goal: 8e6, raised: 8e6, status: "completed", creator: { email: "ngo3@example.com" } },
        { id: "4", title: "Tamil Nadu Cyclone Aid", goal: 45e5, raised: 12e5, status: "active", creator: { email: "ngo4@example.com" } }
      ];
      const mockOracles = [
        { id: "1", name: "Drone Oracle", publicKey: "ABC123...XYZ789", weight: 2, status: "active" },
        { id: "2", name: "Satellite Oracle", publicKey: "DEF456...UVW012", weight: 3, status: "active" },
        { id: "3", name: "IoT Sensor Network", publicKey: "GHI789...RST345", weight: 1, status: "active" },
        { id: "4", name: "NGO Field Report", publicKey: "JKL012...MNO678", weight: 2, status: "inactive" }
      ];
      const mockStats = {
        totalCampaigns: 24,
        activeCampaigns: 18,
        totalFunds: 125e6,
        verifiedFunds: 98e6,
        totalDonors: 5420,
        totalNGOs: 32,
        totalOracles: 4,
        verifiedProofs: 156
      };
      setCampaigns(mockCampaigns);
      setOracles(mockOracles);
      setStats(mockStats);
    } catch (err) {
      setError("Failed to fetch data");
      console.error("Fetch data error:", err);
    } finally {
      setLoading(false);
    }
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center items-center h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600" }) });
  }
  if (error) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-red-100 dark:bg-red-900/30 border border-red-400 dark:border-red-800 text-red-700 dark:text-red-300 px-4 py-3 rounded relative", role: "alert", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: "font-bold", children: "Error! " }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "block sm:inline", children: error })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-7xl mx-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-4xl font-bold text-gray-800 dark:text-white mb-2", children: "Admin Dashboard" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-gray-600 dark:text-gray-300", children: "Manage campaigns, oracles, and users for the ImpactX platform" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-2xl p-6 shadow-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white/20 rounded-full p-3 mr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold", children: stats.totalCampaigns }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-blue-100", children: "Total Campaigns" })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gradient-to-br from-green-500 to-emerald-600 text-white rounded-2xl p-6 shadow-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white/20 rounded-full p-3 mr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-2xl font-bold", children: [
            "",
            Math.round(stats.totalFunds / 1e5),
            "L"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-green-100", children: "Total Funds" })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gradient-to-br from-amber-500 to-orange-600 text-white rounded-2xl p-6 shadow-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white/20 rounded-full p-3 mr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold", children: stats.totalDonors }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-amber-100", children: "Total Donors" })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gradient-to-br from-purple-500 to-fuchsia-600 text-white rounded-2xl p-6 shadow-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white/20 rounded-full p-3 mr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold", children: stats.verifiedProofs }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-purple-100", children: "Verified Proofs" })
        ] })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-2xl shadow-lg mb-8 border border-gray-100 dark:border-gray-700", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-b border-gray-200 dark:border-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "flex -mb-px overflow-x-auto", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setActiveTab("overview"),
            className: `py-4 px-6 text-center border-b-2 font-medium text-sm whitespace-nowrap ${activeTab === "overview" ? "border-blue-500 text-blue-600 dark:text-blue-400" : "border-transparent text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600"}`,
            children: "Overview"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setActiveTab("campaigns"),
            className: `py-4 px-6 text-center border-b-2 font-medium text-sm whitespace-nowrap ${activeTab === "campaigns" ? "border-blue-500 text-blue-600 dark:text-blue-400" : "border-transparent text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600"}`,
            children: "Campaigns"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setActiveTab("oracles"),
            className: `py-4 px-6 text-center border-b-2 font-medium text-sm whitespace-nowrap ${activeTab === "oracles" ? "border-blue-500 text-blue-600 dark:text-blue-400" : "border-transparent text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600"}`,
            children: "Oracles"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setActiveTab("users"),
            className: `py-4 px-6 text-center border-b-2 font-medium text-sm whitespace-nowrap ${activeTab === "users" ? "border-blue-500 text-blue-600 dark:text-blue-400" : "border-transparent text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600"}`,
            children: "Users"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setActiveTab("analytics"),
            className: `py-4 px-6 text-center border-b-2 font-medium text-sm whitespace-nowrap ${activeTab === "analytics" ? "border-blue-500 text-blue-600 dark:text-blue-400" : "border-transparent text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600"}`,
            children: "Analytics"
          }
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6", children: [
        activeTab === "overview" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white mb-6", children: "Platform Overview" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-blue-50 to-indigo-50 dark:from-gray-700 dark:to-gray-800 rounded-2xl p-6 border border-blue-100 dark:border-gray-700", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-4", children: "Campaign Status" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3 h-3 bg-green-500 rounded-full mr-3" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Active Campaigns" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: stats.activeCampaigns })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-green-500 h-2 rounded-full", style: { width: `${stats.activeCampaigns / stats.totalCampaigns * 100}%` } }) })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3 h-3 bg-blue-500 rounded-full mr-3" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Completed Campaigns" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: stats.totalCampaigns - stats.activeCampaigns })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-500 h-2 rounded-full", style: { width: `${(stats.totalCampaigns - stats.activeCampaigns) / stats.totalCampaigns * 100}%` } }) })
                  ] })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-green-50 to-emerald-50 dark:from-gray-700 dark:to-gray-800 rounded-2xl p-6 border border-green-100 dark:border-gray-700", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-4", children: "Fund Distribution" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3 h-3 bg-green-500 rounded-full mr-3" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Verified Funds" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                        "",
                        Math.round(stats.verifiedFunds / 1e5),
                        "L"
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-green-500 h-2 rounded-full", style: { width: `${stats.verifiedFunds / stats.totalFunds * 100}%` } }) })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3 h-3 bg-amber-500 rounded-full mr-3" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Pending Verification" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                        "",
                        Math.round((stats.totalFunds - stats.verifiedFunds) / 1e5),
                        "L"
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-amber-500 h-2 rounded-full", style: { width: `${(stats.totalFunds - stats.verifiedFunds) / stats.totalFunds * 100}%` } }) })
                  ] })
                ] })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 grid grid-cols-1 md:grid-cols-2 gap-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-2xl p-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-4", children: "Recent Campaigns" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: campaigns.slice(0, 3).map((campaign) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 bg-gray-50 dark:bg-gray-600 rounded-xl", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: campaign.title }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-600 dark:text-gray-300", children: [
                    "",
                    campaign.raised.toLocaleString(),
                    " raised"
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-3 py-1 rounded-full text-xs font-semibold ${campaign.status === "active" ? "bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300" : "bg-gray-100 dark:bg-gray-600 text-gray-800 dark:text-gray-300"}`, children: campaign.status === "active" ? "Active" : "Completed" })
              ] }, campaign.id)) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-2xl p-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-4", children: "Platform Activity" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center p-4 bg-gray-50 dark:bg-gray-600 rounded-xl", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-100 dark:bg-blue-900/30 rounded-full p-2 mr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-blue-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }) }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "New Donation" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300", children: "50,000 donated to Kerala Flood Relief" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-500 dark:text-gray-400 text-sm", children: "2 hours ago" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center p-4 bg-gray-50 dark:bg-gray-600 rounded-xl", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-green-100 dark:bg-green-900/30 rounded-full p-2 mr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-green-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "Proof Verified" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300", children: "Rajasthan Drought Support - 3,00,000 released" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-500 dark:text-gray-400 text-sm", children: "1 day ago" })
                ] })
              ] })
            ] })
          ] })
        ] }),
        activeTab === "campaigns" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white", children: "Manage Campaigns" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white font-bold py-2 px-4 rounded-xl transition-all shadow-md", children: "+ Create New Campaign" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full divide-y divide-gray-200 dark:divide-gray-700", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-gray-50 dark:bg-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Campaign" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Goal" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Raised" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Status" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Created By" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Actions" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: "bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700", children: campaigns.map((campaign) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "hover:bg-gray-50 dark:hover:bg-gray-700", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "px-6 py-4 whitespace-nowrap", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm font-medium text-gray-900 dark:text-white", children: campaign.title }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-500 dark:text-gray-400 line-clamp-1", children: campaign.description || "No description provided" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400", children: [
                "",
                campaign.goal.toLocaleString()
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400", children: [
                "",
                campaign.raised.toLocaleString()
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-3 py-1 inline-flex text-xs leading-5 font-semibold rounded-full ${campaign.status === "active" ? "bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300" : "bg-gray-100 dark:bg-gray-600 text-gray-800 dark:text-gray-300"}`, children: campaign.status.charAt(0).toUpperCase() + campaign.status.slice(1) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400", children: campaign.creator.email }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "px-6 py-4 whitespace-nowrap text-sm font-medium", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-blue-600 dark:text-blue-400 hover:text-blue-900 dark:hover:text-blue-300 mr-3", children: "Edit" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-red-600 dark:text-red-400 hover:text-red-900 dark:hover:text-red-300", children: "Delete" })
              ] })
            ] }, campaign.id)) })
          ] }) })
        ] }),
        activeTab === "oracles" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white", children: "Manage Oracles" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white font-bold py-2 px-4 rounded-xl transition-all shadow-md", children: "+ Add New Oracle" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full divide-y divide-gray-200 dark:divide-gray-700", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-gray-50 dark:bg-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Oracle Name" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Public Key" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Weight" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Status" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Actions" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: "bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700", children: oracles.map((oracle) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "hover:bg-gray-50 dark:hover:bg-gray-700", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900 dark:text-white", children: oracle.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400 font-mono", children: oracle.publicKey }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400", children: oracle.weight }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-3 py-1 inline-flex text-xs leading-5 font-semibold rounded-full ${oracle.status === "active" ? "bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300" : "bg-gray-100 dark:bg-gray-600 text-gray-800 dark:text-gray-300"}`, children: oracle.status.charAt(0).toUpperCase() + oracle.status.slice(1) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "px-6 py-4 whitespace-nowrap text-sm font-medium", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-blue-600 dark:text-blue-400 hover:text-blue-900 dark:hover:text-blue-300 mr-3", children: "Edit" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-red-600 dark:text-red-400 hover:text-red-900 dark:hover:text-red-300", children: oracle.status === "active" ? "Deactivate" : "Activate" })
              ] })
            ] }, oracle.id)) })
          ] }) })
        ] }),
        activeTab === "users" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white", children: "Manage Users" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white font-bold py-2 px-4 rounded-xl transition-all shadow-md", children: "+ Add New User" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full divide-y divide-gray-200 dark:divide-gray-700", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-gray-50 dark:bg-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "User" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Email" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Role" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Status" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Actions" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: "bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700", children: [...Array(8)].map((_2, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "hover:bg-gray-50 dark:hover:bg-gray-700", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0 h-10 w-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-10 w-10 rounded-full bg-gradient-to-r from-blue-400 to-indigo-500 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-white font-medium", children: [
                  "U",
                  index + 1
                ] }) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm font-medium text-gray-900 dark:text-white", children: [
                  "User ",
                  index + 1
                ] }) })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400", children: [
                "user",
                index + 1,
                "@example.com"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400", children: index % 3 === 0 ? "ADMIN" : index % 3 === 1 ? "NGO" : "DONOR" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "px-3 py-1 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300", children: "Active" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "px-6 py-4 whitespace-nowrap text-sm font-medium", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-blue-600 dark:text-blue-400 hover:text-blue-900 dark:hover:text-blue-300 mr-3", children: "Edit" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-red-600 dark:text-red-400 hover:text-red-900 dark:hover:text-red-300", children: "Deactivate" })
              ] })
            ] }, index)) })
          ] }) })
        ] }),
        activeTab === "analytics" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white mb-6", children: "Platform Analytics" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-2xl p-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-4", children: "Donation Trends" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64 flex items-end justify-between pt-8 border-t border-gray-200 dark:border-gray-600", children: [65, 80, 60, 90, 75, 85, 70].map((height, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center flex-1 px-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "w-full bg-gradient-to-t from-blue-500 to-indigo-600 rounded-t-lg",
                    style: { height: `${height}%` }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-gray-500 dark:text-gray-400 mt-2", children: [
                  "Oct ",
                  index + 10
                ] })
              ] }, index)) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-2xl p-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 dark:text-white mb-4", children: "User Distribution" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-48 h-48", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 rounded-full border-8 border-blue-500" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-8 rounded-full border-8 border-green-500" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-16 rounded-full border-8 border-amber-500" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold", children: stats.totalUsers || 5420 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-600 dark:text-gray-400", children: "Total Users" })
                ] }) })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-4 mt-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-lg font-bold text-blue-600", children: "32" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-600 dark:text-gray-400", children: "NGOs" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-lg font-bold text-green-600", children: "5,300" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-600 dark:text-gray-400", children: "Donors" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-lg font-bold text-amber-600", children: "88" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-600 dark:text-gray-400", children: "Admins" })
                ] })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-r from-blue-600 to-indigo-700 rounded-2xl p-8 text-white", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-bold mb-4", children: "Platform Performance Report" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white/10 p-4 rounded-xl", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-bold", children: "98.5%" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-blue-100", children: "Verification Success Rate" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white/10 p-4 rounded-xl", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-bold", children: "24h" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-blue-100", children: "Average Verification Time" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white/10 p-4 rounded-xl", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-bold", children: "1.25Cr" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-blue-100", children: "Total Funds Distributed" })
              ] })
            ] })
          ] })
        ] })
      ] })
    ] })
  ] });
};
const DonationDemo = () => {
  const {
    isAuthenticated,
    user,
    loading,
    simulateAuth,
    makeAuthenticatedRequest
  } = useAuth();
  const [donations, setDonations] = reactExports.useState([]);
  const [amount, setAmount] = reactExports.useState("");
  const [submitting, setSubmitting] = reactExports.useState(false);
  const [message, setMessage] = reactExports.useState("");
  reactExports.useEffect(() => {
    const initAuth = async () => {
      try {
        await simulateAuth();
        await loadDonations();
      } catch (error) {
        console.error("Initialization failed:", error);
        setMessage("Failed to initialize authentication");
      }
    };
    if (!isAuthenticated && !loading) {
      initAuth();
    } else if (isAuthenticated) {
      loadDonations();
    }
  }, [isAuthenticated, loading]);
  const loadDonations = async () => {
    try {
      const response = await makeAuthenticatedRequest("http://localhost:5000/api/v1/donations");
      const data = await response.json();
      setDonations(data.donations);
    } catch (error) {
      console.error("Failed to load donations:", error);
      setMessage("Failed to load donations");
    }
  };
  const handleSubmit = async (e3) => {
    e3.preventDefault();
    if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
      setMessage("Please enter a valid amount");
      return;
    }
    setSubmitting(true);
    setMessage("");
    try {
      const response = await makeAuthenticatedRequest("http://localhost:5000/api/v1/donations", {
        method: "POST",
        body: JSON.stringify({ amount: parseFloat(amount) })
      });
      if (response.ok) {
        const data = await response.json();
        setMessage(`Donation of $${amount} created successfully!`);
        setAmount("");
        await loadDonations();
      } else {
        throw new Error("Failed to create donation");
      }
    } catch (error) {
      console.error("Donation failed:", error);
      setMessage("Failed to create donation. Please try again.");
    } finally {
      setSubmitting(false);
    }
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-center items-center h-64", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-3", children: "Initializing authentication..." })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-w-2xl mx-auto p-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-lg shadow-md p-6 mb-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 mb-4", children: "Donation Demo" }),
    isAuthenticated && user && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-6 p-4 bg-green-50 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-green-800", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: "Authenticated as:" }),
      " ",
      user.email,
      " (",
      user.role,
      ")"
    ] }) }),
    message && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `mb-4 p-3 rounded ${message.includes("Failed") ? "bg-red-100 text-red-800" : "bg-green-100 text-green-800"}`, children: message }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: handleSubmit, className: "mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col sm:flex-row gap-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "number",
          step: "0.01",
          value: amount,
          onChange: (e3) => setAmount(e3.target.value),
          placeholder: "Enter donation amount",
          className: "flex-grow px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500",
          disabled: submitting
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "submit",
          disabled: submitting || !amount,
          className: "px-6 py-2 bg-blue-600 text-white font-medium rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors",
          children: submitting ? "Processing..." : "Donate"
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t pt-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-semibold text-gray-800 mb-3", children: "Recent Donations" }),
      donations.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-500 italic", children: "No donations yet. Make your first donation above!" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: donations.map((donation) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center p-3 bg-gray-50 rounded-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium", children: [
          "Donation #",
          donation.id.slice(0, 8),
          "..."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold text-green-600", children: [
          "$",
          donation.amount.toFixed(2)
        ] })
      ] }, donation.id)) })
    ] })
  ] }) });
};
const AuthTest = () => {
  const [donations, setDonations] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const [success, setSuccess] = reactExports.useState(false);
  const [amount, setAmount] = reactExports.useState("");
  const { isAuthenticated, user, simulateAuth } = useAuth();
  reactExports.useEffect(() => {
    const initAuth = async () => {
      try {
        await simulateAuth();
        await loadDonations();
      } catch (err) {
        setError("Failed to initialize authentication: " + err.message);
      }
    };
    if (!isAuthenticated) {
      initAuth();
    } else {
      loadDonations();
    }
  }, [isAuthenticated]);
  const loadDonations = async () => {
    try {
      setLoading(true);
      const response = await apiService.getDonations();
      const data = await response.json();
      setDonations(data.donations);
      setError(null);
    } catch (err) {
      setError("Failed to load donations: " + err.message);
    } finally {
      setLoading(false);
    }
  };
  const handleCreateDonation = async (e3) => {
    e3.preventDefault();
    if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
      setError("Please enter a valid amount");
      return;
    }
    try {
      setLoading(true);
      setError(null);
      const response = await apiService.createDonation(parseFloat(amount));
      const data = await response.json();
      setSuccess(true);
      setAmount("");
      await loadDonations();
      setTimeout(() => setSuccess(false), 3e3);
    } catch (err) {
      setError("Failed to create donation: " + err.message);
    } finally {
      setLoading(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-w-4xl mx-auto p-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-2xl shadow-xl p-6 mb-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold text-gray-800 dark:text-white mb-2", children: "Authentication Test" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-400 mb-6", children: 'This page demonstrates that the authentication system is working correctly and no "Access token required" errors occur.' }),
    isAuthenticated && user && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-green-50 dark:bg-green-900/30 border border-green-200 dark:border-green-800 rounded-xl p-4 mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold text-green-800 dark:text-green-200 mb-2", children: "Authentication Status" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-green-700 dark:text-green-300", children: [
        " Successfully authenticated as ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: user.email }),
        " with role ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: user.role })
      ] })
    ] }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-red-50 dark:bg-red-900/30 border border-red-200 dark:border-red-800 rounded-xl p-4 mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold text-red-800 dark:text-red-200 mb-2", children: "Error" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-red-700 dark:text-red-300", children: error })
    ] }),
    success && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-green-50 dark:bg-green-900/30 border border-green-200 dark:border-green-800 rounded-xl p-4 mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold text-green-800 dark:text-green-200 mb-2", children: "Success" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-green-700 dark:text-green-300", children: "Donation created successfully!" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white mb-4", children: "Create Donation" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleCreateDonation, className: "space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "amount", className: "block text-gray-700 dark:text-gray-300 font-medium mb-2", children: "Donation Amount ()" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                id: "amount",
                value: amount,
                onChange: (e3) => setAmount(e3.target.value),
                placeholder: "Enter amount",
                className: "w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-white",
                disabled: loading
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              disabled: loading || !amount,
              className: `w-full py-3 rounded-xl font-bold transition-all ${loading || !amount ? "bg-gray-300 dark:bg-gray-700 text-gray-500 dark:text-gray-400 cursor-not-allowed" : "bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white shadow-lg transform hover:scale-[1.02]"}`,
              children: loading ? "Creating Donation..." : "Create Donation"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 dark:text-white mb-4", children: "Your Donations" }),
        loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center items-center h-32", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500" }) }) : donations.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-50 dark:bg-gray-700 rounded-xl p-6 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-400", children: "No donations found" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: donations.map((donation) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 dark:bg-gray-700 rounded-xl p-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-semibold", children: [
                "Donation #",
                donation.id.substring(0, 8),
                "..."
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-600 dark:text-gray-400", children: new Date(donation.createdAt).toLocaleDateString() })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-lg font-bold text-green-600 dark:text-green-400", children: [
              "",
              donation.amount.toFixed(2)
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${donation.status === "completed" ? "bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-200" : "bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-200"}`, children: donation.status }) })
        ] }, donation.id)) })
      ] })
    ] })
  ] }) });
};
const IVRSimulator = () => {
  const { t: t2 } = useTranslation();
  const [currentStep, setCurrentStep] = reactExports.useState("welcome");
  const [userInput, setUserInput] = reactExports.useState("");
  const [callHistory, setCallHistory] = reactExports.useState([]);
  const [isCalling, setIsCalling] = reactExports.useState(false);
  const [timer, setTimer] = reactExports.useState(0);
  const [callerId, setCallerId] = reactExports.useState("");
  const [location, setLocation] = reactExports.useState({ latitude: null, longitude: null });
  const [callFlow, setCallFlow] = reactExports.useState([]);
  const [showCallFlow, setShowCallFlow] = reactExports.useState(false);
  const [testMode, setTestMode] = reactExports.useState(false);
  const [testScenarios, setTestScenarios] = reactExports.useState([]);
  const menuOptions = {
    welcome: {
      message: "Welcome to ImpactX Emergency Response System. Press 1 for disaster reporting, Press 2 for emergency contacts, Press 3 for weather alerts, Press 4 for volunteer coordination, Press 5 for fund tracking, Press 0 for operator."
    },
    disasterReporting: {
      message: "Press 1 to report a flood, Press 2 for earthquake, Press 3 for cyclone, Press 4 for drought, Press 5 for landslide, Press 6 for fire, Press 7 for epidemic, Press 8 for chemical hazard, Press 9 for other, Press 0 to go back."
    },
    emergencyContacts: {
      message: "Press 1 for police, Press 2 for fire department, Press 3 for ambulance, Press 4 for disaster management, Press 0 to go back."
    },
    weatherAlerts: {
      message: "Press 1 for current weather, Press 2 for weather alerts, Press 0 to go back."
    },
    volunteerCoordination: {
      message: "Press 1 to register as volunteer, Press 2 to find volunteer opportunities, Press 0 to go back."
    },
    fundTracking: {
      message: "Press 1 to track your donation, Press 2 for project status, Press 0 to go back."
    },
    operator: {
      message: "Connecting you to an operator. Please wait."
    }
  };
  reactExports.useEffect(() => {
    let interval;
    if (isCalling) {
      interval = setInterval(() => {
        setTimer((prev) => prev + 1);
      }, 1e3);
    } else {
      setTimer(0);
    }
    return () => clearInterval(interval);
  }, [isCalling]);
  reactExports.useEffect(() => {
    if (isCalling) {
      setLocation({
        latitude: (Math.random() * 180 - 90).toFixed(6),
        longitude: (Math.random() * 360 - 180).toFixed(6)
      });
      setCallerId(`+91${Math.floor(Math.random() * 9e9) + 1e9}`);
    }
  }, [isCalling]);
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  };
  const updateCallFlow = (step, input = null) => {
    const newFlow = [...callFlow, {
      id: callFlow.length + 1,
      step,
      input,
      timestamp: /* @__PURE__ */ new Date()
    }];
    setCallFlow(newFlow);
  };
  const runTestScenario = (scenario) => {
    setTestMode(true);
    handleStartCall();
    setTimeout(() => {
      scenario.inputs.forEach((input, index) => {
        setTimeout(() => {
          handleKeyPress(input);
        }, (index + 1) * 1e3);
      });
    }, 1e3);
  };
  const handleStartCall = () => {
    setIsCalling(true);
    setCurrentStep("welcome");
    setUserInput("");
    setCallFlow([]);
    updateCallFlow("welcome");
    setCallHistory([{ step: "welcome", message: menuOptions.welcome.message, time: /* @__PURE__ */ new Date() }]);
  };
  const handleEndCall = () => {
    setIsCalling(false);
    setCurrentStep("welcome");
    setUserInput("");
    setCallHistory((prev) => [...prev, { step: "end", message: "Call ended", time: /* @__PURE__ */ new Date() }]);
  };
  const handleInput = (input) => {
    if (!isCalling) return;
    const newHistory = [...callHistory, { step: "user", message: `Pressed: ${input}`, time: /* @__PURE__ */ new Date() }];
    updateCallFlow(currentStep, input);
    let nextStep = currentStep;
    let responseMessage = "";
    switch (currentStep) {
      case "welcome":
        switch (input) {
          case "1":
            nextStep = "disasterReporting";
            responseMessage = menuOptions.disasterReporting.message;
            break;
          case "2":
            nextStep = "emergencyContacts";
            responseMessage = menuOptions.emergencyContacts.message;
            break;
          case "3":
            nextStep = "weatherAlerts";
            responseMessage = menuOptions.weatherAlerts.message;
            break;
          case "4":
            nextStep = "volunteerCoordination";
            responseMessage = menuOptions.volunteerCoordination.message;
            break;
          case "5":
            nextStep = "fundTracking";
            responseMessage = menuOptions.fundTracking.message;
            break;
          case "0":
            nextStep = "operator";
            responseMessage = menuOptions.operator.message;
            break;
          default:
            responseMessage = "Invalid input. " + menuOptions.welcome.message;
        }
        break;
      case "disasterReporting":
        if (input === "0") {
          nextStep = "welcome";
          responseMessage = menuOptions.welcome.message;
        } else if (["1", "2", "3", "4", "5", "6", "7", "8", "9"].includes(input)) {
          const disasters2 = {
            "1": "flood",
            "2": "earthquake",
            "3": "cyclone",
            "4": "drought",
            "5": "landslide",
            "6": "fire",
            "7": "epidemic",
            "8": "chemical hazard",
            "9": "other"
          };
          responseMessage = `Thank you for reporting a ${disasters2[input]}. Our team will respond shortly. Reference ID: ${Math.floor(Math.random() * 1e5)}. Press 0 to return to main menu.`;
          nextStep = "reportConfirmation";
        } else {
          responseMessage = "Invalid input. " + menuOptions.disasterReporting.message;
        }
        break;
      case "reportConfirmation":
        if (input === "0") {
          nextStep = "welcome";
          responseMessage = menuOptions.welcome.message;
        } else {
          responseMessage = "Press 0 to return to main menu.";
        }
        break;
      case "emergencyContacts":
        if (input === "0") {
          nextStep = "welcome";
          responseMessage = menuOptions.welcome.message;
        } else if (["1", "2", "3", "4"].includes(input)) {
          const contacts = {
            "1": "Police: 100",
            "2": "Fire Department: 101",
            "3": "Ambulance: 102",
            "4": "Disaster Management: 1078"
          };
          responseMessage = `Contact: ${contacts[input]}. Press 0 to return to main menu.`;
          nextStep = "contactConfirmation";
        } else {
          responseMessage = "Invalid input. " + menuOptions.emergencyContacts.message;
        }
        break;
      case "contactConfirmation":
        if (input === "0") {
          nextStep = "welcome";
          responseMessage = menuOptions.welcome.message;
        } else {
          responseMessage = "Press 0 to return to main menu.";
        }
        break;
      case "weatherAlerts":
        if (input === "0") {
          nextStep = "welcome";
          responseMessage = menuOptions.welcome.message;
        } else if (["1", "2"].includes(input)) {
          responseMessage = input === "1" ? `Current weather: Clear skies, 28C. Location: ${location.latitude}, ${location.longitude}. Press 0 to return to main menu.` : "No active weather alerts. Press 0 to return to main menu.";
          nextStep = "weatherConfirmation";
        } else {
          responseMessage = "Invalid input. " + menuOptions.weatherAlerts.message;
        }
        break;
      case "weatherConfirmation":
        if (input === "0") {
          nextStep = "welcome";
          responseMessage = menuOptions.welcome.message;
        } else {
          responseMessage = "Press 0 to return to main menu.";
        }
        break;
      case "volunteerCoordination":
        if (input === "0") {
          nextStep = "welcome";
          responseMessage = menuOptions.welcome.message;
        } else if (["1", "2"].includes(input)) {
          responseMessage = input === "1" ? "Thank you for registering as a volunteer. Our team will contact you soon. Press 0 to return to main menu." : "Current volunteer opportunities: Flood relief in Kerala, Earthquake response in Gujarat. Press 0 to return to main menu.";
          nextStep = "volunteerConfirmation";
        } else {
          responseMessage = "Invalid input. " + menuOptions.volunteerCoordination.message;
        }
        break;
      case "volunteerConfirmation":
        if (input === "0") {
          nextStep = "welcome";
          responseMessage = menuOptions.welcome.message;
        } else {
          responseMessage = "Press 0 to return to main menu.";
        }
        break;
      case "fundTracking":
        if (input === "0") {
          nextStep = "welcome";
          responseMessage = menuOptions.welcome.message;
        } else if (["1", "2"].includes(input)) {
          responseMessage = input === "1" ? `Thank you for your donation. Transaction ID: TXN${Math.floor(Math.random() * 1e6)}. Status: Verified. Press 0 to return to main menu.` : "Project Status: 75% complete. Funds distributed: 2,50,000. Beneficiaries reached: 1,200 families. Press 0 to return to main menu.";
          nextStep = "fundConfirmation";
        } else {
          responseMessage = "Invalid input. " + menuOptions.fundTracking.message;
        }
        break;
      case "fundConfirmation":
        if (input === "0") {
          nextStep = "welcome";
          responseMessage = menuOptions.welcome.message;
        } else {
          responseMessage = "Press 0 to return to main menu.";
        }
        break;
      case "operator":
        responseMessage = "Thank you for calling ImpactX. An operator will assist you shortly. Your call ID is ${Math.floor(Math.random() * 100000)}.";
        break;
      default:
        nextStep = "welcome";
        responseMessage = menuOptions.welcome.message;
    }
    setCurrentStep(nextStep);
    setUserInput("");
    updateCallFlow(nextStep);
    setCallHistory([...newHistory, { step: nextStep, message: responseMessage, time: /* @__PURE__ */ new Date() }]);
  };
  const handleKeyPress = (key) => {
    if (!isCalling) return;
    setUserInput(key);
    handleInput(key);
  };
  reactExports.useEffect(() => {
    setTestScenarios([
      {
        id: 1,
        name: "Disaster Reporting Flow",
        description: "Test the disaster reporting functionality",
        inputs: ["1", "2", "0", "0"]
      },
      {
        id: 2,
        name: "Emergency Contacts Flow",
        description: "Test the emergency contacts functionality",
        inputs: ["2", "1", "0", "0"]
      },
      {
        id: 3,
        name: "Weather Alerts Flow",
        description: "Test the weather alerts functionality",
        inputs: ["3", "2", "0", "0"]
      }
    ]);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-lg p-6 max-w-2xl mx-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 mb-6 text-center", children: t2("ivrSimulator.title") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-lg font-semibold text-gray-700", children: isCalling ? t2("ivrSimulator.inProgress") : t2("ivrSimulator.ready") }),
        isCalling && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm font-medium text-gray-500", children: formatTime(timer) })
      ] }),
      isCalling && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-50 rounded-lg p-3 mb-4 text-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Caller ID: ",
          callerId
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Location: ",
          location.latitude ? `${location.latitude}, ${location.longitude}` : "Detecting..."
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-50 rounded-lg p-4 h-48 overflow-y-auto mb-4", children: callHistory.length > 0 ? callHistory.map((entry, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500", children: entry.time.toLocaleTimeString() }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `p-2 rounded ${entry.step === "user" ? "bg-blue-100 text-blue-800" : "bg-gray-100 text-gray-800"}`, children: entry.message })
      ] }, index)) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-500 italic", children: t2("ivrSimulator.noActiveCall") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-center space-x-4 mb-6", children: [
        !isCalling ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: handleStartCall,
            className: "px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-medium",
            children: t2("ivrSimulator.startCall")
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: handleEndCall,
            className: "px-6 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors font-medium",
            children: t2("ivrSimulator.endCall")
          }
        ),
        isCalling && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setShowCallFlow(!showCallFlow),
            className: "px-6 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors font-medium",
            children: showCallFlow ? t2("ivrSimulator.hideFlow") : t2("ivrSimulator.showFlow")
          }
        ),
        !isCalling && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setTestMode(!testMode),
            className: "px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors font-medium",
            children: testMode ? t2("ivrSimulator.exitTestMode") : t2("ivrSimulator.testMode")
          }
        )
      ] })
    ] }),
    showCallFlow && isCalling && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6 bg-yellow-50 rounded-lg p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-3", children: t2("ivrSimulator.callFlow") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-2", children: callFlow.map((flow, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center text-sm", children: index + 1 }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-2 bg-white border border-gray-300 rounded px-2 py-1 text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium", children: flow.step }),
          flow.input && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-gray-600", children: [
            "Input: ",
            flow.input
          ] })
        ] }),
        index < callFlow.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-2 text-gray-400", children: "" })
      ] }, flow.id)) })
    ] }),
    testMode && !isCalling && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6 bg-indigo-50 rounded-lg p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-3", children: t2("ivrSimulator.testScenarios") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-4", children: testScenarios.map((scenario) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-lg p-4 border border-indigo-200", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold text-indigo-800", children: scenario.name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 mt-1", children: scenario.description }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => runTestScenario(scenario),
            className: "mt-3 px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 text-sm transition-colors",
            children: t2("ivrSimulator.runTest")
          }
        )
      ] }, scenario.id)) })
    ] }),
    isCalling && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-100 rounded-lg p-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-4 text-center", children: t2("ivrSimulator.dialpad") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-3 gap-3 max-w-xs mx-auto", children: [1, 2, 3, 4, 5, 6, 7, 8, 9, "*", 0, "#"].map((key) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => handleKeyPress(key.toString()),
          className: "h-16 bg-white rounded-lg shadow hover:bg-gray-50 active:bg-gray-200 transition-colors flex items-center justify-center text-xl font-bold text-gray-800",
          disabled: !isCalling,
          children: key
        },
        key
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-6 text-center text-sm text-gray-600", children: t2("ivrSimulator.instructions") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 bg-blue-50 rounded-lg p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-2", children: t2("ivrSimulator.howItWorks") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 mb-3", children: t2("ivrSimulator.description") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "list-disc list-inside text-gray-600 space-y-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("ivrSimulator.feature1") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("ivrSimulator.feature2") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("ivrSimulator.feature3") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("ivrSimulator.feature4") })
      ] })
    ] })
  ] });
};
const IVRSystem = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 py-8 px-4 sm:px-6 lg:px-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-7xl mx-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-4xl font-extrabold text-gray-900 sm:text-5xl mb-4", children: t2("ivrSystem.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-gray-600 max-w-3xl mx-auto", children: t2("ivrSystem.subtitle") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white rounded-2xl shadow-xl overflow-hidden mb-12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-8", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lg:col-span-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IVRSimulator, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 rounded-lg p-6 border border-gray-200", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-900 mb-4", children: t2("ivrSystem.features") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-8 w-8 rounded-md bg-indigo-500 text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-5 w-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z" }) }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium text-gray-900", children: t2("ivrSystem.feature1Title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-gray-600", children: t2("ivrSystem.feature1Desc") })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-8 w-8 rounded-md bg-indigo-500 text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-5 w-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" }) }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium text-gray-900", children: t2("ivrSystem.feature2Title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-gray-600", children: t2("ivrSystem.feature2Desc") })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-8 w-8 rounded-md bg-indigo-500 text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-5 w-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" }) }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium text-gray-900", children: t2("ivrSystem.feature3Title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-gray-600", children: t2("ivrSystem.feature3Desc") })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-8 w-8 rounded-md bg-indigo-500 text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-5 w-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" }) }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium text-gray-900", children: t2("ivrSystem.feature4Title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-gray-600", children: t2("ivrSystem.feature4Desc") })
              ] })
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-12 bg-indigo-50 rounded-lg p-6 border border-indigo-100", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-900 mb-4", children: t2("ivrSystem.technicalOverview") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 mb-4", children: t2("ivrSystem.technicalDesc") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4 rounded-lg border border-indigo-200", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-gray-900 mb-2", children: t2("ivrSystem.integration") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "text-gray-600 list-disc list-inside space-y-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("ivrSystem.integration1") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("ivrSystem.integration2") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("ivrSystem.integration3") })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4 rounded-lg border border-indigo-200", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-gray-900 mb-2", children: t2("ivrSystem.scalability") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "text-gray-600 list-disc list-inside space-y-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("ivrSystem.scalability1") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("ivrSystem.scalability2") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("ivrSystem.scalability3") })
            ] })
          ] })
        ] })
      ] })
    ] }) })
  ] }) });
};
const StateDisasterStats = () => {
  const { t: t2, i18n } = useTranslation();
  const [selectedState, setSelectedState] = reactExports.useState("all");
  const [disasterData, setDisasterData] = reactExports.useState([]);
  const disasterStats = [
    { state: "Maharashtra", floods: 120, cyclones: 5, earthquakes: 2, droughts: 8, total: 135 },
    { state: "West Bengal", floods: 95, cyclones: 12, earthquakes: 1, droughts: 5, total: 113 },
    { state: "Odisha", floods: 80, cyclones: 15, earthquakes: 0, droughts: 6, total: 101 },
    { state: "Andhra Pradesh", floods: 70, cyclones: 8, earthquakes: 1, droughts: 9, total: 88 },
    { state: "Tamil Nadu", floods: 65, cyclones: 7, earthquakes: 3, droughts: 7, total: 82 },
    { state: "Uttar Pradesh", floods: 90, cyclones: 2, earthquakes: 4, droughts: 10, total: 106 },
    { state: "Bihar", floods: 85, cyclones: 1, earthquakes: 2, droughts: 6, total: 94 },
    { state: "Gujarat", floods: 55, cyclones: 6, earthquakes: 5, droughts: 12, total: 78 },
    { state: "Kerala", floods: 60, cyclones: 3, earthquakes: 1, droughts: 4, total: 68 },
    { state: "Assam", floods: 110, cyclones: 2, earthquakes: 3, droughts: 5, total: 120 }
  ];
  reactExports.useEffect(() => {
    setDisasterData(disasterStats);
  }, []);
  const filteredData = selectedState === "all" ? disasterData : disasterData.filter((item) => item.state === selectedState);
  const getStateOptions = () => {
    return [
      { value: "all", label: t2("common.all_states") },
      ...disasterStats.map((state) => ({
        value: state.state,
        label: state.state
      }))
    ];
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-lg shadow-md p-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 mb-6", children: t2("disaster_stats.title") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "state-select", className: "block text-sm font-medium text-gray-700 mb-2", children: t2("disaster_stats.select_state") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "select",
        {
          id: "state-select",
          value: selectedState,
          onChange: (e3) => setSelectedState(e3.target.value),
          className: "block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md",
          children: getStateOptions().map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: option.value, children: option.label }, option.value))
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full divide-y divide-gray-200", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-gray-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("disaster_stats.state") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("disaster_stats.floods") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("disaster_stats.cyclones") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("disaster_stats.earthquakes") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("disaster_stats.droughts") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("disaster_stats.total") })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: "bg-white divide-y divide-gray-200", children: filteredData.map((state, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: index % 2 === 0 ? "bg-white" : "bg-gray-50", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900", children: state.state }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: state.floods }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: state.cyclones }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: state.earthquakes }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: state.droughts }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm font-bold text-blue-600", children: state.total })
      ] }, index)) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6 p-4 bg-blue-50 rounded-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-blue-800 mb-2", children: t2("disaster_stats.disclaimer") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-blue-600", children: t2("disaster_stats.disclaimer_text") })
    ] })
  ] });
};
const DisasterStatisticsPage = () => {
  const { t: t2 } = useTranslation();
  const [activeTab, setActiveTab] = reactExports.useState("state-stats");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-8 text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl md:text-4xl font-bold text-gray-800 mb-4", children: t2("disasterStatistics.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 max-w-3xl mx-auto", children: t2("disasterStatistics.description") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-8 border-b border-gray-200", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "flex space-x-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setActiveTab("state-stats"),
          className: `py-4 px-1 border-b-2 font-medium text-sm ${activeTab === "state-stats" ? "border-blue-500 text-blue-600" : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"}`,
          children: t2("disasterStatistics.tabs.overview")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setActiveTab("charts"),
          className: `py-4 px-1 border-b-2 font-medium text-sm ${activeTab === "charts" ? "border-blue-500 text-blue-600" : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"}`,
          children: t2("disasterStatistics.tabs.trends")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setActiveTab("regional"),
          className: `py-4 px-1 border-b-2 font-medium text-sm ${activeTab === "regional" ? "border-blue-500 text-blue-600" : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"}`,
          children: t2("disasterStatistics.tabs.regional")
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-8", children: [
      activeTab === "state-stats" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-8", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(StateDisasterStats, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 rounded-lg p-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold text-blue-800 mb-4", children: t2("disasterStatistics.overview.title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-lg shadow p-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-blue-600", children: "1,247" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-600", children: t2("disasterStatistics.overview.totalEvents") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-lg shadow p-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-2xl font-bold text-blue-600", children: [
                "45.2 ",
                t2("common.lakh")
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-600", children: t2("disasterStatistics.overview.totalAffected") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-lg shadow p-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-2xl font-bold text-blue-600", children: [
                "1,842 ",
                t2("common.crore")
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-600", children: t2("disasterStatistics.overview.totalEconomicLoss") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-lg shadow p-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-blue-600", children: "36,200" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-600", children: t2("disasterStatistics.overview.averageAffected") })
            ] })
          ] })
        ] })
      ] }),
      activeTab === "charts" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DisasterStatsChart, {}) }),
      activeTab === "regional" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RegionalStats, {}) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-lg shadow-md p-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold text-gray-800 mb-4", children: t2("disasterStatistics.insights") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 mb-4", children: t2("disasterStatistics.desc") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 p-4 rounded-lg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-blue-800 mb-2", children: t2("disasterTypes.flood") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-blue-600", children: t2("common.flood_desc_insight") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-green-50 p-4 rounded-lg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-green-800 mb-2", children: t2("disasterTypes.drought") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-green-600", children: t2("common.drought_desc_insight") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-red-50 p-4 rounded-lg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-red-800 mb-2", children: t2("disasterTypes.earthquake") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-red-600", children: t2("common.earthquake_desc_insight") })
        ] })
      ] })
    ] })
  ] });
};
const predictDisasterRisk = (region) => {
  const predictions = [];
  switch (region.id) {
    case "kerala":
      predictions.push({
        type: "flood",
        probability: 75,
        riskScore: 82,
        impact: "High",
        timeline: "Next 3-5 days",
        recommendations: [
          "Prepare emergency kits",
          "Identify evacuation routes",
          "Secure important documents"
        ]
      });
      predictions.push({
        type: "landslide",
        probability: 45,
        riskScore: 65,
        impact: "Moderate",
        timeline: "Next 1-2 weeks",
        recommendations: [
          "Avoid hillside areas",
          "Stay alert for warning signs",
          "Prepare for possible evacuation"
        ]
      });
      break;
    case "maharashtra":
      predictions.push({
        type: "flood",
        probability: 60,
        riskScore: 70,
        impact: "Moderate",
        timeline: "Next 1-2 weeks",
        recommendations: [
          "Check drainage systems",
          "Prepare sandbags if needed",
          "Stay informed about weather updates"
        ]
      });
      break;
    case "uttarakhand":
      predictions.push({
        type: "earthquake",
        probability: 35,
        riskScore: 55,
        impact: "High",
        timeline: "Next 1-3 months",
        recommendations: [
          "Secure heavy furniture",
          "Prepare emergency supplies",
          "Know evacuation procedures"
        ]
      });
      predictions.push({
        type: "landslide",
        probability: 55,
        riskScore: 72,
        impact: "High",
        timeline: "Next 2-4 weeks",
        recommendations: [
          "Avoid construction on slopes",
          "Monitor for crack patterns",
          "Prepare for possible evacuation"
        ]
      });
      break;
    case "odisha":
      predictions.push({
        type: "cyclone",
        probability: 80,
        riskScore: 88,
        impact: "Very High",
        timeline: "Next 5-10 days",
        recommendations: [
          "Reinforce roofs and windows",
          "Prepare emergency supplies",
          "Identify shelter locations"
        ]
      });
      break;
    case "assam":
      predictions.push({
        type: "flood",
        probability: 70,
        riskScore: 78,
        impact: "High",
        timeline: "Next 1-2 weeks",
        recommendations: [
          "Elevate important items",
          "Prepare for evacuation",
          "Stay informed about water levels"
        ]
      });
      break;
    case "rajasthan":
      predictions.push({
        type: "drought",
        probability: 65,
        riskScore: 72,
        impact: "Moderate",
        timeline: "Next 2-3 months",
        recommendations: [
          "Conserve water usage",
          "Implement water harvesting",
          "Plan for alternative water sources"
        ]
      });
      break;
    default:
      predictions.push({
        type: "flood",
        probability: 30,
        riskScore: 40,
        impact: "Low",
        timeline: "Next 1-2 weeks",
        recommendations: [
          "Stay informed about weather",
          "Check local advisories"
        ]
      });
  }
  return predictions;
};
const getHistoricalData = () => {
  return [
    {
      year: 2023,
      type: "flood",
      affected: 15e5,
      economicLoss: 25e8,
      region: "Kerala"
    },
    {
      year: 2022,
      type: "cyclone",
      affected: 8e5,
      economicLoss: 18e8,
      region: "Odisha"
    },
    {
      year: 2021,
      type: "earthquake",
      affected: 5e5,
      economicLoss: 12e8,
      region: "Uttarakhand"
    },
    {
      year: 2020,
      type: "flood",
      affected: 2e6,
      economicLoss: 3e9,
      region: "Assam"
    },
    {
      year: 2019,
      type: "drought",
      affected: 3e6,
      economicLoss: 2e9,
      region: "Rajasthan"
    },
    {
      year: 2018,
      type: "cyclone",
      affected: 12e5,
      economicLoss: 22e8,
      region: "Odisha"
    }
  ];
};
const getWeatherData = (region) => {
  const weatherData = {
    kerala: {
      temperature: 28,
      humidity: 85,
      precipitation: 120,
      windSpeed: 15,
      elevation: 50,
      forestCover: 35,
      riverProximity: 2,
      seismicActivity: "Low"
    },
    maharashtra: {
      temperature: 32,
      humidity: 70,
      precipitation: 80,
      windSpeed: 12,
      elevation: 300,
      forestCover: 20,
      riverProximity: 5,
      seismicActivity: "Moderate"
    },
    uttarakhand: {
      temperature: 22,
      humidity: 65,
      precipitation: 60,
      windSpeed: 10,
      elevation: 1500,
      forestCover: 50,
      riverProximity: 1,
      seismicActivity: "High"
    },
    odisha: {
      temperature: 30,
      humidity: 75,
      precipitation: 150,
      windSpeed: 25,
      elevation: 25,
      forestCover: 30,
      riverProximity: 1,
      seismicActivity: "Low"
    },
    assam: {
      temperature: 29,
      humidity: 80,
      precipitation: 180,
      windSpeed: 18,
      elevation: 75,
      forestCover: 40,
      riverProximity: 0.5,
      seismicActivity: "Moderate"
    },
    rajasthan: {
      temperature: 38,
      humidity: 30,
      precipitation: 10,
      windSpeed: 20,
      elevation: 400,
      forestCover: 5,
      riverProximity: 15,
      seismicActivity: "Low"
    }
  };
  return weatherData[region.id] || weatherData.kerala;
};
const DisasterPrediction = () => {
  const { t: t2 } = useTranslation();
  const [selectedRegion, setSelectedRegion] = reactExports.useState("");
  const [predictions, setPredictions] = reactExports.useState([]);
  const [historicalData, setHistoricalData] = reactExports.useState([]);
  const [weatherData, setWeatherData] = reactExports.useState(null);
  const [riskLevel, setRiskLevel] = reactExports.useState("low");
  const [activeTab, setActiveTab] = reactExports.useState("predictions");
  const [alerts, setAlerts] = reactExports.useState([]);
  const [dismissedAlerts, setDismissedAlerts] = reactExports.useState([]);
  const [autoRefreshEnabled, setAutoRefreshEnabled] = reactExports.useState(true);
  const regions = [
    { id: "maharashtra", name: "Maharashtra", lat: 19.7515, lng: 75.7139 },
    { id: "kerala", name: "Kerala", lat: 10.8505, lng: 76.2711 },
    { id: "uttarakhand", name: "Uttarakhand", lat: 30.0668, lng: 79.0193 },
    { id: "odisha", name: "Odisha", lat: 20.9517, lng: 85.0985 },
    { id: "assam", name: "Assam", lat: 26.2006, lng: 92.9376 },
    { id: "rajasthan", name: "Rajasthan", lat: 27.0238, lng: 74.2179 }
  ];
  reactExports.useEffect(() => {
    loadHistoricalData();
  }, []);
  const loadHistoricalData = () => {
    const data = getHistoricalData();
    setHistoricalData(data);
  };
  const loadWeatherData = (region) => {
    const data = getWeatherData(region);
    setWeatherData(data);
  };
  const generateAlerts = (predictions2, weatherData2) => {
    const newAlerts = [];
    predictions2.forEach((prediction) => {
      if (prediction.riskScore >= 80) {
        newAlerts.push({
          id: `risk-${Date.now()}-${prediction.type}`,
          type: "danger",
          message: t2("disasterPrediction.alerts.highRisk", {
            disaster: t2(`disasterTypes.${prediction.type}`),
            score: prediction.riskScore
          }),
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          priority: "high"
        });
      } else if (prediction.riskScore >= 60) {
        newAlerts.push({
          id: `risk-${Date.now()}-${prediction.type}`,
          type: "warning",
          message: t2("disasterPrediction.alerts.moderateRisk", {
            disaster: t2(`disasterTypes.${prediction.type}`),
            score: prediction.riskScore
          }),
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          priority: "medium"
        });
      }
    });
    if (weatherData2) {
      if (weatherData2.precipitation > 150) {
        newAlerts.push({
          id: `weather-${Date.now()}-precipitation`,
          type: "warning",
          message: t2("disasterPrediction.alerts.heavyRain", {
            amount: weatherData2.precipitation
          }),
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          priority: "medium"
        });
      }
      if (weatherData2.windSpeed > 100) {
        newAlerts.push({
          id: `weather-${Date.now()}-wind`,
          type: "danger",
          message: t2("disasterPrediction.alerts.highWinds", {
            speed: weatherData2.windSpeed
          }),
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          priority: "high"
        });
      }
      if (weatherData2.temperature > 45) {
        newAlerts.push({
          id: `weather-${Date.now()}-heat`,
          type: "danger",
          message: t2("disasterPrediction.alerts.extremeHeat", {
            temperature: weatherData2.temperature
          }),
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          priority: "high"
        });
      } else if (weatherData2.temperature < 5) {
        newAlerts.push({
          id: `weather-${Date.now()}-cold`,
          type: "warning",
          message: t2("disasterPrediction.alerts.extremeCold", {
            temperature: weatherData2.temperature
          }),
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          priority: "medium"
        });
      }
      if (weatherData2.humidity > 90) {
        newAlerts.push({
          id: `weather-${Date.now()}-humidity`,
          type: "warning",
          message: t2("disasterPrediction.alerts.highHumidity", {
            humidity: weatherData2.humidity
          }),
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          priority: "medium"
        });
      }
      if (weatherData2.pressure && weatherData2.pressure < 980) {
        newAlerts.push({
          id: `weather-${Date.now()}-pressure`,
          type: "warning",
          message: t2("disasterPrediction.alerts.lowPressure", {
            pressure: weatherData2.pressure
          }),
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          priority: "medium"
        });
      }
    }
    return newAlerts;
  };
  const handleRegionChange = (e3) => {
    const regionId = e3.target.value;
    setSelectedRegion(regionId);
    if (regionId) {
      const region = regions.find((r2) => r2.id === regionId);
      const pred = predictDisasterRisk(region);
      setPredictions(pred);
      loadWeatherData(region);
      const alerts2 = generateAlerts(pred, getWeatherData(region));
      const activeAlerts = alerts2.filter((alert) => !dismissedAlerts.includes(alert.id));
      setAlerts(activeAlerts);
      const maxRisk = Math.max(...pred.map((p2) => p2.riskScore));
      if (maxRisk >= 80) {
        setRiskLevel("critical");
      } else if (maxRisk >= 60) {
        setRiskLevel("high");
      } else if (maxRisk >= 40) {
        setRiskLevel("moderate");
      } else {
        setRiskLevel("low");
      }
    }
  };
  const getRiskColor = (level) => {
    switch (level) {
      case "critical":
        return "bg-red-500";
      case "high":
        return "bg-orange-500";
      case "moderate":
        return "bg-yellow-500";
      default:
        return "bg-green-500";
    }
  };
  const getRiskLabel = (level) => {
    switch (level) {
      case "critical":
        return t2("disasterPrediction.risk.critical");
      case "high":
        return t2("disasterPrediction.risk.high");
      case "moderate":
        return t2("disasterPrediction.risk.moderate");
      default:
        return t2("disasterPrediction.risk.low");
    }
  };
  const getAlertColor = (type) => {
    switch (type) {
      case "danger":
        return "bg-red-100 text-red-800 border-red-200";
      case "warning":
        return "bg-yellow-100 text-yellow-800 border-yellow-200";
      default:
        return "bg-blue-100 text-blue-800 border-blue-200";
    }
  };
  const getPriorityColor = (priority) => {
    switch (priority) {
      case "high":
        return "bg-red-500";
      case "medium":
        return "bg-yellow-500";
      case "low":
        return "bg-green-500";
      default:
        return "bg-gray-500";
    }
  };
  const dismissAlert = (alertId) => {
    setDismissedAlerts((prev) => [...prev, alertId]);
    setAlerts((prev) => prev.filter((alert) => alert.id !== alertId));
  };
  const refreshAlerts = () => {
    if (selectedRegion) {
      const region = regions.find((r2) => r2.id === selectedRegion);
      const pred = predictDisasterRisk(region);
      const alerts2 = generateAlerts(pred, getWeatherData(region));
      const activeAlerts = alerts2.filter((alert) => !dismissedAlerts.includes(alert.id));
      setAlerts(activeAlerts);
    }
  };
  const clearDismissedAlerts = () => {
    setDismissedAlerts([]);
  };
  const toggleAutoRefresh = () => {
    setAutoRefreshEnabled(!autoRefreshEnabled);
  };
  reactExports.useEffect(() => {
    let interval;
    if (selectedRegion && autoRefreshEnabled) {
      interval = setInterval(() => {
        refreshAlerts();
      }, 3e5);
    }
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [selectedRegion, dismissedAlerts, autoRefreshEnabled]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-lg shadow-lg p-6 mb-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 mb-4", children: t2("disasterPrediction.title") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 mb-6", children: t2("disasterPrediction.description") }),
    alerts.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800", children: t2("disasterPrediction.alerts.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: toggleAutoRefresh,
              className: `text-xs px-2 py-1 rounded ${autoRefreshEnabled ? "bg-green-100 text-green-800" : "bg-gray-100 text-gray-800"}`,
              children: autoRefreshEnabled ? t2("disasterPrediction.autoRefreshOn") : t2("disasterPrediction.autoRefreshOff")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: refreshAlerts,
              className: "text-sm text-blue-600 hover:text-blue-800 flex items-center",
              "aria-label": t2("common.refresh"),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-4 h-4 mr-1", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" }) }),
                t2("common.refresh")
              ]
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: alerts.map((alert) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `p-3 rounded-lg border ${getAlertColor(alert.type)} relative`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: alert.message }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs opacity-75 mt-1", children: new Date(alert.timestamp).toLocaleTimeString() })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => dismissAlert(alert.id),
              className: "text-gray-500 hover:text-gray-700 ml-2",
              "aria-label": t2("common.dismiss"),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M6 18L18 6M6 6l12 12" }) })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-0 right-0 -mt-1 -mr-1 flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium ${getPriorityColor(alert.priority)} text-white`, children: t2(`disasterPrediction.priority.${alert.priority}`) }) }),
        alert.priority === "high" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute top-0 left-0 -mt-1 -ml-1 flex h-3 w-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "relative inline-flex rounded-full h-3 w-3 bg-red-500" })
        ] })
      ] }, alert.id)) }),
      dismissedAlerts.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 text-right", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: clearDismissedAlerts,
          className: "text-xs text-gray-500 hover:text-gray-700",
          children: t2("disasterPrediction.clearDismissed")
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-2", children: t2("disasterPrediction.selectRegion") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "select",
        {
          value: selectedRegion,
          onChange: handleRegionChange,
          className: "w-full md:w-64 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: t2("disasterPrediction.selectRegion") }),
            regions.map((region) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: region.id, children: region.name }, region.id))
          ]
        }
      )
    ] }),
    selectedRegion && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6 p-4 bg-gray-50 rounded-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-4 h-4 rounded-full ${getRiskColor(riskLevel)} mr-2` }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium", children: [
          t2("disasterPrediction.currentRiskLevel"),
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 font-bold", children: getRiskLabel(riskLevel) })
      ] }),
      weatherData && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 text-sm text-gray-600", children: [
        t2("disasterPrediction.currentWeather"),
        ": ",
        weatherData.temperature,
        "C, ",
        weatherData.humidity,
        "% humidity, ",
        weatherData.precipitation,
        "mm precipitation"
      ] })
    ] }),
    selectedRegion && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-b border-gray-200 mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "flex space-x-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setActiveTab("predictions"),
          className: `py-4 px-1 border-b-2 font-medium text-sm ${activeTab === "predictions" ? "border-indigo-500 text-indigo-600" : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"}`,
          children: t2("disasterPrediction.tabs.predictions")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setActiveTab("historical"),
          className: `py-4 px-1 border-b-2 font-medium text-sm ${activeTab === "historical" ? "border-indigo-500 text-indigo-600" : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"}`,
          children: t2("disasterPrediction.tabs.historical")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setActiveTab("factors"),
          className: `py-4 px-1 border-b-2 font-medium text-sm ${activeTab === "factors" ? "border-indigo-500 text-indigo-600" : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"}`,
          children: t2("disasterPrediction.tabs.factors")
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6", children: [
      activeTab === "predictions" && selectedRegion && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-4", children: t2("disasterPrediction.predictions.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4", children: predictions.map((prediction, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-gray-200 rounded-lg p-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-900", children: t2(`disasterTypes.${prediction.type}`) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${prediction.riskScore >= 80 ? "bg-red-100 text-red-800" : prediction.riskScore >= 60 ? "bg-orange-100 text-orange-800" : prediction.riskScore >= 40 ? "bg-yellow-100 text-yellow-800" : "bg-green-100 text-green-800"}`, children: [
              prediction.riskScore,
              "%"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 text-sm text-gray-500", children: [
            t2("disasterPrediction.probability"),
            ": ",
            prediction.probability,
            "%"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 text-sm", children: [
            t2("disasterPrediction.expectedImpact"),
            ": ",
            prediction.impact
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 text-sm text-gray-500", children: [
            t2("disasterPrediction.timeline"),
            ": ",
            prediction.timeline
          ] }),
          prediction.recommendations && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-3 pt-3 border-t border-gray-100", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs font-medium text-gray-700", children: [
              t2("disasterPrediction.recommendations"),
              ":"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "mt-1 text-xs text-gray-600 list-disc list-inside", children: prediction.recommendations.map((rec, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: rec }, i2)) })
          ] })
        ] }, index)) })
      ] }),
      activeTab === "historical" && selectedRegion && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-4", children: t2("disasterPrediction.historical.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full divide-y divide-gray-200", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-gray-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("disasterPrediction.historical.year") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("disasterPrediction.historical.disasterType") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("disasterPrediction.historical.affected") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("disasterPrediction.historical.economicLoss") })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: "bg-white divide-y divide-gray-200", children: historicalData.map((record, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900", children: record.year }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: t2(`disasterTypes.${record.type}`) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: record.affected.toLocaleString() }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: [
              "",
              (record.economicLoss / 1e7).toFixed(1),
              "Cr"
            ] })
          ] }, index)) })
        ] }) })
      ] }),
      activeTab === "factors" && selectedRegion && weatherData && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-4", children: t2("disasterPrediction.factors.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 p-4 rounded-lg", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-700 mb-3", children: t2("disasterPrediction.factors.weather") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-600", children: [
                  t2("disasterPrediction.factors.temperature"),
                  ":"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium", children: [
                  weatherData.temperature,
                  "C"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-600", children: [
                  t2("disasterPrediction.factors.humidity"),
                  ":"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium", children: [
                  weatherData.humidity,
                  "%"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-600", children: [
                  t2("disasterPrediction.factors.precipitation"),
                  ":"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium", children: [
                  weatherData.precipitation,
                  "mm"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-600", children: [
                  t2("disasterPrediction.factors.windSpeed"),
                  ":"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium", children: [
                  weatherData.windSpeed,
                  " km/h"
                ] })
              ] }),
              weatherData.pressure && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-600", children: [
                  t2("disasterPrediction.factors.pressure"),
                  ":"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium", children: [
                  weatherData.pressure,
                  " hPa"
                ] })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 p-4 rounded-lg", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-700 mb-3", children: t2("disasterPrediction.factors.geographical") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-600", children: [
                  t2("disasterPrediction.factors.elevation"),
                  ":"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium", children: [
                  weatherData.elevation,
                  "m"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-600", children: [
                  t2("disasterPrediction.factors.forestCover"),
                  ":"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium", children: [
                  weatherData.forestCover,
                  "%"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-600", children: [
                  t2("disasterPrediction.factors.riverProximity"),
                  ":"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium", children: [
                  weatherData.riverProximity,
                  " km"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-600", children: [
                  t2("disasterPrediction.factors.seismicActivity"),
                  ":"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: weatherData.seismicActivity })
              ] })
            ] })
          ] })
        ] })
      ] })
    ] })
  ] });
};
const DisasterPredictionPage = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold text-gray-800 dark:text-white mb-2", children: t2("disasterPrediction.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:text-gray-300", children: t2("disasterPrediction.description") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DisasterPrediction, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 bg-blue-50 dark:bg-blue-900 rounded-lg p-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold text-blue-800 dark:text-blue-200 mb-4", children: t2("disasterPrediction.about.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-blue-700 dark:text-blue-300 mb-4", children: t2("disasterPrediction.about.description") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 p-4 rounded-lg shadow", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium text-gray-800 dark:text-white mb-2", children: t2("disasterPrediction.about.howItWorks") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "list-disc list-inside text-gray-600 dark:text-gray-300 text-sm space-y-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("disasterPrediction.about.step1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("disasterPrediction.about.step2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("disasterPrediction.about.step3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("disasterPrediction.about.step4") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 p-4 rounded-lg shadow", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium text-gray-800 dark:text-white mb-2", children: t2("disasterPrediction.about.benefits") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "list-disc list-inside text-gray-600 dark:text-gray-300 text-sm space-y-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("disasterPrediction.about.benefit1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("disasterPrediction.about.benefit2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("disasterPrediction.about.benefit3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("disasterPrediction.about.benefit4") })
          ] })
        ] })
      ] })
    ] })
  ] });
};
const DisasterRecoveryTracker = () => {
  const { t: t2 } = useTranslation();
  const [selectedRegion, setSelectedRegion] = reactExports.useState("kerala");
  const [recoveryData, setRecoveryData] = reactExports.useState(null);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const mockRecoveryData = {
    kerala: {
      region: "Kerala",
      disasterType: "Flood",
      startDate: "2023-07-15",
      endDate: "2024-07-15",
      overallProgress: 78,
      milestones: [
        { id: 1, name: t2("recoveryTracker.milestones.housing"), progress: 92, targetDate: "2023-12-31", actualDate: "2023-11-15", status: "completed" },
        { id: 2, name: t2("recoveryTracker.milestones.infrastructure"), progress: 85, targetDate: "2024-03-31", actualDate: null, status: "in-progress" },
        { id: 3, name: t2("recoveryTracker.milestones.healthcare"), progress: 75, targetDate: "2024-01-31", actualDate: "2024-02-10", status: "completed" },
        { id: 4, name: t2("recoveryTracker.milestones.education"), progress: 68, targetDate: "2024-05-31", actualDate: null, status: "in-progress" },
        { id: 5, name: t2("recoveryTracker.milestones.livelihood"), progress: 60, targetDate: "2024-07-31", actualDate: null, status: "in-progress" },
        { id: 6, name: t2("recoveryTracker.milestones.environment"), progress: 45, targetDate: "2024-12-31", actualDate: null, status: "not-started" }
      ],
      progressHistory: [
        { date: "2023-08", progress: 15 },
        { date: "2023-09", progress: 28 },
        { date: "2023-10", progress: 35 },
        { date: "2023-11", progress: 52 },
        { date: "2023-12", progress: 65 },
        { date: "2024-01", progress: 70 },
        { date: "2024-02", progress: 72 },
        { date: "2024-03", progress: 75 },
        { date: "2024-04", progress: 76 },
        { date: "2024-05", progress: 77 },
        { date: "2024-06", progress: 78 }
      ],
      resourceAllocation: [
        { category: t2("recoveryTracker.resources.housing"), allocated: 45, spent: 42 },
        { category: t2("recoveryTracker.resources.infrastructure"), allocated: 30, spent: 25 },
        { category: t2("recoveryTracker.resources.healthcare"), allocated: 10, spent: 8 },
        { category: t2("recoveryTracker.resources.education"), allocated: 8, spent: 5 },
        { category: t2("recoveryTracker.resources.livelihood"), allocated: 5, spent: 3 },
        { category: t2("recoveryTracker.resources.admin"), allocated: 2, spent: 2 }
      ],
      challenges: [
        { id: 1, issue: t2("recoveryTracker.challenges.funding"), severity: "high", resolved: false },
        { id: 2, issue: t2("recoveryTracker.challenges.logistics"), severity: "medium", resolved: true },
        { id: 3, issue: t2("recoveryTracker.challenges.coordination"), severity: "medium", resolved: false },
        { id: 4, issue: t2("recoveryTracker.challenges.community"), severity: "low", resolved: false }
      ]
    },
    maharashtra: {
      region: "Maharashtra",
      disasterType: "Cyclone",
      startDate: "2023-06-01",
      endDate: "2024-06-01",
      overallProgress: 65,
      milestones: [
        { id: 1, name: t2("recoveryTracker.milestones.housing"), progress: 80, targetDate: "2023-12-31", actualDate: null, status: "in-progress" },
        { id: 2, name: t2("recoveryTracker.milestones.infrastructure"), progress: 70, targetDate: "2024-02-28", actualDate: null, status: "in-progress" },
        { id: 3, name: t2("recoveryTracker.milestones.healthcare"), progress: 85, targetDate: "2023-10-31", actualDate: "2023-10-15", status: "completed" },
        { id: 4, name: t2("recoveryTracker.milestones.education"), progress: 55, targetDate: "2024-04-30", actualDate: null, status: "in-progress" },
        { id: 5, name: t2("recoveryTracker.milestones.livelihood"), progress: 45, targetDate: "2024-06-30", actualDate: null, status: "in-progress" },
        { id: 6, name: t2("recoveryTracker.milestones.environment"), progress: 30, targetDate: "2024-12-31", actualDate: null, status: "not-started" }
      ],
      progressHistory: [
        { date: "2023-07", progress: 20 },
        { date: "2023-08", progress: 32 },
        { date: "2023-09", progress: 40 },
        { date: "2023-10", progress: 50 },
        { date: "2023-11", progress: 55 },
        { date: "2023-12", progress: 60 },
        { date: "2024-01", progress: 62 },
        { date: "2024-02", progress: 63 },
        { date: "2024-03", progress: 64 },
        { date: "2024-04", progress: 65 }
      ],
      resourceAllocation: [
        { category: t2("recoveryTracker.resources.housing"), allocated: 40, spent: 35 },
        { category: t2("recoveryTracker.resources.infrastructure"), allocated: 35, spent: 28 },
        { category: t2("recoveryTracker.resources.healthcare"), allocated: 12, spent: 11 },
        { category: t2("recoveryTracker.resources.education"), allocated: 7, spent: 4 },
        { category: t2("recoveryTracker.resources.livelihood"), allocated: 4, spent: 2 },
        { category: t2("recoveryTracker.resources.admin"), allocated: 2, spent: 2 }
      ],
      challenges: [
        { id: 1, issue: t2("recoveryTracker.challenges.funding"), severity: "medium", resolved: false },
        { id: 2, issue: t2("recoveryTracker.challenges.logistics"), severity: "high", resolved: false },
        { id: 3, issue: t2("recoveryTracker.challenges.coordination"), severity: "low", resolved: true }
      ]
    }
  };
  reactExports.useEffect(() => {
    setIsLoading(true);
    setTimeout(() => {
      setRecoveryData(mockRecoveryData[selectedRegion]);
      setIsLoading(false);
    }, 500);
  }, [selectedRegion]);
  const regions = [
    { value: "kerala", label: t2("states.kerala") },
    { value: "maharashtra", label: t2("states.maharashtra") }
  ];
  const getStatusColor = (status) => {
    switch (status) {
      case "completed":
        return "bg-green-500";
      case "in-progress":
        return "bg-yellow-500";
      case "not-started":
        return "bg-gray-300";
      default:
        return "bg-gray-300";
    }
  };
  const getSeverityColor = (severity) => {
    switch (severity) {
      case "high":
        return "bg-red-100 text-red-800";
      case "medium":
        return "bg-yellow-100 text-yellow-800";
      case "low":
        return "bg-green-100 text-green-800";
      default:
        return "bg-gray-100 text-gray-800";
    }
  };
  const formatProgress = (progress) => {
    return `${progress}%`;
  };
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white rounded-lg shadow-md p-6 mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center items-center h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500" }) }) });
  }
  if (!recoveryData) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white rounded-lg shadow-md p-6 mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-8 text-gray-500", children: t2("recoveryTracker.noData") }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-lg shadow-md p-6 mb-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col md:flex-row md:justify-between md:items-center mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 mb-4 md:mb-0", children: t2("recoveryTracker.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center space-x-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: t2("recoveryTracker.selectRegion") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "select",
          {
            value: selectedRegion,
            onChange: (e3) => setSelectedRegion(e3.target.value),
            className: "px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500",
            children: regions.map((region) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: region.value, children: region.label }, region.value))
          }
        )
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-4 gap-4 mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 rounded-lg p-4 border border-blue-100", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium text-blue-800 mb-1", children: t2("recoveryTracker.disasterType") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-bold text-blue-900", children: recoveryData.disasterType })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-green-50 rounded-lg p-4 border border-green-100", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium text-green-800 mb-1", children: t2("recoveryTracker.startDate") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-bold text-green-900", children: new Date(recoveryData.startDate).toLocaleDateString() })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-purple-50 rounded-lg p-4 border border-purple-100", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium text-purple-800 mb-1", children: t2("recoveryTracker.endDate") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-bold text-purple-900", children: new Date(recoveryData.endDate).toLocaleDateString() })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-indigo-50 rounded-lg p-4 border border-indigo-100", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium text-indigo-800 mb-1", children: t2("recoveryTracker.overallProgress") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-bold text-indigo-900", children: formatProgress(recoveryData.overallProgress) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-4", children: t2("recoveryTracker.progressTrend") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        LineChart,
        {
          data: recoveryData.progressHistory,
          margin: { top: 5, right: 30, left: 20, bottom: 5 },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "date" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, { domain: [0, 100], tickFormatter: formatProgress }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { formatter: (value) => [`${value}%`, t2("recoveryTracker.progress")] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Line,
              {
                type: "monotone",
                dataKey: "progress",
                name: t2("recoveryTracker.progress"),
                stroke: "#4f46e5",
                activeDot: { r: 8 }
              }
            )
          ]
        }
      ) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-4", children: t2("recoveryTracker.milestones.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: recoveryData.milestones.map((milestone) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-gray-200 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col md:flex-row md:items-center md:justify-between mb-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800", children: milestone.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3 mt-2 md:mt-0", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(milestone.status)}`, children: t2(`recoveryTracker.status.${milestone.status}`) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-lg font-semibold text-gray-900", children: formatProgress(milestone.progress) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-gray-200 rounded-full h-2 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "bg-blue-600 h-2 rounded-full",
            style: { width: `${milestone.progress}%` }
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col md:flex-row md:items-center md:justify-between text-sm text-gray-600", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: milestone.targetDate && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            t2("recoveryTracker.targetDate"),
            ": ",
            new Date(milestone.targetDate).toLocaleDateString()
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: milestone.actualDate && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            t2("recoveryTracker.actualDate"),
            ": ",
            new Date(milestone.actualDate).toLocaleDateString()
          ] }) })
        ] })
      ] }, milestone.id)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-4", children: t2("recoveryTracker.resourceAllocation") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          BarChart,
          {
            data: recoveryData.resourceAllocation,
            layout: "vertical",
            margin: { top: 5, right: 30, left: 100, bottom: 5 },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { type: "number", domain: [0, 100], tickFormatter: formatProgress }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, { dataKey: "category", type: "category", width: 80 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { formatter: (value) => [`${value}%`, t2("recoveryTracker.percentage")] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "allocated", name: t2("recoveryTracker.allocated"), fill: "#8884d8" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "spent", name: t2("recoveryTracker.spent"), fill: "#82ca9d" })
            ]
          }
        ) }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-4", children: t2("recoveryTracker.resourceBreakdown") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(PieChart, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Pie,
            {
              data: recoveryData.resourceAllocation,
              cx: "50%",
              cy: "50%",
              labelLine: true,
              outerRadius: 80,
              fill: "#8884d8",
              dataKey: "allocated",
              nameKey: "category",
              label: ({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`,
              children: recoveryData.resourceAllocation.map((entry, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(Cell, { fill: ["#0088FE", "#00C49F", "#FFBB28", "#FF8042", "#8884D8", "#82CA9D"][index % 6] }, `cell-${index}`))
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { formatter: (value) => [`${value}%`, t2("recoveryTracker.percentage")] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {})
        ] }) }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-4", children: t2("recoveryTracker.challenges.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: recoveryData.challenges.map((challenge) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `p-4 rounded-lg border ${challenge.resolved ? "bg-green-50 border-green-200" : getSeverityColor(challenge.severity).includes("red") ? "bg-red-50 border-red-200" : getSeverityColor(challenge.severity).includes("yellow") ? "bg-yellow-50 border-yellow-200" : "bg-gray-50 border-gray-200"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800", children: challenge.issue }),
        challenge.resolved ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "px-2 py-1 bg-green-100 text-green-800 rounded-full text-xs font-medium", children: t2("recoveryTracker.challenges.resolved") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 py-1 rounded-full text-xs font-medium ${getSeverityColor(challenge.severity)}`, children: t2(`recoveryTracker.severity.${challenge.severity}`) })
      ] }) }, challenge.id)) })
    ] })
  ] });
};
const DisasterRecoveryTrackerPage = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen bg-gray-50 py-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold text-gray-900 mb-2", children: t2("recoveryTracker.pageTitle") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600", children: t2("recoveryTracker.pageDescription") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DisasterRecoveryTracker, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 bg-blue-50 rounded-lg p-6 border border-blue-100", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold text-blue-800 mb-3", children: t2("recoveryTracker.aboutTitle") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-blue-700 mb-3", children: t2("recoveryTracker.aboutDescription") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "list-disc pl-5 text-blue-700 space-y-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("recoveryTracker.benefit1") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("recoveryTracker.benefit2") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("recoveryTracker.benefit3") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("recoveryTracker.benefit4") })
      ] })
    ] })
  ] }) });
};
const CommunityFeedbackSystem = () => {
  const { t: t2 } = useTranslation();
  const [feedback2, setFeedback] = reactExports.useState({
    name: "",
    email: "",
    category: "general",
    rating: 5,
    comment: "",
    location: ""
  });
  const [submittedFeedback, setSubmittedFeedback] = reactExports.useState([]);
  const [isSubmitting, setIsSubmitting] = reactExports.useState(false);
  const [submitSuccess, setSubmitSuccess] = reactExports.useState(false);
  const [activeTab, setActiveTab] = reactExports.useState("submit");
  const [filterCategory, setFilterCategory] = reactExports.useState("all");
  const [filterRating, setFilterRating] = reactExports.useState("all");
  const mockFeedbackData = [
    {
      id: 1,
      name: "Rajesh Kumar",
      email: "rajesh@example.com",
      category: "disaster_response",
      rating: 4,
      comment: "The flood response was quick, but communication could be better.",
      location: "Kolkata",
      date: "2023-07-15",
      status: "resolved"
    },
    {
      id: 2,
      name: "Priya Sharma",
      email: "priya@example.com",
      category: "platform_usability",
      rating: 5,
      comment: "Very easy to use platform for reporting disasters.",
      location: "Mumbai",
      date: "2023-07-10",
      status: "resolved"
    },
    {
      id: 3,
      name: "Amit Patel",
      email: "amit@example.com",
      category: "resource_allocation",
      rating: 3,
      comment: "Resources took too long to reach our area after the cyclone.",
      location: "Ahmedabad",
      date: "2023-06-22",
      status: "pending"
    },
    {
      id: 4,
      name: "Sunita Devi",
      email: "sunita@example.com",
      category: "general",
      rating: 4,
      comment: "Good initiative, but more awareness is needed in rural areas.",
      location: "Patna",
      date: "2023-06-18",
      status: "resolved"
    },
    {
      id: 5,
      name: "Vikram Singh",
      email: "vikram@example.com",
      category: "disaster_response",
      rating: 2,
      comment: "Response time was too slow during the earthquake.",
      location: "Delhi",
      date: "2023-05-30",
      status: "in_progress"
    }
  ];
  reactExports.useEffect(() => {
    setSubmittedFeedback(mockFeedbackData);
  }, []);
  const handleInputChange = (e3) => {
    const { name, value } = e3.target;
    setFeedback((prev) => ({
      ...prev,
      [name]: value
    }));
  };
  const handleSubmit = async (e3) => {
    e3.preventDefault();
    setIsSubmitting(true);
    try {
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      const newFeedback = {
        id: submittedFeedback.length + 1,
        ...feedback2,
        date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        status: "pending"
      };
      setSubmittedFeedback((prev) => [newFeedback, ...prev]);
      setSubmitSuccess(true);
      setFeedback({
        name: "",
        email: "",
        category: "general",
        rating: 5,
        comment: "",
        location: ""
      });
      setTimeout(() => setSubmitSuccess(false), 3e3);
    } catch (error) {
      console.error("Error submitting feedback:", error);
    } finally {
      setIsSubmitting(false);
    }
  };
  const feedbackCategories = [
    { value: "general", label: t2("feedback.categories.general") },
    { value: "disaster_response", label: t2("feedback.categories.disaster_response") },
    { value: "platform_usability", label: t2("feedback.categories.platform_usability") },
    { value: "resource_allocation", label: t2("feedback.categories.resource_allocation") },
    { value: "communication", label: t2("feedback.categories.communication") },
    { value: "volunteer_coordination", label: t2("feedback.categories.volunteer_coordination") }
  ];
  const getStatusColor = (status) => {
    switch (status) {
      case "resolved":
        return "bg-green-100 text-green-800";
      case "in_progress":
        return "bg-yellow-100 text-yellow-800";
      case "pending":
        return "bg-red-100 text-red-800";
      default:
        return "bg-gray-100 text-gray-800";
    }
  };
  const filteredFeedback = submittedFeedback.filter((item) => {
    const categoryMatch = filterCategory === "all" || item.category === filterCategory;
    const ratingMatch = filterRating === "all" || item.rating.toString() === filterRating;
    return categoryMatch && ratingMatch;
  });
  const feedbackStats = {
    total: submittedFeedback.length,
    resolved: submittedFeedback.filter((item) => item.status === "resolved").length,
    pending: submittedFeedback.filter((item) => item.status === "pending").length,
    inProgress: submittedFeedback.filter((item) => item.status === "in_progress").length,
    averageRating: submittedFeedback.length > 0 ? (submittedFeedback.reduce((sum, item) => sum + item.rating, 0) / submittedFeedback.length).toFixed(1) : 0
  };
  const categoryData = feedbackCategories.filter((cat) => cat.value !== "general").map((cat) => ({
    name: cat.label,
    value: submittedFeedback.filter((item) => item.category === cat.value).length
  }));
  const ratingData = [1, 2, 3, 4, 5].map((rating) => ({
    name: `${rating} ${t2("feedback.stars")}`,
    value: submittedFeedback.filter((item) => item.rating === rating).length
  }));
  const statusData = [
    { name: t2("feedback.status.resolved"), value: feedbackStats.resolved },
    { name: t2("feedback.status.pending"), value: feedbackStats.pending },
    { name: t2("feedback.status.in_progress"), value: feedbackStats.inProgress }
  ];
  const COLORS = ["#0088FE", "#00C49F", "#FFBB28", "#FF8042", "#8884D8"];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-lg shadow-md p-6 mb-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 mb-6", children: t2("feedback.title") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-b border-gray-200 mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "flex space-x-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setActiveTab("submit"),
          className: `py-4 px-1 border-b-2 font-medium text-sm ${activeTab === "submit" ? "border-blue-500 text-blue-600" : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"}`,
          children: t2("feedback.submit_feedback")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setActiveTab("view"),
          className: `py-4 px-1 border-b-2 font-medium text-sm ${activeTab === "view" ? "border-blue-500 text-blue-600" : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"}`,
          children: t2("feedback.view_feedback")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setActiveTab("analytics"),
          className: `py-4 px-1 border-b-2 font-medium text-sm ${activeTab === "analytics" ? "border-blue-500 text-blue-600" : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"}`,
          children: t2("feedback.analytics")
        }
      )
    ] }) }),
    activeTab === "submit" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      submitSuccess && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-6 p-4 bg-green-100 text-green-700 rounded-lg", children: t2("feedback.submission_success") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "space-y-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "name", className: "block text-sm font-medium text-gray-700 mb-1", children: t2("feedback.name") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                id: "name",
                name: "name",
                value: feedback2.name,
                onChange: handleInputChange,
                required: true,
                className: "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "email", className: "block text-sm font-medium text-gray-700 mb-1", children: t2("feedback.email") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "email",
                id: "email",
                name: "email",
                value: feedback2.email,
                onChange: handleInputChange,
                required: true,
                className: "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "category", className: "block text-sm font-medium text-gray-700 mb-1", children: t2("feedback.category") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "select",
              {
                id: "category",
                name: "category",
                value: feedback2.category,
                onChange: handleInputChange,
                className: "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500",
                children: feedbackCategories.map((cat) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: cat.value, children: cat.label }, cat.value))
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "location", className: "block text-sm font-medium text-gray-700 mb-1", children: t2("feedback.location") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                id: "location",
                name: "location",
                value: feedback2.location,
                onChange: handleInputChange,
                className: "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: t2("feedback.rating") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
            [1, 2, 3, 4, 5].map((star) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => setFeedback((prev) => ({ ...prev, rating: star })),
                className: "text-2xl focus:outline-none",
                children: star <= feedback2.rating ? "" : ""
              },
              star
            )),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "ml-2 text-gray-600", children: [
              feedback2.rating,
              " ",
              t2("feedback.stars")
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "comment", className: "block text-sm font-medium text-gray-700 mb-1", children: t2("feedback.comment") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              id: "comment",
              name: "comment",
              value: feedback2.comment,
              onChange: handleInputChange,
              required: true,
              rows: 4,
              className: "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "submit",
            disabled: isSubmitting,
            className: "w-full md:w-auto px-6 py-3 bg-blue-600 text-white font-medium rounded-md shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50",
            children: isSubmitting ? t2("feedback.submitting") : t2("feedback.submit")
          }
        ) })
      ] })
    ] }),
    activeTab === "view" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col md:flex-row md:items-center md:justify-between mb-6 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800", children: t2("feedback.feedback_list") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: filterCategory,
              onChange: (e3) => setFilterCategory(e3.target.value),
              className: "px-3 py-1 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: t2("feedback.all_categories") }),
                feedbackCategories.map((cat) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: cat.value, children: cat.label }, cat.value))
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: filterRating,
              onChange: (e3) => setFilterRating(e3.target.value),
              className: "px-3 py-1 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: t2("feedback.all_ratings") }),
                [1, 2, 3, 4, 5].map((rating) => /* @__PURE__ */ jsxRuntimeExports.jsxs("option", { value: rating, children: [
                  rating,
                  " ",
                  t2("feedback.stars")
                ] }, rating))
              ]
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: filteredFeedback.length > 0 ? filteredFeedback.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-gray-200 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col md:flex-row md:items-center md:justify-between mb-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800", children: item.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-600", children: [
              item.email,
              "  ",
              item.location
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3 mt-2 md:mt-0", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(item.status)}`, children: t2(`feedback.status.${item.status}`) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex text-yellow-400", children: [...Array(5)].map((_2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: i2 < item.rating ? "" : "" }, i2)) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-block px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-xs font-medium", children: feedbackCategories.find((cat) => cat.value === item.category)?.label }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-700 mb-2", children: item.comment }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-500", children: [
          t2("feedback.submitted_on"),
          " ",
          item.date
        ] })
      ] }, item.id)) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-8 text-gray-500", children: t2("feedback.no_feedback_found") }) })
    ] }),
    activeTab === "analytics" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-6", children: t2("feedback.feedback_analytics") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-4 gap-4 mb-8", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 p-4 rounded-lg border border-blue-100", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-medium text-blue-800 mb-1", children: t2("feedback.total_feedback") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-bold text-blue-900", children: feedbackStats.total })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-green-50 p-4 rounded-lg border border-green-100", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-medium text-green-800 mb-1", children: t2("feedback.resolved") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-bold text-green-900", children: feedbackStats.resolved })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-yellow-50 p-4 rounded-lg border border-yellow-100", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-medium text-yellow-800 mb-1", children: t2("feedback.in_progress") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-bold text-yellow-900", children: feedbackStats.inProgress })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-purple-50 p-4 rounded-lg border border-purple-100", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-medium text-purple-800 mb-1", children: t2("feedback.average_rating") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-bold text-purple-900", children: feedbackStats.averageRating })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-8", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800 mb-4", children: t2("feedback.category_distribution") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(PieChart, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Pie,
              {
                data: categoryData,
                cx: "50%",
                cy: "50%",
                labelLine: true,
                outerRadius: 80,
                fill: "#8884d8",
                dataKey: "value",
                label: ({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`,
                children: categoryData.map((entry, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(Cell, { fill: COLORS[index % COLORS.length] }, `cell-${index}`))
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {})
          ] }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800 mb-4", children: t2("feedback.rating_distribution") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            BarChart,
            {
              data: ratingData,
              margin: { top: 5, right: 30, left: 20, bottom: 5 },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "name" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "value", name: t2("feedback.feedback_count"), fill: "#8884d8" })
              ]
            }
          ) }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800 mb-4", children: t2("feedback.status_distribution") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          BarChart,
          {
            data: statusData,
            margin: { top: 5, right: 30, left: 20, bottom: 5 },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "name" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { dataKey: "value", name: t2("feedback.feedback_count"), fill: "#82ca9d" })
            ]
          }
        ) }) })
      ] })
    ] })
  ] });
};
const CommunityFeedbackPage = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen bg-gray-50 py-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold text-gray-900 mb-2", children: t2("feedback.page_title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600", children: t2("feedback.page_description") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CommunityFeedbackSystem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 bg-blue-50 rounded-lg p-6 border border-blue-100", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold text-blue-800 mb-3", children: t2("feedback.importance_title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-blue-700 mb-3", children: t2("feedback.importance_description") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "list-disc pl-5 text-blue-700 space-y-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("feedback.benefit1") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("feedback.benefit2") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("feedback.benefit3") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("feedback.benefit4") })
      ] })
    ] })
  ] }) });
};
const ResourceDeploymentTracker = () => {
  const { t: t2 } = useTranslation();
  const [deployments, setDeployments] = reactExports.useState([]);
  const [selectedRegion, setSelectedRegion] = reactExports.useState("all");
  const [selectedResource, setSelectedResource] = reactExports.useState("all");
  const [timeRange, setTimeRange] = reactExports.useState("week");
  const [loading, setLoading] = reactExports.useState(true);
  const mockDeployments = [
    { id: 1, resource: "Water Purification Units", region: "Kerala", status: "deployed", quantity: 50, deployedAt: "2025-10-15", expectedReturn: "2025-11-15", team: "Team Alpha" },
    { id: 2, resource: "Medical Kits", region: "Odisha", status: "in-transit", quantity: 100, deployedAt: "2025-10-18", expectedReturn: "2025-10-20", team: "Team Beta" },
    { id: 3, resource: "Emergency Shelters", region: "Maharashtra", status: "deployed", quantity: 25, deployedAt: "2025-10-10", expectedReturn: "2025-12-10", team: "Team Gamma" },
    { id: 4, resource: "Food Supplies", region: "Kerala", status: "deployed", quantity: 500, deployedAt: "2025-10-12", expectedReturn: "2025-11-12", team: "Team Delta" },
    { id: 5, resource: "Communication Equipment", region: "Rajasthan", status: "requested", quantity: 15, deployedAt: "2025-10-20", expectedReturn: "2025-10-25", team: "Team Epsilon" },
    { id: 6, resource: "Rescue Boats", region: "Assam", status: "deployed", quantity: 10, deployedAt: "2025-10-05", expectedReturn: "2025-11-05", team: "Team Zeta" },
    { id: 7, resource: "Power Generators", region: "Uttarakhand", status: "in-transit", quantity: 8, deployedAt: "2025-10-19", expectedReturn: "2025-10-22", team: "Team Eta" }
  ];
  const statusData = [
    { name: t2("resourceDeployment.status.deployed"), value: 4 },
    { name: t2("resourceDeployment.status.inTransit"), value: 2 },
    { name: t2("resourceDeployment.status.requested"), value: 1 }
  ];
  const timelineData = [
    { date: "2025-10-01", deployed: 2, inTransit: 1, requested: 0 },
    { date: "2025-10-08", deployed: 5, inTransit: 2, requested: 1 },
    { date: "2025-10-15", deployed: 8, inTransit: 3, requested: 2 },
    { date: "2025-10-22", deployed: 10, inTransit: 2, requested: 1 }
  ];
  const COLORS = ["#0088FE", "#00C49F", "#FFBB28"];
  const regions = ["all", "Kerala", "Odisha", "Maharashtra", "Rajasthan", "Assam", "Uttarakhand"];
  const resources2 = ["all", "Water Purification Units", "Medical Kits", "Emergency Shelters", "Food Supplies", "Communication Equipment", "Rescue Boats", "Power Generators"];
  reactExports.useEffect(() => {
    setTimeout(() => {
      setDeployments(mockDeployments);
      setLoading(false);
    }, 1e3);
  }, []);
  const getStatusClass = (status) => {
    switch (status) {
      case "deployed":
        return "bg-green-100 text-green-800";
      case "in-transit":
        return "bg-blue-100 text-blue-800";
      case "requested":
        return "bg-yellow-100 text-yellow-800";
      default:
        return "bg-gray-100 text-gray-800";
    }
  };
  const filteredDeployments = deployments.filter((deployment) => {
    const regionMatch = selectedRegion === "all" || deployment.region === selectedRegion;
    const resourceMatch = selectedResource === "all" || deployment.resource === selectedResource;
    return regionMatch && resourceMatch;
  });
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white rounded-xl shadow-lg p-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center items-center h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500" }) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-lg p-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 mb-6", children: t2("resourceDeployment.title") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-4 gap-4 mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: t2("resourceDeployment.region") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "select",
          {
            value: selectedRegion,
            onChange: (e3) => setSelectedRegion(e3.target.value),
            className: "w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500",
            children: regions.map((region) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: region, children: region === "all" ? t2("resourceDeployment.allRegions") : region }, region))
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: t2("resourceDeployment.resource") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "select",
          {
            value: selectedResource,
            onChange: (e3) => setSelectedResource(e3.target.value),
            className: "w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500",
            children: resources2.map((resource) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: resource, children: resource === "all" ? t2("resourceDeployment.allResources") : resource }, resource))
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: t2("resourceDeployment.timeRange") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "select",
          {
            value: timeRange,
            onChange: (e3) => setTimeRange(e3.target.value),
            className: "w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "week", children: t2("resourceDeployment.timeRangeOptions.week") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "month", children: t2("resourceDeployment.timeRangeOptions.month") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "quarter", children: t2("resourceDeployment.timeRangeOptions.quarter") })
            ]
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => {
            setSelectedRegion("all");
            setSelectedResource("all");
            setTimeRange("week");
          },
          className: "w-full px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition-colors",
          children: t2("resourceDeployment.resetFilters")
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-4 gap-4 mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-blue-800", children: deployments.length }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-blue-600", children: t2("resourceDeployment.totalDeployments") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-green-50 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-green-800", children: deployments.filter((d2) => d2.status === "deployed").length }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-green-600", children: t2("resourceDeployment.deployed") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-yellow-50 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-yellow-800", children: deployments.filter((d2) => d2.status === "in-transit").length }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-yellow-600", children: t2("resourceDeployment.inTransit") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-purple-50 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-purple-800", children: deployments.filter((d2) => d2.status === "requested").length }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-purple-600", children: t2("resourceDeployment.requested") })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-4", children: t2("resourceDeployment.statusDistribution") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: 300, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(PieChart, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Pie,
            {
              data: statusData,
              cx: "50%",
              cy: "50%",
              labelLine: false,
              outerRadius: 80,
              fill: "#8884d8",
              dataKey: "value",
              label: ({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`,
              children: statusData.map((entry, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(Cell, { fill: COLORS[index % COLORS.length] }, `cell-${index}`))
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {})
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-4", children: t2("resourceDeployment.deploymentTimeline") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: 300, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(LineChart, { data: timelineData, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "date" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Line,
            {
              type: "monotone",
              dataKey: "deployed",
              stroke: "#10B981",
              activeDot: { r: 8 },
              name: t2("resourceDeployment.status.deployed")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Line,
            {
              type: "monotone",
              dataKey: "inTransit",
              stroke: "#3B82F6",
              name: t2("resourceDeployment.status.inTransit")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Line,
            {
              type: "monotone",
              dataKey: "requested",
              stroke: "#F59E0B",
              name: t2("resourceDeployment.status.requested")
            }
          )
        ] }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full divide-y divide-gray-200", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-gray-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("resourceDeployment.resource") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("resourceDeployment.region") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("resourceDeployment.quantity") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("resourceDeployment.status") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("resourceDeployment.team") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("resourceDeployment.deployedAt") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("resourceDeployment.expectedReturn") })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: "bg-white divide-y divide-gray-200", children: filteredDeployments.map((deployment) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "hover:bg-gray-50", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900", children: deployment.resource }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: deployment.region }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: deployment.quantity }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${getStatusClass(deployment.status)}`, children: t2(`resourceDeployment.status.${deployment.status}`) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: deployment.team }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: deployment.deployedAt }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: deployment.expectedReturn })
      ] }, deployment.id)) })
    ] }) })
  ] });
};
const ResourceDeploymentTrackerPage = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold text-gray-900 mb-2", children: t2("resourceDeployment.pageTitle") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600", children: t2("resourceDeployment.pageDescription") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-lg p-6 mb-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold text-gray-800 mb-4", children: t2("resourceDeployment.aboutTitle") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 mb-4", children: t2("resourceDeployment.aboutDescription") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 rounded-lg p-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium text-blue-800 mb-2", children: t2("resourceDeployment.benefit1Title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-blue-600 text-sm", children: t2("resourceDeployment.benefit1") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-green-50 rounded-lg p-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium text-green-800 mb-2", children: t2("resourceDeployment.benefit2Title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-green-600 text-sm", children: t2("resourceDeployment.benefit2") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-yellow-50 rounded-lg p-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium text-yellow-800 mb-2", children: t2("resourceDeployment.benefit3Title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-yellow-600 text-sm", children: t2("resourceDeployment.benefit3") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-purple-50 rounded-lg p-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium text-purple-800 mb-2", children: t2("resourceDeployment.benefit4Title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-purple-600 text-sm", children: t2("resourceDeployment.benefit4") })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ResourceDeploymentTracker, {})
  ] });
};
const VolunteerRecognitionSystem = () => {
  const { t: t2 } = useTranslation();
  const [volunteers, setVolunteers] = reactExports.useState([]);
  const [selectedPeriod, setSelectedPeriod] = reactExports.useState("month");
  const [selectedRegion, setSelectedRegion] = reactExports.useState("all");
  const [loading, setLoading] = reactExports.useState(true);
  const mockVolunteers = [
    { id: 1, name: "Rajesh Kumar", region: "Kerala", hours: 120, contributions: 15, recognitionLevel: "gold", badges: ["Flood Relief", "Community Leader"] },
    { id: 2, name: "Priya Sharma", region: "Odisha", hours: 95, contributions: 12, recognitionLevel: "silver", badges: ["Cyclone Response", "Medical Support"] },
    { id: 3, name: "Amit Patel", region: "Maharashtra", hours: 80, contributions: 10, recognitionLevel: "silver", badges: ["Earthquake Relief", "Logistics"] },
    { id: 4, name: "Sunita Devi", region: "Kerala", hours: 150, contributions: 20, recognitionLevel: "platinum", badges: ["Flood Relief", "Community Leader", "Fundraising"] },
    { id: 5, name: "Vikram Singh", region: "Rajasthan", hours: 60, contributions: 8, recognitionLevel: "bronze", badges: ["Drought Response"] },
    { id: 6, name: "Anjali Rao", region: "Odisha", hours: 110, contributions: 14, recognitionLevel: "gold", badges: ["Cyclone Response", "Education"] },
    { id: 7, name: "Deepak Nair", region: "Kerala", hours: 90, contributions: 11, recognitionLevel: "silver", badges: ["Flood Relief", "Technical Support"] },
    { id: 8, name: "Meera Reddy", region: "Assam", hours: 130, contributions: 16, recognitionLevel: "gold", badges: ["Flood Relief", "Medical Support"] }
  ];
  const recognitionColors = {
    platinum: "#E5E4E2",
    gold: "#FFD700",
    silver: "#C0C0C0",
    bronze: "#CD7F32"
  };
  const periods = [
    { value: "week", label: t2("volunteerRecognition.periods.week") },
    { value: "month", label: t2("volunteerRecognition.periods.month") },
    { value: "quarter", label: t2("volunteerRecognition.periods.quarter") },
    { value: "year", label: t2("volunteerRecognition.periods.year") }
  ];
  const regions = ["all", "Kerala", "Odisha", "Maharashtra", "Rajasthan", "Assam"];
  reactExports.useEffect(() => {
    setTimeout(() => {
      setVolunteers(mockVolunteers);
      setLoading(false);
    }, 1e3);
  }, []);
  const filteredVolunteers = volunteers.filter((volunteer) => {
    const regionMatch = selectedRegion === "all" || volunteer.region === selectedRegion;
    return regionMatch;
  });
  const recognitionData = [
    { name: t2("volunteerRecognition.levels.platinum"), value: volunteers.filter((v2) => v2.recognitionLevel === "platinum").length },
    { name: t2("volunteerRecognition.levels.gold"), value: volunteers.filter((v2) => v2.recognitionLevel === "gold").length },
    { name: t2("volunteerRecognition.levels.silver"), value: volunteers.filter((v2) => v2.recognitionLevel === "silver").length },
    { name: t2("volunteerRecognition.levels.bronze"), value: volunteers.filter((v2) => v2.recognitionLevel === "bronze").length }
  ];
  const hoursData = volunteers.map((volunteer) => ({
    name: volunteer.name,
    hours: volunteer.hours
  }));
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white rounded-xl shadow-lg p-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center items-center h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500" }) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-lg p-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-800 mb-6", children: t2("volunteerRecognition.title") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-4 mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: t2("volunteerRecognition.period") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "select",
          {
            value: selectedPeriod,
            onChange: (e3) => setSelectedPeriod(e3.target.value),
            className: "w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500",
            children: periods.map((period) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: period.value, children: period.label }, period.value))
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: t2("volunteerRecognition.region") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "select",
          {
            value: selectedRegion,
            onChange: (e3) => setSelectedRegion(e3.target.value),
            className: "w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500",
            children: regions.map((region) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: region, children: region === "all" ? t2("volunteerRecognition.allRegions") : region }, region))
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => {
            setSelectedPeriod("month");
            setSelectedRegion("all");
          },
          className: "w-full px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition-colors",
          children: t2("volunteerRecognition.resetFilters")
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-4 gap-4 mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-blue-800", children: volunteers.length }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-blue-600", children: t2("volunteerRecognition.totalVolunteers") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-green-50 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-green-800", children: volunteers.reduce((sum, volunteer) => sum + volunteer.hours, 0) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-green-600", children: t2("volunteerRecognition.totalHours") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-yellow-50 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-yellow-800", children: volunteers.length > 0 ? Math.round(volunteers.reduce((sum, volunteer) => sum + volunteer.hours, 0) / volunteers.length) : 0 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-yellow-600", children: t2("volunteerRecognition.avgHoursPerVolunteer") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-purple-50 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-2xl font-bold text-purple-800", children: volunteers.filter((v2) => v2.recognitionLevel === "platinum").length }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-purple-600", children: t2("volunteerRecognition.platinumAwards") })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-4", children: t2("volunteerRecognition.recognitionDistribution") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: 300, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(PieChart, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Pie,
            {
              data: recognitionData,
              cx: "50%",
              cy: "50%",
              labelLine: false,
              outerRadius: 80,
              fill: "#8884d8",
              dataKey: "value",
              label: ({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`,
              children: recognitionData.map((entry, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(Cell, { fill: Object.values(recognitionColors)[index] }, `cell-${index}`))
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {})
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 rounded-lg p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-4", children: t2("volunteerRecognition.volunteerHours") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: 300, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(BarChart, { data: hoursData, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "name" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Bar,
            {
              dataKey: "hours",
              name: t2("volunteerRecognition.hours"),
              fill: "#8884d8"
            }
          )
        ] }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full divide-y divide-gray-200", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-gray-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("volunteerRecognition.volunteer") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("volunteerRecognition.region") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("volunteerRecognition.hours") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("volunteerRecognition.contributions") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("volunteerRecognition.recognitionLevel") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { scope: "col", className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: t2("volunteerRecognition.badges") })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: "bg-white divide-y divide-gray-200", children: filteredVolunteers.map((volunteer) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "hover:bg-gray-50", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900", children: volunteer.name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: volunteer.region }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: volunteer.hours }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: volunteer.contributions }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${volunteer.recognitionLevel === "platinum" ? "bg-gray-200 text-gray-800" : volunteer.recognitionLevel === "gold" ? "bg-yellow-100 text-yellow-800" : volunteer.recognitionLevel === "silver" ? "bg-gray-300 text-gray-800" : "bg-orange-100 text-orange-800"}`, children: t2(`volunteerRecognition.levels.${volunteer.recognitionLevel}`) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-1", children: volunteer.badges.map((badge, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "px-2 py-1 bg-blue-100 text-blue-800 text-xs rounded-full", children: badge }, index)) }) })
      ] }, volunteer.id)) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg p-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-800 mb-4", children: t2("volunteerRecognition.certificateTitle") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 mb-4", children: t2("volunteerRecognition.certificateDescription") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors", children: t2("volunteerRecognition.generateCertificates") })
    ] })
  ] });
};
const VolunteerRecognitionPage = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold text-gray-900 mb-2", children: t2("volunteerRecognition.pageTitle") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600", children: t2("volunteerRecognition.pageDescription") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-xl shadow-lg p-6 mb-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold text-gray-800 mb-4", children: t2("volunteerRecognition.aboutTitle") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 mb-4", children: t2("volunteerRecognition.aboutDescription") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 rounded-lg p-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium text-blue-800 mb-2", children: t2("volunteerRecognition.benefit1Title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-blue-600 text-sm", children: t2("volunteerRecognition.benefit1") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-green-50 rounded-lg p-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium text-green-800 mb-2", children: t2("volunteerRecognition.benefit2Title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-green-600 text-sm", children: t2("volunteerRecognition.benefit2") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-yellow-50 rounded-lg p-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium text-yellow-800 mb-2", children: t2("volunteerRecognition.benefit3Title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-yellow-600 text-sm", children: t2("volunteerRecognition.benefit3") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-purple-50 rounded-lg p-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium text-purple-800 mb-2", children: t2("volunteerRecognition.benefit4Title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-purple-600 text-sm", children: t2("volunteerRecognition.benefit4") })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(VolunteerRecognitionSystem, {})
  ] });
};
function App() {
  const { t: t2, i18n } = useTranslation();
  const [darkMode, setDarkMode] = reactExports.useState(false);
  const [fontSize, setFontSize] = reactExports.useState(16);
  const [highContrast, setHighContrast] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const savedDarkMode2 = localStorage.getItem("darkMode") === "true";
    setDarkMode(savedDarkMode2);
    if (savedDarkMode2) {
      document.documentElement.classList.add("dark");
    }
  }, []);
  reactExports.useEffect(() => {
    const savedFontSize = localStorage.getItem("fontSize");
    if (savedFontSize) {
      setFontSize(parseInt(savedFontSize));
      document.documentElement.style.fontSize = `${savedFontSize}px`;
    }
  }, []);
  reactExports.useEffect(() => {
    const savedHighContrast = localStorage.getItem("highContrast") === "true";
    setHighContrast(savedHighContrast);
    if (savedHighContrast) {
      document.documentElement.classList.add("high-contrast");
    }
  }, []);
  const toggleDarkMode = () => {
    const newDarkMode = !darkMode;
    setDarkMode(newDarkMode);
    localStorage.setItem("darkMode", newDarkMode.toString());
    if (newDarkMode) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  };
  const increaseFontSize = () => {
    const newSize = Math.min(fontSize + 2, 24);
    setFontSize(newSize);
    localStorage.setItem("fontSize", newSize.toString());
    document.documentElement.style.fontSize = `${newSize}px`;
  };
  const decreaseFontSize = () => {
    const newSize = Math.max(fontSize - 2, 12);
    setFontSize(newSize);
    localStorage.setItem("fontSize", newSize.toString());
    document.documentElement.style.fontSize = `${newSize}px`;
  };
  const toggleHighContrast = () => {
    const newHighContrast = !highContrast;
    setHighContrast(newHighContrast);
    localStorage.setItem("highContrast", newHighContrast.toString());
    if (newHighContrast) {
      document.documentElement.classList.add("high-contrast");
    } else {
      document.documentElement.classList.remove("high-contrast");
    }
  };
  const changeLanguage = (lng) => {
    i18n.changeLanguage(lng);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen bg-gradient-to-b from-gray-50 to-gray-100 dark:from-gray-900 dark:to-gray-800", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "a",
      {
        href: "#main-content",
        className: "sr-only focus:not-sr-only focus:absolute focus:p-4 focus:bg-blue-600 focus:text-white focus:z-50 focus:ring-2 focus:ring-white",
        "aria-label": t2("accessibility.skip_to_main_content"),
        children: t2("accessibility.skip_to_main_content")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Navigation,
      {
        darkMode,
        toggleDarkMode,
        increaseFontSize,
        decreaseFontSize,
        highContrast,
        toggleHighContrast,
        changeLanguage
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("main", { id: "main-content", className: "container mx-auto px-4 py-8", role: "main", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Home, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/campaigns", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Campaigns, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/donate", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Donate, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/ngo", element: /* @__PURE__ */ jsxRuntimeExports.jsx(NGODashboard, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AdminDashboard, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/demo", element: /* @__PURE__ */ jsxRuntimeExports.jsx(DonationDemo, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/authtest", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthTest, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/ivr", element: /* @__PURE__ */ jsxRuntimeExports.jsx(IVRSystem, {}) }),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/stats", element: /* @__PURE__ */ jsxRuntimeExports.jsx(DisasterStatisticsPage, {}) }),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/prediction", element: /* @__PURE__ */ jsxRuntimeExports.jsx(DisasterPredictionPage, {}) }),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/recovery", element: /* @__PURE__ */ jsxRuntimeExports.jsx(DisasterRecoveryTrackerPage, {}) }),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/feedback", element: /* @__PURE__ */ jsxRuntimeExports.jsx(CommunityFeedbackPage, {}) }),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/resources", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ResourceDeploymentTrackerPage, {}) }),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/volunteer-recognition", element: /* @__PURE__ */ jsxRuntimeExports.jsx(VolunteerRecognitionPage, {}) }),
      " "
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("footer", { className: "bg-gradient-to-r from-gray-800 to-gray-900 text-white py-12", role: "contentinfo", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-4 gap-8", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "text-xl font-bold mb-4 flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-white text-blue-700 rounded-full w-6 h-6 flex items-center justify-center mr-2 text-sm", children: "" }),
            "ImpactX"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-400", children: t2("home.title") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-lg font-semibold mb-4", children: "Quick Links" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/", className: "text-gray-400 hover:text-white transition-colors", children: "Home" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/campaigns", className: "text-gray-400 hover:text-white transition-colors", children: "Campaigns" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/donate", className: "text-gray-400 hover:text-white transition-colors", children: "Donate" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/ngo", className: "text-gray-400 hover:text-white transition-colors", children: "NGO Dashboard" }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-lg font-semibold mb-4", children: "Resources" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: "Documentation" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: "API Reference" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: "GitHub" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: "Community" }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-lg font-semibold mb-4", children: "Contact Us" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "space-y-2 text-gray-400", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 mr-2 mt-0.5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" }) }),
              "contact@impactx.org"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 mr-2 mt-0.5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z" }) }),
              "+91 98765 43210"
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-gray-700 mt-8 pt-8 text-center text-gray-400", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          " 2025 ImpactX. ",
          t2("home.title"),
          ". Made with  for India."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-sm", children: "Developed by Goodwell Sreejith S, Vasudha, and Nikhil" })
      ] })
    ] }) })
  ] }) });
}
const {
  slice,
  forEach
} = [];
function defaults(obj) {
  forEach.call(slice.call(arguments, 1), (source) => {
    if (source) {
      for (const prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
function hasXSS(input) {
  if (typeof input !== "string") return false;
  const xssPatterns = [/<\s*script.*?>/i, /<\s*\/\s*script\s*>/i, /<\s*img.*?on\w+\s*=/i, /<\s*\w+\s*on\w+\s*=.*?>/i, /javascript\s*:/i, /vbscript\s*:/i, /expression\s*\(/i, /eval\s*\(/i, /alert\s*\(/i, /document\.cookie/i, /document\.write\s*\(/i, /window\.location/i, /innerHTML/i];
  return xssPatterns.some((pattern) => pattern.test(input));
}
const fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
const serializeCookie = function(name, val) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    path: "/"
  };
  const opt = options;
  const value = encodeURIComponent(val);
  let str = `${name}=${value}`;
  if (opt.maxAge > 0) {
    const maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge)) throw new Error("maxAge should be a Number");
    str += `; Max-Age=${Math.floor(maxAge)}`;
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += `; Domain=${opt.domain}`;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += `; Path=${opt.path}`;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly) str += "; HttpOnly";
  if (opt.secure) str += "; Secure";
  if (opt.sameSite) {
    const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  if (opt.partitioned) str += "; Partitioned";
  return str;
};
const cookie = {
  create(name, value, minutes, domain2) {
    let cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    if (minutes) {
      cookieOptions.expires = /* @__PURE__ */ new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3);
    }
    if (domain2) cookieOptions.domain = domain2;
    document.cookie = serializeCookie(name, value, cookieOptions);
  },
  read(name) {
    const nameEQ = `${name}=`;
    const ca = document.cookie.split(";");
    for (let i2 = 0; i2 < ca.length; i2++) {
      let c2 = ca[i2];
      while (c2.charAt(0) === " ") c2 = c2.substring(1, c2.length);
      if (c2.indexOf(nameEQ) === 0) return c2.substring(nameEQ.length, c2.length);
    }
    return null;
  },
  remove(name, domain2) {
    this.create(name, "", -1, domain2);
  }
};
var cookie$1 = {
  name: "cookie",
  // Deconstruct the options object and extract the lookupCookie property
  lookup(_ref2) {
    let {
      lookupCookie
    } = _ref2;
    if (lookupCookie && typeof document !== "undefined") {
      return cookie.read(lookupCookie) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupCookie,
      cookieMinutes,
      cookieDomain,
      cookieOptions
    } = _ref2;
    if (lookupCookie && typeof document !== "undefined") {
      cookie.create(lookupCookie, lng, cookieMinutes, cookieDomain, cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  // Deconstruct the options object and extract the lookupQuerystring property
  lookup(_ref2) {
    let {
      lookupQuerystring
    } = _ref2;
    let found;
    if (typeof window !== "undefined") {
      let {
        search
      } = window.location;
      if (!window.location.search && window.location.hash?.indexOf("?") > -1) {
        search = window.location.hash.substring(window.location.hash.indexOf("?"));
      }
      const query = search.substring(1);
      const params = query.split("&");
      for (let i2 = 0; i2 < params.length; i2++) {
        const pos = params[i2].indexOf("=");
        if (pos > 0) {
          const key = params[i2].substring(0, pos);
          if (key === lookupQuerystring) {
            found = params[i2].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
var hash = {
  name: "hash",
  // Deconstruct the options object and extract the lookupHash property and the lookupFromHashIndex property
  lookup(_ref2) {
    let {
      lookupHash,
      lookupFromHashIndex
    } = _ref2;
    let found;
    if (typeof window !== "undefined") {
      const {
        hash: hash2
      } = window.location;
      if (hash2 && hash2.length > 2) {
        const query = hash2.substring(1);
        if (lookupHash) {
          const params = query.split("&");
          for (let i2 = 0; i2 < params.length; i2++) {
            const pos = params[i2].indexOf("=");
            if (pos > 0) {
              const key = params[i2].substring(0, pos);
              if (key === lookupHash) {
                found = params[i2].substring(pos + 1);
              }
            }
          }
        }
        if (found) return found;
        if (!found && lookupFromHashIndex > -1) {
          const language = hash2.match(/\/([a-zA-Z-]*)/g);
          if (!Array.isArray(language)) return void 0;
          const index = typeof lookupFromHashIndex === "number" ? lookupFromHashIndex : 0;
          return language[index]?.replace("/", "");
        }
      }
    }
    return found;
  }
};
let hasLocalStorageSupport = null;
const localStorageAvailable = () => {
  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = typeof window !== "undefined" && window.localStorage !== null;
    if (!hasLocalStorageSupport) {
      return false;
    }
    const testKey = "i18next.translate.boo";
    window.localStorage.setItem(testKey, "foo");
    window.localStorage.removeItem(testKey);
  } catch (e3) {
    hasLocalStorageSupport = false;
  }
  return hasLocalStorageSupport;
};
var localStorage$1 = {
  name: "localStorage",
  // Deconstruct the options object and extract the lookupLocalStorage property
  lookup(_ref2) {
    let {
      lookupLocalStorage
    } = _ref2;
    if (lookupLocalStorage && localStorageAvailable()) {
      return window.localStorage.getItem(lookupLocalStorage) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupLocalStorage property
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupLocalStorage
    } = _ref2;
    if (lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(lookupLocalStorage, lng);
    }
  }
};
let hasSessionStorageSupport = null;
const sessionStorageAvailable = () => {
  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = typeof window !== "undefined" && window.sessionStorage !== null;
    if (!hasSessionStorageSupport) {
      return false;
    }
    const testKey = "i18next.translate.boo";
    window.sessionStorage.setItem(testKey, "foo");
    window.sessionStorage.removeItem(testKey);
  } catch (e3) {
    hasSessionStorageSupport = false;
  }
  return hasSessionStorageSupport;
};
var sessionStorage = {
  name: "sessionStorage",
  lookup(_ref2) {
    let {
      lookupSessionStorage
    } = _ref2;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      return window.sessionStorage.getItem(lookupSessionStorage) || void 0;
    }
    return void 0;
  },
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupSessionStorage
    } = _ref2;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(lookupSessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup(options) {
    const found = [];
    if (typeof navigator !== "undefined") {
      const {
        languages,
        userLanguage,
        language
      } = navigator;
      if (languages) {
        for (let i2 = 0; i2 < languages.length; i2++) {
          found.push(languages[i2]);
        }
      }
      if (userLanguage) {
        found.push(userLanguage);
      }
      if (language) {
        found.push(language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  // Deconstruct the options object and extract the htmlTag property
  lookup(_ref2) {
    let {
      htmlTag: htmlTag2
    } = _ref2;
    let found;
    const internalHtmlTag = htmlTag2 || (typeof document !== "undefined" ? document.documentElement : null);
    if (internalHtmlTag && typeof internalHtmlTag.getAttribute === "function") {
      found = internalHtmlTag.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  // Deconstruct the options object and extract the lookupFromPathIndex property
  lookup(_ref2) {
    let {
      lookupFromPathIndex
    } = _ref2;
    if (typeof window === "undefined") return void 0;
    const language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
    if (!Array.isArray(language)) return void 0;
    const index = typeof lookupFromPathIndex === "number" ? lookupFromPathIndex : 0;
    return language[index]?.replace("/", "");
  }
};
var subdomain = {
  name: "subdomain",
  lookup(_ref2) {
    let {
      lookupFromSubdomainIndex
    } = _ref2;
    const internalLookupFromSubdomainIndex = typeof lookupFromSubdomainIndex === "number" ? lookupFromSubdomainIndex + 1 : 1;
    const language = typeof window !== "undefined" && window.location?.hostname?.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
    if (!language) return void 0;
    return language[internalLookupFromSubdomainIndex];
  }
};
let canCookies = false;
try {
  document.cookie;
  canCookies = true;
} catch (e3) {
}
const order = ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"];
if (!canCookies) order.splice(1, 1);
const getDefaults = () => ({
  order,
  lookupQuerystring: "lng",
  lookupCookie: "i18next",
  lookupLocalStorage: "i18nextLng",
  lookupSessionStorage: "i18nextLng",
  // cache user language
  caches: ["localStorage"],
  excludeCacheFor: ["cimode"],
  // cookieMinutes: 10,
  // cookieDomain: 'myDomain'
  convertDetectedLanguage: (l2) => l2
});
class Browser {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options);
  }
  init() {
    let services = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      languageUtils: {}
    };
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.services = services;
    this.options = defaults(options, this.options || {}, getDefaults());
    if (typeof this.options.convertDetectedLanguage === "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1) {
      this.options.convertDetectedLanguage = (l2) => l2.replace("-", "_");
    }
    if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
    this.i18nOptions = i18nOptions;
    this.addDetector(cookie$1);
    this.addDetector(querystring);
    this.addDetector(localStorage$1);
    this.addDetector(sessionStorage);
    this.addDetector(navigator$1);
    this.addDetector(htmlTag);
    this.addDetector(path);
    this.addDetector(subdomain);
    this.addDetector(hash);
  }
  addDetector(detector) {
    this.detectors[detector.name] = detector;
    return this;
  }
  detect() {
    let detectionOrder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.order;
    let detected = [];
    detectionOrder.forEach((detectorName) => {
      if (this.detectors[detectorName]) {
        let lookup = this.detectors[detectorName].lookup(this.options);
        if (lookup && typeof lookup === "string") lookup = [lookup];
        if (lookup) detected = detected.concat(lookup);
      }
    });
    detected = detected.filter((d2) => d2 !== void 0 && d2 !== null && !hasXSS(d2)).map((d2) => this.options.convertDetectedLanguage(d2));
    if (this.services && this.services.languageUtils && this.services.languageUtils.getBestMatchFromCodes) return detected;
    return detected.length > 0 ? detected[0] : null;
  }
  cacheUserLanguage(lng) {
    let caches = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.caches;
    if (!caches) return;
    if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
    caches.forEach((cacheName) => {
      if (this.detectors[cacheName]) this.detectors[cacheName].cacheUserLanguage(lng, this.options);
    });
  }
}
Browser.type = "languageDetector";
const common$6 = { "home": "Home", "campaigns": "Campaigns", "donate": "Donate", "ngoDashboard": "NGO Dashboard", "adminDashboard": "Admin Dashboard", "ivrSystem": "IVR System", "statistics": "Statistics", "prediction": "Prediction", "refresh": "Refresh", "dismiss": "Dismiss" };
const home$6 = { "title": "Transparent & Verifiable Disaster Relief Funding on Algorand", "description": "An open-source blockchain-powered disaster relief and impact funding platform built on Algorand. The solution ensures that every donation is transparent, tamper-proof, and outcome-verified. Funds are locked in smart contract escrows and released only when verified by multi-source oracles, including NGO reports, IoT/drones, and satellite data. This approach restores donor trust, eliminates corruption, and establishes a global standard for accountable disaster aid and making sure we create such a ecosystem for india", "getStarted": "Get Started", "learnMore": "Learn More" };
const accessibility$6 = { "skip_to_main_content": "Skip to main content", "accessibility_options": "Accessibility Options", "increase_font_size": "Increase Font Size", "decrease_font_size": "Decrease Font Size", "high_contrast": "High Contrast Mode", "reading_assistance": "Reading Assistance" };
const disasterTypes$3 = { "flood": "Flood", "earthquake": "Earthquake", "cyclone": "Cyclone", "drought": "Drought", "landslide": "Landslide", "fire": "Fire", "tsunami": "Tsunami" };
const disasterPrediction$1 = { "title": "Disaster Prediction & Early Warning", "description": "Predict potential disasters and receive early warnings to prepare communities", "selectRegion": "Select Region", "currentRiskLevel": "Current Risk Level", "currentWeather": "Current Weather", "tabs": { "predictions": "Risk Predictions", "historical": "Historical Data", "factors": "Risk Factors" }, "risk": { "critical": "Critical", "high": "High", "moderate": "Moderate", "low": "Low" }, "predictions": { "title": "Disaster Risk Predictions" }, "probability": "Probability", "expectedImpact": "Expected Impact", "timeline": "Expected Timeline", "recommendations": "Recommendations", "historical": { "title": "Historical Disaster Data", "year": "Year", "disasterType": "Disaster Type", "affected": "People Affected", "economicLoss": "Economic Loss" }, "factors": { "title": "Risk Factors Analysis", "weather": "Weather Conditions", "geographical": "Geographical Factors", "temperature": "Temperature", "humidity": "Humidity", "precipitation": "Precipitation", "windSpeed": "Wind Speed", "elevation": "Elevation", "forestCover": "Forest Cover", "riverProximity": "River Proximity", "seismicActivity": "Seismic Activity" }, "about": { "title": "About Disaster Prediction", "description": "Our disaster prediction system uses advanced algorithms and real-time data to forecast potential disasters and provide early warnings to communities at risk.", "howItWorks": "How It Works", "step1": "Collects real-time weather and environmental data", "step2": "Analyzes historical disaster patterns", "step3": "Applies machine learning models to predict risks", "step4": "Generates actionable alerts and recommendations", "benefits": "Key Benefits", "benefit1": "Early warning systems save lives", "benefit2": "Communities can prepare in advance", "benefit3": "Resources can be pre-positioned", "benefit4": "Economic losses can be minimized" }, "alerts": { "title": "Alerts & Notifications", "highRisk": "High risk of {{disaster}} detected ({{score}}% probability)", "moderateRisk": "Moderate risk of {{disaster}} detected ({{score}}% probability)", "heavyRain": "Heavy rainfall expected ({{amount}}mm)", "highWinds": "High wind speeds detected ({{speed}} km/h)", "extremeHeat": "Extreme heat conditions ({{temperature}}C)", "extremeCold": "Extreme cold conditions ({{temperature}}C)", "highHumidity": "High humidity levels ({{humidity}}%)", "lowPressure": "Low atmospheric pressure ({{pressure}} hPa)" }, "priority": { "high": "High", "medium": "Medium", "low": "Low" }, "autoRefreshOn": "Auto-refresh: ON", "autoRefreshOff": "Auto-refresh: OFF", "clearDismissed": "Clear dismissed alerts" };
const emergencyResourceTracker$5 = { "title": "Emergency Resource Tracker", "totalResources": "Total Resources", "availableResources": "Available Resources", "responseRate": "Response Rate", "region": "Region", "allRegions": "All Regions", "refresh": "Refresh", "sort": { "name": "Sort by Name", "quantity": "Sort by Quantity", "availability": "Sort by Availability" }, "allTypes": "All Types", "resourceType": "Resource Type", "quantity": "Quantity", "location": "Location", "availability": "Availability", "selectType": "Select Resource Type", "enterLocation": "Enter Location", "enterContact": "Enter Contact Information", "submitRequest": "Submit Request", "requestResources": "Request Emergency Resources", "requestStatus": "Request Status", "requestId": "Request ID", "status": "Status", "submitted": "Submitted", "estimatedDelivery": "Estimated Delivery", "refreshStatus": "Refresh Status", "normal": "Normal", "high": "High", "critical": "Critical", "contact": "Contact", "urgency": "Urgency", "resource": "Resource", "allocation": { "title": "Resource Allocation Overview", "allocated": "Allocated", "available": "Available" }, "historicalUsage": "Historical Resource Usage", "month": "Month", "addResource": "Add New Resource", "hideForm": "Hide Form", "resourceName": "Resource Name", "unit": "Unit", "enterUnit": "Enter unit (e.g., kits, packets)", "selectRegion": "Select Region", "cancel": "Cancel" };
const volunteerCoordinator$5 = { "title": "Volunteer Coordinator", "description": "Comprehensive interface for managing volunteers during disaster response and recovery", "tabs": { "matching": "Volunteer Matching", "assignments": "Task Assignments", "communication": "Communication Plan", "tracking": "Hours Tracking", "scheduling": "Shift Scheduling" }, "disasterType": "Disaster Type", "latitude": "Latitude", "longitude": "Longitude", "search": "Search volunteers...", "sort": { "suitability": "Sort by Suitability", "distance": "Sort by Distance", "experience": "Sort by Experience" }, "experience": "Experience", "years": "years", "reassign": "Reassign Volunteers", "regenerate": "Regenerate Plan", "refresh": "Refresh Data", "reschedule": "Reschedule Shifts", "volunteer": "Volunteer", "skills": "Skills", "distance": "Distance", "suitability": "Suitability", "priority": "Priority", "requiredSkills": "Required Skills", "requiredVolunteers": "Required Volunteers", "assignedTo": "Assigned To", "assignedAt": "Assigned At", "tasks": "Tasks", "frequency": "Frequency", "contactList": "Contact List", "totalVolunteers": "Total Volunteers", "totalHours": "Total Hours", "topContributors": "Top Contributors", "recognitionAwards": "Recognition Awards", "recognitionDistribution": "Recognition Distribution", "bronze": "Bronze", "silver": "Silver", "gold": "Gold", "platinum": "Platinum", "recognitionLevel": "Recognition Level", "hours": "hours", "shift": "Shift", "time": "Time", "duration": "Duration", "totalShifts": "Total Shifts", "filledShifts": "Filled Shifts", "coverage": "Coverage", "volunteerUtilization": "Volunteer Utilization", "utilization": "Utilization", "performance": { "title": "Performance Metrics", "utilization": "Volunteer Utilization Rate", "avgSuitability": "Avg. Suitability Score", "shiftCoverage": "Shift Coverage", "assigned": "Volunteers Assigned" }, "engagement": { "title": "Volunteer Engagement", "active": "Active Volunteers", "inactive": "Inactive Volunteers", "averageScore": "Avg. Engagement Score", "high": "High Engagement", "medium": "Medium Engagement", "low": "Low Engagement", "distribution": "Engagement Distribution" }, "skillUtilization": "Skill Utilization Rate", "skillUtilizationTitle": "Skill Utilization Dashboard", "skillAvailability": "available", "avgHoursPerVolunteer": "Avg. Hours per Volunteer" };
const map$1 = { "title": "Disaster Response Map", "allTime": "All Time", "lastMonth": "Last Month", "lastQuarter": "Last Quarter", "lastYear": "Last Year", "riskZones": "Risk Zones", "campaigns": "Campaigns", "active": "Active", "completed": "Completed", "campaign": "Campaign", "fundsRaised": "Funds Raised", "goal": "Goal", "source": "Source", "createdAt": "Created", "endDate": "End Date", "disasterZone": "Disaster Zone", "riskLevel": "Risk Level", "disasterType": "Disaster Type", "lastUpdated": "Last Updated", "riskLevels": { "high": "High", "moderate": "Moderate", "low": "Low" } };
const disasterStatistics$5 = { "title": "Disaster Statistics", "description": "Comprehensive analysis of disaster events, impacts, and trends across India", "export": "Export", "exportData": "Export disaster statistics data", "resetFilters": "Reset Filters", "startDate": "Start Date", "endDate": "End Date", "region": "Region", "allRegions": "All Regions", "events": "Events", "affected": "Affected", "economicLoss": "Economic Loss", "tabs": { "overview": "Overview", "trends": "Trends", "regional": "Regional Analysis", "comparison": "Type Comparison" }, "overview": { "title": "Disaster Overview", "totalEvents": "Total Events", "totalAffected": "Total Affected", "totalEconomicLoss": "Total Economic Loss", "averageAffected": "Average Affected per Event", "byType": "By Disaster Type", "byRegion": "By Region" }, "byType": "By Type", "byRegion": "By Region", "trends": { "title": "Disaster Trends", "yearsCovered": "Years Covered", "annualGrowth": "Annual Growth", "mostIncreasing": "Most Increasing Type", "yearlyBreakdown": "Yearly Breakdown", "year": "Year" }, "regional": { "title": "Regional Risk Analysis", "region": "Region", "riskIndex": "Risk Index" }, "comparison": { "title": "Disaster Type Comparison", "firstType": "First Disaster Type", "secondType": "Second Disaster Type", "compare": "Compare", "averageAffected": "Average Affected", "averageEconomicLoss": "Average Economic Loss" } };
const communityReporting$6 = { "title": "Community Disaster Reporter", "description": "Report disaster incidents in your community to help emergency responders and relief organizations", "disasterType": "Disaster Type", "selectDisasterType": "Select disaster type", "location": "Location", "locationPlaceholder": "Enter location (city, district, or landmark)", "useCurrentLocation": "Use Current Location", "detecting": "Detecting...", "detectingLocation": "Detecting your location...", "locationError": "Unable to retrieve your location. Please try again.", "locationPermissionDenied": "Location access denied. Please enable location permissions in your browser settings.", "locationUnavailable": "Location information is unavailable. Please check your device settings.", "locationTimeout": "Location request timed out. Please try again.", "locationNotSupported": "Geolocation is not supported by your browser.", "descriptionPlaceholder": "Describe the disaster incident, including what happened, when, and any visible damage...", "descriptionHelp": "Please provide as much detail as possible about the incident", "severity": "Severity Level", "severityHelp": "Rate the severity of the incident (1 = Low, 5 = Critical)", "low": "Low", "high": "High", "affectedPeople": "Affected People", "affectedPeopleHelp": "Estimated number of people affected (optional)", "media": "Photos/Videos", "uploadMedia": "Click to upload photos or videos", "mediaLimit": "Upload up to 5 images or videos (max 10MB each)", "maxMediaFiles": "You can only upload a maximum of 5 files.", "submitReport": "Submit Disaster Report", "submitting": "Submitting...", "successMessage": "Your disaster report has been submitted successfully! Emergency responders have been notified.", "submissionError": "There was an error submitting your report. Please try again.", "disasterTypes": { "flood": "Flood", "earthquake": "Earthquake", "cyclone": "Cyclone", "drought": "Drought", "landslide": "Landslide", "fire": "Fire", "epidemic": "Epidemic", "chemical": "Chemical Spill", "other": "Other" }, "validation": { "disasterTypeRequired": "Disaster type is required", "locationRequired": "Location is required", "descriptionRequired": "Description is required", "descriptionTooShort": "Description must be at least 10 characters long", "invalidLatitude": "Invalid latitude value (must be between -90 and 90)", "invalidLongitude": "Invalid longitude value (must be between -180 and 180)", "invalidAffectedPeople": "Affected people count cannot be negative" } };
const responsePlanner$5 = { "title": "Disaster Response Planner", "disasterType": "Disaster Type", "severityLevel": "Severity Level", "region": "Region", "selectDisasterAndRegion": "Select a disaster type and region to generate a response plan", "disasterInfo": "{{disaster}} Response Plan for {{region}}", "affectedArea": "Affected Area", "affectedPopulation": "Affected Population", "immediateActions": "Immediate Actions", "resourceAllocation": "Resource Allocation", "teams": "Teams", "equipmentAndSupplies": "Equipment & Supplies", "timeline": "Response Timeline", "coordination": "Coordination Entities", "specialConsiderations": "Special Considerations", "phases": { "immediate": "Immediate Response", "shortTerm": "Short-term Response", "mediumTerm": "Medium-term Recovery", "longTerm": "Long-term Reconstruction" }, "severity": { "minor": "Minor", "moderate": "Moderate", "significant": "Significant", "severe": "Severe", "catastrophic": "Catastrophic" }, "export": "Export", "exportJSON": "Export as JSON", "exportCSV": "Export as CSV", "savePlan": "Save Plan", "comparePlans": "Compare Plans", "customScenario": "Custom Scenario", "useStandard": "Use Standard", "resourceDistribution": "Resource Distribution", "teamAllocation": "Team Allocation", "quantity": "Quantity", "numberOfTeams": "Number of Teams", "planComparison": "Plan Comparison", "currentPlan": "Current Plan", "savedPlan": "Saved Plan", "totalResources": "Total Resources", "noSavedPlans": "No saved plans available for comparison" };
const emergencyContacts$6 = { "title": "Emergency Contacts", "searchPlaceholder": "Search contacts...", "all": "All", "favorites": "Favorites", "favoriteContacts": "Favorite Contacts", "contactsFound": "contacts found", "noContactsFound": "No contacts found matching your search criteria.", "addToFavorites": "Add to favorites", "removeFromFavorites": "Remove from favorites", "call": "Call", "copy": "Copy", "national": { "title": "National Emergency Numbers", "police": "Police", "policeDesc": "For immediate police assistance", "ambulance": "Ambulance", "ambulanceDesc": "For medical emergencies", "fire": "Fire Department", "fireDesc": "For fire and rescue services", "disaster": "Disaster Management", "disasterDesc": "For disaster response and management" }, "maharashtra": { "controlRoom": "State Control Room", "controlRoomDesc": "Maharashtra State Disaster Management Authority", "emergency": "Emergency Response", "emergencyDesc": "Integrated Emergency Response System" }, "odisha": { "controlRoom": "State Control Room", "controlRoomDesc": "Odisha State Disaster Management Authority", "emergency": "Emergency Response", "emergencyDesc": "Odisha Emergency Response System" }, "kerala": { "controlRoom": "State Control Room", "controlRoomDesc": "Kerala State Disaster Management Authority", "emergency": "Emergency Response", "emergencyDesc": "Kerala Emergency Response System" }, "groups": { "police": "Police", "medical": "Medical", "fire": "Fire", "disaster": "Disaster", "emergency": "Emergency" }, "safetyTip": "Safety Tip", "safetyTipDesc": "Save these numbers in your phone and keep this information easily accessible. In an emergency, every second counts." };
const recoveryTracker$1 = { "pageTitle": "Disaster Recovery Tracker", "pageDescription": "Monitor and track the progress of disaster recovery efforts across different regions", "aboutTitle": "About Disaster Recovery Tracking", "aboutDescription": "The Disaster Recovery Tracker provides comprehensive monitoring of post-disaster recovery efforts, helping stakeholders understand progress and identify areas needing attention.", "benefit1": "Real-time visibility into recovery progress", "benefit2": "Identification of potential bottlenecks and challenges", "benefit3": "Resource allocation optimization", "benefit4": "Stakeholder communication and transparency", "title": "Disaster Recovery Tracker", "selectRegion": "Select Region", "disasterType": "Disaster Type", "startDate": "Start Date", "endDate": "Target End Date", "overallProgress": "Overall Progress", "progressTrend": "Recovery Progress Trend", "progress": "Progress", "milestones": { "title": "Recovery Milestones", "housing": "Housing Reconstruction", "infrastructure": "Infrastructure Restoration", "healthcare": "Healthcare Facilities", "education": "Educational Institutions", "livelihood": "Livelihood Restoration", "environment": "Environmental Rehabilitation" }, "targetDate": "Target Date", "actualDate": "Actual Completion Date", "status": { "completed": "Completed", "in-progress": "In Progress", "not-started": "Not Started" }, "resourceAllocation": "Resource Allocation", "resourceBreakdown": "Resource Breakdown", "resources": { "housing": "Housing", "infrastructure": "Infrastructure", "healthcare": "Healthcare", "education": "Education", "livelihood": "Livelihood", "admin": "Administration" }, "allocated": "Allocated", "spent": "Spent", "percentage": "Percentage", "challenges": { "title": "Recovery Challenges", "resolved": "Resolved", "funding": "Funding Shortage", "logistics": "Logistics Challenges", "coordination": "Coordination Issues", "community": "Community Resistance" }, "severity": { "high": "High", "medium": "Medium", "low": "Low" }, "noData": "No recovery data available for the selected region." };
const weather$5 = { "title": "Weather Monitor", "loading": "Loading...", "refresh": "Refresh", "data_not_available": "Weather data not available", "fetch_error": "Error fetching weather data", "conditions": { "sunny": "Sunny", "cloudy": "Cloudy", "rainy": "Rainy", "stormy": "Stormy" }, "temperature": "Temperature", "humidity": "Humidity", "wind_speed": "Wind Speed", "pressure": "Pressure", "visibility": "Visibility", "risk_assessment": "Risk Assessment", "risk_level": "Risk Level", "alerts": "Alerts", "preparedness_recommendations": "Preparedness Recommendations", "forecast": "Weather Forecast", "high": "High", "low": "Low", "show_trends": "Show Trends", "hide_trends": "Hide Trends", "trend_analysis": "Trend Analysis", "temperature_trend": "Temperature Trend", "condition_distribution": "Weather Condition Distribution", "days": "Days", "trend": { "increasing": "Increasing by {{value}}", "decreasing": "Decreasing by {{value}}", "stable": "Stable" }, "time_range": { "week": "Last Week", "month": "Last Month", "year": "Last Year" } };
const feedback$1 = { "page_title": "Community Feedback System", "page_description": "Share your experiences, suggestions, and concerns to help us improve disaster response efforts", "importance_title": "Why Community Feedback Matters", "importance_description": "Your feedback is crucial for improving our disaster response system. It helps us understand what's working well and where we need to make improvements.", "benefit1": "Identify gaps in disaster response and recovery efforts", "benefit2": "Improve communication and coordination between agencies", "benefit3": "Enhance platform usability based on real user experiences", "benefit4": "Build trust through transparency and community engagement", "title": "Community Feedback", "submit_feedback": "Submit Feedback", "view_feedback": "View Feedback", "analytics": "Analytics", "name": "Full Name", "email": "Email Address", "category": "Feedback Category", "location": "Location", "rating": "Rating", "comment": "Your Feedback", "submit": "Submit Feedback", "submitting": "Submitting...", "submission_success": "Thank you for your feedback! It has been successfully submitted.", "feedback_list": "Community Feedback", "all_categories": "All Categories", "all_ratings": "All Ratings", "no_feedback_found": "No feedback found matching the selected filters.", "submitted_on": "Submitted on", "feedback_analytics": "Feedback Analytics", "total_feedback": "Total Feedback", "resolved": "Resolved", "in_progress": "In Progress", "average_rating": "Average Rating", "category_distribution": "Feedback by Category", "rating_distribution": "Feedback by Rating", "status_distribution": "Feedback by Status", "feedback_count": "Feedback Count", "stars": "stars", "categories": { "general": "General Feedback", "disaster_response": "Disaster Response", "platform_usability": "Platform Usability", "resource_allocation": "Resource Allocation", "communication": "Communication", "volunteer_coordination": "Volunteer Coordination" }, "status": { "resolved": "Resolved", "pending": "Pending", "in_progress": "In Progress" } };
const resourceDeployment$1 = { "pageTitle": "Resource Deployment Tracker", "pageDescription": "Track and monitor the deployment status of emergency resources across different regions", "aboutTitle": "About Resource Deployment Tracking", "aboutDescription": "The Resource Deployment Tracker provides real-time visibility into the status and location of emergency resources, ensuring efficient allocation and deployment during disaster response efforts.", "benefit1Title": "Real-time Visibility", "benefit1": "Monitor resource status and location in real-time for better decision making", "benefit2Title": "Efficient Allocation", "benefit2": "Optimize resource distribution based on current needs and availability", "benefit3Title": "Improved Coordination", "benefit3": "Enhance coordination between response teams and resource managers", "benefit4Title": "Accountability", "benefit4": "Maintain detailed records of resource deployment and usage for reporting", "title": "Resource Deployment Status", "region": "Region", "allRegions": "All Regions", "resource": "Resource", "allResources": "All Resources", "timeRange": "Time Range", "timeRangeOptions": { "week": "Last Week", "month": "Last Month", "quarter": "Last Quarter" }, "resetFilters": "Reset Filters", "totalDeployments": "Total Deployments", "deployed": "Deployed", "inTransit": "In Transit", "requested": "Requested", "statusDistribution": "Status Distribution", "deploymentTimeline": "Deployment Timeline", "quantity": "Quantity", "status": { "deployed": "Deployed", "inTransit": "In Transit", "requested": "Requested" }, "team": "Team", "deployedAt": "Deployed At", "expectedReturn": "Expected Return" };
const impactAssessment$5 = { "title": "Disaster Impact Assessment", "disasterType": "Disaster Type", "region": "Region", "severityLevel": "Severity Level", "populationDensity": "Population Density", "overallImpact": "Overall Impact", "economicImpact": "Economic Impact", "socialImpact": "Social Impact", "environmentalImpact": "Environmental Impact", "recommendations": "Recommendations", "totalEconomicLoss": "Total Economic Loss", "infrastructureLoss": "Infrastructure Loss", "agriculturalLoss": "Agricultural Loss", "recoveryEstimate": "Recovery Estimate", "affectedFamilies": "Affected Families", "childrenAffected": "Children Affected", "displacementRate": "Displacement Rate", "casualtyRate": "Casualty Rate", "healthcareImpact": "Healthcare Impact", "educationImpact": "Education Impact", "forestLoss": "Forest Loss", "co2Emissions": "CO2 Emissions", "biodiversityLoss": "Biodiversity Loss", "species": "species", "recoveryTime": "Estimated Recovery Time", "months": "months", "priorityLevel": "Priority Level", "selectDisasterAndRegion": "Select a disaster type and region to generate an impact assessment", "impactLevels": { "catastrophic": "Catastrophic", "severe": "Severe", "moderate": "Moderate", "minor": "Minor", "low": "Low" }, "priority": { "immediate": "Immediate", "high": "High", "medium": "Medium", "low": "Low" }, "severity": { "low": "Low", "high": "High" }, "predictiveModelOn": "Predictive Model: ON", "predictiveModelOff": "Predictive Model: OFF", "predictiveModelDescription": "Enable predictive modeling to estimate impact based on severity and population density" };
const volunteerRecognition$1 = { "pageTitle": "Volunteer Recognition System", "pageDescription": "Acknowledge and celebrate the contributions of volunteers in disaster response and recovery efforts", "aboutTitle": "About Volunteer Recognition", "aboutDescription": "The Volunteer Recognition System tracks volunteer contributions, hours, and achievements to provide meaningful recognition for their dedicated service in disaster response and recovery efforts.", "benefit1Title": "Motivation Boost", "benefit1": "Recognizing volunteers increases motivation and encourages continued participation", "benefit2Title": "Community Building", "benefit2": "Creates a sense of community and belonging among volunteers", "benefit3Title": "Retention Improvement", "benefit3": "Improves volunteer retention by showing appreciation for their efforts", "benefit4Title": "Recruitment Enhancement", "benefit4": "Attracts new volunteers through positive word-of-mouth and visibility", "title": "Volunteer Recognition Dashboard", "period": "Time Period", "region": "Region", "allRegions": "All Regions", "resetFilters": "Reset Filters", "totalVolunteers": "Total Volunteers", "totalHours": "Total Hours", "avgHoursPerVolunteer": "Avg. Hours per Volunteer", "platinumAwards": "Platinum Awards", "recognitionDistribution": "Recognition Distribution", "volunteerHours": "Volunteer Hours", "hours": "Hours", "volunteer": "Volunteer", "contributions": "Contributions", "recognitionLevel": "Recognition Level", "badges": "Badges", "levels": { "platinum": "Platinum", "gold": "Gold", "silver": "Silver", "bronze": "Bronze" }, "periods": { "week": "Last Week", "month": "Last Month", "quarter": "Last Quarter", "year": "Last Year" }, "certificateTitle": "Recognition Certificates", "certificateDescription": "Generate and download official recognition certificates for outstanding volunteers", "generateCertificates": "Generate Certificates" };
const ivrSimulator$1 = { "title": "IVR System Simulator", "ready": "Ready to receive calls", "inProgress": "Call in progress", "noActiveCall": "No active call. Start a call to begin simulation.", "startCall": "Start Call", "endCall": "End Call", "dialpad": "Dialpad", "instructions": "Press the buttons to simulate user input during the call", "howItWorks": "How It Works", "description": "The IVR (Interactive Voice Response) system allows users to interact with our emergency response services through voice commands and keypad inputs.", "feature1": "24/7 automated emergency response system", "feature2": "Multi-language support for diverse communities", "feature3": "Integration with emergency services and databases", "feature4": "Real-time call routing and escalation", "showFlow": "Hide Call Flow", "hideFlow": "Show Call Flow", "callFlow": "Call Flow Visualization", "testMode": "Test Mode", "exitTestMode": "Exit Test Mode", "testScenarios": "Test Scenarios", "runTest": "Run Test" };
const enTranslation = {
  common: common$6,
  home: home$6,
  accessibility: accessibility$6,
  disasterTypes: disasterTypes$3,
  disasterPrediction: disasterPrediction$1,
  emergencyResourceTracker: emergencyResourceTracker$5,
  volunteerCoordinator: volunteerCoordinator$5,
  map: map$1,
  disasterStatistics: disasterStatistics$5,
  communityReporting: communityReporting$6,
  responsePlanner: responsePlanner$5,
  emergencyContacts: emergencyContacts$6,
  recoveryTracker: recoveryTracker$1,
  weather: weather$5,
  feedback: feedback$1,
  resourceDeployment: resourceDeployment$1,
  impactAssessment: impactAssessment$5,
  volunteerRecognition: volunteerRecognition$1,
  ivrSimulator: ivrSimulator$1
};
const common$5 = { "app_name": "", "home": "", "campaigns": "", "donate": " ", "ngo_dashboard": " ", "admin": "", "demo": "", "auth_test": " ", "dark_mode": " ", "light_mode": " ", "language": "", "english": "English", "hindi": "", "tamil": "", "telugu": "", "marathi": "", "bengali": "", "gujarati": "", "refresh": " ", "dismiss": " " };
const home$5 = { "title": "        ", "hero_title_1": "   ", "hero_description_1": "        ", "hero_title_2": "    ", "hero_description_2": "           ", "hero_title_3": "   ", "hero_description_3": "          ", "stats_funds": "2.5 ", "stats_funds_label": " ", "stats_beneficiaries": "15 +", "stats_beneficiaries_label": "", "stats_campaigns": "42", "stats_campaigns_label": " ", "stats_transparency": "98%", "stats_transparency_label": " ", "why_impactx": " ?", "why_impactx_desc": "  ,                      ", "feature_transparency": " ", "feature_transparency_desc": "                 ", "feature_verification": "- ", "feature_verification_desc": "  (, , )               ", "feature_storage": " ", "feature_storage_desc": "                ", "feature_india": "-", "feature_india_desc": "                 ", "disaster_relief": "    ", "disaster_relief_desc": "          ", "partners": "   ", "partners_desc": "         ", "how_it_works": "    ", "how_it_works_desc": " 4-          ", "step_create": " ", "step_create_desc": "         ", "step_donate": " ", "step_donate_desc": "         ", "step_verify": " ", "step_verify_desc": "             ", "step_release": " ", "step_release_desc": "         ", "cta_title": "     ?", "cta_desc": "                     ", "cta_button_donate": "  ", "cta_button_explore": " ", "funds_raised": " ", "go_to_slide": "  ", "active_campaigns": " ", "completed_campaigns": " ", "common_disasters_india": "   ", "disaster_types_desc": "          ", "disaster_flood": "", "disaster_earthquake": "", "disaster_cyclone": "", "disaster_drought": "", "disaster_landslide": "", "disaster_fire": " ", "quick_links": " ", "resources": "", "documentation": "", "api_reference": " ", "github": "", "community": "", "contact_us": " ", "made_with_love": "       ", "india_disaster_info": "   ", "disaster_affected_regions": " ", "disaster_frequency": "", "disaster_impact": "", "disaster_high": "", "disaster_medium": "", "disaster_low": "", "disaster_severe": "", "disaster_moderate": "", "disaster_flood_desc": "            ,        ", "disaster_earthquake_desc": "             ,      ", "disaster_cyclone_desc": "                    ", "disaster_drought_desc": "                 ", "disaster_landslide_desc": "             ", "disaster_fire_desc": "             ", "disaster_flood_prep1": "            ", "disaster_flood_prep2": " ,        ", "disaster_flood_prep3": "          ", "disaster_earthquake_prep1": "   ,     ", "disaster_earthquake_prep2": "        ", "disaster_earthquake_prep3": "          ", "disaster_cyclone_prep1": "            ", "disaster_cyclone_prep2": "             ", "disaster_cyclone_prep3": "       ", "disaster_drought_prep1": "             ", "disaster_drought_prep2": "       ", "disaster_drought_prep3": "          ", "disaster_landslide_prep1": "        ", "disaster_landslide_prep2": "         ", "disaster_landslide_prep3": "            ", "disaster_fire_prep1": "          ", "disaster_fire_prep2": "     -  ", "disaster_fire_prep3": "         ", "disaster_preparedness": "  ", "disaster_preparedness_tip": "  ", "disaster_preparedness_desc": "       ,      ,           ", "regional_disaster_stats": "  ", "common_disasters": " ", "people_affected": " ", "funds_allocated": " ", "view_detailed_statistics": "  ", "disaster_statistics": " ", "disaster_statistics_insight": " ", "disaster_statistics_desc": "         ,           ,     ,                      ", "bar_chart": " ", "line_chart": " ", "pie_chart": " ", "lakh": "", "crore": "", "thousand": "", "localization_demo": " ", "currency_formatting": " ", "number_formatting": " ", "date_formatting": " ", "percentage_formatting": " ", "large_number_formatting": "  ", "current_locale": " ", "formatting": { "date_format": "dd/MM/yyyy", "currency_symbol": "", "decimal_separator": ".", "thousands_separator": "," } };
const navigation$5 = { "menu": "", "close": " ", "accessibility_options": " " };
const accessibility$5 = { "skip_to_main_content": "   ", "increase_font_size": "  ", "decrease_font_size": "  ", "high_contrast": "  ", "reading_assistance": " ", "reading_mode": " ", "reading_mode_desc": "        ", "text_to_speech": "--", "text_to_speech_desc": "     ", "speech_rate": " ", "stop_speaking": "  ", "how_to_use": "  ", "tts_instructions": "                    ", "accessibility_options": " " };
const disasters$5 = { "stateInfo": { "title": "-  ", "selectState": " " }, "floods": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "cyclones": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "earthquakes": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "droughts": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "landslides": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "info": { "frequency": "", "affectedPopulation": " ", "lastIncident": " ", "preparednessLevel": " " }, "preparednessTips": { "title": "  ", "tip1": "       ", "tip1Desc": ", -   , , ,   ,                   ", "tip2": "         ", "tip2Desc": " ,                           ", "tip3": "             ", "tip3Desc": "          ,                     ", "tip4": "         ", "tip4Desc": "        ,                 ", "highPriority": " ", "mediumPriority": " ", "bookmarkedTips": "   " } };
const states$5 = { "maharashtra": "", "odisha": "", "kerala": "" };
const emergencyContacts$5 = { "title": " ", "searchPlaceholder": " ...", "all": "", "favorites": "", "favoriteContacts": " ", "contactsFound": " ", "noContactsFound": "        ", "addToFavorites": "  ", "removeFromFavorites": "  ", "call": " ", "copy": " ", "national": { "title": "  ", "police": "", "policeDesc": "    ", "ambulance": "", "ambulanceDesc": "   ", "fire": " ", "fireDesc": "     ", "disaster": " ", "disasterDesc": "     " }, "maharashtra": { "controlRoom": "  ", "controlRoomDesc": "    ", "emergency": " ", "emergencyDesc": "   " }, "odisha": { "controlRoom": "  ", "controlRoomDesc": "    ", "emergency": " ", "emergencyDesc": "   " }, "kerala": { "controlRoom": "  ", "controlRoomDesc": "    ", "emergency": " ", "emergencyDesc": "   " }, "groups": { "police": "", "medical": "", "fire": "", "disaster": "", "emergency": "" }, "safetyTip": " ", "safetyTipDesc": "                ,      " };
const weatherAlerts$4 = { "title": " ", "loading": "     ...", "refresh": " ", "noAlerts": "   ", "noAlertsDesc": "          ", "floodWarning": " ", "floodWarningDesc": "           ", "cycloneWatch": " ", "cycloneWatchDesc": "        ", "heatwaveWarning": "   ", "heatwaveWarningDesc": "           ", "issued": "  ", "expires": "  ", "region": "", "safetyTip": "  ", "safetyTipDesc": "                       " };
const disasterRisk$4 = { "title": "  ", "selectRegion": " ", "overallRisk": "  ", "low": "", "high": "", "mitigationTips": "    ", "tip1": "        ", "tip2": "        ", "tip3": "         ", "tip4": "          " };
const resourceAllocator$4 = { "title": "  ", "disasterType": " ", "affectedPopulation": " ", "severityLevel": " ", "affectedArea": " ", "emergencySupplies": " ", "personnelRequirements": " ", "evacuationCapacity": "   ", "shelterAllocation": " ", "water": "", "food": "", "medicalKits": " ", "blankets": "", "hygieneKits": " ", "rescueTeams": " ", "medicalTeams": " ", "logisticsTeams": " ", "totalTeams": " ", "totalCapacity": " ", "totalVehicles": " ", "vehicleBreakdown": " ", "shelter1": " ", "shelter2": " ", "shelter3": " ", "totalSheltered": " ", "unshelteredPopulation": " ", "allocationDetails": " ", "remainingCapacity": " ", "liters": "", "meals": "", "note": ":                     ", "severity": { "1": "", "2": "", "3": "", "4": "", "5": "" } };
const impactAssessment$4 = { "title": "  ", "disasterType": " ", "region": "", "severityLevel": " ", "populationDensity": " ", "overallImpact": " ", "economicImpact": " ", "socialImpact": " ", "environmentalImpact": " ", "recommendations": "", "totalEconomicLoss": "  ", "infrastructureLoss": "  ", "agriculturalLoss": " ", "recoveryEstimate": "  ", "affectedFamilies": " ", "childrenAffected": " ", "displacementRate": " ", "casualtyRate": " ", "healthcareImpact": "  ", "educationImpact": " ", "forestLoss": " ", "co2Emissions": "CO2 ", "biodiversityLoss": "  ", "species": "", "recoveryTime": "  ", "months": "", "priorityLevel": " ", "selectDisasterAndRegion": "          ", "impactLevels": { "catastrophic": "", "severe": "", "moderate": "", "minor": "", "low": "" }, "priority": { "immediate": "", "high": "", "medium": "", "low": "" }, "severity": { "low": "", "high": "" }, "predictiveModelOn": " : ", "predictiveModelOff": " : ", "predictiveModelDescription": "                " };
const responsePlanner$4 = { "title": "  ", "disasterType": " ", "severityLevel": " ", "region": "", "selectDisasterAndRegion": "           ", "disasterInfo": "{{region}}   {{disaster}}  ", "affectedArea": " ", "affectedPopulation": " ", "immediateActions": " ", "resourceAllocation": " ", "teams": "", "equipmentAndSupplies": "  ", "timeline": " ", "coordination": " ", "specialConsiderations": " ", "phases": { "immediate": " ", "shortTerm": " ", "mediumTerm": " ", "longTerm": " " }, "severity": { "minor": "", "moderate": "", "significant": "", "severe": "", "catastrophic": "" }, "export": " ", "exportJSON": "JSON     ", "exportCSV": "CSV     ", "savePlan": " ", "comparePlans": "   ", "customScenario": " ", "useStandard": "   ", "resourceDistribution": " ", "teamAllocation": " ", "quantity": "", "numberOfTeams": "  ", "planComparison": " ", "currentPlan": " ", "savedPlan": "  ", "totalResources": " ", "noSavedPlans": "         " };
const recoveryPlanner$2 = { "title": "  ", "description": "                  ", "disasterType": "  ", "selectDisaster": "   ", "region": "", "selectRegion": " ", "affectedPopulation": " ", "populationPlaceholder": "   ", "severity": " ", "generatePlan": "   ", "progressOverview": "  ", "overallProgress": "  ", "status": "", "completedTasks": "", "fillAllFields": "         ", "tabs": { "timeline": "", "resources": "", "stakeholders": "", "actionPlan": " " }, "timeline": { "title": " ", "phases": { "immediate": " ", "shortTerm": " ", "mediumTerm": " ", "longTerm": " " } }, "resources": { "title": " ", "personnel": "", "supplies": "", "financial": " ", "roles": { "emergencyResponders": "   ", "medicalStaff": " ", "engineers": "", "logistics": " " }, "items": { "water": "", "food": "", "medical": " ", "shelter": " " } }, "stakeholders": { "title": " " }, "actionPlan": { "title": "  " }, "priority": { "high": " ", "medium": " ", "low": " " } };
const disasterTypes$2 = { "flood": "", "earthquake": "", "cyclone": "", "drought": "", "landslide": "" };
const communityReporting$5 = { "title": "  ", "description": "                  ", "disasterType": " ", "selectDisasterType": "  ", "location": "", "locationPlaceholder": "   (, ,  )", "useCurrentLocation": "    ", "detecting": "   ...", "detectingLocation": "     ...", "locationError": "          ", "locationPermissionDenied": "           ", "locationUnavailable": "          ", "locationTimeout": "          ", "locationNotSupported": "   -   ", "descriptionPlaceholder": "    ,      ,  ,    ...", "descriptionHelp": "          ", "severity": " ", "severityHelp": "      (1 = , 5 = )", "low": "", "high": "", "affectedPeople": " ", "affectedPeopleHelp": "     ()", "media": "/", "uploadMedia": "        ", "mediaLimit": "5      (  10MB)", "maxMediaFiles": "   5     ", "submitReport": "   ", "submitting": "   ...", "successMessage": "        !          ", "submissionError": "          ", "disasterTypes": { "flood": "", "earthquake": "", "cyclone": "", "drought": "", "landslide": "", "fire": "", "epidemic": "", "chemical": " ", "other": "" }, "validation": { "disasterTypeRequired": "   ", "locationRequired": "  ", "descriptionRequired": "  ", "descriptionTooShort": "    10    ", "invalidLatitude": "   (-90  90    )", "invalidLongitude": "   (-180  180    )", "invalidAffectedPeople": "       " } };
const volunteerCoordinator$4 = { "title": " ", "description": "            ", "tabs": { "matching": " ", "assignments": " ", "communication": " ", "tracking": " ", "scheduling": " " }, "disasterType": " ", "latitude": "", "longitude": "", "search": "  ...", "sort": { "suitability": "    ", "distance": "    ", "experience": "    " }, "experience": "", "years": "", "reassign": "    ", "regenerate": "    ", "refresh": "  ", "reschedule": "    ", "volunteer": "", "skills": "", "distance": "", "suitability": "", "priority": "", "requiredSkills": " ", "requiredVolunteers": " ", "assignedTo": "   ", "assignedAt": "   ", "tasks": "", "frequency": "", "contactList": " ", "totalVolunteers": " ", "totalHours": " ", "topContributors": " ", "recognitionAwards": " ", "recognitionDistribution": " ", "bronze": "", "silver": "", "gold": "", "platinum": "", "recognitionLevel": " ", "hours": "", "shift": "", "time": "", "duration": "", "totalShifts": " ", "filledShifts": "  ", "coverage": "", "volunteerUtilization": " ", "utilization": "", "performance": { "title": " ", "utilization": "  ", "avgSuitability": "  ", "shiftCoverage": " ", "assigned": "   " }, "engagement": { "title": " ", "active": " ", "inactive": " ", "averageScore": "  ", "high": " ", "medium": " ", "low": " ", "distribution": " " }, "skillUtilization": "  ", "skillUtilizationTitle": "  ", "skillAvailability": "", "avgHoursPerVolunteer": "   " };
const disaster_stats$1 = { "title": "-  ", "select_state": " ", "state": "", "floods": "", "cyclones": "", "earthquakes": "", "droughts": "", "total": "", "disclaimer": " ", "disclaimer_text": "             ,                " };
const disasterStatistics$4 = { "title": " ", "description": "    ,      ", "export": "", "exportData": "    ", "resetFilters": "  ", "startDate": "   ", "endDate": " ", "region": "", "allRegions": " ", "events": "", "affected": "", "economicLoss": " ", "tabs": { "overview": "", "trends": "", "regional": " ", "comparison": " " }, "overview": { "title": " ", "totalEvents": " ", "totalAffected": " ", "totalEconomicLoss": "  ", "averageAffected": "   ", "byType": "  ", "byRegion": " " }, "byType": " ", "byRegion": " ", "trends": { "title": " ", "yearsCovered": " ", "annualGrowth": " ", "mostIncreasing": "   ", "yearlyBreakdown": " ", "year": "" }, "regional": { "title": "  ", "region": "", "riskIndex": " " }, "comparison": { "title": "  ", "firstType": "  ", "secondType": "  ", "compare": " ", "averageAffected": " ", "averageEconomicLoss": "  " } };
const weather$4 = { "title": " ", "loading": "   ...", "refresh": " ", "data_not_available": "    ", "fetch_error": "     ", "conditions": { "sunny": "", "cloudy": "", "rainy": "", "stormy": "" }, "temperature": "", "humidity": "", "wind_speed": "  ", "pressure": "", "visibility": "", "risk_assessment": " ", "risk_level": " ", "alerts": "", "preparedness_recommendations": "  ", "forecast": " ", "high": "", "low": "", "show_trends": " ", "hide_trends": " ", "trend_analysis": " ", "temperature_trend": " ", "condition_distribution": "  ", "days": "", "trend": { "increasing": "{{value}}    ", "decreasing": "{{value}}    ", "stable": "" }, "time_range": { "week": " ", "month": " ", "year": " " } };
const emergencyResourceTracker$4 = { "title": "  ", "totalResources": " ", "availableResources": " ", "responseRate": " ", "region": "", "allRegions": " ", "resource": "", "quantity": "", "location": "", "availability": "", "requestResources": "   ", "resourceType": " ", "selectType": "  ", "urgency": "", "normal": "", "high": "", "critical": "", "enterLocation": "  ", "contact": "", "enterContact": "   ", "submitRequest": "  ", "requestStatus": " ", "requestId": " ", "status": "", "submitted": "  ", "estimatedDelivery": " ", "refreshStatus": "  ", "historicalUsage": "  ", "month": "", "addResource": "  ", "hideForm": " ", "resourceName": "  ", "unit": "", "enterUnit": "   (., , )", "selectRegion": " ", "cancel": " " };
const disasterCommunicationHub$4 = { "title": "  ", "selectRegion": " ", "allRegions": " ", "selectDisaster": "  ", "communicationChannels": " ", "channelName": "  ", "type": "", "frequency": "", "coverage": "", "status": "", "contact": "", "broadcastInfo": "  ", "tvChannels": " ", "radioStations": " ", "transmission": "", "smsAlerts": " ", "service": "", "shortcode": "", "provider": "", "equipment": " ", "availability": "", "protocols": "{{disaster}}    ", "immediateResponse": " ", "shortTermResponse": " ", "longTermResponse": " ", "emergencyContacts": " " };
const disasterPrediction = { "title": "    ", "description": "               ", "selectRegion": " ", "currentRiskLevel": "  ", "currentWeather": " ", "tabs": { "predictions": " ", "historical": " ", "factors": " " }, "risk": { "critical": "", "high": "", "moderate": "", "low": "" }, "predictions": { "title": "  " }, "probability": "", "expectedImpact": " ", "timeline": " ", "recommendations": "", "historical": { "title": "  ", "year": "", "disasterType": " ", "affected": " ", "economicLoss": " " }, "factors": { "title": "  ", "weather": "  ", "geographical": " ", "temperature": "", "humidity": "", "precipitation": "", "windSpeed": "  ", "elevation": "", "forestCover": " ", "riverProximity": "  ", "seismicActivity": " " }, "alerts": { "title": "  ", "highRisk": "{{disaster}}      ({{score}}% )", "moderateRisk": "{{disaster}}      ({{score}}% )", "heavyRain": "    ({{amount}}mm)", "highWinds": "       ({{speed}} /)", "extremeHeat": "    ({{temperature}}C)", "extremeCold": "    ({{temperature}}C)", "highHumidity": "   ({{humidity}}%)", "lowPressure": "   ({{pressure}} )" }, "priority": { "high": "", "medium": "", "low": "" }, "autoRefreshOn": " : ", "autoRefreshOff": " : ", "clearDismissed": "     " };
const map = { "title": "  ", "allTime": " ", "lastMonth": " ", "lastQuarter": " ", "lastYear": " ", "riskZones": " ", "campaigns": "", "active": "", "completed": "", "campaign": "", "fundsRaised": " ", "goal": "", "source": "", "createdAt": " ", "endDate": " ", "disasterZone": " ", "riskLevel": " ", "disasterType": " ", "lastUpdated": " ", "riskLevels": { "high": "", "moderate": "", "low": "" } };
const recoveryTracker = { "pageTitle": "  ", "pageDescription": "            ", "aboutTitle": "     ", "aboutDescription": "              ,                    ", "benefit1": "     ", "benefit2": "     ", "benefit3": "  ", "benefit4": "   ", "title": "  ", "selectRegion": " ", "disasterType": " ", "startDate": "   ", "endDate": "  ", "overallProgress": " ", "progressTrend": "  ", "progress": "", "milestones": { "title": "   ", "housing": " ", "infrastructure": "  ", "healthcare": " ", "education": " ", "livelihood": " ", "environment": " " }, "targetDate": " ", "actualDate": "  ", "status": { "completed": "", "in-progress": "  ", "not-started": "  " }, "resourceAllocation": " ", "resourceBreakdown": " ", "resources": { "housing": "", "infrastructure": " ", "healthcare": " ", "education": "", "livelihood": "", "admin": "" }, "allocated": "", "spent": "  ", "percentage": "", "challenges": { "title": " ", "resolved": "  ", "funding": "  ", "logistics": " ", "coordination": " ", "community": " " }, "severity": { "high": "", "medium": "", "low": "" }, "noData": "         " };
const ivrSimulator = { "title": "  ", "ready": "     ", "inProgress": "   ", "noActiveCall": "            ", "startCall": "  ", "endCall": "  ", "dialpad": "", "instructions": "           ", "howItWorks": "    ", "description": " (  )                       ", "feature1": "24/7    ", "feature2": "    - ", "feature3": "      ", "feature4": "     ", "showFlow": "  ", "hideFlow": "  ", "callFlow": "  ", "testMode": " ", "exitTestMode": "  ", "testScenarios": " ", "runTest": " " };
const resourceDeployment = { "pageTitle": "  ", "pageDescription": "            ", "aboutTitle": "     ", "aboutDescription": "                            ", "benefit1Title": "  ", "benefit1": "              ", "benefit2Title": " ", "benefit2": "           ", "benefit3Title": " ", "benefit3": "          ", "benefit4Title": "", "benefit4": "           ", "title": "  ", "region": "", "allRegions": " ", "resource": "", "allResources": " ", "timeRange": " ", "timeRangeOptions": { "week": " ", "month": " ", "quarter": " " }, "resetFilters": "  ", "totalDeployments": " ", "deployed": "", "inTransit": " ", "requested": "", "statusDistribution": " ", "deploymentTimeline": " ", "quantity": "", "status": { "deployed": "", "inTransit": " ", "requested": "" }, "team": "", "deployedAt": " ", "expectedReturn": " " };
const volunteerRecognition = { "pageTitle": "  ", "pageDescription": "               ", "aboutTitle": "    ", "aboutDescription": "     ,                         ", "benefit1Title": " ", "benefit1": "                ", "benefit2Title": " ", "benefit2": "          ", "benefit3Title": " ", "benefit3": "          ", "benefit4Title": " ", "benefit4": " -           ", "title": "  ", "period": " ", "region": "", "allRegions": " ", "resetFilters": "  ", "totalVolunteers": " ", "totalHours": " ", "avgHoursPerVolunteer": "   ", "platinumAwards": " ", "recognitionDistribution": " ", "volunteerHours": " ", "hours": "", "volunteer": "", "contributions": "", "recognitionLevel": " ", "badges": "", "levels": { "platinum": "", "gold": "", "silver": "", "bronze": "" }, "periods": { "week": " ", "month": " ", "quarter": " ", "year": " " }, "certificateTitle": " ", "certificateDescription": "          ", "generateCertificates": "  " };
const feedback = { "page_title": "  ", "page_description": "             ,     ", "importance_title": "    ", "importance_description": "                                  ", "benefit1": "         ", "benefit2": "        ", "benefit3": "           ", "benefit4": "        ", "title": " ", "submit_feedback": "  ", "view_feedback": " ", "analytics": "", "name": " ", "email": " ", "category": " ", "location": "", "rating": "", "comment": " ", "submit": "  ", "submitting": "    ...", "submission_success": "    !       ", "feedback_list": " ", "all_categories": " ", "all_ratings": " ", "no_feedback_found": "       ", "submitted_on": "   ", "feedback_analytics": " ", "total_feedback": " ", "resolved": "  ", "in_progress": "  ", "average_rating": " ", "category_distribution": "   ", "rating_distribution": "   ", "status_distribution": "   ", "feedback_count": " ", "stars": "", "categories": { "general": " ", "disaster_response": " ", "platform_usability": " ", "resource_allocation": " ", "communication": "", "volunteer_coordination": " " }, "status": { "resolved": "  ", "pending": "", "in_progress": "  " } };
const hiTranslation = {
  common: common$5,
  home: home$5,
  navigation: navigation$5,
  accessibility: accessibility$5,
  disasters: disasters$5,
  states: states$5,
  emergencyContacts: emergencyContacts$5,
  weatherAlerts: weatherAlerts$4,
  disasterRisk: disasterRisk$4,
  resourceAllocator: resourceAllocator$4,
  impactAssessment: impactAssessment$4,
  responsePlanner: responsePlanner$4,
  recoveryPlanner: recoveryPlanner$2,
  disasterTypes: disasterTypes$2,
  communityReporting: communityReporting$5,
  volunteerCoordinator: volunteerCoordinator$4,
  disaster_stats: disaster_stats$1,
  disasterStatistics: disasterStatistics$4,
  weather: weather$4,
  emergencyResourceTracker: emergencyResourceTracker$4,
  disasterCommunicationHub: disasterCommunicationHub$4,
  disasterPrediction,
  map,
  recoveryTracker,
  ivrSimulator,
  resourceDeployment,
  volunteerRecognition,
  feedback
};
const common$4 = { "app_name": "", "home": "", "campaigns": "", "donate": " ", "ngo_dashboard": " ", "admin": "", "demo": "", "auth_test": " ", "dark_mode": " ", "light_mode": " ", "language": "", "english": "English", "hindi": "", "tamil": "", "telugu": "", "marathi": "", "bengali": "", "gujarati": "", "search": "", "all_states": " ", "statistics": "" };
const home$4 = { "title": "      ", "hero_title_1": "  ", "hero_description_1": "    ", "hero_title_2": "  ", "hero_description_2": "      ", "hero_title_3": "  ", "hero_description_3": "       ", "stats_funds": "2.5 ", "stats_funds_label": " ", "stats_beneficiaries": "15,000+", "stats_beneficiaries_label": "", "stats_campaigns": "42", "stats_campaigns_label": "  ", "stats_transparency": "98%", "stats_transparency_label": " ", "why_impactx": " ?", "why_impactx_desc": "  ,            ", "feature_transparency": " ", "feature_transparency_desc": "       .", "feature_verification": "- ", "feature_verification_desc": "  (, , )       .", "feature_storage": " ", "feature_storage_desc": "       .", "feature_india": "- ", "feature_india_desc": "        .", "disaster_relief": "   ", "disaster_relief_desc": "         ", "partners": "   ", "partners_desc": "      ", "how_it_works": "  ", "how_it_works_desc": "        4- ", "step_create": " ", "step_create_desc": "      ", "step_donate": " ", "step_donate_desc": "      ", "step_verify": "", "step_verify_desc": "       ", "step_release": "", "step_release_desc": "     ", "cta_title": "  ?", "cta_desc": "             ", "cta_button_donate": "  ", "cta_button_explore": " ", "funds_raised": " ", "go_to_slide": " ", "active_campaigns": "  ", "completed_campaigns": " ", "common_disasters_india": "  ", "disaster_types_desc": "      ", "disaster_flood": "", "disaster_earthquake": "", "disaster_cyclone": "", "disaster_drought": "", "disaster_landslide": "", "disaster_fire": "", "quick_links": " ", "resources": "", "documentation": "", "api_reference": " ", "github": "", "community": "", "contact_us": "  ", "made_with_love": "   ", "india_disaster_info": "  ", "disaster_affected_regions": " ", "disaster_frequency": "", "disaster_impact": "", "disaster_high": "", "disaster_medium": "", "disaster_low": "", "disaster_severe": "", "disaster_moderate": "", "disaster_flood_desc": "        ,    .", "disaster_earthquake_desc": "      ,   .", "disaster_cyclone_desc": "      ,       .", "disaster_drought_desc": "          .", "disaster_landslide_desc": "       .", "disaster_fire_desc": "       .", "disaster_flood_prep1": "      ", "disaster_flood_prep2": ",        ", "disaster_flood_prep3": "       ", "disaster_earthquake_prep1": "   ,  ,   ", "disaster_earthquake_prep2": "  furniture     ", "disaster_earthquake_prep3": "       ", "disaster_cyclone_prep1": "       ", "disaster_cyclone_prep2": "        ", "disaster_cyclone_prep3": "     ", "disaster_drought_prep1": "       ", "disaster_drought_prep2": "     ", "disaster_drought_prep3": "      ", "disaster_landslide_prep1": "      ", "disaster_landslide_prep2": "      ", "disaster_landslide_prep3": "        ", "disaster_fire_prep1": "       ", "disaster_fire_prep2": "      ", "disaster_fire_prep3": "        ", "disaster_preparedness": " ", "disaster_preparedness_tip": "  ", "disaster_preparedness_desc": "     ,     ,        .", "regional_disaster_stats": "  ", "common_disasters": " ", "people_affected": " ", "funds_allocated": " ", "view_detailed_statistics": "  ", "disaster_statistics": " ", "disaster_statistics_insight": " ", "disaster_statistics_desc": "       ,    .   ,   ,   .            .", "bar_chart": " ", "line_chart": " ", "pie_chart": " ", "lakh": "", "crore": "", "thousand": "", "localization_demo": " ", "currency_formatting": " ", "number_formatting": " ", "date_formatting": " ", "percentage_formatting": " ", "large_number_formatting": "  ", "current_locale": " ", "formatting": { "date_format": "dd/MM/yyyy", "currency_symbol": "", "decimal_separator": ".", "thousands_separator": "," } };
const navigation$4 = { "menu": "", "close": "", "accessibility_options": " " };
const accessibility$4 = { "skip_to_main_content": "  ", "increase_font_size": "  ", "decrease_font_size": "  ", "high_contrast": "  ", "reading_assistance": " ", "reading_mode": " ", "reading_mode_desc": "    ", "text_to_speech": "--", "text_to_speech_desc": "   ", "speech_rate": " ", "stop_speaking": " ", "how_to_use": " ", "tts_instructions": "       .     .", "accessibility_options": " " };
const disasters$4 = { "stateInfo": { "title": "-  ", "selectState": " " }, "floods": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "cyclones": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "earthquakes": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "droughts": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "landslides": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "info": { "frequency": "", "affectedPopulation": "  ", "lastIncident": " ", "preparednessLevel": " " }, "preparednessTips": { "title": "  ", "tip1": "     ", "tip1Desc": ",  , , ,   ,       .     .", "tip2": "     ", "tip2Desc": " ,      .       .     .", "tip3": "         ", "tip3Desc": "  ,           .         .", "tip4": "      ", "tip4Desc": "      ,      .       .", "highPriority": " ", "mediumPriority": " ", "bookmarkedTips": " " } };
const states$4 = { "maharashtra": "", "odisha": "", "kerala": "" };
const emergencyContacts$4 = { "title": " ", "selectState": " ", "chooseState": "  ", "search": " ", "searchPlaceholder": "    ...", "contactsFor": "  ", "call": "", "copy": "", "noContactsFound": "     .", "selectStateMessage": "     .", "quickAccess": "  ", "police": "", "fire": "", "ambulance": "", "disaster": " ", "calling": "", "numberCopied": "   !" };
const weatherAlerts$3 = { "title": " ", "loading": "  ...", "refresh": "", "noAlerts": "   ", "noAlertsDesc": "      .", "floodWarning": " ", "floodWarningDesc": "   .   .", "cycloneWatch": " ", "cycloneWatchDesc": "     .", "heatwaveWarning": "  ", "heatwaveWarningDesc": " extreme   .      .", "issued": "", "expires": "", "region": "", "safetyTip": "  ", "safetyTipDesc": "     .           ." };
const disasterRisk$3 = { "title": "  ", "selectRegion": " ", "overallRisk": "  ", "low": "", "high": "", "mitigationTips": "  ", "tip1": "     ", "tip2": "     ", "tip3": "      ", "tip4": "     " };
const resourceAllocator$3 = { "title": "  ", "disasterType": " ", "affectedPopulation": "  ", "severityLevel": " ", "affectedArea": " ", "emergencySupplies": " ", "personnelRequirements": " ", "evacuationCapacity": "  ", "shelterAllocation": "  ", "water": "", "food": "", "medicalKits": " ", "blankets": "", "hygieneKits": " ", "rescueTeams": " ", "medicalTeams": " ", "logisticsTeams": " ", "totalTeams": " ", "totalCapacity": " ", "totalVehicles": " ", "vehicleBreakdown": " ", "shelter1": " ", "shelter2": " ", "shelter3": " ", "totalSheltered": " ", "unshelteredPopulation": "  ", "allocationDetails": " ", "remainingCapacity": " ", "liters": "", "meals": "", "note": ":               .", "severity": { "1": "", "2": "", "3": "", "4": "", "5": "" } };
const impactAssessment$3 = { "title": "  ", "disasterType": " ", "region": "", "overallImpact": " ", "economicImpact": " ", "socialImpact": " ", "environmentalImpact": " ", "recommendations": "", "totalEconomicLoss": "  ", "infrastructureLoss": " ", "agriculturalLoss": " ", "recoveryEstimate": "  ", "affectedFamilies": " ", "childrenAffected": " ", "displacementRate": " ", "casualtyRate": " ", "healthcareImpact": " ", "educationImpact": " ", "forestLoss": " ", "co2Emissions": "CO2 ", "biodiversityLoss": "  ", "species": "", "recoveryTime": "  ", "months": "", "priorityLevel": " ", "selectDisasterAndRegion": "        ", "impactLevels": { "catastrophic": "", "severe": "", "moderate": "", "minor": "", "low": "" }, "priority": { "immediate": "", "high": "", "medium": "", "low": "" } };
const responsePlanner$3 = { "title": "  ", "disasterType": " ", "severityLevel": " ", "region": "", "disasterInfo": "{{region}}  {{disaster}}  ", "immediateActions": " ", "resourceAllocation": " ", "teams": "", "equipmentAndSupplies": "  ", "timeline": " ", "coordination": " ", "specialConsiderations": " ", "selectDisasterAndRegion": "      ,     ", "phases": { "immediate": "  (0-2 )", "shortTerm": "   (2-24 )", "mediumTerm": "   (1-30 )", "longTerm": "   (1-36 )" }, "severity": { "minor": "", "moderate": "", "significant": "", "severe": "", "catastrophic": "" } };
const recoveryPlanner$1 = { "title": "  ", "description": "      ,      .", "disasterType": " ", "selectDisaster": "  ", "region": "", "selectRegion": " ", "affectedPopulation": "  ", "populationPlaceholder": "  ", "severity": " ", "generatePlan": "  ", "progressOverview": "  ", "overallProgress": "  ", "status": "", "completedTasks": "", "fillAllFields": "     .", "tabs": { "timeline": "", "resources": "", "stakeholders": "", "actionPlan": " " }, "timeline": { "title": " ", "phases": { "immediate": " ", "shortTerm": "  ", "mediumTerm": "  ", "longTerm": "  " } }, "resources": { "title": " ", "personnel": "", "supplies": "", "financial": " ", "roles": { "emergencyResponders": " ", "medicalStaff": " ", "engineers": "", "logistics": "  " }, "items": { "water": "", "food": "", "medical": " ", "shelter": " " } }, "stakeholders": { "title": " " }, "actionPlan": { "title": "  " }, "priority": { "high": " ", "medium": " ", "low": " " } };
const disaster_stats = { "title": "-  ", "select_state": " ", "state": "", "floods": "", "cyclones": "", "earthquakes": "", "droughts": "", "total": "", "disclaimer": " ", "disclaimer_text": "       .  ,         ." };
const disasterTypes$1 = { "flood": "", "earthquake": "", "cyclone": "", "drought": "", "landslide": "" };
const communityReporting$4 = { "title": "  ", "description": "             .", "disasterType": " ", "selectDisasterType": "  ", "disasterTypes": { "flood": "", "earthquake": "", "cyclone": "", "drought": "", "landslide": "", "fire": "", "epidemic": "", "chemical": " ", "other": "" } };
const taTranslation = {
  common: common$4,
  home: home$4,
  navigation: navigation$4,
  accessibility: accessibility$4,
  disasters: disasters$4,
  states: states$4,
  emergencyContacts: emergencyContacts$4,
  weatherAlerts: weatherAlerts$3,
  disasterRisk: disasterRisk$3,
  resourceAllocator: resourceAllocator$3,
  impactAssessment: impactAssessment$3,
  responsePlanner: responsePlanner$3,
  recoveryPlanner: recoveryPlanner$1,
  disaster_stats,
  disasterTypes: disasterTypes$1,
  communityReporting: communityReporting$4
};
const common$3 = { "app_name": " ", "home": "", "campaigns": "", "donate": " ", "ngo_dashboard": "NGO ", "admin": "", "demo": "", "auth_test": " ", "dark_mode": " ", "light_mode": " ", "language": "", "english": "English", "hindi": "", "tamil": "", "telugu": "", "marathi": "", "bengali": "", "gujarati": "" };
const home$3 = { "title": "       ", "hero_title_1": "  ", "hero_description_1": "      ", "hero_title_2": "   ", "hero_description_2": "       ", "hero_title_3": "   ", "hero_description_3": "       ", "stats_funds": "2.5 ", "stats_funds_label": "  ", "stats_beneficiaries": "15,000+", "stats_beneficiaries_label": "", "stats_campaigns": "42", "stats_campaigns_label": " ", "stats_transparency": "98%", "stats_transparency_label": " ", "why_impactx": "  ?", "why_impactx_desc": "  ,           ", "feature_transparency": "  ", "feature_transparency_desc": "             .", "feature_verification": "-  ", "feature_verification_desc": "   (, , IoT)           .", "feature_storage": "IPFS ", "feature_storage_desc": "        IPFS  .", "feature_india": "- ", "feature_india_desc": "         .", "disaster_relief": "   ", "disaster_relief_desc": "        ", "partners": "  NGO ", "partners_desc": "      ", "how_it_works": "   ", "how_it_works_desc": " 4-       ", "step_create": " ", "step_create_desc": "NGOs      ", "step_donate": " ", "step_donate_desc": "      ", "step_verify": "", "step_verify_desc": "         ", "step_release": " ", "step_release_desc": "  NGO   ", "cta_title": "   ?", "cta_desc": "              ", "cta_button_donate": " ", "cta_button_explore": " ", "funds_raised": " ", "go_to_slide": "  ", "active_campaigns": " ", "completed_campaigns": " ", "common_disasters_india": "  ", "disaster_types_desc": "        ", "disaster_flood": "", "disaster_earthquake": "", "disaster_cyclone": "", "disaster_drought": "", "disaster_landslide": "", "disaster_fire": " ", "quick_links": " ", "resources": "", "documentation": "", "api_reference": "API ", "github": " ", "community": "", "contact_us": " ", "made_with_love": "   ", "india_disaster_info": "  ", "disaster_affected_regions": " ", "disaster_frequency": "", "disaster_impact": "", "disaster_high": "", "disaster_medium": "", "disaster_low": "", "disaster_severe": "", "disaster_moderate": "", "disaster_flood_desc": "        ,     .", "disaster_earthquake_desc": "       ,   .", "disaster_cyclone_desc": "             .", "disaster_drought_desc": "             .", "disaster_landslide_desc": "         .", "disaster_fire_desc": "           .", "disaster_flood_prep1": "       ", "disaster_flood_prep2": ",        ", "disaster_flood_prep3": "         ", "disaster_earthquake_prep1": "  ,     ", "disaster_earthquake_prep2": "      ", "disaster_earthquake_prep3": "      ", "disaster_cyclone_prep1": "         ", "disaster_cyclone_prep2": "        ", "disaster_cyclone_prep3": "   -  ", "disaster_drought_prep1": "        ", "disaster_drought_prep2": "     ", "disaster_drought_prep3": "       ", "disaster_landslide_prep1": "         ", "disaster_landslide_prep2": "      ", "disaster_landslide_prep3": "          ", "disaster_fire_prep1": "        ", "disaster_fire_prep2": "   -  ", "disaster_fire_prep3": "       ", "disaster_preparedness": " ", "disaster_preparedness_tip": "  ", "disaster_preparedness_desc": "     ,              .", "regional_disaster_stats": "  ", "common_disasters": " ", "people_affected": " ", "funds_allocated": " ", "view_detailed_statistics": "  ", "disaster_statistics": " ", "disaster_statistics_insight": " ", "disaster_statistics_desc": "        ,     .   ,    ,    .            .", "bar_chart": " ", "line_chart": " ", "pie_chart": " ", "lakh": "", "crore": "", "thousand": "", "localization_demo": " ", "currency_formatting": " ", "number_formatting": " ", "date_formatting": " ", "percentage_formatting": " ", "large_number_formatting": "  ", "current_locale": " ", "formatting": { "date_format": "dd/MM/yyyy", "currency_symbol": "", "decimal_separator": ".", "thousands_separator": "," } };
const navigation$3 = { "menu": "", "close": "", "accessibility_options": " " };
const accessibility$3 = { "skip_to_main_content": "   ", "increase_font_size": "  ", "decrease_font_size": "  ", "high_contrast": "  ", "reading_assistance": " ", "reading_mode": " ", "reading_mode_desc": "       ", "text_to_speech": "--", "text_to_speech_desc": "   ", "speech_rate": " ", "stop_speaking": " ", "how_to_use": " ", "tts_instructions": "      .       .", "accessibility_options": " " };
const disasters$3 = { "stateInfo": { "title": "-  ", "selectState": " " }, "floods": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "cyclones": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "earthquakes": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "droughts": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "landslides": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "info": { "frequency": "", "affectedPopulation": " ", "lastIncident": " ", "preparednessLevel": " " }, "preparednessTips": { "title": "  ", "tip1": "     ", "tip1Desc": ",  , , ,   ,        .       .", "tip2": "      ", "tip2Desc": " ,      .        .      .", "tip3": "        ", "tip3Desc": "  ,           .         .", "tip4": "     ", "tip4Desc": "         ,     .      .", "highPriority": " ", "mediumPriority": " ", "bookmarkedTips": "  " } };
const states$3 = { "maharashtra": "", "odisha": "", "kerala": "" };
const emergencyContacts$3 = { "title": " ", "selectState": " ", "chooseState": "  ", "search": " ", "searchPlaceholder": "    ...", "contactsFor": "  ", "call": " ", "copy": " ", "noContactsFound": "     .", "selectStateMessage": "      .", "quickAccess": "  ", "police": "", "fire": "", "ambulance": "", "disaster": " ", "calling": " ", "numberCopied": "    !" };
const communityReporting$3 = { "title": "  ", "description": "", "disasterType": " ", "selectDisasterType": "  ", "disasterTypes": { "flood": "", "earthquake": "", "cyclone": "", "drought": "", "landslide": "", "fire": "", "epidemic": "", "chemical": " ", "other": "" }, "location": "", "locationPlaceholder": "     ", "useCurrentLocation": "  ", "latitude": "", "longitude": "", "descriptionPlaceholder": ",       ...", "severity": " ", "low": "", "high": "", "affectedPeople": "  ()", "media": " (/)", "uploadMedia": "      ", "mediaLimit": " 5 .    .", "submitReport": "  ", "submitting": "...", "successMessage": "    !    .", "submissionError": "  .   .", "locationError": "    .     .", "locationNotSupported": "     .", "maxMediaFiles": " 5     ." };
const volunteerCoordinator$3 = { "title": " ", "description": "         ", "disasterType": " ", "latitude": "", "longitude": "", "tabs": { "matching": "  ", "assignments": " ", "communication": " ", "tracking": " ", "scheduling": " " }, "matching": { "title": "   " }, "volunteer": " ", "skills": "", "distance": "", "suitability": "", "tasks": "", "assignments": "", "assignedTo": " ", "assignedAt": " ", "requiredSkills": " ", "requiredVolunteers": "  ", "priority": "", "communication": { "title": " ", "channels": " " }, "channels": "", "frequency": "", "contactList": " ", "tracking": { "title": "   " }, "totalVolunteers": "  ", "totalHours": " ", "topContributors": " ", "recognitionAwards": " ", "recognitionDistribution": " ", "bronze": "", "silver": "", "gold": "", "platinum": "", "recognitionLevel": " ", "hours": "", "scheduling": { "title": "   " }, "shift": "", "time": "", "duration": "", "totalShifts": " ", "filledShifts": " ", "coverage": "", "volunteerUtilization": "  ", "utilization": "" };
const disasterStatistics$3 = { "title": " ", "description": "       ", "tabs": { "overview": "", "trends": "", "regional": " ", "comparison": " " }, "overview": { "title": "  ", "totalEvents": " ", "totalAffected": " ", "totalEconomicLoss": "  ", "averageAffected": "  " }, "byType": "  ", "byRegion": " ", "events": "", "affected": " ", "economicLoss": " ", "trends": { "title": "  ", "yearsCovered": "  ", "annualGrowth": "  ", "mostIncreasing": "  ", "yearlyBreakdown": " ", "year": "" }, "regional": { "title": "  ", "region": "", "riskIndex": " " }, "comparison": { "title": "  ", "firstType": "  ", "secondType": "  ", "compare": "", "averageAffected": " ", "averageEconomicLoss": "  " } };
const weather$3 = { "title": " ", "conditions": " ", "humidity": "", "wind_speed": " ", "pressure": "", "visibility": "", "risk_assessment": " ", "risk_level": " ", "alerts": "", "preparedness_recommendations": " ", "forecast": " ", "high": "", "low": "", "refresh": " ", "loading": "...", "data_not_available": "   ", "fetch_error": "   " };
const emergencyResourceTracker$3 = { "title": "  ", "totalResources": " ", "availableResources": "  ", "responseRate": " ", "region": "", "allRegions": " ", "resource": "", "quantity": "", "location": "", "availability": "", "requestResources": " ", "resourceType": " ", "selectType": "  ", "urgency": "", "normal": "", "high": "", "critical": "", "enterLocation": "  ", "contact": "", "enterContact": "   ", "submitRequest": " ", "requestStatus": " ", "requestId": " ", "status": "", "submitted": "", "estimatedDelivery": " ", "refreshStatus": "  " };
const disasterCommunicationHub$3 = { "title": "Disaster Communication Hub", "selectRegion": "Select Region", "allRegions": "All Regions", "selectDisaster": "Select Disaster Type", "communicationChannels": "Communication Channels", "channelName": "Channel Name", "type": "Type", "frequency": "Frequency", "coverage": "Coverage", "status": "Status", "contact": "Contact", "broadcastInfo": "Emergency Broadcast Information", "tvChannels": "TV Channels", "radioStations": "Radio Stations", "transmission": "Transmission", "smsAlerts": "SMS Alerts", "service": "Service", "shortcode": "Shortcode", "provider": "Provider", "equipment": "Communication Equipment", "availability": "Availability", "protocols": "Communication Protocols for {{disaster}}", "immediateResponse": "Immediate Response", "shortTermResponse": "Short-term Response", "longTermResponse": "Long-term Response", "emergencyContacts": "Emergency Contacts" };
const teTranslation = {
  common: common$3,
  home: home$3,
  navigation: navigation$3,
  accessibility: accessibility$3,
  disasters: disasters$3,
  states: states$3,
  emergencyContacts: emergencyContacts$3,
  communityReporting: communityReporting$3,
  volunteerCoordinator: volunteerCoordinator$3,
  disasterStatistics: disasterStatistics$3,
  weather: weather$3,
  emergencyResourceTracker: emergencyResourceTracker$3,
  disasterCommunicationHub: disasterCommunicationHub$3
};
const common$2 = { "app_name": "", "home": "", "campaigns": "", "donate": " ", "ngo_dashboard": "NGO ", "admin": "", "demo": "", "auth_test": " ", "dark_mode": " ", "light_mode": " ", "language": "", "english": "English", "hindi": "", "tamil": "", "telugu": "", "marathi": "", "bengali": "", "gujarati": "" };
const home$2 = { "title": "       ", "hero_title_1": "  ", "hero_description_1": "      ", "hero_title_2": "  ", "hero_description_2": "       ", "hero_title_3": "  ", "hero_description_3": "        ", "stats_funds": "2.5 ", "stats_funds_label": " ", "stats_beneficiaries": "15,000+", "stats_beneficiaries_label": "", "stats_campaigns": "42", "stats_campaigns_label": " ", "stats_transparency": "98%", "stats_transparency_label": " ", "why_impactx": "  ?", "why_impactx_desc": "  ,             ", "feature_transparency": " ", "feature_transparency_desc": "          .", "feature_verification": "- ", "feature_verification_desc": "    (, , IoT)       .", "feature_storage": "IPFS ", "feature_storage_desc": "     IPFS     .", "feature_india": "-", "feature_india_desc": "         .", "disaster_relief": "  ", "disaster_relief_desc": "        ", "partners": "  NGO ", "partners_desc": "     ", "how_it_works": "   ", "how_it_works_desc": " 4-        ", "step_create": "  ", "step_create_desc": "NGO        ", "step_donate": " ", "step_donate_desc": "      ", "step_verify": " ", "step_verify_desc": "        ", "step_release": " ", "step_release_desc": "  NGO     ", "cta_title": "     ?", "cta_desc": "          ", "cta_button_donate": "  ", "cta_button_explore": "  ", "funds_raised": "  ", "go_to_slide": " ", "active_campaigns": " ", "completed_campaigns": "  ", "common_disasters_india": "  ", "disaster_types_desc": "       ", "disaster_flood": "", "disaster_earthquake": "", "disaster_cyclone": "", "disaster_drought": "", "disaster_landslide": "", "disaster_fire": " ", "quick_links": " ", "resources": "", "documentation": "", "api_reference": "API ", "github": "", "community": "", "contact_us": "  ", "made_with_love": "   ", "india_disaster_info": "  ", "disaster_affected_regions": " ", "disaster_frequency": "", "disaster_impact": "", "disaster_high": "", "disaster_medium": "", "disaster_low": "", "disaster_severe": "", "disaster_moderate": "", "disaster_flood_desc": "        ,      .", "disaster_earthquake_desc": "        ,   .", "disaster_cyclone_desc": "              .", "disaster_drought_desc": "           .", "disaster_landslide_desc": "         .", "disaster_fire_desc": "           .", "disaster_flood_prep1": "          ", "disaster_flood_prep2": ",        ", "disaster_flood_prep3": "      ", "disaster_earthquake_prep1": " ,     ", "disaster_earthquake_prep2": "     ", "disaster_earthquake_prep3": "      ", "disaster_cyclone_prep1": "        ", "disaster_cyclone_prep2": "         ", "disaster_cyclone_prep3": "  -  ", "disaster_drought_prep1": "         ", "disaster_drought_prep2": "-    ", "disaster_drought_prep3": "    ", "disaster_landslide_prep1": "       ", "disaster_landslide_prep2": "       ", "disaster_landslide_prep3": "       ", "disaster_fire_prep1": "       ", "disaster_fire_prep2": "   -   ", "disaster_fire_prep3": "      ", "disaster_preparedness": " ", "disaster_preparedness_tip": "  ", "disaster_preparedness_desc": "       ,             .", "regional_disaster_stats": "  ", "common_disasters": " ", "people_affected": "  ", "funds_allocated": "  ", "view_detailed_statistics": "  ", "disaster_statistics": " ", "disaster_statistics_insight": " ", "disaster_statistics_desc": "         ,      .   ,     ,   .            .", "bar_chart": " ", "line_chart": " ", "pie_chart": " ", "lakh": "", "crore": "", "thousand": "", "localization_demo": " ", "currency_formatting": " ", "number_formatting": " ", "date_formatting": " ", "percentage_formatting": " ", "large_number_formatting": "  ", "current_locale": " ", "formatting": { "date_format": "dd/MM/yyyy", "currency_symbol": "", "decimal_separator": ".", "thousands_separator": "," } };
const navigation$2 = { "menu": "", "close": " ", "accessibility_options": " " };
const accessibility$2 = { "skip_to_main_content": "  ", "increase_font_size": "  ", "decrease_font_size": "   ", "high_contrast": "  ", "reading_assistance": " ", "reading_mode": " ", "reading_mode_desc": "     ", "text_to_speech": "--", "text_to_speech_desc": "   ", "speech_rate": " ", "stop_speaking": " ", "how_to_use": " ", "tts_instructions": "      .      .", "accessibility_options": " " };
const disasters$2 = { "stateInfo": { "title": "-  ", "selectState": " " }, "floods": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "cyclones": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "earthquakes": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "droughts": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "landslides": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "info": { "frequency": "", "affectedPopulation": " ", "lastIncident": " ", "preparednessLevel": " " }, "preparednessTips": { "title": "  ", "tip1": "      ", "tip1Desc": ",     , , ,   ,        .       .", "tip2": "     ", "tip2Desc": " ,       .        .      .", "tip3": "       ", "tip3Desc": "   ,             .         .", "tip4": "      ", "tip4Desc": "        ,     .      .", "highPriority": " ", "mediumPriority": " ", "bookmarkedTips": "  " } };
const states$2 = { "maharashtra": "", "odisha": "", "kerala": "" };
const emergencyContacts$2 = { "title": " ", "selectState": " ", "chooseState": "  ", "search": " ", "searchPlaceholder": "   ...", "contactsFor": "  ", "call": " ", "copy": " ", "noContactsFound": "      .", "selectStateMessage": "      .", "quickAccess": "  ", "police": "", "fire": "", "ambulance": "", "disaster": " ", "calling": "  ", "numberCopied": "    !" };
const weatherAlerts$2 = { "title": " ", "loading": "    ...", "refresh": " ", "noAlerts": "   ", "noAlertsDesc": "      .", "floodWarning": " ", "floodWarningDesc": "    .    .", "cycloneWatch": " ", "cycloneWatchDesc": "      .", "heatwaveWarning": " ", "heatwaveWarningDesc": "  .       .", "issued": " ", "expires": " ", "region": "", "safetyTip": "  ", "safetyTipDesc": "      .           ." };
const disasterRisk$2 = { "title": "  ", "selectRegion": " ", "overallRisk": "  ", "low": "", "high": "", "mitigationTips": "  ", "tip1": "         ", "tip2": "      ", "tip3": "      ", "tip4": "      " };
const resourceAllocator$2 = { "title": "  ", "disasterType": " ", "affectedPopulation": " ", "severityLevel": " ", "affectedArea": " ", "emergencySupplies": " ", "personnelRequirements": " ", "evacuationCapacity": " ", "shelterAllocation": " ", "water": "", "food": "", "medicalKits": " ", "blankets": "", "hygieneKits": " ", "rescueTeams": " ", "medicalTeams": " ", "logisticsTeams": " ", "totalTeams": " ", "totalCapacity": " ", "totalVehicles": " ", "vehicleBreakdown": " ", "shelter1": " ", "shelter2": " ", "shelter3": " ", "totalSheltered": "  ", "unshelteredPopulation": " ", "allocationDetails": " ", "remainingCapacity": " ", "liters": "", "meals": "", "note": ":                .", "severity": { "1": "", "2": "", "3": "", "4": "", "5": "" } };
const impactAssessment$2 = { "title": "  ", "disasterType": " ", "region": "", "overallImpact": " ", "economicImpact": " ", "socialImpact": " ", "environmentalImpact": " ", "recommendations": "", "totalEconomicLoss": "  ", "infrastructureLoss": "  ", "agriculturalLoss": " ", "recoveryEstimate": "  ", "affectedFamilies": " ", "childrenAffected": " ", "displacementRate": " ", "casualtyRate": " ", "healthcareImpact": "  ", "educationImpact": " ", "forestLoss": " ", "co2Emissions": "CO2 ", "biodiversityLoss": "  ", "species": "", "recoveryTime": "  ", "months": "", "priorityLevel": " ", "selectDisasterAndRegion": "       ", "impactLevels": { "catastrophic": "", "severe": "", "moderate": "", "minor": "", "low": "" }, "priority": { "immediate": "", "high": "", "medium": "", "low": "" } };
const responsePlanner$2 = { "title": "  ", "disasterType": " ", "severityLevel": " ", "region": "", "disasterInfo": "{{region}}  {{disaster}}  ", "immediateActions": " ", "resourceAllocation": " ", "teams": "", "equipmentAndSupplies": "  ", "timeline": " ", "coordination": " ", "specialConsiderations": " ", "selectDisasterAndRegion": "     ,     ", "phases": { "immediate": "  (0-2 )", "shortTerm": "  (2-24 )", "mediumTerm": "  (1-30 )", "longTerm": "  (1-36 )" }, "severity": { "minor": "", "moderate": "", "significant": "", "severe": "", "catastrophic": "" } };
const communityReporting$2 = { "title": "  ", "description": "", "disasterType": " ", "selectDisasterType": "  ", "disasterTypes": { "flood": "", "earthquake": "", "cyclone": "", "drought": "", "landslide": "", "fire": "", "epidemic": "", "chemical": " ", "other": "" }, "location": "", "locationPlaceholder": "    ", "useCurrentLocation": "  ", "latitude": "", "longitude": "", "descriptionPlaceholder": ",        ...", "severity": " ", "low": "", "high": "", "affectedPeople": "  ()", "media": " (/)", "uploadMedia": "     ", "mediaLimit": " 5 .    .", "submitReport": "   ", "submitting": "  ...", "successMessage": "       !       .", "submissionError": "   .    .", "locationError": "    .     .", "locationNotSupported": "    .", "maxMediaFiles": " 5    ." };
const volunteerCoordinator$2 = { "title": " ", "description": "       ", "disasterType": " ", "latitude": "", "longitude": "", "tabs": { "matching": " ", "assignments": " ", "communication": " ", "tracking": " ", "scheduling": " " }, "matching": { "title": "  " }, "volunteer": "", "skills": "", "distance": "", "suitability": "", "tasks": "", "assignments": "", "assignedTo": " ", "assignedAt": " ", "requiredSkills": " ", "requiredVolunteers": " ", "priority": "", "communication": { "title": " ", "channels": " " }, "channels": "", "frequency": "", "contactList": " ", "tracking": { "title": "  " }, "totalVolunteers": " ", "totalHours": " ", "topContributors": " ", "recognitionAwards": " ", "recognitionDistribution": " ", "bronze": "", "silver": "", "gold": "", "platinum": "", "recognitionLevel": " ", "hours": "", "scheduling": { "title": "  " }, "shift": "", "time": "", "duration": "", "totalShifts": " ", "filledShifts": " ", "coverage": "", "volunteerUtilization": " ", "utilization": "" };
const disasterStatistics$2 = { "title": " ", "description": "        ", "tabs": { "overview": "", "trends": "", "regional": " ", "comparison": " " }, "overview": { "title": "  ", "totalEvents": " ", "totalAffected": " ", "totalEconomicLoss": "  ", "averageAffected": "   " }, "byType": " ", "byRegion": "", "events": "", "affected": " ", "economicLoss": " ", "trends": { "title": "  ", "yearsCovered": " ", "annualGrowth": "  ", "mostIncreasing": "  ", "yearlyBreakdown": " ", "year": "" }, "regional": { "title": "  ", "region": "", "riskIndex": " " }, "comparison": { "title": "  ", "firstType": "  ", "secondType": "  ", "compare": " ", "averageAffected": " ", "averageEconomicLoss": "  " } };
const weather$2 = { "title": " ", "conditions": " ", "humidity": "", "wind_speed": " ", "pressure": "", "visibility": "", "risk_assessment": " ", "risk_level": " ", "alerts": "", "preparedness_recommendations": " ", "forecast": " ", "high": "", "low": "", "refresh": " ", "loading": "  ...", "data_not_available": "   ", "fetch_error": "   " };
const emergencyResourceTracker$2 = { "title": "  ", "totalResources": " ", "availableResources": " ", "responseRate": " ", "region": "", "allRegions": " ", "resource": "", "quantity": "", "location": "", "availability": "", "requestResources": "  ", "resourceType": " ", "selectType": "  ", "urgency": "", "normal": "", "high": "", "critical": "", "enterLocation": "  ", "contact": "", "enterContact": "   ", "submitRequest": "  ", "requestStatus": " ", "requestId": " ", "status": "", "submitted": " ", "estimatedDelivery": " ", "refreshStatus": "  " };
const disasterCommunicationHub$2 = { "title": "  ", "selectRegion": " ", "allRegions": " ", "selectDisaster": "  ", "communicationChannels": " ", "channelName": " ", "type": "", "frequency": "", "coverage": "", "status": "", "contact": "", "broadcastInfo": "  ", "tvChannels": " ", "radioStations": " ", "transmission": "", "smsAlerts": " ", "service": "", "shortcode": "", "provider": "", "equipment": " ", "availability": "", "protocols": "{{disaster}}   ", "immediateResponse": " ", "shortTermResponse": " ", "longTermResponse": " ", "emergencyContacts": " " };
const mrTranslation = {
  common: common$2,
  home: home$2,
  navigation: navigation$2,
  accessibility: accessibility$2,
  disasters: disasters$2,
  states: states$2,
  emergencyContacts: emergencyContacts$2,
  weatherAlerts: weatherAlerts$2,
  disasterRisk: disasterRisk$2,
  resourceAllocator: resourceAllocator$2,
  impactAssessment: impactAssessment$2,
  responsePlanner: responsePlanner$2,
  communityReporting: communityReporting$2,
  volunteerCoordinator: volunteerCoordinator$2,
  disasterStatistics: disasterStatistics$2,
  weather: weather$2,
  emergencyResourceTracker: emergencyResourceTracker$2,
  disasterCommunicationHub: disasterCommunicationHub$2
};
const common$1 = { "app_name": "", "home": "", "campaigns": "", "donate": " ", "ngo_dashboard": "NGO ", "admin": "", "demo": "", "auth_test": " ", "dark_mode": " ", "light_mode": " ", "language": "", "english": "English", "hindi": "", "tamil": "", "telugu": "", "marathi": "", "bengali": "", "gujarati": "" };
const home$1 = { "title": "      ", "hero_title_1": "  ", "hero_description_1": "       ", "hero_title_2": "   ", "hero_description_2": "       ", "hero_title_3": "  ", "hero_description_3": "        ", "stats_funds": "2.5 ", "stats_funds_label": " ", "stats_beneficiaries": "15,000+", "stats_beneficiaries_label": "", "stats_campaigns": "42", "stats_campaigns_label": " ", "stats_transparency": "98%", "stats_transparency_label": " ", "why_impactx": " ?", "why_impactx_desc": "    ,            ", "feature_transparency": " ", "feature_transparency_desc": "            ", "feature_verification": "- ", "feature_verification_desc": "     (, , IoT)       ", "feature_storage": "IPFS ", "feature_storage_desc": "       IPFS-    ", "feature_india": "-", "feature_india_desc": "            ", "disaster_relief": "   ", "disaster_relief_desc": "        ", "partners": "  NGO ", "partners_desc": "        ", "how_it_works": "   ", "how_it_works_desc": " 4-        ", "step_create": "  ", "step_create_desc": "NGO        ", "step_donate": " ", "step_donate_desc": "      ", "step_verify": " ", "step_verify_desc": "         ", "step_release": " ", "step_release_desc": "   NGO    ", "cta_title": "  ?", "cta_desc": "             ", "cta_button_donate": "  ", "cta_button_explore": "  ", "funds_raised": " ", "go_to_slide": " ", "active_campaigns": " ", "completed_campaigns": " ", "common_disasters_india": "  ", "disaster_types_desc": "        ", "disaster_flood": "", "disaster_earthquake": "", "disaster_cyclone": "", "disaster_drought": "", "disaster_landslide": "", "disaster_fire": " ", "quick_links": " ", "resources": "", "documentation": "", "api_reference": "API ", "github": "", "community": "", "contact_us": "   ", "made_with_love": "    ", "india_disaster_info": "  ", "disaster_affected_regions": " ", "disaster_frequency": " ", "disaster_impact": "", "disaster_high": "", "disaster_medium": "", "disaster_low": "", "disaster_severe": "", "disaster_moderate": "", "disaster_flood_desc": "         ,      ", "disaster_earthquake_desc": "         ,    ", "disaster_cyclone_desc": "              ", "disaster_drought_desc": "             ", "disaster_landslide_desc": "         ", "disaster_fire_desc": "           ", "disaster_flood_prep1": "        ", "disaster_flood_prep2": ",        ", "disaster_flood_prep3": "          ", "disaster_earthquake_prep1": "  ,     ", "disaster_earthquake_prep2": "       ", "disaster_9uake_prep3": "       ", "disaster_cyclone_prep1": "         ", "disaster_cyclone_prep2": "         ", "disaster_cyclone_prep3": "      ", "disaster_drought_prep1": "          ", "disaster_drought_prep2": "     ", "disaster_drought_prep3": "       ", "disaster_landslide_prep1": "       ", "disaster_landslide_prep2": "       ", "disaster_landslide_prep3": "         ", "disaster_fire_prep1": "        ", "disaster_fire_prep2": "   -   ", "disaster_fire_prep3": "       ", "disaster_preparedness": " ", "disaster_preparedness_tip": "  ", "disaster_preparedness_desc": "       ,               ", "regional_disaster_stats": "  ", "common_disasters": " ", "people_affected": " ", "funds_allocated": " ", "view_detailed_statistics": "  ", "disaster_statistics": " ", "disaster_statistics_insight": " ", "disaster_statistics_desc": "       ,         ,    ,               ", "bar_chart": " ", "line_chart": " ", "pie_chart": " ", "lakh": "", "crore": "", "thousand": "", "localization_demo": " ", "currency_formatting": " ", "number_formatting": " ", "date_formatting": " ", "percentage_formatting": " ", "large_number_formatting": "  ", "current_locale": " ", "formatting": { "date_format": "dd/MM/yyyy", "currency_symbol": "", "decimal_separator": ".", "thousands_separator": "," } };
const navigation$1 = { "menu": "", "close": " ", "accessibility_options": " " };
const accessibility$1 = { "skip_to_main_content": "  ", "increase_font_size": "  ", "decrease_font_size": "  ", "high_contrast": "  ", "reading_assistance": " ", "reading_mode": " ", "reading_mode_desc": "      ", "text_to_speech": "--", "text_to_speech_desc": "   ", "speech_rate": " ", "stop_speaking": "   ", "how_to_use": "  ", "tts_instructions": "              ", "accessibility_options": " " };
const disasters$1 = { "stateInfo": { "title": "-  ", "selectState": "  " }, "floods": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "cyclones": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "earthquakes": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "droughts": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "landslides": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "info": { "frequency": " ", "affectedPopulation": " ", "lastIncident": " ", "preparednessLevel": " " }, "preparednessTips": { "title": "  ", "tip1": "      ", "tip1Desc": ",     , , ,   ,               ", "tip2": "      ", "tip2Desc": " ,                       ", "tip3": "         ", "tip3Desc": "  ,                      ", "tip4": "     ", "tip4Desc": "       ,             ", "highPriority": " ", "mediumPriority": " ", "bookmarkedTips": "  " } };
const states$1 = { "maharashtra": "", "odisha": "", "kerala": "" };
const emergencyContacts$1 = { "title": " ", "selectState": "  ", "chooseState": "   ", "search": "  ", "searchPlaceholder": "     ...", "contactsFor": "  ", "call": " ", "copy": " ", "noContactsFound": "       ", "selectStateMessage": "      ", "quickAccess": "  ", "police": "", "fire": "", "ambulance": "", "disaster": " ", "calling": "  ", "numberCopied": "     !" };
const weatherAlerts$1 = { "title": " ", "loading": "   ...", "refresh": " ", "noAlerts": "   ", "noAlertsDesc": "       ", "floodWarning": " ", "floodWarningDesc": "       ", "cycloneWatch": " ", "cycloneWatchDesc": "      ", "heatwaveWarning": "  ", "heatwaveWarningDesc": "         ", "issued": "  ", "expires": "  ", "region": "", "safetyTip": "  ", "safetyTipDesc": "                   " };
const disasterRisk$1 = { "title": "  ", "selectRegion": "  ", "overallRisk": "  ", "low": "", "high": "", "mitigationTips": "  ", "tip1": "      ", "tip2": "       ", "tip3": "       ", "tip4": "      " };
const resourceAllocator$1 = { "title": "  ", "disasterType": " ", "affectedPopulation": " ", "severityLevel": " ", "affectedArea": " ", "emergencySupplies": " ", "personnelRequirements": " ", "evacuationCapacity": " ", "shelterAllocation": " ", "water": "", "food": "", "medicalKits": " ", "blankets": "", "hygieneKits": " ", "rescueTeams": " ", "medicalTeams": " ", "logisticsTeams": " ", "totalTeams": " ", "totalCapacity": " ", "totalVehicles": " ", "vehicleBreakdown": " ", "shelter1": " ", "shelter2": " ", "shelter3": " ", "totalSheltered": " ", "unshelteredPopulation": " ", "allocationDetails": " ", "remainingCapacity": " ", "liters": "", "meals": "", "note": ":                    ", "severity": { "1": "", "2": "", "3": "", "4": "", "5": "" } };
const impactAssessment$1 = { "title": "  ", "disasterType": " ", "region": "", "overallImpact": " ", "economicImpact": " ", "socialImpact": " ", "environmentalImpact": " ", "recommendations": "", "totalEconomicLoss": "  ", "infrastructureLoss": " ", "agriculturalLoss": " ", "recoveryEstimate": "  ", "affectedFamilies": " ", "childrenAffected": " ", "displacementRate": " ", "casualtyRate": " ", "healthcareImpact": " ", "educationImpact": " ", "forestLoss": " ", "co2Emissions": "CO2 ", "biodiversityLoss": "  ", "species": "", "recoveryTime": "  ", "months": "", "priorityLevel": " ", "selectDisasterAndRegion": "         ", "impactLevels": { "catastrophic": "", "severe": "", "moderate": "", "minor": "", "low": "" }, "priority": { "immediate": "", "high": "", "medium": "", "low": "" } };
const responsePlanner$1 = { "title": "  ", "disasterType": " ", "severityLevel": " ", "region": "", "disasterInfo": "{{region}}-  {{disaster}}  ", "immediateActions": " ", "resourceAllocation": " ", "teams": "", "equipmentAndSupplies": "  ", "timeline": " ", "coordination": " ", "specialConsiderations": " ", "selectDisasterAndRegion": "      ,      ", "phases": { "immediate": "  (0-2 )", "shortTerm": "  (2-24 )", "mediumTerm": "  (1-30 )", "longTerm": "  (1-36 )" }, "severity": { "minor": "", "moderate": "", "significant": "", "severe": "", "catastrophic": "" } };
const recoveryPlanner = { "title": "  ", "description": "              ", "disasterType": " ", "selectDisaster": "   ", "region": "", "selectRegion": "  ", "affectedPopulation": " ", "populationPlaceholder": "  ", "severity": " ", "generatePlan": "   ", "progressOverview": "   ", "overallProgress": "  ", "status": "", "completedTasks": "", "fillAllFields": "          ", "tabs": { "timeline": "", "resources": "", "stakeholders": "", "actionPlan": " " }, "timeline": { "title": " ", "phases": { "immediate": " ", "shortTerm": " ", "mediumTerm": "  ", "longTerm": " " } }, "resources": { "title": " ", "personnel": "", "supplies": "", "financial": " ", "roles": { "emergencyResponders": "  ", "medicalStaff": " ", "engineers": "", "logistics": " " }, "items": { "water": "", "food": "", "medical": " ", "shelter": " " } }, "stakeholders": { "title": " " }, "actionPlan": { "title": "  " }, "priority": { "high": " ", "medium": " ", "low": " " } };
const disasterTypes = { "flood": "", "earthquake": "", "cyclone": "", "drought": "", "landslide": "" };
const communityReporting$1 = { "title": "  ", "description": "", "disasterType": " ", "selectDisasterType": "   ", "disasterTypes": { "flood": "", "earthquake": "", "cyclone": "", "drought": "", "landslide": "", "fire": "", "epidemic": "", "chemical": " ", "other": "" }, "location": "", "locationPlaceholder": "   ", "useCurrentLocation": "   ", "latitude": "", "longitude": "", "descriptionPlaceholder": ",        ...", "severity": " ", "low": "", "high": "", "affectedPeople": "  ()", "media": " (/)", "uploadMedia": "     ", "mediaLimit": " 5      ", "submitReport": "   ", "submitting": "  ...", "successMessage": "      !      ", "submissionError": "         ", "locationError": "          ", "locationNotSupported": "     ", "maxMediaFiles": " 5    " };
const volunteerCoordinator$1 = { "title": " ", "description": "        ", "disasterType": " ", "latitude": "", "longitude": "", "tabs": { "matching": " ", "assignments": " ", "communication": " ", "tracking": " ", "scheduling": " " }, "matching": { "title": "  " }, "volunteer": "", "skills": "", "distance": "", "suitability": "", "tasks": "", "assignments": "", "assignedTo": "   ", "assignedAt": "   ", "requiredSkills": " ", "requiredVolunteers": " ", "priority": "", "communication": { "title": " ", "channels": " " }, "channels": "", "frequency": "", "contactList": " ", "tracking": { "title": "  " }, "totalVolunteers": " ", "totalHours": " ", "topContributors": " ", "recognitionAwards": " ", "recognitionDistribution": " ", "bronze": "", "silver": "", "gold": "", "platinum": "", "recognitionLevel": " ", "hours": "", "scheduling": { "title": "  " }, "shift": "", "time": "", "duration": "", "totalShifts": " ", "filledShifts": "  ", "coverage": "", "volunteerUtilization": " ", "utilization": "" };
const disasterStatistics$1 = { "title": " ", "description": "        ", "tabs": { "overview": " ", "trends": "", "regional": " ", "comparison": " " }, "overview": { "title": "   ", "totalEvents": " ", "totalAffected": " ", "totalEconomicLoss": "  ", "averageAffected": "   " }, "byType": "  ", "byRegion": " ", "events": "", "affected": " ", "economicLoss": " ", "trends": { "title": "  ", "yearsCovered": " ", "annualGrowth": "  ", "mostIncreasing": "    ", "yearlyBreakdown": " ", "year": "" }, "regional": { "title": "  ", "region": "", "riskIndex": " " }, "comparison": { "title": "  ", "firstType": "  ", "secondType": "  ", "compare": " ", "averageAffected": " ", "averageEconomicLoss": "  " } };
const weather$1 = { "title": " ", "conditions": " ", "humidity": "", "wind_speed": " ", "pressure": "", "visibility": "", "risk_assessment": " ", "risk_level": " ", "alerts": "", "preparedness_recommendations": " ", "forecast": " ", "high": "", "low": "", "refresh": " ", "loading": " ...", "data_not_available": "   ", "fetch_error": "   " };
const emergencyResourceTracker$1 = { "title": "  ", "totalResources": " ", "availableResources": " ", "responseRate": " ", "region": "", "allRegions": " ", "resource": "", "quantity": "", "location": "", "availability": "", "requestResources": "  ", "resourceType": " ", "selectType": "   ", "urgency": " ", "normal": "", "high": "", "critical": "", "enterLocation": " ", "contact": "", "enterContact": "  ", "submitRequest": "  ", "requestStatus": " ", "requestId": " ", "status": "", "submitted": "  ", "estimatedDelivery": " ", "refreshStatus": "  " };
const disasterCommunicationHub$1 = { "title": "  ", "selectRegion": "  ", "allRegions": " ", "selectDisaster": "   ", "communicationChannels": " ", "channelName": " ", "type": "", "frequency": "", "coverage": "", "status": "", "contact": "", "broadcastInfo": "  ", "tvChannels": " ", "radioStations": " ", "transmission": "", "smsAlerts": " ", "service": "", "shortcode": "", "provider": "", "equipment": " ", "availability": "", "protocols": "{{disaster}}-   ", "immediateResponse": " ", "shortTermResponse": " ", "longTermResponse": " ", "emergencyContacts": " " };
const bnTranslation = {
  common: common$1,
  home: home$1,
  navigation: navigation$1,
  accessibility: accessibility$1,
  disasters: disasters$1,
  states: states$1,
  emergencyContacts: emergencyContacts$1,
  weatherAlerts: weatherAlerts$1,
  disasterRisk: disasterRisk$1,
  resourceAllocator: resourceAllocator$1,
  impactAssessment: impactAssessment$1,
  responsePlanner: responsePlanner$1,
  recoveryPlanner,
  disasterTypes,
  communityReporting: communityReporting$1,
  volunteerCoordinator: volunteerCoordinator$1,
  disasterStatistics: disasterStatistics$1,
  weather: weather$1,
  emergencyResourceTracker: emergencyResourceTracker$1,
  disasterCommunicationHub: disasterCommunicationHub$1
};
const common = { "app_name": " ", "home": "", "campaigns": "", "donate": " ", "ngo_dashboard": "NGO ", "admin": "", "demo": "", "auth_test": " ", "dark_mode": " ", "light_mode": " ", "language": "", "english": "English", "hindi": "", "tamil": "", "telugu": "", "marathi": "", "bengali": "", "gujarati": "" };
const home = { "title": "        ", "hero_title_1": "  ", "hero_description_1": "     ", "hero_title_2": "   ", "hero_description_2": "       ", "hero_title_3": "  ", "hero_description_3": "         ", "stats_funds": "2.5 ", "stats_funds_label": " ", "stats_beneficiaries": "15,000+", "stats_beneficiaries_label": "", "stats_campaigns": "42", "stats_campaigns_label": " ", "stats_transparency": "98%", "stats_transparency_label": " ", "why_impactx": "   ?", "why_impactx_desc": "    ,               ", "feature_transparency": " ", "feature_transparency_desc": "            .", "feature_verification": "- ", "feature_verification_desc": "      (, , IoT)      .", "feature_storage": "IPFS ", "feature_storage_desc": "       IPFS      .", "feature_india": "-", "feature_india_desc": "            .", "disaster_relief": "   ", "disaster_relief_desc": "        ", "partners": "  NGO ", "partners_desc": "       ", "how_it_works": "     ", "how_it_works_desc": " 4-         ", "step_create": " ", "step_create_desc": "NGO        ", "step_donate": " ", "step_donate_desc": "       ", "step_verify": "", "step_verify_desc": "         ", "step_release": " ", "step_release_desc": "   NGO      ", "cta_title": "    ?", "cta_desc": "               ", "cta_button_donate": "  ", "cta_button_explore": " ", "funds_raised": " ", "go_to_slide": "  ", "active_campaigns": " ", "completed_campaigns": "  ", "common_disasters_india": "  ", "disaster_types_desc": "       ", "disaster_flood": "", "disaster_earthquake": "", "disaster_cyclone": " ", "disaster_drought": "", "disaster_landslide": "", "disaster_fire": " ", "quick_links": " ", "resources": "", "documentation": "", "api_reference": "API ", "github": "", "community": "", "contact_us": "  ", "made_with_love": "    ", "india_disaster_info": "  ", "disaster_affected_regions": " ", "disaster_frequency": "", "disaster_impact": "", "disaster_high": "", "disaster_medium": "", "disaster_low": "", "disaster_severe": "", "disaster_moderate": "", "disaster_flood_desc": "        ,        .", "disaster_earthquake_desc": "         ,    .", "disaster_cyclone_desc": "                  .", "disaster_drought_desc": "            .", "disaster_landslide_desc": "          .", "disaster_fire_desc": "            .", "disaster_flood_prep1": "            ", "disaster_flood_prep2": ",        ", "disaster_flood_prep3": "      ", "disaster_earthquake_prep1": "   ,     ", "disaster_earthquake_prep2": "       ", "disaster_2quake_prep3": "       ", "disaster_cyclone_prep1": "         ", "disaster_cyclone_prep2": "         ", "disaster_cyclone_prep3": "   -  ", "disaster_drought_prep1": "        ", "disaster_drought_prep2": "      ", "disaster_drought_prep3": "       ", "disaster_landslide_prep1": "        ", "disaster_landslide_prep2": "       ", "disaster_landslide_prep3": "        ", "disaster_fire_prep1": "        ", "disaster_fire_prep2": "   -  ", "disaster_fire_prep3": "       ", "disaster_preparedness": " ", "disaster_preparedness_tip": "  ", "disaster_preparedness_desc": "      ,              .", "regional_disaster_stats": "  ", "common_disasters": " ", "people_affected": " ", "funds_allocated": " ", "view_detailed_statistics": "  ", "disaster_statistics": " ", "disaster_statistics_insight": " ", "disaster_statistics_desc": "        ,        .    ,    ,   .              .", "bar_chart": " ", "line_chart": " ", "pie_chart": " ", "lakh": "", "crore": "", "thousand": "", "localization_demo": " ", "currency_formatting": " ", "number_formatting": " ", "date_formatting": " ", "percentage_formatting": " ", "large_number_formatting": "  ", "current_locale": " ", "formatting": { "date_format": "dd/MM/yyyy", "currency_symbol": "", "decimal_separator": ".", "thousands_separator": "," } };
const navigation = { "menu": "", "close": " ", "accessibility_options": " " };
const accessibility = { "skip_to_main_content": "   ", "increase_font_size": "  ", "decrease_font_size": "  ", "high_contrast": "  ", "reading_assistance": " ", "reading_mode": " ", "reading_mode_desc": "      ", "text_to_speech": "--", "text_to_speech_desc": "    ", "speech_rate": " ", "stop_speaking": "  ", "how_to_use": "   ", "tts_instructions": "         .       .", "accessibility_options": " " };
const disasters = { "stateInfo": { "title": "-  ", "selectState": "  " }, "floods": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "cyclones": { "title": " ", "frequency": { "high": "", "moderate": "", "low": "" } }, "earthquakes": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "droughts": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "landslides": { "title": "", "frequency": { "high": "", "moderate": "", "low": "" } }, "info": { "frequency": "", "affectedPopulation": " ", "lastIncident": " ", "preparednessLevel": " " }, "preparednessTips": { "title": "  ", "tip1": "      ", "tip1Desc": ",      , , ,   ,        .         .", "tip2": "      ", "tip2Desc": " ,       .         .       .", "tip3": "          ", "tip3Desc": "   ,            .           .", "tip4": "     ", "tip4Desc": "       ,       .      .", "highPriority": " ", "mediumPriority": " ", "bookmarkedTips": "  " } };
const states = { "maharashtra": "", "odisha": "", "kerala": "" };
const emergencyContacts = { "title": " ", "selectState": "  ", "chooseState": "   ", "search": " ", "searchPlaceholder": "    ...", "contactsFor": "  ", "call": " ", "copy": " ", "noContactsFound": "        .", "selectStateMessage": "         .", "quickAccess": "  ", "police": "", "fire": "", "ambulance": "", "disaster": " ", "calling": "   ", "numberCopied": "     !" };
const weatherAlerts = { "title": " ", "loading": "     ...", "refresh": " ", "noAlerts": "   ", "noAlertsDesc": "       .", "floodWarning": " ", "floodWarningDesc": "   .    .", "cycloneWatch": "  ", "cycloneWatchDesc": "         .", "heatwaveWarning": " ", "heatwaveWarningDesc": "  .       .", "issued": " ", "expires": "  ", "region": "", "safetyTip": "  ", "safetyTipDesc": "      .            ." };
const disasterRisk = { "title": "  ", "selectRegion": "  ", "overallRisk": "  ", "low": "", "high": "", "mitigationTips": "  ", "tip1": "        ", "tip2": "       ", "tip3": "       ", "tip4": "       " };
const resourceAllocator = { "title": "  ", "disasterType": " ", "affectedPopulation": " ", "severityLevel": " ", "affectedArea": " ", "emergencySupplies": " ", "personnelRequirements": " ", "evacuationCapacity": "  ", "shelterAllocation": " ", "water": "", "food": "", "medicalKits": " ", "blankets": "", "hygieneKits": " ", "rescueTeams": " ", "medicalTeams": " ", "logisticsTeams": " ", "totalTeams": " ", "totalCapacity": " ", "totalVehicles": " ", "vehicleBreakdown": " ", "shelter1": " ", "shelter2": " ", "shelter3": " ", "totalSheltered": " ", "unshelteredPopulation": "- ", "allocationDetails": " ", "remainingCapacity": " ", "liters": "", "meals": "", "note": ":                  .", "severity": { "1": "", "2": "", "3": "", "4": "", "5": "" } };
const impactAssessment = { "title": "  ", "disasterType": " ", "region": "", "overallImpact": " ", "economicImpact": " ", "socialImpact": " ", "environmentalImpact": " ", "recommendations": "", "totalEconomicLoss": "  ", "infrastructureLoss": " ", "agriculturalLoss": " ", "recoveryEstimate": "  ", "affectedFamilies": " ", "childrenAffected": " ", "displacementRate": " ", "casualtyRate": " ", "healthcareImpact": "  ", "educationImpact": " ", "forestLoss": " ", "co2Emissions": "CO2 ", "biodiversityLoss": "  ", "species": "", "recoveryTime": "  ", "months": "", "priorityLevel": " ", "selectDisasterAndRegion": "         ", "impactLevels": { "catastrophic": "", "severe": "", "moderate": "", "minor": "", "low": "" }, "priority": { "immediate": "", "high": "", "medium": "", "low": "" } };
const responsePlanner = { "title": "  ", "disasterType": " ", "severityLevel": " ", "region": "", "disasterInfo": "{{region}}  {{disaster}}  ", "immediateActions": " ", "resourceAllocation": " ", "teams": "", "equipmentAndSupplies": "  ", "timeline": " ", "coordination": " ", "specialConsiderations": " ", "selectDisasterAndRegion": "     ,      ", "phases": { "immediate": "  (0-2 )", "shortTerm": "   (2-24 )", "mediumTerm": "   (1-30 )", "longTerm": "   (1-36 )" }, "severity": { "minor": "", "moderate": "", "significant": "", "severe": "", "catastrophic": "" } };
const communityReporting = { "title": "  ", "description": "", "disasterType": " ", "selectDisasterType": "   ", "disasterTypes": { "flood": "", "earthquake": "", "cyclone": "", "drought": "", "landslide": "", "fire": "", "epidemic": "", "chemical": " ", "other": "" }, "location": "", "locationPlaceholder": "    ", "useCurrentLocation": "   ", "latitude": "", "longitude": "", "descriptionPlaceholder": ",        ...", "severity": " ", "low": "", "high": "", "affectedPeople": "  ()", "media": " (/)", "uploadMedia": "      ", "mediaLimit": " 5 .    .", "submitReport": "   ", "submitting": "   ...", "successMessage": "       !       .", "submissionError": "   .     .", "locationError": "    .       .", "locationNotSupported": "     .", "maxMediaFiles": " 5    ." };
const volunteerCoordinator = { "title": " ", "description": "        ", "disasterType": " ", "latitude": "", "longitude": "", "tabs": { "matching": " ", "assignments": " ", "communication": " ", "tracking": " ", "scheduling": " " }, "matching": { "title": "  " }, "volunteer": "", "skills": "", "distance": "", "suitability": "", "tasks": "", "assignments": "", "assignedTo": " ", "assignedAt": " ", "requiredSkills": " ", "requiredVolunteers": " ", "priority": "", "communication": { "title": " ", "channels": " " }, "channels": "", "frequency": "", "contactList": " ", "tracking": { "title": "  " }, "totalVolunteers": " ", "totalHours": " ", "topContributors": " ", "recognitionAwards": " ", "recognitionDistribution": " ", "bronze": "", "silver": "", "gold": "", "platinum": "", "recognitionLevel": " ", "hours": "", "scheduling": { "title": "  " }, "shift": "", "time": "", "duration": "", "totalShifts": " ", "filledShifts": " ", "coverage": "", "volunteerUtilization": " ", "utilization": "" };
const disasterStatistics = { "title": " ", "description": "         ", "tabs": { "overview": "", "trends": "", "regional": " ", "comparison": " " }, "overview": { "title": "  ", "totalEvents": " ", "totalAffected": " ", "totalEconomicLoss": "  ", "averageAffected": "   " }, "byType": "  ", "byRegion": " ", "events": "", "affected": " ", "economicLoss": " ", "trends": { "title": "  ", "yearsCovered": " ", "annualGrowth": "  ", "mostIncreasing": "   ", "yearlyBreakdown": " ", "year": "" }, "regional": { "title": "  ", "region": "", "riskIndex": " " }, "comparison": { "title": "  ", "firstType": "  ", "secondType": "  ", "compare": "", "averageAffected": " ", "averageEconomicLoss": "  " } };
const weather = { "title": " ", "conditions": " ", "humidity": "", "wind_speed": " ", "pressure": "", "visibility": "", "risk_assessment": " ", "risk_level": " ", "alerts": "", "preparedness_recommendations": " ", "forecast": " ", "high": "", "low": "", "refresh": " ", "loading": "   ...", "data_not_available": "   ", "fetch_error": "   " };
const emergencyResourceTracker = { "title": "  ", "totalResources": " ", "availableResources": " ", "responseRate": " ", "region": "", "allRegions": " ", "resource": "", "quantity": "", "location": "", "availability": "", "requestResources": "  ", "resourceType": " ", "selectType": "   ", "urgency": "", "normal": "", "high": "", "critical": "", "enterLocation": "  ", "contact": "", "enterContact": "   ", "submitRequest": "  ", "requestStatus": " ", "requestId": " ", "status": "", "submitted": " ", "estimatedDelivery": " ", "refreshStatus": "  " };
const disasterCommunicationHub = { "title": "  ", "selectRegion": "  ", "allRegions": " ", "selectDisaster": "   ", "communicationChannels": " ", "channelName": " ", "type": "", "frequency": "", "coverage": "", "status": "", "contact": "", "broadcastInfo": "  ", "tvChannels": " ", "radioStations": " ", "transmission": "", "smsAlerts": " ", "service": "", "shortcode": "", "provider": "", "equipment": " ", "availability": "", "protocols": "{{disaster}}   ", "immediateResponse": " ", "shortTermResponse": "  ", "longTermResponse": "  ", "emergencyContacts": " " };
const guTranslation = {
  common,
  home,
  navigation,
  accessibility,
  disasters,
  states,
  emergencyContacts,
  weatherAlerts,
  disasterRisk,
  resourceAllocator,
  impactAssessment,
  responsePlanner,
  communityReporting,
  volunteerCoordinator,
  disasterStatistics,
  weather,
  emergencyResourceTracker,
  disasterCommunicationHub
};
const resources = {
  en: {
    translation: enTranslation
  },
  hi: {
    translation: hiTranslation
  },
  ta: {
    translation: taTranslation
  },
  te: {
    translation: teTranslation
  },
  mr: {
    translation: mrTranslation
  },
  bn: {
    translation: bnTranslation
  },
  gu: {
    translation: guTranslation
  }
};
instance.use(Browser).use(initReactI18next).init({
  resources,
  fallbackLng: "en",
  detection: {
    order: ["localStorage", "navigator"],
    caches: ["localStorage"]
  },
  interpolation: {
    escapeValue: false
  }
});
var buffer = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  (function(exports) {
    const base64 = requireBase64Js();
    const ieee7542 = requireIeee754();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e3) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from2(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from2(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b2 = fromObject(value);
      if (b2) return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from2(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string2, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string2, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string2, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array2) {
      const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
      const buf = createBuffer(length);
      for (let i2 = 0; i2 < length; i2 += 1) {
        buf[i2] = array2[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy2 = new Uint8Array(arrayView);
        return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array2, byteOffset, length) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array2.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array2);
      } else if (length === void 0) {
        buf = new Uint8Array(array2, byteOffset);
      } else {
        buf = new Uint8Array(array2, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a2, b2) {
      if (isInstance(a2, Uint8Array)) a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b2, Uint8Array)) b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
      if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a2 === b2) return 0;
      let x2 = a2.length;
      let y2 = b2.length;
      for (let i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
        if (a2[i2] !== b2[i2]) {
          x2 = a2[i2];
          y2 = b2[i2];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i2;
      if (length === void 0) {
        length = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length += list[i2].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        let buf = list[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string2, encoding) {
      if (Buffer2.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      const len = string2.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes2(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string2).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap2(b2, n2, m2) {
      const i2 = b2[n2];
      b2[n2] = b2[m2];
      b2[m2] = i2;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 2) {
        swap2(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 4) {
        swap2(this, i2, i2 + 3);
        swap2(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 8) {
        swap2(this, i2, i2 + 7);
        swap2(this, i2 + 1, i2 + 6);
        swap2(this, i2 + 2, i2 + 5);
        swap2(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b2) {
      if (!Buffer2.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
      if (this === b2) return true;
      return Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max2 = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x2 = thisEnd - thisStart;
      let y2 = end - start;
      const len = Math.min(x2, y2);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x2 = thisCopy[i2];
          y2 = targetCopy[i2];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      let i2;
      if (dir) {
        let foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          let found = true;
          for (let j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i2 + j2) !== read(val, j2)) {
              found = false;
              break;
            }
          }
          if (found) return i2;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string2, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string2.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        const parsed = parseInt(string2.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string2, offset, length) {
      return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string2, offset, length) {
      return blitBuffer(asciiToBytes(string2), buf, offset, length);
    }
    function base64Write(buf, string2, offset, length) {
      return blitBuffer(base64ToBytes2(string2), buf, offset, length);
    }
    function ucs2Write(buf, string2, offset, length) {
      return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string2, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset, length);
          case "base64":
            return base64Write(this, string2, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i2 = start;
      while (i2 < end) {
        const firstByte = buf[i2];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i2 = 0;
      while (i2 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice2(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i2 = byteLength2;
      let mul = 1;
      let val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max2, min2) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i2 = byteLength2 - 1;
      let mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min2, max2) {
      checkIntBI(value, min2, max2, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min2, max2) {
      checkIntBI(value, min2, max2, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i2 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i2 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max2, min2) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee7542.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee7542.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len];
        }
      }
      return this;
    };
    const errors2 = {};
    function E2(sym, getMessage, Base) {
      errors2[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E2(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E2(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E2(
      "ERR_OUT_OF_RANGE",
      function(str, range2, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range2}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min2, max2, buf, offset, byteLength2) {
      if (value > max2 || value < min2) {
        const n2 = typeof min2 === "bigint" ? "n" : "";
        let range2;
        {
          if (min2 === 0 || min2 === BigInt(0)) {
            range2 = `>= 0${n2} and < 2${n2} ** ${(byteLength2 + 1) * 8}${n2}`;
          } else {
            range2 = `>= -(2${n2} ** ${(byteLength2 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n2}`;
          }
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors2.ERR_OUT_OF_RANGE("offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(
        "offset",
        `>= ${0} and <= ${length}`,
        value
      );
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string2, units) {
      units = units || Infinity;
      let codePoint;
      const length = string2.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i2 = 0; i2 < length; ++i2) {
        codePoint = string2.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c2, hi, lo;
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0) break;
        c2 = str.charCodeAt(i2);
        hi = c2 >> 8;
        lo = c2 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes2(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src.length) break;
        dst[i2 + offset] = src[i2];
      }
      return i2;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = (function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i2 = 0; i2 < 16; ++i2) {
        const i16 = i2 * 16;
        for (let j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet[i2] + alphabet[j2];
        }
      }
      return table;
    })();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  })(buffer);
  return buffer;
}
var bufferExports = requireBuffer();
const savedDarkMode = localStorage.getItem("darkMode") === "true";
if (savedDarkMode) {
  document.documentElement.classList.add("dark");
}
window.Buffer = bufferExports.Buffer;
ReactDOM.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
);
